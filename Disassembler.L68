00004110 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/2/2016 12:20:28 PM

00000000                             1  ******************************************************************************
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Brandon Authier (Hblkr), Jack S. Eldridge
00000000                             4  *              (JackScottie), Marijn Burger (marijnburger)
00000000                             5  * Date       : 16 May 2016
00000000                             6  * Description: An inverse assembler that will convert a memory
00000000                             7  *              image of instructions and data back to the display.
00000000                             8  *              The following will be decoded:
00000000                             9  *
00000000                            10  *              Addressing Modes
00000000                            11  *
00000000                            12  *                Data Register Direct
00000000                            13  *                Address Register Direct
00000000                            14  *                Address Register Indirect
00000000                            15  *                Immediate Data
00000000                            16  *                Address Register Indirect with Post Increment
00000000                            17  *                Address Register Indirect with Pre Decrement
00000000                            18  *                Absolute Long Address
00000000                            19  *                Absolute Word Address
00000000                            20  *
00000000                            21  *              Instructions
00000000                            22  *
00000000                            23  *                NOP
00000000                            24  *                MOVE
00000000                            25  *                MOVEA
00000000                            26  *                MOVEQ
00000000                            27  *                MOVEM
00000000                            28  *                ADD
00000000                            29  *                ADDA
00000000                            30  *                ADDI
00000000                            31  *                ADDQ
00000000                            32  *                SUB
00000000                            33  *                MULS
00000000                            34  *                DIVU
00000000                            35  *                LEA
00000000                            36  *                CLR
00000000                            37  *                AND
00000000                            38  *                OR
00000000                            39  *                LSL
00000000                            40  *                LSR
00000000                            41  *                ASR
00000000                            42  *                ASL
00000000                            43  *                ROL
00000000                            44  *                ROR
00000000                            45  *                CMP
00000000                            46  *                Bcc (BCC, BGT, BLE)
00000000                            47  *                JSR
00000000                            48  *                RTS
00000000                            49  *
00000000                            50  ******************************************************************************
00000000                            51  
00000000                            52  ******************************************************************************
00000000                            53  *           DEFINITIONS                                                      *
00000000                            54  ******************************************************************************
00000000  =00007000                 55  STACK     EQU   $7000               * Beginning address for stack pointer
00000000                            56  
00000000  =00005000                 57  BEGINADDR EQU   $5000               * Variable to hold beginning address value
00000000  =00005010                 58  ENDADDR   EQU   $5010               * Variable to hold ending address value
00000000                            59  
00000000  =00006000                 60  RUNAGAIN  EQU   $6000               * Value equivalent to 'true'
00000000                            61  
00001000                            62            ORG   $1000               * Program begins at address 1000
00001000                            63  
00001000                            64  *********** END DEFINITIONS **************************************************
00001000                            65  
00001000                            66  
00001000                            67  ******************************************************************************
00001000                            68  *           INCLUDES                                                         *
00001000                            69  ******************************************************************************
00001000                            70  
00001000                            71      INCLUDE 'IO.X68'
00001000                            72  
00001000                            73  
00001000                            74  
00001000  =00005020                 75  STR_LEN   EQU   $5020
00001000  =00005021                 76  HEXFLAG   EQU   $5021
00001000  =00005030                 77  HEXVALUE  EQU   $5030
00001000  =00005050                 78  REMAINDER EQU   $5050
00001000  =00000002                 79  MOD       EQU   2
00001000                            80  
00001000  =0000000D                 81  CR        EQU   $0D
00001000  =0000000A                 82  LF        EQU   $0A 
00001000                            83  
00001000                            84  
00001000                            85  GET_ADDRESSES
00001000  4EB9 000012D0             86      JSR         CLEARSCRN
00001006  4EB9 000010C4             87      JSR         IO_WELCOME          * Run welcome subroutine
0000100C                            88              
0000100C                            89  GET_FIRST_ADDRESS
0000100C  43F9 0000136C             90      LEA         PS1,A1              * Loads message into A1
00001012  4EB9 000010F2             91      JSR         GET_HEXSTRING       * Get string from user
00001018  0C38 0001 5021            92      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000101E  66EC                      93      BNE         GET_FIRST_ADDRESS   * If no, get hex again
00001020                            94     
00001020  4EB9 00001124             95      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001026  0C38 0001 5021            96      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000102C  66DE                      97      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000102E                            98      
0000102E  4EB9 00001280             99      JSR         IS_HEX_EVEN         * Check that hex value is even
00001034  0C38 0001 5021           100      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000103A  66D0                     101      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000103C                           102     
0000103C  21F8 5030 5000           103      MOVE.L      HEXVALUE,BEGINADDR  * Copy hex value to begin
00001042  43F9 000013FE            104      LEA         BMESSAGE,A1         * Load message in A1 for display
00001048  2238 5030                105      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display 
0000104C  4EB9 000012C2            106      JSR         NEW_LINE            * Space
00001052                           107      
00001052  4EB9 000010D8            108      JSR         CLEAR               * Clear values for next hex
00001058                           109      
00001058                           110  GET_SECOND_ADDRESS
00001058  43F9 000013B6            111      LEA         PS2,A1              * Loads message into A1
0000105E  4EB9 000010F2            112      JSR         GET_HEXSTRING       * Get string from user
00001064  0C38 0001 5021           113      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000106A  66EC                     114      BNE         GET_SECOND_ADDRESS  * If no, get hex again
0000106C                           115     
0000106C  4EB9 00001124            116      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001072  0C38 0001 5021           117      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001078  66DE                     118      BNE         GET_SECOND_ADDRESS  * If no, get hex again
0000107A                           119      
0000107A  4EB9 00001280            120      JSR         IS_HEX_EVEN         * Check that hex value is even
00001080  0C38 0001 5021           121      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001086  66D0                     122      BNE         GET_SECOND_ADDRESS  * If no, get hex again
00001088                           123     
00001088  21F8 5030 5010           124      MOVE.L      HEXVALUE,ENDADDR    * Copy hex value to begin
0000108E  43F9 0000141D            125      LEA         EMESSAGE,A1         * Load message in A1 for display
00001094  2238 5030                126      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display
00001098  4EB9 000012C2            127      JSR         NEW_LINE            * Space
0000109E                           128      
0000109E  4EB9 000010D8            129      JSR         CLEAR               * Clear values for next hex
000010A4                           130      
000010A4                           131  CHECK_BADDR_IS_LESS_THAN_EADDR
000010A4  4EB9 00001260            132      JSR         IS_LESSTHAN         *
000010AA  0C38 0001 5021           133      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000010B0  6700 0010                134      BEQ         FINISHED            * If yes, finished
000010B4  43F9 00001446            135      LEA         ADR_ERR_NOTLT,A1    * Else, load error message
000010BA  6100 0220                136      BSR.W       ADDRESS_ERR
000010BE  6100 3050                137      BSR.W       START      
000010C2                           138  
000010C2                           139  
000010C2                           140  FINISHED
000010C2  4E75                     141      RTS                             * Return to Disassembler
000010C4                           142      
000010C4                           143         
000010C4                           144             
000010C4                           145             
000010C4                           146  
000010C4                           147  IO_WELCOME: 
000010C4  43F9 00001344            148      LEA         INTRO,A1            * Loads message into A1
000010CA  103C 000E                149      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010CE  4E4F                     150      TRAP        #15                 * Displays Intro Message 
000010D0                           151        
000010D0  4EB9 000012C2            152      JSR         NEW_LINE            * Call Subroutine        
000010D6  4E75                     153      RTS                             * Return from subroutine
000010D8                           154          
000010D8                           155  
000010D8                           156  
000010D8                           157  CLEAR
000010D8  4286                     158      CLR.L       D6                   * Clear
000010DA  31FC FFFF 5020           159      MOVE.W      #$FFFF,STR_LEN       * Clear   
000010E0  21FC FFFFFFFF 5030       160      MOVE.L      #$FFFFFFFF,HEXVALUE  * Clear  
000010E8  21FC FFFFFFFF 5050       161      MOVE.L      #$FFFFFFFF,REMAINDER * Clear
000010F0  4E75                     162      RTS                              * Return to main to get hex
000010F2                           163  
000010F2                           164  
000010F2                           165          
000010F2                           166  GET_HEXSTRING
000010F2  103C 000E                167      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010F6  323C 004A                168      MOVE.W      #(PS2-PS1),D1       * The prompt string length
000010FA  4E4F                     169      TRAP        #15                 * Displays contents of A1
000010FC                           170   
000010FC  43F9 000014A1            171      LEA         HEXSTRING,A1        * Pointer to store the sentence
00001102  103C 0002                172      MOVE.B      #2,D0               * Set up readstring function
00001106  4E4F                     173      TRAP        #15                 * Get string from keyboard
00001108  11C1 5020                174      MOVE.B      D1,STR_LEN          * Save length of input string
0000110C                           175      
0000110C  0C38 0008 5020           176      CMPI.B      #8,(STR_LEN)        * Is length > 8?
00001112  6E00 FEF8                177      BGT         GET_FIRST_ADDRESS   * If yes, get hex again
00001116                           178         
00001116  41F9 000014A1            179      LEA         HEXSTRING,A0        * Load address for verification     
0000111C  11FC 0001 5021           180      MOVE.B      #1,(HEXFLAG)   
00001122  4E75                     181      RTS                             * Return from subroutine
00001124                           182          
00001124                           183  
00001124                           184  
00001124                           185  ASCII_TO_HEX      
00001124  1618                     186      MOVE.B      (A0)+,D3            * Move first char into D3    
00001126  0C03 0030                187      CMPI.B      #'0',D3             * Is Char equal to 0?
0000112A  6700 00D4                188      BEQ         HEXZERO            
0000112E  0C03 0031                189      CMPI.B      #'1',D3             * Is Char equal to 1?
00001132  6700 00D4                190      BEQ         HEXONE                   
00001136  0C03 0032                191      CMPI.B      #'2',D3             * Is Char equal to 2?
0000113A  6700 00D0                192      BEQ         HEXTWO    
0000113E  0C03 0033                193      CMPI.B      #'3',D3             * Is Char equal to 3?
00001142  6700 00CC                194      BEQ         HEXTHREE    
00001146  0C03 0034                195      CMPI.B      #'4',D3             * Is Char equal to 4?
0000114A  6700 00C8                196      BEQ         HEXFOUR    
0000114E  0C03 0035                197      CMPI.B      #'5',D3             * Is Char equal to 5?
00001152  6700 00C4                198      BEQ         HEXFIVE    
00001156  0C03 0036                199      CMPI.B      #'6',D3             * Is Char equal to 6?
0000115A  6700 00C0                200      BEQ         HEXSIX
0000115E  0C03 0037                201      CMPI.B      #'7',D3             * Is Char equal to 7?
00001162  6700 00BC                202      BEQ         HEXSEVEN
00001166  0C03 0038                203      CMPI.B      #'8',D3             * Is Char equal to 8?
0000116A  6700 00B8                204      BEQ         HEXEIGHT
0000116E  0C03 0039                205      CMPI.B      #'9',D3             * Is Char equal to 9?
00001172  6700 00B4                206      BEQ         HEXNINE
00001176  0C03 0041                207      CMPI.B      #'A',D3             * Is Char equal to A?
0000117A  6700 00B4                208      BEQ         HEXA                      
0000117E  0C03 0042                209      CMPI.B      #'B',D3             * Is Char equal to B?
00001182  6700 00B4                210      BEQ         HEXB
00001186  0C03 0043                211      CMPI.B      #'C',D3             * Is Char equal to C?
0000118A  6700 00B4                212      BEQ         HEXC
0000118E  0C03 0044                213      CMPI.B      #'D',D3             * Is Char equal to D?
00001192  6700 00B4                214      BEQ         HEXD
00001196  0C03 0045                215      CMPI.B      #'E',D3             * Is Char equal to E?
0000119A  6700 00B4                216      BEQ         HEXE
0000119E  0C03 0046                217      CMPI.B      #'F',D3             * Is Char equal to F?
000011A2  6700 00B4                218      BEQ         HEXF
000011A6  0C03 0061                219      CMPI.B      #'a',D3             * Is Char equal to a?
000011AA  6700 0084                220      BEQ         HEXA
000011AE  0C03 0062                221      CMPI.B      #'b',D3             * Is Char equal to b?
000011B2  6700 0084                222      BEQ         HEXB
000011B6  0C03 0063                223      CMPI.B      #'c',D3             * Is Char equal to c?
000011BA  6700 0084                224      BEQ         HEXC
000011BE  0C03 0064                225      CMPI.B      #'d',D3             * Is Char equal to d?
000011C2  6700 0084                226      BEQ         HEXD
000011C6  0C03 0065                227      CMPI.B      #'e',D3             * Is Char equal to e?
000011CA  6700 0084                228      BEQ         HEXE
000011CE  0C03 0066                229      CMPI.B      #'f',D3             * Is Char equal to f?
000011D2  6700 0084                230      BEQ         HEXF
000011D6                           231      
000011D6  11FC 0000 5021           232      MOVE.B      #0,HEXFLAG          * Set false    
000011DC  6000 FEFA                233      BRA         CLEAR               * Clear some values
000011E0                           234      
000011E0                           235  FOUND  
000011E0  5338 5020                236      SUBI.B      #1,STR_LEN          * Decrease string by one
000011E4  0C38 0000 5020           237      CMPI.B      #0,STR_LEN          * Is string = 0?
000011EA  6600 000E                238      BNE         SHIFTLEFT           * If no, shift value left 
000011EE  21C6 5030                239      MOVE.L      D6,HEXVALUE         * If yes, save hex value
000011F2  11FC 0001 5021           240      MOVE.B      #1,HEXFLAG          * Set true
000011F8  4E75                     241      RTS                             * Then, return to main
000011FA                           242  
000011FA                           243  SHIFTLEFT
000011FA  E98E                     244      LSL.L       #4,D6               * Shift the value left
000011FC  6000 FF26                245      BRA         ASCII_TO_HEX        * Check next char
00001200                           246  
00001200                           247  HEXZERO
00001200  0686 00000000            248      ADD.L       #$0,D6              * Add value
00001206  60D8                     249      BRA         FOUND               * found, decrease strlen, shift value left    
00001208                           250  HEXONE
00001208  5286                     251      ADD.L       #$1,D6              * Add value
0000120A  60D4                     252      BRA         FOUND               * found, decrease strlen, shift value left
0000120C                           253  HEXTWO
0000120C  5486                     254      ADD.L       #$2,D6              * Add value
0000120E  60D0                     255      BRA         FOUND               * found, decrease strlen, shift value left
00001210                           256  HEXTHREE
00001210  5686                     257      ADD.L       #$3,D6              * Add value
00001212  60CC                     258      BRA         FOUND               * found, decrease strlen, shift value left
00001214                           259  HEXFOUR
00001214  5886                     260      ADD.L       #$4,D6              * Add value
00001216  60C8                     261      BRA         FOUND               * found, decrease strlen, shift value left
00001218                           262  HEXFIVE
00001218  5A86                     263      ADD.L       #$5,D6              * Add value
0000121A  60C4                     264      BRA         FOUND               * found, decrease strlen, shift value left
0000121C                           265  HEXSIX
0000121C  5C86                     266      ADD.L       #$6,D6              * Add value
0000121E  60C0                     267      BRA         FOUND               * found, decrease strlen, shift value left
00001220                           268  HEXSEVEN
00001220  5E86                     269      ADD.L       #$7,D6              * Add value
00001222  60BC                     270      BRA         FOUND               * found, decrease strlen, shift value left
00001224                           271  HEXEIGHT
00001224  5086                     272      ADD.L       #$8,D6              * Add value
00001226  60B8                     273      BRA         FOUND               * found, decrease strlen, shift value left
00001228                           274  HEXNINE
00001228  0686 00000009            275      ADD.L       #$9,D6              * Add value
0000122E  60B0                     276      BRA         FOUND               * found, decrease strlen, shift value left
00001230                           277  HEXA
00001230  0686 0000000A            278      ADD.L       #$A,D6              * Add value
00001236  60A8                     279      BRA         FOUND               * found, decrease strlen, shift value left    
00001238                           280  HEXB
00001238  0686 0000000B            281      ADD.L       #$B,D6              * Add value
0000123E  60A0                     282      BRA         FOUND               * found, decrease strlen, shift value left
00001240                           283  HEXC
00001240  0686 0000000C            284      ADD.L       #$C,D6              * Add value
00001246  6098                     285      BRA         FOUND               * found, decrease strlen, shift value left
00001248                           286  HEXD
00001248  0686 0000000D            287      ADD.L       #$D,D6              * Add value
0000124E  6090                     288      BRA         FOUND               * found, decrease strlen, shift value left
00001250                           289  HEXE
00001250  0686 0000000E            290      ADD.L       #$E,D6              * Add value
00001256  6088                     291      BRA         FOUND               * found, decrease strlen, shift value left
00001258                           292  HEXF
00001258  0686 0000000F            293      ADD.L       #$F,D6              * Add value
0000125E  6080                     294      BRA         FOUND               * found, decrease strlen, shift value left 
00001260                           295     
00001260                           296  
00001260                           297  
00001260                           298  IS_LESSTHAN
00001260  2838 5000                299      MOVE.L      BEGINADDR,D4        * Store beginning address in D4
00001264  2C38 5010                300      MOVE.L      ENDADDR,D6          * Store ending address in D6
00001268  B886                     301      CMP.L       D6,D4               * Is D4 < D6
0000126A  6D00 000C                302      BLT         LT                  * Yes, mark true return to main
0000126E  11FC 0000 5021           303      MOVE.B      #0,HEXFLAG          * No, mark false
00001274  6000 FE62                304      BRA         CLEAR               * Clear values, return to main
00001278                           305  
00001278                           306  LT
00001278  11FC 0001 5021           307      MOVE.B      #1,HEXFLAG          * Mark true
0000127E  4E75                     308      RTS                             * Return to main
00001280                           309  
00001280                           310  
00001280                           311  
00001280                           312  IS_HEX_EVEN      
00001280  3606                     313      MOVE.W      D6,D3               * Move value to be modded into D3
00001282  3A3C 0002                314      MOVE.W      #MOD,D5             * Move mod value into D5
00001286  86C5                     315      DIVU        D5,D3               * Divide D3 by D5
00001288  123C 0003                316      MOVE.B      #3,D1               * Set counter to shift value into word 
0000128C                           317                                      * position    
0000128C                           318  REPEAT 
0000128C  E88B                     319      LSR.L       #4,D3               * Shift remainder to lower word
0000128E  57C9 FFFC                320      DBEQ        D1,REPEAT           * UNTIL [D0] = - 1
00001292  4241                     321      CLR         D1                  * Clear
00001294                           322      
00001294  B6BC 00000000            323      CMP.L       #0,D3               * Is hex even?
0000129A  6600 000E                324      BNE         NOTEVEN             * No, clear and go back to get_hex
0000129E  31C3 5050                325      MOVE.W      D3,REMAINDER        * Save remainder
000012A2  11FC 0001 5021           326      MOVE.B      #1,HEXFLAG          * Set true
000012A8  4E75                     327      RTS                             * Return to main
000012AA                           328  
000012AA                           329  NOTEVEN
000012AA  11FC 0000 5021           330      MOVE.B      #0,HEXFLAG          * Set false
000012B0  6000 FE26                331      BRA         CLEAR               * Clear values
000012B4                           332  
000012B4                           333  
000012B4                           334  
000012B4                           335  PRINT_HEXVALUE
000012B4  103C 000E                336      MOVE.B      #14,D0              * Moves the Task 14 into D0
000012B8  4E4F                     337      TRAP        #15                 * Displays contents of A1    
000012BA                           338      
000012BA  103C 0003                339      MOVE.B      #3,D0               * Moves the Task 3 into D0
000012BE  4E4F                     340      TRAP        #15                 * Displays contents of D1
000012C0                           341      
000012C0  4E75                     342      RTS                             * Return from subroutine                                  
000012C2                           343  
000012C2                           344  
000012C2                           345  NEW_LINE
000012C2  43F9 0000143C            346      LEA         ENDL,A1             * Loads message into A1
000012C8  103C 000E                347      MOVE.B      #14,D0              * Moves the TRACK 14 into D0
000012CC  4E4F                     348      TRAP        #15                 * Displays New line
000012CE  4E75                     349      RTS                             * Return from subroutine
000012D0                           350  
000012D0                           351  
000012D0                           352  CLEARSCRN     
000012D0  103C 000B                353      MOVE.B      #11,D0              * Task 11 for clearing screen
000012D4  323C FF00                354      MOVE.W      #$FF00,D1           * FF00, Clear screen
000012D8  4E4F                     355      TRAP        #15                 * Wait for keystroke
000012DA  4E75                     356      RTS                             * Return from subroutine
000012DC                           357  
000012DC                           358  
000012DC                           359  
000012DC                           360  
000012DC                           361  ADDRESS_ERR
000012DC  6100 FFF2                362      BSR.W       CLEARSCRN           * Clear output before displaying error
000012E0  103C 000D                363      MOVE.B      #13,D0              * Moves the Task 13 into D0
000012E4  4E4F                     364      TRAP        #15                 * Displays contents of A1
000012E6  103C 0005                365      MOVE.B      #5,D0               * Read single character from 
000012EA  4E4F                     366      TRAP        #15                 * The keyboard into D1.B
000012EC  4E75                     367      RTS                             * Return from subroutine
000012EE                           368  
000012EE                           369  
000012EE                           370  
000012EE                           371  INVALID_DATA
000012EE  220E                     372      MOVE.L      A6,D1               * Move the address location to D1
000012F0  143C 0010                373      MOVE.B      #16,D2              * Move base 16 to D2
000012F4  103C 000F                374      MOVE.B      #15,D0              * Moves Task 15 into D0
000012F8  4E4F                     375      TRAP        #15                 * Displays contents of D1
000012FA                           376      
000012FA  43F9 0000143F            377      LEA         TAB,A1              * Load TAB to A1
00001300  103C 000E                378      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001304  4E4F                     379      TRAP        #15                 * Displays a tab of A1
00001306                           380      
00001306  43F9 000014F1            381      LEA         DATA,A1             * Load address location to A1
0000130C  103C 000E                382      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001310  4E4F                     383      TRAP        #15                 * Displays location of A1
00001312                           384      
00001312  43F9 0000143F            385      LEA         TAB,A1              * Load TAB to A1
00001318  103C 000E                386      MOVE.B      #14,D0              * Moves the Task 14 into D0
0000131C  4E4F                     387      TRAP        #15                 * Displays a tab of A1
0000131E                           388      
0000131E  43F9 00001444            389      LEA         DOLLAR,A1           * Load TAB to A1
00001324  103C 000E                390      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001328  4E4F                     391      TRAP        #15                 * Displays a tab of A1
0000132A                           392      
0000132A  3216                     393      MOVE.W      (A6),D1             * Move the address value to D1
0000132C  143C 0010                394      MOVE.B      #16,D2              * Move base 16 to D2
00001330  103C 000F                395      MOVE.B      #15,D0              * Moves Task 15 into D0
00001334  4E4F                     396      TRAP        #15                 * Displays value of D1
00001336                           397      
00001336  43F9 0000143C            398      LEA         ENDL,A1             * Load TAB to A1
0000133C  103C 000E                399      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001340  4E4F                     400      TRAP        #15                 * Displays a tab of A1
00001342                           401      
00001342  4E75                     402      RTS                             * Return from subroutine
00001344                           403  
00001344                           404  
00001344                           405  
00001344                           406  
00001344= 57 45 4C 43 4F 4D ...    407  INTRO           DC.B 'WELCOME!',CR,LF,'THIS IS A 68K DISASSEMBLER.',CR,LF,0
0000136C= 50 4C 45 41 53 45 ...    408  PS1             DC.B 'PLEASE ENTER THE STARTING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000013B6= 50 4C 45 41 53 45 ...    409  PS2             DC.B 'PLEASE ENTER THE ENDING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000013FE= 0D 0A 42 45 47 49 ...    410  BMESSAGE        DC.B CR,LF,'BEGINNING ADDRESS GIVEN IS: ',0
0000141D= 0D 0A 45 4E 44 49 ...    411  EMESSAGE        DC.B CR,LF,'ENDING ADDRESS GIVEN IS   : ',0
0000143C= 0D 0A 00                 412  ENDL            DC.B CR,LF,0
0000143F= 20 20 20 20 00           413  TAB             DC.B '    ',0
00001444= 24 00                    414  DOLLAR          DC.B '$',0
00001446                           415  
00001446= 54 48 45 20 42 45 ...    416  ADR_ERR_NOTLT   DC.B 'THE BEGINNING ADDRESS MUST BE LESS THAN THE ENDING ADDRESS.',CR,LF,'PRESS ANY KEY TO TRY AGAIN...',0
000014A1                           417  
000014A1                           418  HEXSTRING       DS.B 80             * Var for hex string
000014F1                           419  
000014F1= 44 41 54 41 00           420  DATA            DC.B 'DATA',0
000014F6                           421  
000014F6                           422  
000014F6                           423  
000014F6                           424  
000014F6                           425  
000014F6                           426  
000014F6                           427  
000014F6                           428  
000014F6                           429  
000014F6                           430  -------------------- end include --------------------
000014F6                           431      INCLUDE 'OpCodes.X68'
000014F6                           432  
000014F6                           433          INCLUDE 'OCMessages.X68'
000014F6                           434  
000014F6                           435  
000014F6  =0000000D                436  CR      EQU     $0D
000014F6  =0000000A                437  LF      EQU     $0A
000014F6= 4E 4F 50 0D 0A 00        438  MESSAGENOP DC.B    'NOP',CR,LF, 0
000014FC                           439  
000014FC= 4D 4F 56 45 2E 57 ...    440  MESSAGEMOVEW DC.B    'MOVE.W',CR,LF, 0
00001505= 4D 4F 56 45 2E 4C ...    441  MESSAGEMOVEL DC.B    'MOVE.L',CR,LF, 0
0000150E= 4D 4F 56 45 2E 42 ...    442  MESSAGEMOVEB DC.B    'MOVE.B',CR,LF, 0
00001517                           443  
00001517= 41 44 44 49 2E 57 ...    444  MESSAGEADDIW DC.B    'ADDI.W',CR,LF, 0
00001520= 41 44 44 49 2E 4C ...    445  MESSAGEADDIL DC.B    'ADDI.L',CR,LF, 0
00001529= 41 44 44 49 2E 42 ...    446  MESSAGEADDIB DC.B    'ADDI.B',CR,LF, 0
00001532                           447  
00001532= 4D 4F 56 45 41 2E ...    448  MESSAGEMOVEAL DC.B    'MOVEA.L',CR,LF, 0
0000153C= 4D 4F 56 45 41 2E ...    449  MESSAGEMOVEAW DC.B    'MOVEA.W',CR,LF, 0
00001546                           450  
00001546= 4D 4F 56 45 4D 2E ...    451  MESSAGEMOVEML DC.B    'MOVEM.L',CR,LF, 0
00001550= 4D 4F 56 45 4D 2E ...    452  MESSAGEMOVEMW DC.B    'MOVEM.W',CR,LF, 0
0000155A                           453  
0000155A= 4A 53 52 0D 0A 00        454  MESSAGEJSR DC.B    'JSR',CR,LF, 0
00001560                           455  
00001560= 43 4C 52 0D 0A 00        456  MESSAGECLR DC.B    'CLR',CR,LF, 0
00001566                           457  
00001566= 52 54 53 0D 0A 00        458  MESSAGERTS DC.B    'RTS',CR,LF, 0
0000156C                           459  
0000156C= 4C 45 41 0D 0A 00        460  MESSAGELEA DC.B    'LEA',CR,LF, 0
00001572                           461  
00001572= 43 4C 52 2E 42 0D ...    462  MESSAGECLRB DC.B    'CLR.B',CR,LF, 0
0000157A= 43 4C 52 2E 57 0D ...    463  MESSAGECLRW DC.B    'CLR.W',CR,LF, 0
00001582= 43 4C 52 2E 4C 0D ...    464  MESSAGECLRL DC.B    'CLR.L',CR,LF, 0
0000158A                           465  
0000158A= 41 44 44 51 2E 42 ...    466  MESSAGEADDQB DC.B    'ADDQ.B',CR,LF, 0
00001593= 41 44 44 51 2E 57 ...    467  MESSAGEADDQW DC.B    'ADDQ.W',CR,LF, 0
0000159C= 41 44 44 51 2E 4C ...    468  MESSAGEADDQL DC.B    'ADDQ.L',CR,LF, 0
000015A5                           469  
000015A5= 43 4D 50 2E 42 0D ...    470  MESSAGECMPB DC.B    'CMP.B',CR,LF, 0
000015AD= 43 4D 50 2E 57 0D ...    471  MESSAGECMPW DC.B    'CMP.W',CR,LF, 0
000015B5= 43 4D 50 2E 4C 0D ...    472  MESSAGECMPL DC.B    'CMP.L',CR,LF, 0
000015BD                           473  
000015BD= 53 55 42 2E 42 0D ...    474  MESSAGESUBB DC.B    'SUB.B',CR,LF, 0
000015C5= 53 55 42 2E 57 0D ...    475  MESSAGESUBW DC.B    'SUB.W',CR,LF, 0
000015CD= 53 55 42 2E 4C 0D ...    476  MESSAGESUBL DC.B    'SUB.L',CR,LF, 0
000015D5                           477  
000015D5= 41 44 44 2E 42 0D ...    478  MESSAGEADDB DC.B    'ADD.B',CR,LF, 0
000015DD= 41 44 44 2E 57 0D ...    479  MESSAGEADDW DC.B    'ADD.W',CR,LF, 0
000015E5= 41 44 44 2E 4C 0D ...    480  MESSAGEADDL DC.B    'ADD.L',CR,LF, 0
000015ED                           481  
000015ED= 41 44 44 41 2E 57 ...    482  MESSAGEADDAW DC.B    'ADDA.W',CR,LF, 0
000015F6= 41 44 44 41 2E 4C ...    483  MESSAGEADDAL DC.B    'ADDA.L',CR,LF, 0
000015FF                           484  
000015FF= 4D 4F 56 45 51 2E ...    485  MESSAGEMOVEQL DC.B    'MOVEQ.L',CR,LF, 0
00001609                           486  
00001609= 41 4E 44 2E 42 0D ...    487  MESSAGEANDB DC.B    'AND.B',CR,LF, 0
00001611= 41 4E 44 2E 57 0D ...    488  MESSAGEANDW DC.B    'AND.W',CR,LF, 0
00001619= 41 4E 44 2E 4C 0D ...    489  MESSAGEANDL DC.B    'AND.L',CR,LF, 0
00001621                           490  
00001621= 4D 55 4C 53 2E 57 ...    491  MESSAGEMULSW DC.B    'MULS.W',CR,LF, 0
0000162A                           492  
0000162A= 41 53 52 2E 42 0D ...    493  MESSAGEASRB DC.B    'ASR.B',CR,LF, 0
00001632= 41 53 52 2E 57 0D ...    494  MESSAGEASRW DC.B    'ASR.W',CR,LF, 0
0000163A= 41 53 52 2E 4C 0D ...    495  MESSAGEASRL DC.B    'ASR.L',CR,LF, 0
00001642                           496  
00001642= 41 53 4C 2E 42 0D ...    497  MESSAGEASLB DC.B    'ASL.B',CR,LF, 0
0000164A= 41 53 4C 2E 57 0D ...    498  MESSAGEASLW DC.B    'ASL.W',CR,LF, 0
00001652= 41 53 4C 2E 4C 0D ...    499  MESSAGEASLL DC.B    'ASL.L',CR,LF, 0
0000165A                           500  
0000165A= 52 4F 52 2E 42 0D ...    501  MESSAGERORB DC.B    'ROR.B',CR,LF, 0
00001662= 52 4F 52 2E 57 0D ...    502  MESSAGERORW DC.B    'ROR.W',CR,LF, 0
0000166A= 52 4F 52 2E 4C 0D ...    503  MESSAGERORL DC.B    'ROR.L',CR,LF, 0
00001672                           504  
00001672= 52 4F 4C 2E 42 0D ...    505  MESSAGEROLB DC.B    'ROL.B',CR,LF, 0
0000167A= 52 4F 4C 2E 57 0D ...    506  MESSAGEROLW DC.B    'ROL.W',CR,LF, 0
00001682= 52 4F 4C 2E 4C 0D ...    507  MESSAGEROLL DC.B    'ROL.L',CR,LF, 0
0000168A                           508  
0000168A= 4C 53 52 2E 42 0D ...    509  MESSAGELSRB DC.B    'LSR.B',CR,LF, 0
00001692= 4C 53 52 2E 57 0D ...    510  MESSAGELSRW DC.B    'LSR.W',CR,LF, 0
0000169A= 4C 53 52 2E 4C 0D ...    511  MESSAGELSRL DC.B    'LSR.L',CR,LF, 0
000016A2                           512  
000016A2= 4C 53 4C 2E 42 0D ...    513  MESSAGELSLB DC.B    'LSL.B',CR,LF, 0
000016AA= 4C 53 4C 2E 57 0D ...    514  MESSAGELSLW DC.B    'LSL.W',CR,LF, 0
000016B2= 4C 53 4C 2E 4C 0D ...    515  MESSAGELSLL DC.B    'LSL.L',CR,LF, 0
000016BA                           516  
000016BA= 4F 52 2E 42 0D 0A 00     517  MESSAGEORB DC.B    'OR.B',CR,LF, 0
000016C1= 4F 52 2E 57 0D 0A 00     518  MESSAGEORW DC.B    'OR.W',CR,LF, 0
000016C8= 4F 52 2E 4C 0D 0A 00     519  MESSAGEORL DC.B    'OR.L',CR,LF, 0
000016CF                           520  
000016CF= 44 49 56 55 2E 57 ...    521  MESSAGEDIVUW DC.B    'DIVU.W',CR,LF, 0
000016D8                           522  
000016D8= 42 43 43 0D 0A 00        523  MESSAGEBCC DC.B    'BCC',CR,LF, 0
000016DE= 42 47 54 0D 0A 00        524  MESSAGEBGT DC.B    'BGT',CR,LF, 0
000016E4= 42 4C 45 0D 0A 00        525  MESSAGEBLE DC.B    'BLE',CR,LF, 0
000016EA                           526  
000016EA= 54 68 61 74 20 69 ...    527  MESSAGEOPCODE_INVALID DC.B    'That is not an opcode!',CR,LF, 0
00001703                           528  
00001703                           529  
00001703                           530  
00001703                           531  
00001703                           532  -------------------- end include --------------------
00001703                           533  
00001703                           534  
00001703                           535  OC_PARSE:
00001704  48E7 FFFE                536          MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001708  41F9 00001720            537          LEA         initial_table,A0 ; Index into the table
0000170E  4280                     538          CLR.L       D0              ; Zero it
00001710  3012                     539          MOVE.W      (A2),D0         ; We'll play with it here
00001712  123C 000C                540          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001716  E268                     541          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001718                           542                                      ; and the rest are zeroed out)
00001718  C0FC 0006                543          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000171C  4EF0 0000                544          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001720                           545  
00001720                           546  initial_table:
00001720  4EF9 00001780            547          JMP         code0000        ; ADDI.B, ADDI.W, or ADDI.L
00001726  4EF9 00001786            548          JMP         code0001        ; MOVE.B
0000172C  4EF9 00001792            549          JMP         code0010        ; MOVEA.L or MOVE.L
00001732  4EF9 00001798            550          JMP         code0011        ; MOVEA.W or MOVE.W
00001738  4EF9 0000179E            551          JMP         code0100        ; NOP or MOVEM.W or MOVEM.L or LEA or CLR.B or CLR.W or CLR.L or JSR or RTS or MULS.W
0000173E  4EF9 000017AA            552          JMP         code0101        ; ADDQ.B or ADDQ.W or ADDQ.L
00001744  4EF9 000017B6            553          JMP         code0110        ; BCC or BGT or BLE
0000174A  4EF9 000017C2            554          JMP         code0111        ; MOVEQ.L
00001750  4EF9 000017CE            555          JMP         code1000        ; OR.B or OR.W or OR.L or DIVU (DIVU is either word or long depending on ea)
00001756  4EF9 000017DA            556          JMP         code1001        ; SUB.B or SUB.W or SUB.L
0000175C  4EF9 000017E6            557          JMP         code1010
00001762  4EF9 000017EE            558          JMP         code1011        ; CMP.B or CMP.W or CMP.L
00001768  4EF9 000017FA            559          JMP         code1100        ; AND_BorAND_WorAND_LorMULS_W
0000176E  4EF9 00001806            560          JMP         code1101        ; ADD.B or ADD.W or ADD.L
00001774  4EF9 00001812            561          JMP         code1110        ; ROd_LSd_ASd
0000177A  4EF9 0000181E            562          JMP         code1111
00001780                           563  
00001780  4EB9 0000210A            564  code0000 JSR        ADDI_BorADDI_WorADDI_L
00001786  4EB9 00002868            565  code0001 JSR        ISMOVEB
0000178C  4EB9 00001826            566           JSR        DONE
00001792  4EB9 00002160            567  code0010 JSR        MOVEA_LorMOVE_L
00001798  4EB9 000021EE            568  code0011 JSR        MOVEA_WorMOVE_W
0000179E  4EB9 0000200C            569  code0100 JSR        NOP_MOVEM_LEA_JSR_CLR_RTS
000017A4  4EB9 00001826            570           JSR        DONE
000017AA  4EB9 00001E06            571  code0101 JSR        ADDQ_BorADDQ_WorADDQ_L
000017B0  4EB9 00001826            572           JSR        DONE
000017B6  4EB9 0000182C            573  code0110 JSR        BCCorBGTorBLE
000017BC  4EB9 00001826            574           JSR        DONE
000017C2  4EB9 000026EA            575  code0111 JSR        ISMOVEQL
000017C8  4EB9 00001826            576           JSR        DONE
000017CE  4EB9 00001882            577  code1000 JSR        OR_BorOR_WorOR_LorDIVU
000017D4  4EB9 00001826            578           JSR        DONE
000017DA  4EB9 00001D22            579  code1001 JSR        SUB_BorSUB_WorSUB_L
000017E0  4EB9 00001826            580           JSR        DONE
000017E6  4EB9 0000227C            581  code1010 JSR    OPCODE_INVALID              ;INVALID
000017EC  4E75                     582           RTS
000017EE  4EB9 00001DB0            583  code1011 JSR        CMP_BorCMP_WorCMP_L
000017F4  4EB9 00001826            584           JSR        DONE
000017FA  4EB9 00001C06            585  code1100 JSR        AND_BorAND_WorAND_LorMULS_W
00001800  4EB9 00001826            586           JSR        DONE
00001806  4EB9 00001C94            587  code1101 JSR        ADD_BorADD_WorADD_L
0000180C  4EB9 00001826            588           JSR        DONE
00001812  4EB9 00001BB6            589  code1110 JSR        ROd_LSd_ASd
00001818  4EB9 00001826            590           JSR        DONE
0000181E  4EB9 0000227C            591  code1111 JSR    OPCODE_INVALID              ;INVALID
00001824  4E75                     592           RTS
00001826  4CDF 7FFF                593  DONE    MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000182A  4E75                     594          RTS
0000182C                           595  
0000182C  41F9 0000184A            596  BCCorBGTorBLE       LEA     tableBCCorBGTorBLE, A0            ; Index into the table
00001832  4280                     597                      CLR.L   D0                  ; Zero it
00001834  3016                     598                      MOVE.W  (A6),D0         ; We'll play with it here
00001836  123C 0006                599                      MOVE.B  #6,D1           ; Shift 6 bits left
0000183A  E360                     600                      ASL.W   D1,D0
0000183C  123C 000E                601                      MOVE.B  #14,D1           ; Shift 14 bits to the right
00001840  E268                     602                      LSR.W   D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001842                           603                                      ; and the rest are zeroed out)
00001842  C0FC 0006                604                      MULU    #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001846  4EF0 0000                605                      JMP     0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
0000184A                           606  
0000184A  4EF9 00001862            607  tableBCCorBGTorBLE   JMP    BCCorBGTorBLEcode00   ; BCC
00001850  4EF9 0000186A            608                       JMP    BCCorBGTorBLEcode01   ;
00001856  4EF9 00001872            609                       JMP    BCCorBGTorBLEcode10   ; BGT
0000185C  4EF9 0000187A            610                       JMP    BCCorBGTorBLEcode11   ; BLE
00001862                           611  
00001862                           612  
00001862                           613  
00001862  4EB9 0000228C            614  BCCorBGTorBLEcode00    JSR     ISBCC
00001868  4E75                     615                         RTS
0000186A  4EB9 0000227C            616  BCCorBGTorBLEcode01    JSR    OPCODE_INVALID              ;INVALID
00001870  4E75                     617                         RTS
00001872  4EB9 000022A6            618  BCCorBGTorBLEcode10    JSR     ISBGT
00001878  4E75                     619                         RTS
0000187A  4EB9 000022C0            620  BCCorBGTorBLEcode11    JSR     ISBLE
00001880  4E75                     621                         RTS
00001882                           622  
00001882                           623  
00001882                           624  OR_BorOR_WorOR_LorDIVU:
00001882  41F9 000018A0            625          LEA         tableOR_BorOR_WorOR_LorDIVU, A0 ; Index into the table
00001888  4280                     626          CLR.L       D0              ; Zero it
0000188A  3016                     627          MOVE.W      (A6),D0     ; We'll play with it here
0000188C  123C 0007                628          MOVE.B      #7,D1           ; Shift 7 bits left
00001890  E360                     629          ASL.W       D1,D0
00001892  123C 000D                630          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001896  E268                     631          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001898                           632                                      ; and the rest are zeroed out)
00001898  C0FC 0006                633          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000189C  4EF0 0000                634          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000018A0                           635  
000018A0                           636  tableOR_BorOR_WorOR_LorDIVU
000018A0  4EF9 000018D0            637          JMP         OR_DIVUcode000  ; OR.B
000018A6  4EF9 000018D8            638          JMP         OR_DIVUcode001  ; OR.W
000018AC  4EF9 000018E0            639          JMP         OR_DIVUcode010  ; OR.L
000018B2  4EF9 000018E8            640          JMP         OR_DIVUcode011  ; DIVU.W
000018B8  4EF9 000018F0            641          JMP         OR_DIVUcode100  ; OR.B
000018BE  4EF9 000018F8            642          JMP         OR_DIVUcode101  ; OR.W
000018C4  4EF9 00001900            643          JMP         OR_DIVUcode110  ; OR.L
000018CA  4EF9 00001908            644          JMP         OR_DIVUcode111  ; INVALID
000018D0                           645  
000018D0                           646  
000018D0  4EB9 000022F4            647  OR_DIVUcode000 JSR  ISORB
000018D6  4E75                     648                 RTS
000018D8  4EB9 0000230E            649  OR_DIVUcode001 JSR  ISORW
000018DE  4E75                     650                 RTS
000018E0  4EB9 00002328            651  OR_DIVUcode010 JSR  ISORL
000018E6  4E75                     652                 RTS
000018E8  4EB9 000022DA            653  OR_DIVUcode011 JSR  ISDIVUW
000018EE  4E75                     654                 RTS
000018F0  4EB9 000022F4            655  OR_DIVUcode100 JSR  ISORB
000018F6  4E75                     656                 RTS
000018F8  4EB9 0000230E            657  OR_DIVUcode101 JSR  ISORW
000018FE  4E75                     658                 RTS
00001900  4EB9 00002328            659  OR_DIVUcode110 JSR  ISORL
00001906  4E75                     660                 RTS
00001908  4EB9 0000227C            661  OR_DIVUcode111 JSR    OPCODE_INVALID              ;INVALID
0000190E  4E75                     662                 RTS
00001910                           663  
00001910                           664  
00001910                           665  someASR:
00001910  41F9 0000192E            666          LEA         tableSomeASR, A0 ; Index into the table
00001916  4280                     667          CLR.L       D0              ; Zero it
00001918  3016                     668          MOVE.W      (A6),D0         ; We'll play with it here
0000191A  123C 0008                669          MOVE.B      #8,D1           ; Shift 8 bits left
0000191E  E360                     670          ASL.W       D1,D0
00001920  123C 000E                671          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001924  E268                     672          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001926                           673                                      ; and the rest are zeroed out)
00001926  C0FC 0006                674          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000192A  4EF0 0000                675          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000192E                           676  
0000192E                           677  tableSomeASR:
0000192E  4EF9 00001946            678          JMP         ASRcode00       *ASR.B
00001934  4EF9 0000194E            679          JMP         ASRcode01       *ASR.W
0000193A  4EF9 00001956            680          JMP         ASRcode10       *ASR.L
00001940  4EF9 0000195E            681          JMP         ASRcode11       *ASR.W
00001946                           682  
00001946  4EB9 00002342            683  ASRcode00 JSR       ISASRB
0000194C  4E75                     684            RTS
0000194E  4EB9 0000235C            685  ASRcode01 JSR       ISASRW
00001954  4E75                     686            RTS
00001956  4EB9 00002376            687  ASRcode10 JSR       ISASRL
0000195C  4E75                     688            RTS
0000195E  4EB9 0000235C            689  ASRcode11 JSR       ISASRW
00001964  4E75                     690            RTS
00001966                           691  
00001966                           692  someASL:
00001966  41F9 00001984            693          LEA         tableSomeASL, A0 ; Index into the table
0000196C  4280                     694          CLR.L       D0              ; Zero it
0000196E  3016                     695          MOVE.W      (A6),D0     ; We'll play with it here
00001970  123C 0008                696          MOVE.B      #8,D1           ; Shift 8 bits left
00001974  E360                     697          ASL.W       D1,D0
00001976  123C 000E                698          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000197A  E268                     699          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000197C                           700                                      ; and the rest are zeroed out)
0000197C  C0FC 0006                701          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001980  4EF0 0000                702          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001984                           703  
00001984                           704  tableSomeASL:
00001984  4EF9 0000199C            705          JMP         ASLcode00       *ASL.B
0000198A  4EF9 000019A4            706          JMP         ASLcode01       *ASL.W
00001990  4EF9 000019AC            707          JMP         ASLcode10       *ASL.L
00001996  4EF9 000019B4            708          JMP         ASLcode11       *ASL.W
0000199C                           709  
0000199C  4EB9 00002390            710  ASLcode00 JSR       ISASLB
000019A2  4E75                     711            RTS
000019A4  4EB9 000023AA            712  ASLcode01 JSR       ISASLW
000019AA  4E75                     713            RTS
000019AC  4EB9 000023C4            714  ASLcode10 JSR       ISASLL
000019B2  4E75                     715            RTS
000019B4  4EB9 000023AA            716  ASLcode11 JSR       ISASLW
000019BA  4E75                     717            RTS
000019BC                           718  
000019BC                           719  someLSR:
000019BC  41F9 000019DA            720          LEA         tableSomeLSR, A0 ; Index into the table
000019C2  4280                     721          CLR.L       D0              ; Zero it
000019C4  3016                     722          MOVE.W      (A6),D0     ; We'll play with it here
000019C6  123C 0008                723          MOVE.B      #8,D1           ; Shift 8 bits left
000019CA  E360                     724          ASL.W       D1,D0
000019CC  123C 000E                725          MOVE.B      #14,D1          ; Shift 14 bits to the right
000019D0  E268                     726          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000019D2                           727                                      ; and the rest are zeroed out)
000019D2  C0FC 0006                728          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000019D6  4EF0 0000                729          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000019DA                           730  
000019DA                           731  tableSomeLSR:
000019DA  4EF9 000019F2            732          JMP         LSRcode00       *LSR.B
000019E0  4EF9 000019FA            733          JMP         LSRcode01       *LSR.W
000019E6  4EF9 00001A02            734          JMP         LSRcode10       *LSR.L
000019EC  4EF9 00001A0A            735          JMP         LSRcode11       *LSR.W
000019F2  4EB9 000023DE            736  LSRcode00 JSR       ISLSRB
000019F8  4E75                     737            RTS
000019FA  4EB9 000023F8            738  LSRcode01 JSR       ISLSRW
00001A00  4E75                     739            RTS
00001A02  4EB9 00002412            740  LSRcode10 JSR       ISLSRL
00001A08  4E75                     741            RTS
00001A0A  4EB9 000023F8            742  LSRcode11 JSR       ISLSRW
00001A10  4E75                     743            RTS
00001A12                           744  
00001A12                           745  someLSL:
00001A12  41F9 00001A30            746          LEA         tableSomeLSL, A0 ; Index into the table
00001A18  4280                     747          CLR.L       D0              ; Zero it
00001A1A  3016                     748          MOVE.W      (A6),D0     ; We'll play with it here
00001A1C  123C 0008                749          MOVE.B      #8,D1           ; Shift 8 bits left
00001A20  E360                     750          ASL.W       D1,D0
00001A22  123C 000E                751          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001A26  E268                     752          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001A28                           753                                      ; and the rest are zeroed out)
00001A28  C0FC 0006                754          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001A2C  4EF0 0000                755          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A30                           756  
00001A30                           757  tableSomeLSL:
00001A30  4EF9 00001A48            758          JMP         LSLcode00       *LSL.B
00001A36  4EF9 00001A50            759          JMP         LSLcode01       *LSL.W
00001A3C  4EF9 00001A58            760          JMP         LSLcode10       *LSL.L
00001A42  4EF9 00001A60            761          JMP         LSLcode11       *LSL.W
00001A48                           762  
00001A48  4EB9 0000242C            763  LSLcode00 JSR       ISLSLB
00001A4E  4E75                     764            RTS
00001A50  4EB9 00002446            765  LSLcode01 JSR       ISLSLW
00001A56  4E75                     766            RTS
00001A58  4EB9 00002460            767  LSLcode10 JSR       ISLSLL
00001A5E  4E75                     768            RTS
00001A60  4EB9 00002446            769  LSLcode11 JSR       ISLSLW
00001A66  4E75                     770            RTS
00001A68                           771  
00001A68                           772  someROL:
00001A68  41F9 00001A86            773          LEA         tableSomeROL, A0 ; Index into the table
00001A6E  4280                     774          CLR.L       D0              ; Zero it
00001A70  3016                     775          MOVE.W      (A6),D0     ; We'll play with it here
00001A72  123C 0008                776          MOVE.B      #8,D1           ; Shift 8 bits left
00001A76  E360                     777          ASL.W       D1,D0
00001A78  123C 000E                778          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001A7C  E268                     779          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001A7E                           780                                      ; and the rest are zeroed out)
00001A7E  C0FC 0006                781          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001A82  4EF0 0000                782          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A86                           783  
00001A86                           784  tableSomeROL:
00001A86  4EF9 00001A9E            785          JMP         ROLcode00       *ROL.B
00001A8C  4EF9 00001AA6            786          JMP         ROLcode01       *ROL.W
00001A92  4EF9 00001AAE            787          JMP         ROLcode10       *ROL.L
00001A98  4EF9 00001AB6            788          JMP         ROLcode11       *ROL.W
00001A9E                           789  
00001A9E  4EB9 000024C8            790  ROLcode00 JSR       ISROLB
00001AA4  4E75                     791            RTS
00001AA6  4EB9 000024E2            792  ROLcode01 JSR       ISROLW
00001AAC  4E75                     793            RTS
00001AAE  4EB9 000024FC            794  ROLcode10 JSR       ISROLL
00001AB4  4E75                     795            RTS
00001AB6  4EB9 000024E2            796  ROLcode11 JSR       ISROLW
00001ABC  4E75                     797            RTS
00001ABE                           798  
00001ABE                           799  
00001ABE                           800  someROR:
00001ABE  41F9 00001ADC            801          LEA         tableSomeROR, A0 ; Index into the table
00001AC4  4280                     802          CLR.L       D0              ; Zero it
00001AC6  3016                     803          MOVE.W      (A6),D0     ; We'll play with it here
00001AC8  123C 0008                804          MOVE.B      #8,D1           ; Shift 8 bits left
00001ACC  E360                     805          ASL.W       D1,D0
00001ACE  123C 000E                806          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001AD2  E268                     807          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001AD4                           808                                      ; and the rest are zeroed out)
00001AD4  C0FC 0006                809          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001AD8  4EF0 0000                810          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001ADC                           811  
00001ADC                           812  tableSomeROR:
00001ADC  4EF9 00001AF4            813          JMP         RORcode00       *ROR.B
00001AE2  4EF9 00001AFC            814          JMP         RORcode01       *ROR.W
00001AE8  4EF9 00001B04            815          JMP         RORcode10       *ROR.L
00001AEE  4EF9 00001B0C            816          JMP         RORcode11       *ROR.W
00001AF4                           817  
00001AF4  4EB9 0000247A            818  RORcode00 JSR       ISRORB
00001AFA  4E75                     819            RTS
00001AFC  4EB9 00002494            820  RORcode01 JSR       ISRORW
00001B02  4E75                     821            RTS
00001B04  4EB9 000024AE            822  RORcode10 JSR       ISRORL
00001B0A  4E75                     823            RTS
00001B0C  4EB9 00002494            824  RORcode11 JSR       ISRORW
00001B12  4E75                     825            RTS
00001B14                           826  
00001B14                           827  ROL_ROR:
00001B14  41F9 00001B32            828          LEA         tableROL_ROR, A0 ; Index into the table
00001B1A  4280                     829          CLR.L       D0              ; Zero it
00001B1C  3016                     830          MOVE.W      (A6),D0     ; We'll play with it here
00001B1E  123C 0007                831          MOVE.B      #7,D1           ; Shift 7 bits left
00001B22  E360                     832          ASL.W       D1,D0
00001B24  123C 000F                833          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001B28  E268                     834          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B2A                           835                                      ; and the rest are zeroed out)
00001B2A  C0FC 0006                836          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B2E  4EF0 0000                837          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B32                           838  
00001B32                           839  tableROL_ROR:
00001B32  4EF9 00001B3E            840          JMP         ROL_RORcode0    ; ROR
00001B38  4EF9 00001B44            841          JMP         ROL_RORcode1    ; ROL
00001B3E                           842  
00001B3E  4EB8 1ABE                843  ROL_RORcode0 JSR    someROR
00001B42  4E75                     844               RTS
00001B44  4EB8 1A68                845  ROL_RORcode1 JSR    someROL
00001B48  4E75                     846               RTS
00001B4A                           847  
00001B4A                           848  LSL_LSR:
00001B4A  41F9 00001B68            849          LEA         tableLSL_LSR, A0 ; Index into the table
00001B50  4280                     850          CLR.L       D0              ; Zero it
00001B52  3016                     851          MOVE.W      (A6),D0     ; We'll play with it here
00001B54  123C 0007                852          MOVE.B      #7,D1           ; Shift 7 bits left
00001B58  E360                     853          ASL.W       D1,D0
00001B5A  123C 000F                854          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001B5E  E268                     855          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B60                           856                                      ; and the rest are zeroed out)
00001B60  C0FC 0006                857          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B64  4EF0 0000                858          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B68                           859  
00001B68                           860  tableLSL_LSR:
00001B68  4EF9 00001B74            861          JMP         LSL_LSRcode0    ; LSR
00001B6E  4EF9 00001B7A            862          JMP         LSL_LSRcode1    ; LSL
00001B74                           863  
00001B74  4EB8 19BC                864  LSL_LSRcode0 JSR    someLSR
00001B78  4E75                     865               RTS
00001B7A  4EB8 1A12                866  LSL_LSRcode1 JSR    someLSL
00001B7E  4E75                     867               RTS
00001B80                           868  
00001B80                           869  ASL_ASR:
00001B80  41F9 00001B9E            870          LEA         tableASL_ASR, A0 ; Index into the table
00001B86  4280                     871          CLR.L       D0              ; Zero it
00001B88  3016                     872          MOVE.W      (A6),D0     ; We'll play with it here
00001B8A  123C 0007                873          MOVE.B      #7,D1           ; Shift 7 bits left
00001B8E  E360                     874          ASL.W       D1,D0
00001B90  123C 000F                875          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001B94  E268                     876          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B96                           877                                      ; and the rest are zeroed out)
00001B96  C0FC 0006                878          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B9A  4EF0 0000                879          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B9E                           880  
00001B9E                           881  tableASL_ASR:
00001B9E  4EF9 00001BAA            882          JMP         ASL_ASRcode0    ; ASR
00001BA4  4EF9 00001BB0            883          JMP         ASL_ASRcode1    ; ASL
00001BAA                           884  
00001BAA  4EB8 1910                885  ASL_ASRcode0 JSR    someASR
00001BAE  4E75                     886               RTS
00001BB0  4EB8 1966                887  ASL_ASRcode1 JSR    someASL
00001BB4  4E75                     888               RTS
00001BB6                           889  
00001BB6                           890  ROd_LSd_ASd:
00001BB6  41F9 00001BD4            891          LEA         tableROd_LSd_ASd, A0 ; Index into the table
00001BBC  4280                     892          CLR.L       D0              ; Zero it
00001BBE  3016                     893          MOVE.W      (A6),D0     ; We'll play with it here
00001BC0  123C 000B                894          MOVE.B      #11,D1          ; Shift 11 bits left
00001BC4  E360                     895          ASL.W       D1,D0
00001BC6  123C 000F                896          MOVE.B      #15,D1          ; Shift 12 bits to the right
00001BCA  E268                     897          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001BCC                           898                                      ; and the rest are zeroed out)
00001BCC  C0FC 0006                899          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001BD0  4EF0 0000                900          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001BD4                           901  
00001BD4                           902  tableROd_LSd_ASd:
00001BD4  4EF9 00001BEC            903          JMP         ROd_LSd_ASdcode00 ; ASL_ASR
00001BDA  4EF9 00001BF2            904          JMP         ROd_LSd_ASdcode01 ; LSL_LSR
00001BE0  4EF9 00001BF8            905          JMP         ROd_LSd_ASdcode10
00001BE6  4EF9 00001C00            906          JMP         ROd_LSd_ASdcode11 ; ROL_ROR
00001BEC                           907  
00001BEC  4EB8 1B80                908  ROd_LSd_ASdcode00 JSR ASL_ASR
00001BF0  4E75                     909                    RTS
00001BF2  4EB8 1B4A                910  ROd_LSd_ASdcode01 JSR LSL_LSR
00001BF6  4E75                     911                    RTS
00001BF8  4EB9 0000227C            912  ROd_LSd_ASdcode10 JSR    OPCODE_INVALID              ;INVALID
00001BFE  4E75                     913                    RTS
00001C00  4EB8 1B14                914  ROd_LSd_ASdcode11 JSR ROL_ROR
00001C04  4E75                     915                    RTS
00001C06                           916  
00001C06                           917  AND_BorAND_WorAND_LorMULS_W:
00001C06  41F9 00001C24            918          LEA         tableAND_BorAND_WorAND_LorMULS_W, A0            ; Index into the table
00001C0C  4280                     919          CLR.L       D0                  ; Zero it
00001C0E  3016                     920          MOVE.W      (A6),D0         ; We'll play with it here
00001C10  123C 0007                921          MOVE.B      #7,D1           ; Shift 7 bits left
00001C14  E360                     922          ASL.W       D1,D0
00001C16  123C 000D                923          MOVE.B      #13,D1              ; Shift 13 bits to the right
00001C1A  E268                     924          LSR.W       D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001C1C                           925                                  ; and the rest are zeroed out)
00001C1C  C0FC 0006                926          MULU        #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001C20  4EF0 0000                927          JMP         0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
00001C24                           928  
00001C24                           929  tableAND_BorAND_WorAND_LorMULS_W:
00001C24  4EF9 00001C54            930          JMP         ANDcode000   ; AND.B
00001C2A  4EF9 00001C5C            931          JMP         ANDcode001   ; AND.W
00001C30  4EF9 00001C64            932          JMP         ANDcode010   ; AND.L
00001C36  4EF9 00001C6C            933          JMP         ANDcode011
00001C3C  4EF9 00001C74            934          JMP         ANDcode100   ; AND.B
00001C42  4EF9 00001C7C            935          JMP         ANDcode101   ; AND.W
00001C48  4EF9 00001C84            936          JMP         ANDcode110   ; AND.L
00001C4E  4EF9 00001C8C            937          JMP         ANDcode111   ; MULS.W
00001C54                           938  
00001C54  4EB9 00002530            939  ANDcode000 JSR      ISANDB
00001C5A  4E75                     940             RTS
00001C5C  4EB9 0000254A            941  ANDcode001 JSR      ISANDW
00001C62  4E75                     942             RTS
00001C64  4EB9 00002564            943  ANDcode010 JSR      ISANDL
00001C6A  4E75                     944             RTS
00001C6C  4EB9 0000227C            945  ANDcode011 JSR    OPCODE_INVALID              ;INVALID
00001C72  4E75                     946             RTS
00001C74  4EB9 00002530            947  ANDcode100 JSR      ISANDB
00001C7A  4E75                     948             RTS
00001C7C  4EB9 0000254A            949  ANDcode101 JSR      ISANDW
00001C82  4E75                     950             RTS
00001C84  4EB9 00002564            951  ANDcode110 JSR      ISANDL
00001C8A  4E75                     952             RTS
00001C8C  4EB9 00002516            953  ANDcode111 JSR      ISMULSW
00001C92  4E75                     954             RTS
00001C94                           955  
00001C94                           956  ADD_BorADD_WorADD_L:
00001C94  41F9 00001CB2            957          LEA         tableADD_BorADD_WorADD_L, A0 ; Index into the table
00001C9A  4280                     958          CLR.L       D0              ; Zero it
00001C9C  3016                     959          MOVE.W      (A6),D0     ; We'll play with it here
00001C9E  123C 0007                960          MOVE.B      #7,D1           ; Shift 7 bits left
00001CA2  E360                     961          ASL.W       D1,D0
00001CA4  123C 000D                962          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001CA8  E268                     963          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001CAA                           964                                      ; and the rest are zeroed out)
00001CAA  C0FC 0006                965          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001CAE  4EF0 0000                966          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001CB2                           967  
00001CB2                           968  tableADD_BorADD_WorADD_L:
00001CB2  4EF9 00001CE2            969          JMP         ADDcode000      *ADD.B
00001CB8  4EF9 00001CEA            970          JMP         ADDcode001      *ADD.W
00001CBE  4EF9 00001CF2            971          JMP         ADDcode010      *ADD.L
00001CC4  4EF9 00001CFA            972          JMP         ADDcode011      *ADDA.W
00001CCA  4EF9 00001D02            973          JMP         ADDcode100      *ADD.B
00001CD0  4EF9 00001D0A            974          JMP         ADDcode101      *ADD.W
00001CD6  4EF9 00001D12            975          JMP         ADDcode110      *ADD.L
00001CDC  4EF9 00001D1A            976          JMP         ADDcode111      *ADDA.L
00001CE2                           977  
00001CE2  4EB9 000025B2            978  ADDcode000 JSR      ISADDB
00001CE8  4E75                     979             RTS
00001CEA  4EB9 000025CC            980  ADDcode001 JSR      ISADDW
00001CF0  4E75                     981             RTS
00001CF2  4EB9 000025E6            982  ADDcode010 JSR      ISADDL
00001CF8  4E75                     983             RTS
00001CFA  4EB9 0000257E            984  ADDcode011 JSR      ISADDAW
00001D00  4E75                     985             RTS
00001D02  4EB9 000025B2            986  ADDcode100 JSR      ISADDB
00001D08  4E75                     987             RTS
00001D0A  4EB9 000025CC            988  ADDcode101 JSR      ISADDW
00001D10  4E75                     989             RTS
00001D12  4EB9 000025E6            990  ADDcode110 JSR      ISADDL
00001D18  4E75                     991             RTS
00001D1A  4EB9 00002598            992  ADDcode111 JSR      ISADDAL
00001D20  4E75                     993             RTS
00001D22                           994  
00001D22                           995  SUB_BorSUB_WorSUB_L:
00001D22  41F9 00001D40            996          LEA         tableSUB_BorSUB_WorSUB_L, A0 ; Index into the table
00001D28  4280                     997          CLR.L       D0              ; Zero it
00001D2A  3016                     998          MOVE.W      (A6),D0     ; We'll play with it here
00001D2C  123C 0007                999          MOVE.B      #7,D1           ; Shift 7 bits left
00001D30  E360                    1000          ASL.W       D1,D0
00001D32  123C 000D               1001          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001D36  E268                    1002          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001D38                          1003                                      ; and the rest are zeroed out)
00001D38  C0FC 0006               1004          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001D3C  4EF0 0000               1005          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001D40                          1006  
00001D40                          1007  tableSUB_BorSUB_WorSUB_L:
00001D40  4EF9 00001D70           1008          JMP         SUBcode000      *SUB.B
00001D46  4EF9 00001D78           1009          JMP         SUBcode001      *SUB.W
00001D4C  4EF9 00001D80           1010          JMP         SUBcode010      *SUB.L
00001D52  4EF9 00001D88           1011          JMP         SUBcode011
00001D58  4EF9 00001D90           1012          JMP         SUBcode100      *SUB.B
00001D5E  4EF9 00001D98           1013          JMP         SUBcode101      *SUB.W
00001D64  4EF9 00001DA0           1014          JMP         SUBcode110      *SUB.L
00001D6A  4EF9 00001DA8           1015          JMP         SUBcode111      ; INVALID
00001D70                          1016  
00001D70  4EB9 00002600           1017  SUBcode000 JSR      ISSUBB
00001D76  4E75                    1018             RTS
00001D78  4EB9 0000261A           1019  SUBcode001 JSR      ISSUBW
00001D7E  4E75                    1020             RTS
00001D80  4EB9 00002634           1021  SUBcode010 JSR      ISSUBL
00001D86  4E75                    1022             RTS
00001D88  4EB9 0000227C           1023  SUBcode011 JSR      OPCODE_INVALID              ;INVALID
00001D8E  4E75                    1024             RTS
00001D90  4EB9 00002600           1025  SUBcode100 JSR      ISSUBB
00001D96  4E75                    1026             RTS
00001D98  4EB9 0000261A           1027  SUBcode101 JSR      ISSUBW
00001D9E  4E75                    1028             RTS
00001DA0  4EB9 00002634           1029  SUBcode110 JSR      ISSUBL
00001DA6  4E75                    1030             RTS
00001DA8  4EB9 0000227C           1031  SUBcode111 JSR      OPCODE_INVALID              ;INVALID
00001DAE  4E75                    1032             RTS
00001DB0                          1033  
00001DB0                          1034  CMP_BorCMP_WorCMP_L:
00001DB0  41F9 00001DCE           1035          LEA         tableCMP_BorCMP_WorCMP_L, A0 ; Index into the table
00001DB6  4280                    1036          CLR.L       D0              ; Zero it
00001DB8  3016                    1037          MOVE.W      (A6),D0     ; We'll play with it here
00001DBA  123C 0008               1038          MOVE.B      #8,D1           ; Shift 8 bits left
00001DBE  E360                    1039          ASL.W       D1,D0
00001DC0  123C 000E               1040          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001DC4  E268                    1041          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001DC6                          1042                                      ; and the rest are zeroed out)
00001DC6  C0FC 0006               1043          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001DCA  4EF0 0000               1044          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001DCE                          1045  
00001DCE                          1046  tableCMP_BorCMP_WorCMP_L:
00001DCE  4EF9 00001DE6           1047          JMP         CMPcode00       *CMP.B
00001DD4  4EF9 00001DEE           1048          JMP         CMPcode01       *CMP.W
00001DDA  4EF9 00001DF6           1049          JMP         CMPcode10       *CMP.L
00001DE0  4EF9 00001DFE           1050          JMP         CMPcode11       ; INVALID
00001DE6                          1051  
00001DE6  4EB9 0000264E           1052  CMPcode00   JSR      ISCMPB
00001DEC  4E75                    1053              RTS
00001DEE  4EB9 00002668           1054  CMPcode01   JSR      ISCMPW
00001DF4  4E75                    1055              RTS
00001DF6  4EB9 00002682           1056  CMPcode10   JSR      ISCMPL
00001DFC  4E75                    1057              RTS
00001DFE  4EB9 0000227C           1058  CMPcode11   JSR    OPCODE_INVALID              ;INVALID
00001E04  4E75                    1059              RTS
00001E06                          1060  
00001E06                          1061  ADDQ_BorADDQ_WorADDQ_L:
00001E06  41F9 00001E24           1062          LEA         tableADDQ_BorADDQ_WorADDQ_L, A0 ; Index into the table
00001E0C  4280                    1063          CLR.L       D0              ; Zero it
00001E0E  3016                    1064          MOVE.W      (A6),D0     ; We'll play with it here
00001E10  123C 0008               1065          MOVE.B      #8,D1           ; Shift 8 bits left
00001E14  E360                    1066          ASL.W       D1,D0
00001E16  123C 000E               1067          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001E1A  E268                    1068          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001E1C                          1069                                      ; and the rest are zeroed out)
00001E1C  C0FC 0006               1070          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001E20  4EF0 0000               1071          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001E24                          1072  
00001E24                          1073  tableADDQ_BorADDQ_WorADDQ_L:
00001E24  4EF9 00001E3C           1074          JMP         ADDQcode00      *ADDQ.B
00001E2A  4EF9 00001E44           1075          JMP         ADDQcode01      *ADDQ.W
00001E30  4EF9 00001E4C           1076          JMP         ADDQcode10      *ADDQ.L
00001E36  4EF9 00001E54           1077          JMP         ADDQcode11      ; INVALID
00001E3C                          1078  
00001E3C  4EB9 0000269C           1079  ADDQcode00 JSR      ISADDQB
00001E42  4E75                    1080             RTS
00001E44  4EB9 000026B6           1081  ADDQcode01 JSR      ISADDQW
00001E4A  4E75                    1082             RTS
00001E4C  4EB9 000026D0           1083  ADDQcode10 JSR      ISADDQL
00001E52  4E75                    1084             RTS
00001E54  4EB9 0000227C           1085  ADDQcode11   JSR    OPCODE_INVALID              ;INVALID
00001E5A  4E75                    1086              RTS
00001E5C                          1087  
00001E5C                          1088  someCLR:
00001E5C  41F9 00001E7A           1089          LEA         tableSomeCLR, A0 ; Index into the table
00001E62  4280                    1090          CLR.L       D0              ; Zero it
00001E64  3016                    1091          MOVE.W      (A6),D0     ; We'll play with it here
00001E66  123C 0008               1092          MOVE.B      #8,D1           ; Shift 8 bits left
00001E6A  E360                    1093          ASL.W       D1,D0
00001E6C  123C 000E               1094          MOVE.B      #14,D1       ; Shift 12 bits to the right
00001E70  E268                    1095          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001E72                          1096                                      ; and the rest are zeroed out)
00001E72  C0FC 0006               1097          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001E76  4EF0 0000               1098          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001E7A                          1099  
00001E7A                          1100  tableSomeCLR:
00001E7A  4EF9 00001E92           1101          JMP         CLRcode00       *CLR.B
00001E80  4EF9 00001E9A           1102          JMP         CLRcode01       *CLR.W
00001E86  4EF9 00001EA2           1103          JMP         CLRcode10       *CLR.L
00001E8C  4EF9 00001EAA           1104          JMP         CLRcode11       ; INVALID
00001E92                          1105  
00001E92  4EB9 00002704           1106  CLRcode00 JSR       ISCLRB
00001E98  4E75                    1107            RTS
00001E9A  4EB9 0000271E           1108  CLRcode01 JSR       ISCLRW
00001EA0  4E75                    1109            RTS
00001EA2  4EB9 00002738           1110  CLRcode10 JSR       ISCLRL
00001EA8  4E75                    1111            RTS
00001EAA  4EB9 0000227C           1112  CLRcode11 JSR    OPCODE_INVALID              ;INVALID
00001EB0  4E75                    1113            RTS
00001EB2                          1114  
00001EB2                          1115  NOPorCLRorRTSorJSR:
00001EB2  41F9 00001EE4           1116          LEA         tableNOPorCLRorRTSorJSR, A0 ; Index into the table
00001EB8  4280                    1117          CLR.L       D0              ; Zero it
00001EBA  3016                    1118          MOVE.W      (A6),D0     ; We'll play with it here
00001EBC                          1119  
00001EBC  323C 4E71               1120          MOVE.W      #%0100111001110001, D1 ; 0100111001110001 = NOP
00001EC0  B240                    1121          CMP.W       D0, D1
00001EC2  6700 0088               1122          BEQ         NOPcommand
00001EC6                          1123  
00001EC6  323C 4E75               1124          MOVE.W      #%0100111001110101, D1 ; 0100111001110101 = RTS
00001ECA  B240                    1125          CMP.W       D0, D1
00001ECC  6700 0076               1126          BEQ         RTScommand
00001ED0                          1127  
00001ED0  123C 0004               1128          MOVE.B      #4,D1           ; Shift 4 bits left
00001ED4  E360                    1129          ASL.W       D1,D0
00001ED6  123C 000C               1130          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001EDA  E268                    1131          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001EDC                          1132                                      ; and the rest are zeroed out)
00001EDC  C0FC 0006               1133          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001EE0  4EF0 0000               1134          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001EE4                          1135  
00001EE4                          1136  tableNOPorCLRorRTSorJSR:
00001EE4  4EF9 00001F54           1137          JMP         JSRorCLRcode0000
00001EEA  4EF9 00001F5C           1138          JMP         JSRorCLRcode0001
00001EF0  4EF9 00001F64           1139          JMP         JSRorCLRcode0010
00001EF6  4EF9 00001F6A           1140          JMP         JSRorCLRcode0011
00001EFC  4EF9 00001F72           1141          JMP         JSRorCLRcode0100
00001F02  4EF9 00001F7A           1142          JMP         JSRorCLRcode0101
00001F08  4EF9 00001F82           1143          JMP         JSRorCLRcode0110
00001F0E  4EF9 00001F8A           1144          JMP         JSRorCLRcode0111
00001F14  4EF9 00001F92           1145          JMP         JSRorCLRcode1000
00001F1A  4EF9 00001F9A           1146          JMP         JSRorCLRcode1001
00001F20  4EF9 00001FA2           1147          JMP         JSRorCLRcode1010
00001F26  4EF9 00001FAA           1148          JMP         JSRorCLRcode1011
00001F2C  4EF9 00001FB2           1149          JMP         JSRorCLRcode1100
00001F32  4EF9 00001FBA           1150          JMP         JSRorCLRcode1101
00001F38  4EF9 00001FC2           1151          JMP         JSRorCLRcode1110
00001F3E  4EF9 00001FCA           1152          JMP         JSRorCLRcode1111
00001F44                          1153  
00001F44  4EB9 000027BA           1154  RTScommand JSR      ISRTS
00001F4A  4E75                    1155             RTS
00001F4C  4EB9 000027EA           1156  NOPcommand JSR      ISNOP
00001F52  4E75                    1157             RTS
00001F54  4EB9 0000227C           1158  JSRorCLRcode0000 JSR    OPCODE_INVALID              ;INVALID
00001F5A  4E75                    1159                   RTS
00001F5C  4EB9 0000227C           1160  JSRorCLRcode0001 JSR    OPCODE_INVALID              ;INVALID
00001F62  4E75                    1161                   RTS
00001F64  4EB8 1E5C               1162  JSRorCLRcode0010 JSR someCLR
00001F68  4E75                    1163                   RTS
00001F6A  4EB9 0000227C           1164  JSRorCLRcode0011 JSR    OPCODE_INVALID              ;INVALID
00001F70  4E75                    1165                   RTS
00001F72  4EB9 0000227C           1166  JSRorCLRcode0100 JSR    OPCODE_INVALID              ;INVALID
00001F78  4E75                    1167                   RTS
00001F7A  4EB9 0000227C           1168  JSRorCLRcode0101 JSR    OPCODE_INVALID              ;INVALID
00001F80  4E75                    1169                   RTS
00001F82  4EB9 0000227C           1170  JSRorCLRcode0110 JSR    OPCODE_INVALID              ;INVALID
00001F88  4E75                    1171                   RTS
00001F8A  4EB9 0000227C           1172  JSRorCLRcode0111 JSR    OPCODE_INVALID              ;INVALID
00001F90  4E75                    1173                   RTS
00001F92  4EB9 0000227C           1174  JSRorCLRcode1000 JSR    OPCODE_INVALID              ;INVALID
00001F98  4E75                    1175                   RTS
00001F9A  4EB9 0000227C           1176  JSRorCLRcode1001 JSR    OPCODE_INVALID              ;INVALID
00001FA0  4E75                    1177                   RTS
00001FA2  4EB9 0000227C           1178  JSRorCLRcode1010 JSR    OPCODE_INVALID              ;INVALID
00001FA8  4E75                    1179                   RTS
00001FAA  4EB9 0000227C           1180  JSRorCLRcode1011 JSR    OPCODE_INVALID              ;INVALID
00001FB0  4E75                    1181                   RTS
00001FB2  4EB9 0000227C           1182  JSRorCLRcode1100 JSR    OPCODE_INVALID              ;INVALID
00001FB8  4E75                    1183                   RTS
00001FBA  4EB9 0000227C           1184  JSRorCLRcode1101 JSR    OPCODE_INVALID              ;INVALID
00001FC0  4E75                    1185                   RTS
00001FC2  4EB9 000027A0           1186  JSRorCLRcode1110 JSR ISJSR
00001FC8  4E75                    1187                   RTS
00001FCA  4EB9 0000227C           1188  JSRorCLRcode1111 JSR    OPCODE_INVALID              ;INVALID
00001FD0  4E75                    1189                   RTS
00001FD2                          1190  
00001FD2                          1191  someMOVEM:
00001FD2  41F9 00001FF0           1192          LEA         tableSomeMOVEM, A0 ; Index into the table
00001FD8  4280                    1193          CLR.L       D0              ; Zero it
00001FDA  3016                    1194          MOVE.W      (A6),D0     ; We'll play with it here
00001FDC  123C 0009               1195          MOVE.B      #9,D1           ; Shift 9 bits left
00001FE0  E360                    1196          ASL.W       D1,D0
00001FE2  123C 000F               1197          MOVE.B      #15,D1       ; Shift 12 bits to the right
00001FE6  E268                    1198          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001FE8                          1199                                      ; and the rest are zeroed out)
00001FE8  C0FC 0006               1200          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001FEC  4EF0 0000               1201          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001FF0                          1202  
00001FF0                          1203  tableSomeMOVEM:
00001FF0  4EF9 00001FFC           1204          JMP         MOVEMcode0      ; MOVEM.W
00001FF6  4EF9 00002004           1205          JMP         MOVEMcode1      ; MOVEM.L
00001FFC                          1206  
00001FFC  4EB9 0000276C           1207  MOVEMcode0 JSR      ISMOVEMW
00002002  4E75                    1208             RTS
00002004  4EB9 00002752           1209  MOVEMcode1 JSR      ISMOVEML
0000200A  4E75                    1210             RTS
0000200C                          1211  
0000200C                          1212  NOP_MOVEM_LEA_JSR_CLR_RTS:
0000200C  41F9 00002030           1213          LEA         tableNOP_MOVEM_LEA_JSR_CLR_RTS, A0 ; Index into the table
00002012  4280                    1214          CLR.L       D0              ; Zero it
00002014  3016                    1215          MOVE.W      (A6),D0     ; We'll play with it here
00002016  123C 0007               1216          MOVE.B      #7,D1           ; Shift 7 bits right
0000201A  E260                    1217          ASR.W       D1,D0
0000201C  123C 000D               1218          MOVE.B      #13,D1          ; Shift 13 bits left
00002020  E360                    1219          ASL.W       D1,D0
00002022  123C 000C               1220          MOVE.B      #12,D1          ; Shift 12 bits to the right
00002026  E268                    1221          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00002028                          1222                                      ; and the rest are zeroed out)
00002028  C0FC 0006               1223          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000202C  4EF0 0000               1224          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00002030                          1225  
00002030                          1226  tableNOP_MOVEM_LEA_JSR_CLR_RTS:
00002030  4EF9 00002090           1227          JMP         LOTScode0000
00002036  4EF9 00002098           1228          JMP         LOTScode0001
0000203C  4EF9 000020A0           1229          JMP         LOTScode0010
00002042  4EF9 000020A6           1230          JMP         LOTScode0011
00002048  4EF9 000020AE           1231          JMP         LOTScode0100
0000204E  4EF9 000020B6           1232          JMP         LOTScode0101
00002054  4EF9 000020BE           1233          JMP         LOTScode0110
0000205A  4EF9 000020C6           1234          JMP         LOTScode0111
00002060  4EF9 000020CE           1235          JMP         LOTScode1000
00002066  4EF9 000020D4           1236          JMP         LOTScode1001
0000206C  4EF9 000020DC           1237          JMP         LOTScode1010
00002072  4EF9 000020E2           1238          JMP         LOTScode1011
00002078  4EF9 000020EA           1239          JMP         LOTScode1100
0000207E  4EF9 000020F2           1240          JMP         LOTScode1101
00002084  4EF9 000020FA           1241          JMP         LOTScode1110
0000208A  4EF9 00002102           1242          JMP         LOTScode1111
00002090                          1243  
00002090  4EB9 0000227C           1244  LOTScode0000 JSR    OPCODE_INVALID              ; MULS.L and DIVU.L are not supported for 68000 Disassember
00002096  4E75                    1245               RTS
00002098  4EB9 0000227C           1246  LOTScode0001 JSR    OPCODE_INVALID              ;INVALID
0000209E  4E75                    1247               RTS
000020A0  4EB8 1FD2               1248  LOTScode0010 JSR    someMOVEM
000020A4  4E75                    1249               RTS
000020A6  4EB9 0000227C           1250  LOTScode0011 JSR    OPCODE_INVALID              ;INVALID
000020AC  4E75                    1251               RTS
000020AE  4EB9 0000227C           1252  LOTScode0100 JSR    OPCODE_INVALID              ;INVALID
000020B4  4E75                    1253               RTS
000020B6  4EB9 0000227C           1254  LOTScode0101 JSR    OPCODE_INVALID              ;INVALID
000020BC  4E75                    1255               RTS
000020BE  4EB9 00002786           1256  LOTScode0110 JSR    ISLEA
000020C4  4E75                    1257               RTS
000020C6  4EB9 0000227C           1258  LOTScode0111 JSR    OPCODE_INVALID              ;INVALID
000020CC  4E75                    1259               RTS
000020CE  4EB8 1EB2               1260  LOTScode1000 JSR    NOPorCLRorRTSorJSR
000020D2  4E75                    1261               RTS
000020D4  4EB9 0000227C           1262  LOTScode1001 JSR    OPCODE_INVALID              ;INVALID
000020DA  4E75                    1263               RTS
000020DC  4EB8 1EB2               1264  LOTScode1010 JSR    NOPorCLRorRTSorJSR
000020E0  4E75                    1265               RTS
000020E2  4EB9 0000227C           1266  LOTScode1011 JSR    OPCODE_INVALID              ;INVALID
000020E8  4E75                    1267               RTS
000020EA  4EB9 0000227C           1268  LOTScode1100 JSR    OPCODE_INVALID              ;INVALID
000020F0  4E75                    1269               RTS
000020F2  4EB9 0000227C           1270  LOTScode1101 JSR    OPCODE_INVALID              ;INVALID
000020F8  4E75                    1271               RTS
000020FA  4EB9 00002786           1272  LOTScode1110 JSR    ISLEA
00002100  4E75                    1273               RTS
00002102  4EB9 0000227C           1274  LOTScode1111 JSR    OPCODE_INVALID              ;INVALID
00002108  4E75                    1275               RTS
0000210A                          1276  
0000210A                          1277  ADDI_BorADDI_WorADDI_L:
0000210A  41F9 00002128           1278          LEA         tableADDI_BorADDI_WorADDI_L,A0 ; Index into the table
00002110  4280                    1279          CLR.L       D0              ; Zero it
00002112  3016                    1280          MOVE.W      (A6),D0     ; We'll play with it here
00002114  123C 0007               1281          MOVE.B      #7,D1           ; Shift 7 bits left
00002118  E360                    1282          ASL.W       D1,D0
0000211A  123C 000D               1283          MOVE.B      #13,D1          ; Shift 13 bits right
0000211E  E260                    1284          ASR.W       D1,D0
00002120  C0FC 0006               1285          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002124  4EF0 0000               1286          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00002128                          1287  
00002128                          1288  tableADDI_BorADDI_WorADDI_L:
00002128  4EF9 00002140           1289          JMP         ADDIBcode00
0000212E  4EF9 00002148           1290          JMP         ADDIWcode01
00002134  4EF9 00002150           1291          JMP         ADDILcode10
0000213A  4EF9 00002158           1292          JMP         ADDILcode11
00002140                          1293  
00002140  4EB9 000028B6           1294  ADDIBcode00 JSR     ISADDIB
00002146  4E75                    1295              RTS
00002148  4EB9 00002882           1296  ADDIWcode01 JSR     ISADDIW
0000214E  4E75                    1297              RTS
00002150  4EB9 0000289C           1298  ADDILcode10 JSR     ISADDIL
00002156  4E75                    1299              RTS
00002158  4EB9 0000227C           1300  ADDILcode11 JSR    OPCODE_INVALID              ;INVALID
0000215E  4E75                    1301              RTS
00002160                          1302  
00002160                          1303  MOVEA_LorMOVE_L:
00002160  41F9 0000217E           1304          LEA         tableMOVEA_LorMOVE_L,A0 ; Index into the table
00002166  4280                    1305          CLR.L       D0              ; Zero it
00002168  3016                    1306          MOVE.W      (A6),D0         ; We'll play with it here
0000216A  123C 0007               1307          MOVE.B      #7,D1           ; Shift 7 bits left
0000216E  E360                    1308          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
00002170  123C 000D               1309          MOVE.B      #13,D1          ; Shift 13 bits right
00002174  E260                    1310          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
00002176  C0FC 0006               1311          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000217A  4EF0 0000               1312          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000217E                          1313  
0000217E                          1314  tableMOVEA_LorMOVE_L:
0000217E  4EF9 000021AE           1315          JMP         MOVEcode000
00002184  4EF9 000021B6           1316          JMP         MOVEAcode001
0000218A  4EF9 000021BE           1317          JMP         MOVEcode010
00002190  4EF9 000021C6           1318          JMP         MOVEcode011
00002196  4EF9 000021CE           1319          JMP         MOVEcode100
0000219C  4EF9 000021D6           1320          JMP         MOVEcode101
000021A2  4EF9 000021DE           1321          JMP         MOVEcode110
000021A8  4EF9 000021E6           1322          JMP         MOVEcode111
000021AE                          1323  
000021AE  4EB9 00002834           1324  MOVEcode000 JSR     ISMOVEL
000021B4  4E75                    1325              RTS
000021B6  4EB9 0000284E           1326  MOVEAcode001 JSR    ISMOVEAL
000021BC  4E75                    1327               RTS
000021BE  4EB9 00002834           1328  MOVEcode010 JSR     ISMOVEL
000021C4  4E75                    1329              RTS
000021C6  4EB9 00002834           1330  MOVEcode011 JSR     ISMOVEL
000021CC  4E75                    1331              RTS
000021CE  4EB9 00002834           1332  MOVEcode100 JSR     ISMOVEL
000021D4  4E75                    1333              RTS
000021D6  4EB9 00002834           1334  MOVEcode101 JSR     ISMOVEL
000021DC  4E75                    1335              RTS
000021DE  4EB9 00002834           1336  MOVEcode110 JSR     ISMOVEL
000021E4  4E75                    1337              RTS
000021E6  4EB9 00002834           1338  MOVEcode111 JSR     ISMOVEL
000021EC  4E75                    1339              RTS
000021EE                          1340  
000021EE                          1341  MOVEA_WorMOVE_W:
000021EE  41F9 0000220C           1342          LEA         tableMOVEA_WorMOVE_W,A0 ; Index into the table
000021F4  4280                    1343          CLR.L       D0              ; Zero it
000021F6  3016                    1344          MOVE.W      (A6),D0     ; We'll play with it here
000021F8  123C 0007               1345          MOVE.B      #7,D1           ; Shift 7 bits left
000021FC  E360                    1346          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
000021FE  123C 000D               1347          MOVE.B      #13,D1          ; Shift 13 bits right
00002202  E260                    1348          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
00002204  C0FC 0006               1349          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002208  4EF0 0000               1350          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000220C                          1351  
0000220C                          1352  tableMOVEA_WorMOVE_W:
0000220C  4EF9 0000223C           1353          JMP         MOVEWcode000
00002212  4EF9 00002244           1354          JMP         MOVEAWcode001
00002218  4EF9 0000224C           1355          JMP         MOVEWcode010
0000221E  4EF9 00002254           1356          JMP         MOVEWcode011
00002224  4EF9 0000225C           1357          JMP         MOVEWcode100
0000222A  4EF9 00002264           1358          JMP         MOVEWcode101
00002230  4EF9 0000226C           1359          JMP         MOVEWcode110
00002236  4EF9 00002274           1360          JMP         MOVEWcode111
0000223C                          1361  
0000223C  4EB9 00002800           1362  MOVEWcode000 JSR    ISMOVEW
00002242  4E75                    1363               RTS
00002244  4EB9 0000281A           1364  MOVEAWcode001 JSR   ISMOVEAW
0000224A  4E75                    1365                RTS
0000224C  4EB9 00002800           1366  MOVEWcode010 JSR    ISMOVEW
00002252  4E75                    1367               RTS
00002254  4EB9 00002800           1368  MOVEWcode011 JSR    ISMOVEW
0000225A  4E75                    1369               RTS
0000225C  4EB9 00002800           1370  MOVEWcode100 JSR    ISMOVEW
00002262  4E75                    1371               RTS
00002264  4EB9 00002800           1372  MOVEWcode101 JSR    ISMOVEW
0000226A  4E75                    1373               RTS
0000226C  4EB9 00002800           1374  MOVEWcode110 JSR    ISMOVEW
00002272  4E75                    1375               RTS
00002274  4EB9 00002800           1376  MOVEWcode111 JSR    ISMOVEW
0000227A  4E75                    1377               RTS
0000227C                          1378  
0000227C                          1379  ; TODO: adjust workflow to:
0000227C                          1380  ;   1) save message address to buffer pointer
0000227C  48E7 FFFE               1381  OPCODE_INVALID  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002280  4EB8 12EE               1382              JSR     INVALID_DATA
00002284  548E                    1383              ADDA.L      #$00000002, A6          ; Increment past current opcode word
00002286  4CDF 7FFF               1384              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
0000228A  4E75                    1385              RTS
0000228C                          1386  
0000228C  48E7 FFFE               1387  ISBCC  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002290  43F8 16D8               1388              LEA MESSAGEBCC, A1
00002294  103C 000E               1389              MOVE.B  #14, D0
00002298  4E4F                    1390              TRAP    #15
0000229A  4EB9 0000323C           1391              JSR     EA_Bcc
000022A0  4CDF 7FFF               1392              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
000022A4  4E75                    1393              RTS
000022A6  48E7 FFFE               1394  ISBGT  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022AA  43F8 16DE               1395              LEA MESSAGEBGT, A1
000022AE  103C 000E               1396              MOVE.B  #14, D0
000022B2  4E4F                    1397              TRAP    #15
000022B4  4EB9 0000323C           1398              JSR     EA_Bcc
000022BA  4CDF 7FFF               1399              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
000022BE  4E75                    1400              RTS
000022C0                          1401  
000022C0  48E7 FFFE               1402  ISBLE  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022C4  43F8 16E4               1403              LEA MESSAGEBLE, A1
000022C8  103C 000E               1404              MOVE.B  #14, D0
000022CC  4E4F                    1405              TRAP    #15
000022CE  4EB9 0000323C           1406              JSR     EA_Bcc
000022D4  4CDF 7FFF               1407              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
000022D8  4E75                    1408              RTS
000022DA                          1409  
000022DA  48E7 FFFE               1410  ISDIVUW     MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022DE  43F8 16CF               1411              LEA MESSAGEDIVUW, A1
000022E2  103C 000E               1412              MOVE.B  #14, D0
000022E6  4E4F                    1413              TRAP    #15
000022E8  4EB9 00003462           1414              JSR     EA_DIVU_W
000022EE  4CDF 7FFF               1415              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
000022F2  4E75                    1416              RTS
000022F4                          1417  
000022F4  48E7 FFFE               1418  ISORB   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022F8  43F8 16BA               1419          LEA         MESSAGEORB, A1
000022FC  103C 000E               1420          MOVE.B      #14, D0
00002300  4E4F                    1421          TRAP        #15
00002302  4EB9 00003C3A           1422          JSR         EA_OR
00002308  4CDF 7FFF               1423          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000230C  4E75                    1424          RTS
0000230E                          1425  
0000230E  48E7 FFFE               1426  ISORW   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002312  43F8 16C1               1427          LEA         MESSAGEORW, A1
00002316  103C 000E               1428          MOVE.B      #14, D0
0000231A  4E4F                    1429          TRAP        #15
0000231C  4EB9 00003C3A           1430          JSR         EA_OR
00002322  4CDF 7FFF               1431          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002326  4E75                    1432          RTS
00002328                          1433  
00002328  48E7 FFFE               1434  ISORL   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000232C  43F8 16C8               1435          LEA         MESSAGEORL, A1
00002330  103C 000E               1436          MOVE.B      #14, D0
00002334  4E4F                    1437          TRAP        #15
00002336  4EB9 00003C3A           1438          JSR         EA_OR
0000233C  4CDF 7FFF               1439          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002340  4E75                    1440          RTS
00002342                          1441  
00002342  48E7 FFFE               1442  ISASRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002346  43F8 162A               1443          LEA         MESSAGEASRB, A1
0000234A  103C 000E               1444          MOVE.B      #14, D0
0000234E  4E4F                    1445          TRAP        #15
00002350  4EB9 00003128           1446          JSR         EA_ASd
00002356  4CDF 7FFF               1447          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000235A  4E75                    1448          RTS
0000235C                          1449  
0000235C  48E7 FFFE               1450  ISASRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002360  43F8 1632               1451          LEA         MESSAGEASRW, A1
00002364  103C 000E               1452          MOVE.B      #14, D0
00002368  4E4F                    1453          TRAP        #15
0000236A  4EB9 00003128           1454          JSR         EA_ASd
00002370  4CDF 7FFF               1455          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002374  4E75                    1456          RTS
00002376                          1457  
00002376  48E7 FFFE               1458  ISASRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000237A  43F8 163A               1459          LEA         MESSAGEASRL, A1
0000237E  103C 000E               1460          MOVE.B      #14, D0
00002382  4E4F                    1461          TRAP        #15
00002384  4EB9 00003128           1462          JSR         EA_ASd
0000238A  4CDF 7FFF               1463          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000238E  4E75                    1464          RTS
00002390                          1465  
00002390  48E7 FFFE               1466  ISASLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002394  43F8 1642               1467          LEA         MESSAGEASLB, A1
00002398  103C 000E               1468          MOVE.B      #14, D0
0000239C  4E4F                    1469          TRAP        #15
0000239E  4EB9 00003128           1470          JSR         EA_ASd
000023A4  4CDF 7FFF               1471          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023A8  4E75                    1472          RTS
000023AA                          1473  
000023AA  48E7 FFFE               1474  ISASLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023AE  43F8 164A               1475          LEA         MESSAGEASLW, A1
000023B2  103C 000E               1476          MOVE.B      #14, D0
000023B6  4E4F                    1477          TRAP        #15
000023B8  4EB9 00003128           1478          JSR         EA_ASd
000023BE  4CDF 7FFF               1479          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023C2  4E75                    1480          RTS
000023C4                          1481  
000023C4  48E7 FFFE               1482  ISASLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023C8  43F8 1652               1483          LEA         MESSAGEASLL, A1
000023CC  103C 000E               1484          MOVE.B      #14, D0
000023D0  4E4F                    1485          TRAP        #15
000023D2  4EB9 00003128           1486          JSR         EA_ASd
000023D8  4CDF 7FFF               1487          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023DC  4E75                    1488          RTS
000023DE                          1489  
000023DE  48E7 FFFE               1490  ISLSRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023E2  43F8 168A               1491          LEA         MESSAGELSRB, A1
000023E6  103C 000E               1492          MOVE.B      #14, D0
000023EA  4E4F                    1493          TRAP        #15
000023EC  4EB9 000036EA           1494          JSR         EA_LSd
000023F2  4CDF 7FFF               1495          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023F6  4E75                    1496          RTS
000023F8                          1497  
000023F8  48E7 FFFE               1498  ISLSRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023FC  43F8 1692               1499          LEA         MESSAGELSRW, A1
00002400  103C 000E               1500          MOVE.B      #14, D0
00002404  4E4F                    1501          TRAP        #15
00002406  4EB9 000036EA           1502          JSR         EA_LSd
0000240C  4CDF 7FFF               1503          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002410  4E75                    1504          RTS
00002412                          1505  
00002412  48E7 FFFE               1506  ISLSRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002416  43F8 169A               1507          LEA         MESSAGELSRL, A1
0000241A  103C 000E               1508          MOVE.B      #14, D0
0000241E  4E4F                    1509          TRAP        #15
00002420  4EB9 000036EA           1510          JSR         EA_LSd
00002426  4CDF 7FFF               1511          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000242A  4E75                    1512          RTS
0000242C                          1513  
0000242C  48E7 FFFE               1514  ISLSLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002430  43F8 16A2               1515          LEA         MESSAGELSLB, A1
00002434  103C 000E               1516          MOVE.B      #14, D0
00002438  4E4F                    1517          TRAP        #15
0000243A  4EB9 000036EA           1518          JSR         EA_LSd
00002440  4CDF 7FFF               1519          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002444  4E75                    1520          RTS
00002446                          1521  
00002446  48E7 FFFE               1522  ISLSLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000244A  43F8 16AA               1523          LEA         MESSAGELSLW, A1
0000244E  103C 000E               1524          MOVE.B      #14, D0
00002452  4E4F                    1525          TRAP        #15
00002454  4EB9 000036EA           1526          JSR         EA_LSd
0000245A  4CDF 7FFF               1527          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000245E  4E75                    1528          RTS
00002460                          1529  
00002460  48E7 FFFE               1530  ISLSLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002464  43F8 16B2               1531          LEA         MESSAGELSLL, A1
00002468  103C 000E               1532          MOVE.B      #14, D0
0000246C  4E4F                    1533          TRAP        #15
0000246E  4EB9 000036EA           1534          JSR         EA_LSd
00002474  4CDF 7FFF               1535          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002478  4E75                    1536          RTS
0000247A                          1537  
0000247A  48E7 FFFE               1538  ISRORB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000247E  43F8 165A               1539          LEA         MESSAGERORB, A1
00002482  103C 000E               1540          MOVE.B      #14, D0
00002486  4E4F                    1541          TRAP        #15
00002488  4EB9 00003DE6           1542          JSR         EA_ROd
0000248E  4CDF 7FFF               1543          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002492  4E75                    1544          RTS
00002494                          1545  
00002494  48E7 FFFE               1546  ISRORW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002498  43F8 1662               1547          LEA         MESSAGERORW, A1
0000249C  103C 000E               1548          MOVE.B      #14, D0
000024A0  4E4F                    1549          TRAP        #15
000024A2  4EB9 00003DE6           1550          JSR         EA_ROd
000024A8  4CDF 7FFF               1551          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024AC  4E75                    1552          RTS
000024AE                          1553  
000024AE  48E7 FFFE               1554  ISRORL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024B2  43F8 166A               1555          LEA         MESSAGERORL, A1
000024B6  103C 000E               1556          MOVE.B      #14, D0
000024BA  4E4F                    1557          TRAP        #15
000024BC  4EB9 00003DE6           1558          JSR         EA_ROd
000024C2  4CDF 7FFF               1559          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024C6  4E75                    1560          RTS
000024C8                          1561  
000024C8  48E7 FFFE               1562  ISROLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024CC  43F8 1672               1563          LEA         MESSAGEROLB, A1
000024D0  103C 000E               1564          MOVE.B      #14, D0
000024D4  4E4F                    1565          TRAP        #15
000024D6  4EB9 00003DE6           1566          JSR         EA_ROd
000024DC  4CDF 7FFF               1567          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024E0  4E75                    1568          RTS
000024E2                          1569  
000024E2  48E7 FFFE               1570  ISROLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024E6  43F8 167A               1571          LEA         MESSAGEROLW, A1
000024EA  103C 000E               1572          MOVE.B      #14, D0
000024EE  4E4F                    1573          TRAP        #15
000024F0  4EB9 00003DE6           1574          JSR         EA_ROd
000024F6  4CDF 7FFF               1575          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024FA  4E75                    1576          RTS
000024FC                          1577  
000024FC  48E7 FFFE               1578  ISROLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002500  43F8 1682               1579          LEA         MESSAGEROLL, A1
00002504  103C 000E               1580          MOVE.B      #14, D0
00002508  4E4F                    1581          TRAP        #15
0000250A  4EB9 00003DE6           1582          JSR         EA_ROd
00002510  4CDF 7FFF               1583          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002514  4E75                    1584          RTS
00002516                          1585  
00002516  48E7 FFFE               1586  ISMULSW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000251A  43F8 1621               1587          LEA         MESSAGEMULSW, A1 *OPCODE is MULS.W
0000251E  103C 000E               1588          MOVE.B      #14, D0
00002522  4E4F                    1589          TRAP        #15
00002524  4EB9 00003B4A           1590          JSR         EA_MULS_W
0000252A  4CDF 7FFF               1591          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000252E  4E75                    1592          RTS
00002530                          1593  
00002530  48E7 FFFE               1594  ISANDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002534  43F8 1609               1595          LEA         MESSAGEANDB, A1 *OPCODE is AND.B
00002538  103C 000E               1596          MOVE.B      #14, D0
0000253C  4E4F                    1597          TRAP        #15
0000253E  4EB9 00002F82           1598          JSR         EA_AND
00002544  4CDF 7FFF               1599          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002548  4E75                    1600          RTS
0000254A                          1601  
0000254A  48E7 FFFE               1602  ISANDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000254E  43F8 1611               1603          LEA         MESSAGEANDW, A1 *OPCODE is AND.W
00002552  103C 000E               1604          MOVE.B      #14, D0
00002556  4E4F                    1605          TRAP        #15
00002558  4EB9 00002F82           1606          JSR         EA_AND
0000255E  4CDF 7FFF               1607          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002562  4E75                    1608          RTS
00002564                          1609  
00002564  48E7 FFFE               1610  ISANDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002568  43F8 1619               1611          LEA         MESSAGEANDL, A1 *OPCODE is AND.L
0000256C  103C 000E               1612          MOVE.B      #14, D0
00002570  4E4F                    1613          TRAP        #15
00002572  4EB9 00002F82           1614          JSR         EA_AND
00002578  4CDF 7FFF               1615          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000257C  4E75                    1616          RTS
0000257E                          1617  
0000257E  48E7 FFFE               1618  ISADDAW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002582  43F8 15ED               1619          LEA         MESSAGEADDAW, A1 *OPCODE is ADDA.W
00002586  103C 000E               1620          MOVE.B      #14, D0
0000258A  4E4F                    1621          TRAP        #15
0000258C  4EB9 00002CA0           1622          JSR         EA_ADDA
00002592  4CDF 7FFF               1623          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002596  4E75                    1624          RTS
00002598                          1625  
00002598  48E7 FFFE               1626  ISADDAL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000259C  43F8 15F6               1627          LEA         MESSAGEADDAL, A1 *OPCODE is ADDA.L
000025A0  103C 000E               1628          MOVE.B      #14, D0
000025A4  4E4F                    1629          TRAP        #15
000025A6  4EB9 00002CA0           1630          JSR         EA_ADDA
000025AC  4CDF 7FFF               1631          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025B0  4E75                    1632          RTS
000025B2                          1633  
000025B2  48E7 FFFE               1634  ISADDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025B6  43F8 15D5               1635          LEA         MESSAGEADDB, A1 *OPCODE is ADD.B
000025BA  103C 000E               1636          MOVE.B      #14, D0
000025BE  4E4F                    1637          TRAP        #15
000025C0  4EB9 00002AEC           1638          JSR         EA_ADD
000025C6  4CDF 7FFF               1639          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025CA  4E75                    1640          RTS
000025CC                          1641  
000025CC  48E7 FFFE               1642  ISADDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025D0  43F8 15DD               1643          LEA         MESSAGEADDW, A1 *OPCODE is ADD.W
000025D4  103C 000E               1644          MOVE.B      #14, D0
000025D8  4E4F                    1645          TRAP        #15
000025DA  4EB9 00002AEC           1646          JSR         EA_ADD
000025E0  4CDF 7FFF               1647          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025E4  4E75                    1648          RTS
000025E6                          1649  
000025E6  48E7 FFFE               1650  ISADDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025EA  43F8 15E5               1651          LEA         MESSAGEADDL, A1 *OPCODE is ADD.L
000025EE  103C 000E               1652          MOVE.B      #14, D0
000025F2  4E4F                    1653          TRAP        #15
000025F4  4EB9 00002AEC           1654          JSR         EA_ADD
000025FA  4CDF 7FFF               1655          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025FE  4E75                    1656          RTS
00002600                          1657  
00002600  48E7 FFFE               1658  ISSUBB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002604  43F8 15BD               1659          LEA         MESSAGESUBB, A1 *OPCODE is SUB.B
00002608  103C 000E               1660          MOVE.B      #14, D0
0000260C  4E4F                    1661          TRAP        #15
0000260E  4EB9 00003EFA           1662          JSR         EA_SUB
00002614  4CDF 7FFF               1663          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002618  4E75                    1664          RTS
0000261A                          1665  
0000261A  48E7 FFFE               1666  ISSUBW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000261E  43F8 15C5               1667          LEA         MESSAGESUBW, A1 *OPCODE is SUB.W
00002622  103C 000E               1668          MOVE.B      #14, D0
00002626  4E4F                    1669          TRAP        #15
00002628  4EB9 00003EFA           1670          JSR         EA_SUB
0000262E  4CDF 7FFF               1671          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002632  4E75                    1672          RTS
00002634                          1673  
00002634  48E7 FFFE               1674  ISSUBL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002638  43F8 15CD               1675          LEA         MESSAGESUBL, A1 *OPCODE is SUB.L
0000263C  103C 000E               1676          MOVE.B      #14, D0
00002640  4E4F                    1677          TRAP        #15
00002642  4EB9 00003EFA           1678          JSR         EA_SUB
00002648  4CDF 7FFF               1679          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000264C  4E75                    1680          RTS
0000264E                          1681  
0000264E  48E7 FFFE               1682  ISCMPB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002652  43F8 15A5               1683          LEA         MESSAGECMPB, A1 *OPCODE is CMP.B
00002656  103C 000E               1684          MOVE.B      #14, D0
0000265A  4E4F                    1685          TRAP        #15
0000265C  4EB9 00003392           1686          JSR         EA_CMP
00002662  4CDF 7FFF               1687          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002666  4E75                    1688          RTS
00002668                          1689  
00002668  48E7 FFFE               1690  ISCMPW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000266C  43F8 15AD               1691          LEA         MESSAGECMPW, A1 *OPCODE is CMP.W
00002670  103C 000E               1692          MOVE.B      #14, D0
00002674  4E4F                    1693          TRAP        #15
00002676  4EB9 00003392           1694          JSR         EA_CMP
0000267C  4CDF 7FFF               1695          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002680  4E75                    1696          RTS
00002682                          1697  
00002682  48E7 FFFE               1698  ISCMPL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002686  43F8 15B5               1699          LEA         MESSAGECMPL, A1 *OPCODE is CMP.L
0000268A  103C 000E               1700          MOVE.B      #14, D0
0000268E  4E4F                    1701          TRAP        #15
00002690  4EB9 00003392           1702          JSR         EA_CMP
00002696  4CDF 7FFF               1703          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000269A  4E75                    1704          RTS
0000269C                          1705  
0000269C  48E7 FFFE               1706  ISADDQB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026A0  43F8 158A               1707          LEA         MESSAGEADDQB, A1 *OPCODE is ADDQ.B
000026A4  103C 000E               1708          MOVE.B      #14, D0
000026A8  4E4F                    1709          TRAP        #15
000026AA  4EB9 00002EA0           1710          JSR         EA_ADDQ
000026B0  4CDF 7FFF               1711          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026B4  4E75                    1712          RTS
000026B6                          1713  
000026B6  48E7 FFFE               1714  ISADDQW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026BA  43F8 1593               1715          LEA         MESSAGEADDQW, A1 *OPCODE is ADDQ.W
000026BE  103C 000E               1716          MOVE.B      #14, D0
000026C2  4E4F                    1717          TRAP        #15
000026C4  4EB9 00002EA0           1718          JSR         EA_ADDQ
000026CA  4CDF 7FFF               1719          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026CE  4E75                    1720          RTS
000026D0                          1721  
000026D0  48E7 FFFE               1722  ISADDQL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026D4  43F8 159C               1723          LEA         MESSAGEADDQL, A1 *OPCODE is ADDQ.L
000026D8  103C 000E               1724          MOVE.B      #14, D0
000026DC  4E4F                    1725          TRAP        #15
000026DE  4EB9 00002EA0           1726          JSR         EA_ADDQ
000026E4  4CDF 7FFF               1727          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026E8  4E75                    1728          RTS
000026EA                          1729  
000026EA  48E7 FFFE               1730  ISMOVEQL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000026EE  43F8 15FF               1731          LEA         MESSAGEMOVEQL, A1 *OPCODE is MOVEQ.L
000026F2  103C 000E               1732          MOVE.B      #14, D0
000026F6  4E4F                    1733          TRAP        #15
000026F8  4EB9 00003B06           1734          JSR         EA_MOVEQ
000026FE  4CDF 7FFF               1735          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002702  4E75                    1736          RTS
00002704                          1737  
00002704  48E7 FFFE               1738  ISCLRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002708  43F8 1572               1739          LEA         MESSAGECLRB, A1 *OPCODE is CLR.B
0000270C  103C 000E               1740          MOVE.B      #14, D0
00002710  4E4F                    1741          TRAP        #15
00002712  4EB9 00003B06           1742          JSR         EA_MOVEQ
00002718  4CDF 7FFF               1743          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000271C  4E75                    1744          RTS
0000271E                          1745  
0000271E  48E7 FFFE               1746  ISCLRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002722  43F8 157A               1747          LEA         MESSAGECLRW, A1 *OPCODE is CLR.W
00002726  103C 000E               1748          MOVE.B      #14, D0
0000272A  4E4F                    1749          TRAP        #15
0000272C  4EB9 000032CA           1750          JSR         EA_CLR
00002732  4CDF 7FFF               1751          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002736  4E75                    1752          RTS
00002738                          1753  
00002738  48E7 FFFE               1754  ISCLRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000273C  43F8 1582               1755          LEA         MESSAGECLRL, A1 *OPCODE is CLR.L
00002740  103C 000E               1756          MOVE.B      #14, D0
00002744  4E4F                    1757          TRAP        #15
00002746  4EB9 000032CA           1758          JSR         EA_CLR
0000274C  4CDF 7FFF               1759          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002750  4E75                    1760          RTS
00002752                          1761  
00002752  48E7 FFFE               1762  ISMOVEML MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
00002756  43F8 1546               1763          LEA         MESSAGEMOVEML, A1 *OPCODE is MOVEM.L
0000275A  103C 000E               1764          MOVE.B      #14, D0
0000275E  4E4F                    1765          TRAP        #15
00002760  4EB9 00003B00           1766          JSR         EA_MOVEM
00002766  4CDF 7FFF               1767          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000276A  4E75                    1768          RTS
0000276C                          1769  
0000276C  48E7 FFFE               1770  ISMOVEMW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
00002770  43F8 1550               1771          LEA         MESSAGEMOVEMW, A1 *OPCODE is MOVEM.W
00002774  103C 000E               1772          MOVE.B      #14, D0
00002778  4E4F                    1773          TRAP        #15
0000277A  4EB9 00003B00           1774          JSR         EA_MOVEM
00002780  4CDF 7FFF               1775          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002784  4E75                    1776          RTS
00002786                          1777  
00002786  48E7 FFFE               1778  ISLEA   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000278A  43F8 156C               1779          LEA         MESSAGELEA, A1  *OPCODE is LEA so display LEA message
0000278E  103C 000E               1780          MOVE.B      #14, D0
00002792  4E4F                    1781          TRAP        #15
00002794  4EB9 0000361A           1782          JSR         EA_LEA
0000279A  4CDF 7FFF               1783          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000279E  4E75                    1784          RTS                         ; Exit subroutine
000027A0                          1785  
000027A0  48E7 FFFE               1786  ISJSR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027A4  43F8 155A               1787          LEA         MESSAGEJSR, A1  *OPCODE is NOP so display NOP message
000027A8  103C 000E               1788          MOVE.B      #14, D0
000027AC  4E4F                    1789          TRAP        #15
000027AE  4EB9 00003552           1790          JSR         EA_JSR
000027B4  4CDF 7FFF               1791          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027B8  4E75                    1792          RTS                         ; Exit subroutine
000027BA                          1793  
000027BA  48E7 FFFE               1794  ISRTS   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027BE  43F8 1566               1795          LEA         MESSAGERTS, A1  *OPCODE is RTS
000027C2  103C 000E               1796          MOVE.B      #14, D0
000027C6  4E4F                    1797          TRAP        #15
000027C8  548E                    1798          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
000027CA  4CDF 7FFF               1799          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027CE  4E75                    1800          RTS
000027D0                          1801  
000027D0  48E7 FFFE               1802  ISCLR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027D4  43F8 1560               1803          LEA         MESSAGECLR, A1  *OPCODE is CLR
000027D8  103C 000E               1804          MOVE.B      #14, D0
000027DC  4E4F                    1805          TRAP        #15
000027DE  4EB9 000032CA           1806          JSR         EA_CLR
000027E4  4CDF 7FFF               1807          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027E8  4E75                    1808          RTS
000027EA                          1809  
000027EA  48E7 FFFE               1810  ISNOP   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027EE  43F8 14F6               1811          LEA         MESSAGENOP, A1  *OPCODE is NOP so display NOP message
000027F2  103C 000E               1812          MOVE.B      #14, D0
000027F6  4E4F                    1813          TRAP        #15
000027F8  548E                    1814          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
000027FA  4CDF 7FFF               1815          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027FE  4E75                    1816          RTS                         ; Exit subroutine
00002800                          1817  
00002800  48E7 FFFE               1818  ISMOVEW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002804  43F8 14FC               1819          LEA         MESSAGEMOVEW, A1 *OPCODE is MOVE.W so display MOVEW message
00002808  103C 000E               1820          MOVE.B      #14, D0
0000280C  4E4F                    1821          TRAP        #15
0000280E  4EB9 000037FE           1822          JSR         EA_MOVE
00002814  4CDF 7FFF               1823          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002818  4E75                    1824          RTS                         ; Exit subroutine
0000281A                          1825  
0000281A  48E7 FFFE               1826  ISMOVEAW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
0000281E  43F8 153C               1827          LEA         MESSAGEMOVEAW, A1 *OPCODE is MOVEA.W so display MOVEA.W message
00002822  103C 000E               1828          MOVE.B      #14, D0
00002826  4E4F                    1829          TRAP        #15
00002828  4EB9 000039D6           1830          JSR         EA_MOVEA
0000282E  4CDF 7FFF               1831          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002832  4E75                    1832          RTS                         ; Exit subroutine
00002834                          1833  
00002834  48E7 FFFE               1834  ISMOVEL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002838  43F8 1505               1835          LEA         MESSAGEMOVEL, A1 *OPCODE is MOVE.L so display MOVE.L message
0000283C  103C 000E               1836          MOVE.B      #14, D0
00002840  4E4F                    1837          TRAP        #15
00002842  4EB9 000037FE           1838          JSR         EA_MOVE
00002848  4CDF 7FFF               1839          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000284C  4E75                    1840          RTS                         ; Exit subroutine
0000284E                          1841  
0000284E  48E7 FFFE               1842  ISMOVEAL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
00002852  43F8 1532               1843          LEA         MESSAGEMOVEAL, A1 *OPCODE is MOVEA.L so display MOVEA.L message
00002856  103C 000E               1844          MOVE.B      #14, D0
0000285A  4E4F                    1845          TRAP        #15
0000285C  4EB9 000039D6           1846          JSR         EA_MOVEA
00002862  4CDF 7FFF               1847          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002866  4E75                    1848          RTS                         ; Exit subroutine
00002868                          1849  
00002868  48E7 FFFE               1850  ISMOVEB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000286C  43F8 150E               1851          LEA         MESSAGEMOVEB, A1 *OPCODE is MOVE.B so display MOVEB message
00002870  103C 000E               1852          MOVE.B      #14, D0
00002874  4E4F                    1853          TRAP        #15
00002876  4EB9 000037FE           1854          JSR         EA_MOVE
0000287C  4CDF 7FFF               1855          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002880  4E75                    1856          RTS                         ; Exit subroutine
00002882                          1857  
00002882  48E7 FFFE               1858  ISADDIW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002886  43F8 1517               1859          LEA         MESSAGEADDIW, A1 *OPCODE is ADDI.W so display ADDI.W message
0000288A  103C 000E               1860          MOVE.B      #14, D0
0000288E  4E4F                    1861          TRAP        #15
00002890  4EB9 00002D84           1862          JSR         EA_ADDI
00002896  4CDF 7FFF               1863          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000289A  4E75                    1864          RTS                         ; Exit subroutine
0000289C                          1865  
0000289C  48E7 FFFE               1866  ISADDIL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000028A0  43F8 1520               1867          LEA         MESSAGEADDIL, A1 *OPCODE is ADDI.L so display ADDI.L message
000028A4  103C 000E               1868          MOVE.B      #14, D0
000028A8  4E4F                    1869          TRAP        #15
000028AA  4EB9 00002D84           1870          JSR         EA_ADDI
000028B0  4CDF 7FFF               1871          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000028B4  4E75                    1872          RTS                         ; Exit subroutine
000028B6                          1873  
000028B6  48E7 FFFE               1874  ISADDIB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000028BA  43F8 1529               1875          LEA         MESSAGEADDIB, A1 *OPCODE is ADDI.B so display ADDI.B message
000028BE  103C 000E               1876          MOVE.B      #14, D0
000028C2  4E4F                    1877          TRAP        #15
000028C4  4EB9 00002D84           1878          JSR         EA_ADDI
000028CA  4CDF 7FFF               1879          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000028CE  4E75                    1880          RTS                         ; Exit subroutine
000028D0                          1881  
000028D0                          1882  
000028D0                          1883  
000028D0                          1884  
000028D0                          1885  
000028D0                          1886  
000028D0                          1887  
000028D0                          1888  -------------------- end include --------------------
000028D0                          1889      INCLUDE 'EA.X68'
000028D0                          1890  
000028D0                          1891      INCLUDE 'EAMessages.X68'
000028D0                          1892  
000028D0= 00                      1893  EA_MSG_NULL         DC.B    0
000028D1= 20                      1894  EA_MSG_SPACE        DC.B    ' '
000028D2= 2C 20                   1895  EA_MSG_COMMA        DC.B    ', '
000028D4= 28                      1896  EA_MSG_OPENPAREN    DC.B    '('
000028D5= 29                      1897  EA_MSG_CLOSEPAREN   DC.B    ')'
000028D6= 2D                      1898  EA_MSG_MIN          DC.B    '-'
000028D7= 2B                      1899  EA_MSG_PLUS         DC.B    '+'
000028D8= 23                      1900  EA_MSG_HASH         DC.B    '#'
000028D9= 24                      1901  EA_MSG_HEX          DC.B    '$'
000028DA                          1902  
000028DA= 44 30                   1903  EA_MSG_D0           DC.B    'D0'
000028DC= 44 31                   1904  EA_MSG_D1           DC.B    'D1'
000028DE= 44 32                   1905  EA_MSG_D2           DC.B    'D2'
000028E0= 44 33                   1906  EA_MSG_D3           DC.B    'D3'
000028E2= 44 34                   1907  EA_MSG_D4           DC.B    'D4'
000028E4= 44 35                   1908  EA_MSG_D5           DC.B    'D5'
000028E6= 44 36                   1909  EA_MSG_D6           DC.B    'D6'
000028E8= 44 37                   1910  EA_MSG_D7           DC.B    'D7'
000028EA                          1911  
000028EA= 41 30                   1912  EA_MSG_A0           DC.B    'A0'
000028EC= 41 31                   1913  EA_MSG_A1           DC.B    'A1'
000028EE= 41 32                   1914  EA_MSG_A2           DC.B    'A2'
000028F0= 41 33                   1915  EA_MSG_A3           DC.B    'A3'
000028F2= 41 34                   1916  EA_MSG_A4           DC.B    'A4'
000028F4= 41 35                   1917  EA_MSG_A5           DC.B    'A5'
000028F6= 41 36                   1918  EA_MSG_A6           DC.B    'A6'
000028F8= 41 37                   1919  EA_MSG_A7           DC.B    'A7'
000028FA                          1920  
000028FA                          1921  
000028FA                          1922  -------------------- end include --------------------
000028FA                          1923      INCLUDE 'EA_UTIL.X68'
000028FA                          1924  
000028FA                          1925  
000028FA                          1926  EA_UNIMPLEMENTED:
000028FA  548E                    1927      ADDA.L      #$00000002, A6      ; Increment past current opcode word
000028FC                          1928      *print unimplemented message
000028FC  4E75                    1929      RTS
000028FE                          1930  
000028FE                          1931  EA_INVALID:
000028FE  2A4E                    1932      MOVEA.L     A6, A5              ; Copy global pointer
00002900  548D                    1933      ADDA.L      #$00000002, A5      ; Increment past current opcode word
00002902  4EB8 12EE               1934      JSR         INVALID_DATA        ; Print data error message
00002906  4E75                    1935      RTS
00002908                          1936  
00002908                          1937  EA_UPDATE_POINTER:
00002908  BDCD                    1938      CMP.L       A5, A6              ; Check if A5==A6
0000290A  6600 0004               1939      BNE         UPDATE_PTR          ; If NOT equal (a.k.a if any extra operands
0000290E                          1940                                      ; were read, and is already up to date),
0000290E                          1941                                      ; update global with current
0000290E  548D                    1942      ADDA.L      #$00000002, A5      ; Else, increment past current opcode word, then update
00002910                          1943  UPDATE_PTR:
00002910  2C4D                    1944      MOVEA.L     A5, A6              ; Update global pointer
00002912  4E75                    1945      RTS
00002914                          1946  
00002914                          1947  EA_COPY_PTR:
00002914  2A4E                    1948      MOVEA.L     A6, A5              ; Save global pointer
00002916  4E75                    1949      RTS
00002918                          1950  
00002918                          1951  EA_DEFAULT_COMBO:
00002918  4286                    1952      CLR.L       D6                  ; Clear space for mode bits
0000291A  4287                    1953      CLR.L       D7                  ; Clear space for register bits
0000291C  2216                    1954      MOVE.L      (A6), D1            ; Load opcode to data register 1
0000291E  143C 000A               1955      MOVE.B      #10, D2             ; Clear upper 10 bits of opcode word
00002922  E569                    1956      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002924  143C 000D               1957      MOVE.B      #13, D2             ; 'Right-align' bits 3-5 to determine mode bits
00002928  E469                    1958      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
0000292A  1C01                    1959      MOVE.B      D1, D6              ; Save mode bits to D6
0000292C  2216                    1960      MOVE.L      (A6), D1            ; Reload opcode to data register 1
0000292E  143C 000D               1961      MOVE.B      #13, D2             ; Clear upper 13 bits of opcode word
00002932  E569                    1962      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002934  143C 000D               1963      MOVE.B      #13, D2             ; 'Right-align' bits 0-2 to determine register bits
00002938  E469                    1964      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
0000293A  1E01                    1965      MOVE.B      D1, D7              ; Save register bits to D7
0000293C  4E75                    1966      RTS                             ; Return from subroutine
0000293E                          1967  
0000293E                          1968  EA_OPMODE_COMBO:
0000293E  4286                    1969      CLR.L       D6                  ; Clear space for mode bits
00002940  4287                    1970      CLR.L       D7                  ; Clear space for register bits
00002942  2216                    1971      MOVE.L      (A6), D1            ; Load opcode to data register 1
00002944  143C 0007               1972      MOVE.B      #7, D2              ; Clear upper 7 bits of opcode word
00002948  E569                    1973      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
0000294A  143C 000D               1974      MOVE.B      #13, D2             ; 'Right-align' bits 6-8 to determine opmode bits
0000294E  E469                    1975      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002950  1C01                    1976      MOVE.B      D1, D6              ; Save opmode bits to D6
00002952  2216                    1977      MOVE.L      (A6), D1            ; Reload opcode to data register 1
00002954  143C 0004               1978      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00002958  E569                    1979      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
0000295A  143C 000D               1980      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register bits
0000295E  E469                    1981      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002960  1E01                    1982      MOVE.B      D1, D7              ; Save register bits to D7
00002962  4E75                    1983      RTS                             ; Return from subroutine
00002964                          1984  
00002964                          1985  EA_SIZE_BITS:
00002964  4287                    1986      CLR.L       D7
00002966  2E16                    1987      MOVE.L      (A6), D7            ; Load opcode to data register 1
00002968  143C 0008               1988      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
0000296C  E56F                    1989      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
0000296E  143C 000E               1990      MOVE.B      #14, D2             ; 'Right-align' bits 6-7 to determine size bits
00002972  E46F                    1991      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00002974  4E75                    1992      RTS
00002976                          1993  
00002976                          1994  
00002976                          1995  EA_PRINT_DN:
00002976  41F9 00002984           1996      LEA         EA_PRINT_DN_JMP, A0 ; Set index '0' for jump table
0000297C  CEFC 0006               1997      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002980  4EF0 7000               1998      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002984                          1999  EA_PRINT_DN_JMP:
00002984  4EF9 000029B4           2000      JMP         DN_000 ; D0
0000298A  4EF9 000029B4           2001      JMP         DN_001 ; D1
00002990  4EF9 000029B4           2002      JMP         DN_010 ; D2
00002996  4EF9 000029B4           2003      JMP         DN_011 ; D3
0000299C  4EF9 000029B4           2004      JMP         DN_100 ; D4
000029A2  4EF9 000029B4           2005      JMP         DN_101 ; D5
000029A8  4EF9 000029B4           2006      JMP         DN_110 ; D6
000029AE  4EF9 000029B4           2007      JMP         DN_111 ; D7
000029B4                          2008  DN_000: ; D0
000029B4                          2009      *MOVE.L      #DREG0, A4
000029B4                          2010      *JSR         WRITE_LINE
000029B4                          2011  DN_001 ; D1
000029B4                          2012  DN_010 ; D2
000029B4                          2013  DN_011 ; D3
000029B4                          2014  DN_100 ; D4
000029B4                          2015  DN_101 ; D5
000029B4                          2016  DN_110 ; D6
000029B4                          2017  DN_111 ; D7
000029B4                          2018  
000029B4                          2019  EA_PRINT_DN_END:
000029B4  4E75                    2020      RTS
000029B6                          2021  
000029B6                          2022  EA_PRINT_AN:
000029B6  41F9 000029C4           2023      LEA         AN_JMP, A0          ; Set index '0' for jump table
000029BC  CEFC 0006               2024      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000029C0  4EF0 7000               2025      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000029C4                          2026  AN_JMP:
000029C4  4EF9 000029F4           2027      JMP         AN_000 ; A0
000029CA  4EF9 000029F4           2028      JMP         AN_001 ; A1
000029D0  4EF9 000029F4           2029      JMP         AN_010 ; A2
000029D6  4EF9 000029F4           2030      JMP         AN_011 ; A3
000029DC  4EF9 000029F4           2031      JMP         AN_100 ; A4
000029E2  4EF9 000029F4           2032      JMP         AN_101 ; A5
000029E8  4EF9 000029F4           2033      JMP         AN_110 ; A6
000029EE  4EF9 000029F4           2034      JMP         AN_111 ; A7
000029F4                          2035  AN_000 ; A0
000029F4                          2036  AN_001 ; A1
000029F4                          2037  AN_010 ; A2
000029F4                          2038  AN_011 ; A3
000029F4                          2039  AN_100 ; A4
000029F4                          2040  AN_101 ; A5
000029F4                          2041  AN_110 ; A6
000029F4                          2042  AN_111 ; A7
000029F4                          2043  
000029F4                          2044  EA_PRINT_AN_END:
000029F4  4E75                    2045      RTS
000029F6                          2046  EA_PRINT_IND:
000029F6  41F9 00002A04           2047      LEA         IND_JMP, A0         ; Set index '0' for jump table
000029FC  CEFC 0006               2048      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002A00  4EF0 7000               2049      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002A04                          2050  IND_JMP:
00002A04  4EF9 00002A34           2051      JMP         IND_000 ; (A0)
00002A0A  4EF9 00002A34           2052      JMP         IND_001 ; (A1)
00002A10  4EF9 00002A34           2053      JMP         IND_010 ; (A2)
00002A16  4EF9 00002A34           2054      JMP         IND_011 ; (A3)
00002A1C  4EF9 00002A34           2055      JMP         IND_100 ; (A4)
00002A22  4EF9 00002A34           2056      JMP         IND_101 ; (A5)
00002A28  4EF9 00002A34           2057      JMP         IND_110 ; (A6)
00002A2E  4EF9 00002A34           2058      JMP         IND_111 ; (A7)
00002A34                          2059  IND_000 ; (A0)
00002A34                          2060  IND_001 ; (A1)
00002A34                          2061  IND_010 ; (A2)
00002A34                          2062  IND_011 ; (A3)
00002A34                          2063  IND_100 ; (A4)
00002A34                          2064  IND_101 ; (A5)
00002A34                          2065  IND_110 ; (A6)
00002A34                          2066  IND_111 ; (A7)
00002A34                          2067  
00002A34                          2068  EA_PRINT_IND_END:
00002A34  4E75                    2069      RTS
00002A36                          2070  EA_PRINT_IMM:
00002A36  224D                    2071      MOVEA.L     A5, A1              ; copy pointer to temp
00002A38  5489                    2072      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002A3A  BA7C 0003               2073      CMP         #3, D5
00002A3E  6700 000C               2074      BEQ         PRINT_IMM_L         ; if L, branch
00002A42  3011                    2075      MOVE.W      (A1), D0            ; store value in a register (todo, register tbd)
00002A44                          2076      *print value TODO
00002A44  5489                    2077      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002A46  4EF9 00002A50           2078      JMP         PRINT_IMM_END
00002A4C                          2079  PRINT_IMM_L:
00002A4C  2011                    2080      MOVE.L      (A1), D0            ; store value in a register (todo, register tbd)
00002A4E                          2081      *print value TODO
00002A4E  5889                    2082      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002A50                          2083  PRINT_IMM_END:
00002A50  2A49                    2084      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002A52  4E75                    2085      RTS
00002A54                          2086  EA_PRINT_POSTINC:
00002A54  41F9 00002A62           2087      LEA         POSTINC_JMP, A0     ; Set index '0' for jump table
00002A5A  CEFC 0006               2088      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002A5E  4EF0 7000               2089      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002A62                          2090  POSTINC_JMP:
00002A62  4EF9 00002A92           2091      JMP         POSTINC_000 ; (A0)+
00002A68  4EF9 00002A92           2092      JMP         POSTINC_001 ; (A1)+
00002A6E  4EF9 00002A92           2093      JMP         POSTINC_010 ; (A2)+
00002A74  4EF9 00002A92           2094      JMP         POSTINC_011 ; (A3)+
00002A7A  4EF9 00002A92           2095      JMP         POSTINC_100 ; (A4)+
00002A80  4EF9 00002A92           2096      JMP         POSTINC_101 ; (A5)+
00002A86  4EF9 00002A92           2097      JMP         POSTINC_110 ; (A6)+
00002A8C  4EF9 00002A92           2098      JMP         POSTINC_111 ; (A7)+
00002A92                          2099  POSTINC_000 ; (A0)+
00002A92                          2100  POSTINC_001 ; (A1)+
00002A92                          2101  POSTINC_010 ; (A2)+
00002A92                          2102  POSTINC_011 ; (A3)+
00002A92                          2103  POSTINC_100 ; (A4)+
00002A92                          2104  POSTINC_101 ; (A5)+
00002A92                          2105  POSTINC_110 ; (A6)+
00002A92                          2106  POSTINC_111 ; (A7)+
00002A92                          2107  
00002A92                          2108  EA_PRINT_PI_END:
00002A92  4E75                    2109      RTS
00002A94                          2110  EA_PRINT_PREDEC:
00002A94  41F9 00002AA2           2111      LEA         PREDEC_JMP, A0      ; Set index '0' for jump table
00002A9A  CEFC 0006               2112      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002A9E  4EF0 7000               2113      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002AA2                          2114  PREDEC_JMP:
00002AA2  4EF9 00002AD2           2115      JMP         PREDEC_000 ; -(A0)
00002AA8  4EF9 00002AD2           2116      JMP         PREDEC_001 ; -(A1)
00002AAE  4EF9 00002AD2           2117      JMP         PREDEC_010 ; -(A2)
00002AB4  4EF9 00002AD2           2118      JMP         PREDEC_011 ; -(A3)
00002ABA  4EF9 00002AD2           2119      JMP         PREDEC_100 ; -(A4)
00002AC0  4EF9 00002AD2           2120      JMP         PREDEC_101 ; -(A5)
00002AC6  4EF9 00002AD2           2121      JMP         PREDEC_110 ; -(A6)
00002ACC  4EF9 00002AD2           2122      JMP         PREDEC_111 ; -(A7)
00002AD2                          2123  PREDEC_000 ; -(A0)
00002AD2                          2124  PREDEC_001 ; -(A1)
00002AD2                          2125  PREDEC_010 ; -(A2)
00002AD2                          2126  PREDEC_011 ; -(A3)
00002AD2                          2127  PREDEC_100 ; -(A4)
00002AD2                          2128  PREDEC_101 ; -(A5)
00002AD2                          2129  PREDEC_110 ; -(A6)
00002AD2                          2130  PREDEC_111 ; -(A7)
00002AD2                          2131  
00002AD2                          2132  EA_PRINT_PD_END:
00002AD2  4E75                    2133      RTS
00002AD4                          2134  EA_PRINT_ABS_L:
00002AD4  224D                    2135      MOVEA.L     A5, A1              ; copy pointer to temp
00002AD6  5489                    2136      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002AD8  2011                    2137      MOVE.L      (A1), D0            ; store longword address to print TODO
00002ADA                          2138      *print value TODO
00002ADA  5889                    2139      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002ADC  2A49                    2140      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002ADE  4E75                    2141      RTS
00002AE0                          2142  EA_PRINT_ABS_W:
00002AE0  224D                    2143      MOVEA.L     A5, A1              ; copy pointer to temp
00002AE2  5489                    2144      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002AE4  2011                    2145      MOVE.L      (A1), D0            ; store word address to print in TODO
00002AE6                          2146      *print value TODO
00002AE6  5489                    2147      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002AE8  2A49                    2148      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002AEA  4E75                    2149      RTS
00002AEC                          2150  
00002AEC                          2151  
00002AEC                          2152  -------------------- end include --------------------
00002AEC                          2153  
00002AEC                          2154  EA_ADD:
00002AEC  48E7 FFFC               2155      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002AF0  4EB8 2914               2156      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002AF4  4EB8 293E               2157      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00002AF8  41F9 00002B06           2158      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
00002AFE  CCFC 0006               2159      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002B02  4EF0 6000               2160      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002B06                          2161  ADD_OPMODE:
00002B06  4EF9 00002B36           2162      JMP         ADD_OPMODE_000      ; mode 1, byte
00002B0C  4EF9 00002B40           2163      JMP         ADD_OPMODE_001      ; mode 1, word
00002B12  4EF9 00002B4A           2164      JMP         ADD_OPMODE_010      ; mode 1, long
00002B18  4EF9 00002B54           2165      JMP         ADD_OPMODE_011      ; Invalid value
00002B1E  4EF9 00002B5E           2166      JMP         ADD_OPMODE_100      ; mode 2, byte
00002B24  4EF9 00002B68           2167      JMP         ADD_OPMODE_101      ; mode 2, word
00002B2A  4EF9 00002B72           2168      JMP         ADD_OPMODE_110      ; mode 2, long
00002B30  4EF9 00002B7C           2169      JMP         ADD_OPMODE_111      ; Invalid value
00002B36                          2170  ADD_OPMODE_000: ; mode 1, byte
00002B36  1A3C 0001               2171      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002B3A  4EF9 00002B86           2172      JMP         ADD_MODE_1
00002B40                          2173  ADD_OPMODE_001: ; mode 1, word
00002B40  1A3C 0002               2174      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00002B44  4EF9 00002B86           2175      JMP         ADD_MODE_1
00002B4A                          2176  ADD_OPMODE_010: ; mode 1, long
00002B4A  1A3C 0003               2177      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00002B4E  4EF9 00002B86           2178      JMP         ADD_MODE_1
00002B54                          2179  ADD_OPMODE_011: ; Invalid value
00002B54  4EB8 28FE               2180      JSR         EA_INVALID
00002B58  4EF9 00002C96           2181      JMP         ADD_END
00002B5E                          2182  ADD_OPMODE_100: ; mode 2, byte
00002B5E  1A3C 0001               2183      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002B62  4EF9 00002BA4           2184      JMP         ADD_MODE_2
00002B68                          2185  ADD_OPMODE_101: ; mode 2, word
00002B68  1A3C 0001               2186      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002B6C  4EF9 00002BA4           2187      JMP         ADD_MODE_2
00002B72                          2188  ADD_OPMODE_110: ; mode 2, long
00002B72  1A3C 0001               2189      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002B76  4EF9 00002BA4           2190      JMP         ADD_MODE_2
00002B7C                          2191  ADD_OPMODE_111: ; Invalid value
00002B7C  4EB8 28FE               2192      JSR         EA_INVALID
00002B80  4EF9 00002C96           2193      JMP         ADD_END
00002B86                          2194  ADD_MODE_1:
00002B86  4280                    2195      CLR.L       D0                  ; Clear data register 0
00002B88  103C 0001               2196      MOVE.B      #1, D0              ; Save mode number to D0
00002B8C  3207                    2197      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00002B8E  4EB8 2918               2198      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002B92  4EB9 00002BBE           2199      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002B98                          2200      *PRINT COMMA TODO
00002B98  3E01                    2201      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00002B9A  4EB8 2976               2202      JSR         EA_PRINT_DN         ; Print data register
00002B9E  4EF9 00002C96           2203      JMP         ADD_END
00002BA4                          2204  ADD_MODE_2:
00002BA4  4280                    2205      CLR.L       D0                  ; Clear data register 0
00002BA6  103C 0002               2206      MOVE.B      #2, D0              ; Save mode number to D0
00002BAA  4EB8 2976               2207      JSR         EA_PRINT_DN         ; Print data register
00002BAE                          2208      *PRINT COMMA TODO
00002BAE  4EB8 2918               2209      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002BB2  4EB9 00002BBE           2210      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002BB8  4EF9 00002C96           2211      JMP         ADD_END
00002BBE                          2212  ADD_EVAL_EA:
00002BBE  41F9 00002BCC           2213      LEA         ADD_MODE, A0        ; Set index '0' for jump table
00002BC4  CCFC 0006               2214      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002BC8  4EF0 6000               2215      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002BCC                          2216  ADD_MODE:
00002BCC  4EF9 00002BFC           2217      JMP         ADD_MODE_000        ; Dn (invalid if opmode 2)
00002BD2  4EF9 00002C0E           2218      JMP         ADD_MODE_001        ; An (invalid if opmode 2)
00002BD8  4EF9 00002C20           2219      JMP         ADD_MODE_010        ; (An)
00002BDE  4EF9 00002C2A           2220      JMP         ADD_MODE_011        ; (An)+
00002BE4  4EF9 00002C34           2221      JMP         ADD_MODE_100        ; -(An)
00002BEA  4EF9 00002C3E           2222      JMP         ADD_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00002BF0  4EF9 00002C44           2223      JMP         ADD_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002BF6  4EF9 00002C4A           2224      JMP         ADD_MODE_111        ; The rest (not all valid, validated by register number)
00002BFC                          2225  ADD_MODE_000: ; Dn (invalid if opmode 2)
00002BFC  B07C 0002               2226      CMP         #2, D0
00002C00  6700 008E               2227      BEQ         ADD_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00002C04  4EB8 2976               2228      JSR         EA_PRINT_DN         ; Print data register direct operand
00002C08  4EF9 00002C8E           2229      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002C0E                          2230  ADD_MODE_001: ; An (invalid if opmode 2)
00002C0E  B07C 0002               2231      CMP         #2, D0
00002C12  6700 007C               2232      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002C16  4EB8 29B6               2233      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002C1A  4EF9 00002C8E           2234      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002C20                          2235  ADD_MODE_010: ; (An)
00002C20  4EB8 29F6               2236      JSR         EA_PRINT_IND         ; Print address register indirect
00002C24  4EF9 00002C8E           2237      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002C2A                          2238  ADD_MODE_011: ; (An)+
00002C2A  4EB8 2A54               2239      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002C2E  4EF9 00002C8E           2240      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002C34                          2241  ADD_MODE_100: ; -(An)
00002C34  4EB8 2A94               2242      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002C38  4EF9 00002C8E           2243      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002C3E                          2244  ADD_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002C3E  4EF9 00002C90           2245      JMP         ADD_MODE_INVALID
00002C44                          2246  ADD_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002C44  4EF9 00002C90           2247      JMP         ADD_MODE_INVALID
00002C4A                          2248  ADD_MODE_111: ; The rest (not all valid, validated by register number)
00002C4A  BE3C 0000               2249      CMP.B       #$00, D7            ; Test for absolute word address
00002C4E  6700 0018               2250      BEQ         ADD_ABS_W
00002C52  BE3C 0001               2251      CMP.B       #$01, D7            ; Test for absolute long address
00002C56  6700 001A               2252      BEQ         ADD_ABS_L
00002C5A  BE3C 0004               2253      CMP.B       #$04, D7            ; Test for immediate data
00002C5E  6700 001C               2254      BEQ         ADD_IMM
00002C62  4EF9 00002C90           2255      JMP         ADD_MODE_INVALID    ; else, invalid
00002C68                          2256  ADD_ABS_W:
00002C68  4EB8 2AE0               2257      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002C6C  4EF9 00002C8E           2258      JMP         ADD_MODE_END
00002C72                          2259  ADD_ABS_L:
00002C72  4EB8 2AD4               2260      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002C76  4EF9 00002C8E           2261      JMP         ADD_MODE_END
00002C7C                          2262  ADD_IMM: ; invalid if opmode is 2
00002C7C  B07C 0002               2263      CMP         #2, D0
00002C80  6700 000E               2264      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002C84  4EB8 2A36               2265      JSR         EA_PRINT_IMM        ; Print immediate data
00002C88  4EF9 00002C8E           2266      JMP         ADD_MODE_END
00002C8E                          2267  ADD_MODE_END:
00002C8E  4E75                    2268      RTS                             ; Finish evaluating EA bits
00002C90                          2269  ADD_MODE_INVALID:
00002C90  4EB8 28FE               2270      JSR         EA_INVALID          ; Opcode word is Invalid
00002C94  4E75                    2271      RTS                             ; Finish evaluating EA bits
00002C96                          2272  ADD_END:
00002C96  4EB8 2908               2273      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00002C9A  4CDF 3FFF               2274      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002C9E  4E75                    2275      RTS
00002CA0                          2276  
00002CA0                          2277  EA_ADDA:
00002CA0  48E7 FFFC               2278      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002CA4  4EB8 2914               2279      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002CA8  4EB8 2918               2280      JSR         EA_DEFAULT_COMBO    ; Mode: D6, register: D7
00002CAC  41F9 00002CBA           2281      LEA         ADDA_MODE, A0       ; Set index '0' for jump table
00002CB2  CCFC 0006               2282      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002CB6  4EF0 6000               2283      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002CBA                          2284  ADDA_MODE:
00002CBA  4EF9 00002CEA           2285      JMP         ADDA_MODE_000       ; Dn
00002CC0  4EF9 00002CF4           2286      JMP         ADDA_MODE_001       ; An
00002CC6  4EF9 00002CFE           2287      JMP         ADDA_MODE_010       ; (An)
00002CCC  4EF9 00002D08           2288      JMP         ADDA_MODE_011       ; (An)+
00002CD2  4EF9 00002D12           2289      JMP         ADDA_MODE_100       ; -(An)
00002CD8  4EF9 00002D1C           2290      JMP         ADDA_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00002CDE  4EF9 00002D22           2291      JMP         ADDA_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002CE4  4EF9 00002D28           2292      JMP         ADDA_MODE_111       ; The rest (not all valid, validated by register number)
00002CEA                          2293  ADDA_MODE_000: ; Dn
00002CEA  4EB8 2976               2294      JSR         EA_PRINT_DN         ; Print data register direct operand
00002CEE  4EF9 00002D72           2295      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002CF4                          2296  ADDA_MODE_001: ; An
00002CF4  4EB8 29B6               2297      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002CF8  4EF9 00002D72           2298      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002CFE                          2299  ADDA_MODE_010: ; (An)
00002CFE  4EB8 29F6               2300      JSR         EA_PRINT_IND         ; Print address register indirect
00002D02  4EF9 00002D72           2301      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002D08                          2302  ADDA_MODE_011: ; (An)+
00002D08  4EB8 2A54               2303      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002D0C  4EF9 00002D72           2304      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002D12                          2305  ADDA_MODE_100: ; -(An)
00002D12  4EB8 2A94               2306      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002D16  4EF9 00002D72           2307      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002D1C                          2308  ADDA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002D1C  4EF9 00002D68           2309      JMP         ADDA_MODE_INVALID
00002D22                          2310  ADDA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002D22  4EF9 00002D68           2311      JMP         ADDA_MODE_INVALID
00002D28                          2312  ADDA_MODE_111: ; The rest (not all valid, validated by register number)
00002D28  BE3C 0000               2313      CMP.B       #$00, D7            ; Test for absolute word address
00002D2C  6700 0018               2314      BEQ         ADDA_ABS_W
00002D30  BE3C 0001               2315      CMP.B       #$01, D7            ; Test for absolute long address
00002D34  6700 001A               2316      BEQ         ADDA_ABS_L
00002D38  BE3C 0004               2317      CMP.B       #$04, D7            ; Test for immediate data
00002D3C  6700 001C               2318      BEQ         ADDA_IMM
00002D40  4EF9 00002D68           2319      JMP         ADDA_MODE_INVALID   ; Else, invalid
00002D46                          2320  ADDA_ABS_W:
00002D46  4EB8 2AE0               2321      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002D4A  4EF9 00002D72           2322      JMP         ADDA_MODE_END
00002D50                          2323  ADDA_ABS_L:
00002D50  4EB8 2AD4               2324      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002D54  4EF9 00002D72           2325      JMP         ADDA_MODE_END
00002D5A                          2326  ADDA_IMM:
00002D5A  4EB8 293E               2327      JSR         EA_OPMODE_COMBO     ; Get opmode bits in
00002D5E  4EB8 2A36               2328      JSR         EA_PRINT_IMM        ; Print immediate data
00002D62  4EF9 00002D72           2329      JMP         ADDA_MODE_END
00002D68                          2330  ADDA_MODE_INVALID:
00002D68  4EB8 28FE               2331      JSR         EA_INVALID          ; Opcode word is Invalid
00002D6C  4EF9 00002D7A           2332      JMP         ADDA_END
00002D72                          2333  ADDA_MODE_END:
00002D72                          2334      *PRINT COMMA TODO
00002D72  4EB8 293E               2335      JSR         EA_OPMODE_COMBO     ; Opmode: D6, register: D7
00002D76  4EB8 29B6               2336      JSR         EA_PRINT_AN         ; Print address register
00002D7A                          2337  ADDA_END:
00002D7A  4EB8 2908               2338      JSR         EA_UPDATE_POINTER   ; Update global pointer
00002D7E  4CDF 3FFF               2339      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002D82  4E75                    2340      RTS
00002D84                          2341  
00002D84                          2342  EA_ADDI:
00002D84  48E7 FFFC               2343      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002D88  4EB8 2914               2344      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002D8C  4EB8 2964               2345      JSR         EA_SIZE_BITS        ; get size bits in D7
00002D90  BE3C 0000               2346      CMP.B       #$00, D7            ; Test if size: byte
00002D94  6700 001C               2347      BEQ         ADDI_B
00002D98  BE3C 0001               2348      CMP.B       #$01, D7            ; Test if size: word
00002D9C  6700 002E               2349      BEQ         ADDI_W
00002DA0  BE3C 0002               2350      CMP.B       #$02, D7            ; Test if size: long
00002DA4  6700 0034               2351      BEQ         ADDI_L
00002DA8  4EB8 28FE               2352      JSR         EA_INVALID          ; Else, invalid
00002DAC  4EF9 00002E96           2353      JMP         ADDI_END
00002DB2                          2354  ADDI_B:
00002DB2  548D                    2355      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002DB4  4280                    2356      CLR.L       D0
00002DB6  3015                    2357      MOVE.W      (A5), D0            ; read next word in memory and save
00002DB8  143C 0008               2358      MOVE.B      #8, D2              ; Clear upper 8 bits of operand word
00002DBC  E568                    2359      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00002DBE  143C 0008               2360      MOVE.B      #8, D2             ; 'Right-align' bits 0-7 to get value
00002DC2  E468                    2361      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00002DC4                          2362      *print data
00002DC4  548D                    2363      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
00002DC6  4EF9 00002DE0           2364      JMP         ADDI_GET_DEST
00002DCC                          2365  ADDI_W:
00002DCC  548D                    2366      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002DCE  4280                    2367      CLR.L       D0
00002DD0  3015                    2368      MOVE.W      (A5), D0            ; read next word in memory and save
00002DD2                          2369      *print data
00002DD2  548D                    2370      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
00002DD4  4EF9 00002DE0           2371      JMP         ADDI_GET_DEST
00002DDA                          2372  ADDI_L:
00002DDA  548D                    2373      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002DDC  2015                    2374      MOVE.L      (A5), D0            ; read next two words in memory and save
00002DDE  588D                    2375      ADDA.L      #$00000004, A5      ; Increment A5 past operand longword
00002DE0                          2376  ADDI_GET_DEST:
00002DE0                          2377      *PRINT COMMA
00002DE0  4EB8 2918               2378      JSR         EA_DEFAULT_COMBO    ; get mode bits in D6, register bits in D7
00002DE4  41F9 00002DF2           2379      LEA         ADDI_MODE, A0       ; Set index '0' for jump table
00002DEA  CCFC 0006               2380      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002DEE  4EF0 6000               2381      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002DF2                          2382  ADDI_MODE:
00002DF2  4EF9 00002E22           2383      JMP         ADDI_MODE_000       ; Dn
00002DF8  4EF9 00002E2C           2384      JMP         ADDI_MODE_001       ; Invalid: An
00002DFE  4EF9 00002E36           2385      JMP         ADDI_MODE_010       ; (An)
00002E04  4EF9 00002E40           2386      JMP         ADDI_MODE_011       ; (An)+
00002E0A  4EF9 00002E4A           2387      JMP         ADDI_MODE_100       ; -(An)
00002E10  4EF9 00002E54           2388      JMP         ADDI_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00002E16  4EF9 00002E5E           2389      JMP         ADDI_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002E1C  4EF9 00002E68           2390      JMP         ADDI_MODE_111       ; The rest (not all valid, validated by register number)
00002E22                          2391  ADDI_MODE_000: ; Dn
00002E22  4EB8 2976               2392      JSR         EA_PRINT_DN         ; Print data register direct operand
00002E26  4EF9 00002E96           2393      JMP         ADDI_END
00002E2C                          2394  ADDI_MODE_001: ; Invalid: An
00002E2C  4EB8 28FE               2395      JSR         EA_INVALID          ; Opcode word is Invalid
00002E30  4EF9 00002E96           2396      JMP         ADDI_END
00002E36                          2397  ADDI_MODE_010: ; (An)
00002E36  4EB8 29F6               2398      JSR         EA_PRINT_IND         ; Print address register indirect
00002E3A  4EF9 00002E96           2399      JMP         ADDI_END            ; End evaluation of ea mode
00002E40                          2400  ADDI_MODE_011: ; (An)+
00002E40  4EB8 2A54               2401      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002E44  4EF9 00002E96           2402      JMP         ADDI_END            ; End evaluation of ea mode
00002E4A                          2403  ADDI_MODE_100: ; -(An)
00002E4A  4EB8 2A94               2404      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002E4E  4EF9 00002E96           2405      JMP         ADDI_END            ; End evaluation of ea mode
00002E54                          2406  ADDI_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002E54  4EB8 28FE               2407      JSR         EA_INVALID          ; Opcode word is Invalid
00002E58  4EF9 00002E96           2408      JMP         ADDI_END
00002E5E                          2409  ADDI_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002E5E  4EB8 28FE               2410      JSR         EA_INVALID          ; Opcode word is Invalid
00002E62  4EF9 00002E96           2411      JMP         ADDI_END
00002E68                          2412  ADDI_MODE_111: ; The rest (not all valid, validated by register number)
00002E68  BE3C 0000               2413      CMP.B       #$00, D7            ; Test for absolute word address
00002E6C  6700 0014               2414      BEQ         ADDI_ABS_W
00002E70  BE3C 0001               2415      CMP.B       #$01, D7            ; Test for absolute long address
00002E74  6700 0016               2416      BEQ         ADDI_ABS_L
00002E78  4EB8 28FE               2417      JSR         EA_INVALID          ; else, invalid
00002E7C  4EF9 00002E96           2418      JMP         ADDI_END
00002E82                          2419  ADDI_ABS_W:
00002E82  4EB8 2AE0               2420      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002E86  4EF9 00002E96           2421      JMP         ADDI_END
00002E8C                          2422  ADDI_ABS_L:
00002E8C  4EB8 2AD4               2423      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002E90  4EF9 00002E96           2424      JMP         ADDI_END
00002E96                          2425  ADDI_END:
00002E96  4EB8 2908               2426      JSR         EA_UPDATE_POINTER   ; Update global pointer
00002E9A  4CDF 3FFF               2427      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002E9E  4E75                    2428      RTS
00002EA0                          2429  EA_ADDQ:
00002EA0  48E7 FFFC               2430      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002EA4  4EB8 2914               2431      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002EA8  2216                    2432      MOVE.L      (A6), D1            ; Load opcode to data register 1
00002EAA  143C 0004               2433      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00002EAE  E569                    2434      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002EB0  143C 000D               2435      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine mode bits
00002EB4  E469                    2436      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002EB6  B23C 0000               2437      CMP.B       #$00, D1            ; Check for special case (if imm. data is 0, value is actually 8)
00002EBA  6600 0006               2438      BNE         ADDQ_PRINT_IMM      ; If any value other than 0, print the data
00002EBE  123C 0008               2439      MOVE.B      #$08, D1            ; Else, the value is 0 and therefore symbolic of the value 8, so replace with the value 8
00002EC2                          2440  ADDQ_PRINT_IMM:
00002EC2                          2441      *PRINT HASH TODO
00002EC2                          2442      *PRINT IMM DATA IN D1 AS BYTE TODO
00002EC2                          2443      *PRINT COMMA TODO
00002EC2  4EB8 2918               2444      JSR         EA_DEFAULT_COMBO
00002EC6  41F9 00002ED4           2445      LEA         ADDQ_MODE, A0       ; Set index '0' for jump table
00002ECC  CCFC 0006               2446      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002ED0  4EF0 6000               2447      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002ED4                          2448  ADDQ_MODE:
00002ED4  4EF9 00002F04           2449      JMP         ADDQ_MODE_000       ; Dn
00002EDA  4EF9 00002F0E           2450      JMP         ADDQ_MODE_001       ; An
00002EE0  4EF9 00002F18           2451      JMP         ADDQ_MODE_010       ; (An)
00002EE6  4EF9 00002F22           2452      JMP         ADDQ_MODE_011       ; (An)+
00002EEC  4EF9 00002F2C           2453      JMP         ADDQ_MODE_100       ; -(An)
00002EF2  4EF9 00002F36           2454      JMP         ADDQ_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00002EF8  4EF9 00002F40           2455      JMP         ADDQ_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002EFE  4EF9 00002F4A           2456      JMP         ADDQ_MODE_111       ; The rest (not all valid, validated by register number)
00002F04                          2457  ADDQ_MODE_000: ; Dn
00002F04  4EB8 2976               2458      JSR         EA_PRINT_DN         ; Print data register direct operand
00002F08  4EF9 00002F78           2459      JMP         ADDQ_END            ; End evaluation of ea mode
00002F0E                          2460  ADDQ_MODE_001: ; An
00002F0E  4EB8 29B6               2461      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002F12  4EF9 00002F78           2462      JMP         ADDQ_END            ; End evaluation of ea mode
00002F18                          2463  ADDQ_MODE_010: ; (An)
00002F18  4EB8 29F6               2464      JSR         EA_PRINT_IND         ; Print address register indirect
00002F1C  4EF9 00002F78           2465      JMP         ADDQ_END            ; End evaluation of ea mode
00002F22                          2466  ADDQ_MODE_011: ; (An)+
00002F22  4EB8 2A54               2467      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002F26  4EF9 00002F78           2468      JMP         ADDQ_END            ; End evaluation of ea mode
00002F2C                          2469  ADDQ_MODE_100: ; -(An)
00002F2C  4EB8 2A94               2470      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002F30  4EF9 00002F78           2471      JMP         ADDQ_END            ; End evaluation of ea mode
00002F36                          2472  ADDQ_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002F36  4EB8 28FE               2473      JSR         EA_INVALID          ; Opcode word is Invalid
00002F3A  4EF9 00002F78           2474      JMP         ADDQ_END
00002F40                          2475  ADDQ_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002F40  4EB8 28FE               2476      JSR         EA_INVALID          ; Opcode word is Invalid
00002F44  4EF9 00002F78           2477      JMP         ADDQ_END
00002F4A                          2478  ADDQ_MODE_111: ; The rest (not all valid, validated by register number)
00002F4A  BE3C 0000               2479      CMP.B       #$00, D7            ; Test for absolute word address
00002F4E  6700 0014               2480      BEQ         ADDQ_ABS_W
00002F52  BE3C 0001               2481      CMP.B       #$01, D7            ; Test for absolute long address
00002F56  6700 0016               2482      BEQ         ADDQ_ABS_L
00002F5A  4EB8 28FE               2483      JSR         EA_INVALID          ; Opcode word is Invalid
00002F5E  4EF9 00002F78           2484      JMP         ADDQ_END
00002F64                          2485  ADDQ_ABS_W:
00002F64  4EB8 2AE0               2486      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002F68  4EF9 00002F78           2487      JMP         ADDQ_END
00002F6E                          2488  ADDQ_ABS_L:
00002F6E  4EB8 2AD4               2489      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002F72  4EF9 00002F78           2490      JMP         ADDQ_END
00002F78                          2491  
00002F78                          2492  ADDQ_END:
00002F78  4EB8 2908               2493      JSR         EA_UPDATE_POINTER   ; Update global pointer
00002F7C  4CDF 3FFF               2494      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002F80  4E75                    2495      RTS
00002F82                          2496  EA_AND:
00002F82  48E7 FFFC               2497      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002F86  4EB8 2914               2498      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002F8A  4EB8 293E               2499      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00002F8E  41F8 2B06               2500      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
00002F92  CCFC 0006               2501      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002F96  4EF0 6000               2502      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002F9A                          2503  AND_OPMODE:
00002F9A  4EF9 00002FCA           2504      JMP         AND_OPMODE_000      ; mode 1, byte
00002FA0  4EF9 00002FD4           2505      JMP         AND_OPMODE_001      ; mode 1, word
00002FA6  4EF9 00002FDE           2506      JMP         AND_OPMODE_010      ; mode 1, long
00002FAC  4EF9 00002FE8           2507      JMP         AND_OPMODE_011      ; Invalid value
00002FB2  4EF9 00002FF2           2508      JMP         AND_OPMODE_100      ; mode 2, byte
00002FB8  4EF9 00002FFC           2509      JMP         AND_OPMODE_101      ; mode 2, word
00002FBE  4EF9 00003006           2510      JMP         AND_OPMODE_110      ; mode 2, long
00002FC4  4EF9 00003010           2511      JMP         AND_OPMODE_111      ; Invalid value
00002FCA                          2512  AND_OPMODE_000: ; mode 1, byte
00002FCA  1A3C 0001               2513      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002FCE  4EF9 0000301A           2514      JMP         AND_MODE_1
00002FD4                          2515  AND_OPMODE_001: ; mode 1, word
00002FD4  1A3C 0002               2516      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00002FD8  4EF9 0000301A           2517      JMP         AND_MODE_1
00002FDE                          2518  AND_OPMODE_010: ; mode 1, long
00002FDE  1A3C 0003               2519      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00002FE2  4EF9 0000301A           2520      JMP         AND_MODE_1
00002FE8                          2521  AND_OPMODE_011: ; Invalid value
00002FE8  4EB8 28FE               2522      JSR         EA_INVALID
00002FEC  4EF9 0000311E           2523      JMP         AND_END
00002FF2                          2524  AND_OPMODE_100: ; mode 2, byte
00002FF2  1A3C 0001               2525      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002FF6  4EF9 00003038           2526      JMP         AND_MODE_2
00002FFC                          2527  AND_OPMODE_101: ; mode 2, word
00002FFC  1A3C 0001               2528      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003000  4EF9 00003038           2529      JMP         AND_MODE_2
00003006                          2530  AND_OPMODE_110: ; mode 2, long
00003006  1A3C 0001               2531      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000300A  4EF9 00003038           2532      JMP         AND_MODE_2
00003010                          2533  AND_OPMODE_111: ; Invalid value
00003010  4EB8 28FE               2534      JSR         EA_INVALID
00003014  4EF9 0000311E           2535      JMP         AND_END
0000301A                          2536  AND_MODE_1:
0000301A  4280                    2537      CLR.L       D0                  ; Clear data register 0
0000301C  103C 0001               2538      MOVE.B      #1, D0              ; Save mode number to D0
00003020  3207                    2539      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003022  4EB8 2918               2540      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003026  4EB9 00003052           2541      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
0000302C                          2542      *PRINT COMMA TODO
0000302C  3E01                    2543      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
0000302E  4EB8 2976               2544      JSR         EA_PRINT_DN         ; Print data register
00003032  4EF9 0000311E           2545      JMP         AND_END
00003038                          2546  AND_MODE_2:
00003038  4280                    2547      CLR.L       D0                  ; Clear data register 0
0000303A  103C 0002               2548      MOVE.B      #2, D0              ; Save mode number to D0
0000303E  4EB8 2976               2549      JSR         EA_PRINT_DN         ; Print data register
00003042                          2550      *PRINT COMMA TODO
00003042  4EB8 2918               2551      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003046  4EB9 00003052           2552      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
0000304C  4EF9 0000311E           2553      JMP         AND_END
00003052                          2554  AND_EVAL_EA:
00003052  41F9 00003060           2555      LEA         AND_MODE, A0        ; Set index '0' for jump table
00003058  CCFC 0006               2556      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000305C  4EF0 6000               2557      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003060                          2558  AND_MODE:
00003060  4EF9 00003090           2559      JMP         AND_MODE_000        ; Dn (invalid if opmode 2)
00003066  4EF9 000030A2           2560      JMP         AND_MODE_001        ; Invalid: An
0000306C  4EF9 000030A8           2561      JMP         AND_MODE_010        ; (An)
00003072  4EF9 000030B2           2562      JMP         AND_MODE_011        ; (An)+
00003078  4EF9 000030BC           2563      JMP         AND_MODE_100        ; -(An)
0000307E  4EF9 000030C6           2564      JMP         AND_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003084  4EF9 000030CC           2565      JMP         AND_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000308A  4EF9 000030D2           2566      JMP         AND_MODE_111        ; The rest (not all valid, validated by register number)
00003090                          2567  AND_MODE_000: ; Dn (invalid if opmode 2)
00003090  B07C 0002               2568      CMP         #2, D0
00003094  6700 0082               2569      BEQ         AND_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00003098  4EB8 2976               2570      JSR         EA_PRINT_DN         ; Print data register direct operand
0000309C  4EF9 00003116           2571      JMP         AND_MODE_END        ; End evaluation of ea mode
000030A2                          2572  AND_MODE_001: ; Invalid: An
000030A2  4EF9 00003118           2573      JMP         AND_MODE_INVALID
000030A8                          2574  AND_MODE_010: ; (An)
000030A8  4EB8 29F6               2575      JSR         EA_PRINT_IND         ; Print address register indirect
000030AC  4EF9 00003116           2576      JMP         AND_MODE_END        ; End evaluation of ea mode
000030B2                          2577  AND_MODE_011: ; (An)+
000030B2  4EB8 2A54               2578      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000030B6  4EF9 00003116           2579      JMP         AND_MODE_END        ; End evaluation of ea mode
000030BC                          2580  AND_MODE_100: ; -(An)
000030BC  4EB8 2A94               2581      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000030C0  4EF9 00003116           2582      JMP         AND_MODE_END        ; End evaluation of ea mode
000030C6                          2583  AND_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000030C6  4EF9 00003118           2584      JMP         AND_MODE_INVALID
000030CC                          2585  AND_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000030CC  4EF9 00003118           2586      JMP         AND_MODE_INVALID
000030D2                          2587  AND_MODE_111: ; The rest (not all valid, validated by register number)
000030D2  BE3C 0000               2588      CMP.B       #$00, D7            ; Test for absolute word address
000030D6  6700 0018               2589      BEQ         AND_ABS_W
000030DA  BE3C 0001               2590      CMP.B       #$01, D7            ; Test for absolute long address
000030DE  6700 001A               2591      BEQ         AND_ABS_L
000030E2  BE3C 0004               2592      CMP.B       #$04, D7            ; Test for immediate data
000030E6  6700 001C               2593      BEQ         AND_IMM
000030EA  4EF9 00003118           2594      JMP         AND_MODE_INVALID    ; else, invalid
000030F0                          2595  AND_ABS_W:
000030F0  4EB8 2AE0               2596      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000030F4  4EF9 00003116           2597      JMP         AND_MODE_END
000030FA                          2598  AND_ABS_L:
000030FA  4EB8 2AD4               2599      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000030FE  4EF9 00003116           2600      JMP         AND_MODE_END
00003104                          2601  AND_IMM: ; invalid if opmode is 2
00003104  B07C 0002               2602      CMP         #2, D0
00003108  6700 000E               2603      BEQ         AND_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
0000310C  4EB8 2A36               2604      JSR         EA_PRINT_IMM        ; Print immediate data
00003110  4EF9 00003116           2605      JMP         AND_MODE_END
00003116                          2606  AND_MODE_END:
00003116  4E75                    2607      RTS                             ; Finish evaluating EA bits
00003118                          2608  AND_MODE_INVALID:
00003118  4EB8 28FE               2609      JSR         EA_INVALID          ; Opcode word is Invalid
0000311C  4E75                    2610      RTS                             ; Finish evaluating EA bits
0000311E                          2611  AND_END:
0000311E  4EB8 2908               2612      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003122  4CDF 3FFF               2613      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003126  4E75                    2614      RTS
00003128                          2615  EA_ASd:
00003128  48E7 FFFC               2616      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000312C  4EB8 2914               2617      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003130  4EB8 2964               2618      JSR         EA_SIZE_BITS        ; get size bits in D7
00003134  BE3C 0003               2619      CMP.B       #$03, D7            ; test if memory shift
00003138  6700 0042               2620      BEQ         ASd_MEM
0000313C  6000 0002               2621      BRA         ASd_REG             ; else, register shfit
00003140                          2622  ASd_REG:
00003140  3E16                    2623      MOVE.W      (A6), D7            ; read opcode word in memory and save,
00003142                          2624                                      ; (using D7 because EA_PRINT_DN uses D7)
00003142  143C 0004               2625      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
00003146  E56F                    2626      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003148  143C 000D               2627      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
0000314C  E46F                    2628      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
0000314E  3016                    2629      MOVE.W      (A6), D0            ; read opcode word in memory and save
00003150  143C 000A               2630      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
00003154  E568                    2631      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00003156  143C 000F               2632      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
0000315A  E468                    2633      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
0000315C  B03C 0000               2634      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
00003160  6700 000C               2635      BEQ         ASd_REG_COUNT
00003164                          2636  ASd_REG_REG:                        ; Else, count/register field contains register number
00003164  4EB8 2976               2637      JSR         EA_PRINT_DN         ; Print register value, stored in D7
00003168  4EF9 0000316E           2638      JMP         ASd_REG_END         ; Jump to end of ASd_REG
0000316E                          2639  ASd_REG_COUNT:
0000316E                          2640      *print hash todo
0000316E                          2641      *print hex value in D7 as byte todo, continue on to ASd_REG_END
0000316E                          2642  ASd_REG_END:
0000316E                          2643      *PRINT COMMA todo
0000316E  4EB8 2918               2644      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
00003172  4EB8 2976               2645      JSR         EA_PRINT_DN         ; Print register value in D7
00003176  4EF9 00003232           2646      JMP         ASd_END
0000317C                          2647  ASd_MEM:
0000317C  4EB8 2918               2648      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003180  41F9 0000318E           2649      LEA         ASd_MEM_MODE, A0    ; Set index '0' for jump table
00003186  CCFC 0006               2650      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000318A  4EF0 6000               2651      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000318E                          2652  ASd_MEM_MODE:
0000318E  4EF9 000031BE           2653      JMP         ASd_MEM_MODE_000     ; Invalid: Dn
00003194  4EF9 000031C8           2654      JMP         ASd_MEM_MODE_001     ; Invalid: An
0000319A  4EF9 000031D2           2655      JMP         ASd_MEM_MODE_010     ; (An)
000031A0  4EF9 000031DC           2656      JMP         ASd_MEM_MODE_011     ; (An)+
000031A6  4EF9 000031E6           2657      JMP         ASd_MEM_MODE_100     ; -(An)
000031AC  4EF9 000031F0           2658      JMP         ASd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
000031B2  4EF9 000031FA           2659      JMP         ASd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000031B8  4EF9 00003204           2660      JMP         ASd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
000031BE                          2661  ASd_MEM_MODE_000: ; Invalid: Dn
000031BE  4EB8 28FE               2662      JSR         EA_INVALID          ; Data register direct is invalid mode
000031C2  4EF9 00003232           2663      JMP         ASd_END
000031C8                          2664  ASd_MEM_MODE_001: ; Invalid: An
000031C8  4EB8 28FE               2665      JSR         EA_INVALID          ; Address register direct is invalid mode
000031CC  4EF9 00003232           2666      JMP         ASd_END
000031D2                          2667  ASd_MEM_MODE_010: ; (An)
000031D2  4EB8 29F6               2668      JSR         EA_PRINT_IND         ; Print address register indirect
000031D6  4EF9 00003232           2669      JMP         ASd_END
000031DC                          2670  ASd_MEM_MODE_011: ; (An)+
000031DC  4EB8 2A54               2671      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000031E0  4EF9 00003232           2672      JMP         ASd_END
000031E6                          2673  ASd_MEM_MODE_100: ; -(An)
000031E6  4EB8 2A94               2674      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000031EA  4EF9 00003232           2675      JMP         ASd_END         ; Continue with parsing destination operand
000031F0                          2676  ASd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000031F0  4EB8 28FE               2677      JSR         EA_INVALID          ; Opcode word is Invalid
000031F4  4EF9 00003232           2678      JMP         ASd_END
000031FA                          2679  ASd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000031FA  4EB8 28FE               2680      JSR         EA_INVALID          ; Opcode word is Invalid
000031FE  4EF9 00003232           2681      JMP         ASd_END
00003204                          2682  ASd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
00003204  BE3C 0000               2683      CMP.B       #$00, D7            ; Test for absolute word address
00003208  6700 0014               2684      BEQ         ASd_MEM_ABS_W
0000320C  BE3C 0001               2685      CMP.B       #$01, D7            ; Test for absolute long address
00003210  6700 0016               2686      BEQ         ASd_MEM_ABS_L
00003214  4EB8 28FE               2687      JSR         EA_INVALID          ; Else: invalid
00003218  4EF9 00003232           2688      JMP         ASd_END
0000321E                          2689  ASd_MEM_ABS_W:
0000321E  4EB8 2AE0               2690      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003222  4EF9 00003232           2691      JMP         ASd_END
00003228                          2692  ASd_MEM_ABS_L:
00003228  4EB8 2AD4               2693      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000322C  4EF9 00003232           2694      JMP         ASd_END
00003232                          2695  ASd_END:
00003232  4EB8 2908               2696      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003236  4CDF 3FFF               2697      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000323A  4E75                    2698      RTS
0000323C                          2699  EA_Bcc: *ONLY BCC (0100), BGT (1110), BLE (1111)
0000323C                          2700          *two's complement and stuff. for later TODO
0000323C  48E7 FFFC               2701      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003240  4EB8 2914               2702      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003244  2216                    2703      MOVE.L      (A6), D1            ; Load opcode to data register 1
00003246  143C 0008               2704      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
0000324A  E569                    2705      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
0000324C  143C 0008               2706      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine condition
00003250  E469                    2707      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00003252                          2708      *save ultimate address to be printed
00003252  284E                    2709      MOVEA.L     A6, A4              ; Copy global pointer for dislay
00003254  B23C 0000               2710      CMP.B       #$00, D1            ; If value is zero, real value is next word in memory
00003258  6700 0034               2711      BEQ         BCC_W
0000325C  B23C 00FF               2712      CMP.B       #$FF, D1            ; If value is FF, real value is next longword
00003260  6700 004E               2713      BEQ         BCC_L
00003264  4EF9 0000326A           2714      JMP         BCC_B               ; Else, parse lower-order byte of opcode word
0000326A                          2715  BCC_B:
0000326A  548C                    2716      ADDA.L      #$00000002, A4      ; Increment display pointer past opcode word
0000326C  3616                    2717      MOVE.W      (A6), D3            ; Save opcode word
0000326E  143C 0008               2718      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003272  E56B                    2719      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
00003274  143C 000F               2720      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
00003278  E46B                    2721      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
0000327A  B63C 0000               2722      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
0000327E  6700 003E               2723      BEQ         BCC_DISPLAY
00003282  0681 FFFFFF00           2724      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
00003288  4EF9 000032BE           2725      JMP         BCC_DISPLAY
0000328E                          2726  BCC_W:
0000328E  588C                    2727      ADDA.L      #$00000004, A4      ; Increment display pointer past opcode word
00003290                          2728                                      ; and displacement word in memory
00003290  548D                    2729      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
00003292  3615                    2730      MOVE.W      (A5), D3            ; Read word displacement from memory
00003294  548D                    2731      ADDA.L      #$00000002, A5      ; Increment A5 past word read
00003296  143C 000F               2732      MOVE.B      #15, D2             ; 'Right-align' bit 15 to determine MSB
0000329A  E46B                    2733      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
0000329C  B63C 0000               2734      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
000032A0  6700 001C               2735      BEQ         BCC_DISPLAY
000032A4  0681 FFFF0000           2736      ADD.L       #$FFFF0000, D1      ; Else, sign extend data with F
000032AA  4EF9 000032BE           2737      JMP         BCC_DISPLAY
000032B0                          2738  BCC_L:
000032B0  5C8C                    2739      ADDA.L      #$00000006, A4      ; Increment display pointer past opcode word
000032B2                          2740                                      ; and displacement longword in memory
000032B2  548D                    2741      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
000032B4  2215                    2742      MOVE.L      (A5), D1            ; Read longword displacement from memory
000032B6  588D                    2743      ADDA.L      #$00000004, A5      ; Increment A5 past longword read
000032B8  4EF9 000032BE           2744      JMP         BCC_DISPLAY
000032BE                          2745  BCC_DISPLAY:
000032BE  D9C1                    2746      ADDA.L      D1, A4              ; add displacement to current addressing
000032C0                          2747      *print address in A4
000032C0  4EB8 2908               2748      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000032C4  4CDF 3FFF               2749      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000032C8  4E75                    2750      RTS
000032CA                          2751  EA_CLR:
000032CA  48E7 FFFC               2752      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000032CE  4EB8 2914               2753      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000032D2  4EB8 2918               2754      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000032D6  41F9 000032E4           2755      LEA         CLR_MODE, A0        ; Set index '0' for jump table
000032DC  CCFC 0006               2756      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000032E0  4EF0 6000               2757      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000032E4                          2758  CLR_MODE:
000032E4  4EF9 00003314           2759      JMP         CLR_MODE_000        ; Dn
000032EA  4EF9 0000331E           2760      JMP         CLR_MODE_001        ; Invalid: An
000032F0  4EF9 00003328           2761      JMP         CLR_MODE_010        ; (An)
000032F6  4EF9 00003332           2762      JMP         CLR_MODE_011        ; (An)+
000032FC  4EF9 0000333C           2763      JMP         CLR_MODE_100        ; -(An)
00003302  4EF9 00003346           2764      JMP         CLR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003308  4EF9 00003350           2765      JMP         CLR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000330E  4EF9 0000335A           2766      JMP         CLR_MODE_111        ; The rest (not all valid, validated by register number)
00003314                          2767  CLR_MODE_000: ; Dn
00003314  4EB8 2976               2768      JSR         EA_PRINT_DN
00003318  4EF9 00003388           2769      JMP         CLR_END
0000331E                          2770  CLR_MODE_001: ; Invalid: An
0000331E  4EB8 28FE               2771      JSR         EA_INVALID          ; Address register direct is invalid mode
00003322  4EF9 00003388           2772      JMP         CLR_END
00003328                          2773  CLR_MODE_010: ; (An)
00003328  4EB8 29F6               2774      JSR         EA_PRINT_IND         ; Print address register indirect
0000332C  4EF9 00003388           2775      JMP         CLR_END
00003332                          2776  CLR_MODE_011: ; (An)+
00003332  4EB8 2A54               2777      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003336  4EF9 00003388           2778      JMP         CLR_END
0000333C                          2779  CLR_MODE_100: ; -(An)
0000333C  4EB8 2A94               2780      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003340  4EF9 00003388           2781      JMP         CLR_END             ; Continue with parsing destination operand
00003346                          2782  CLR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003346  4EB8 28FE               2783      JSR         EA_INVALID          ; Opcode word is Invalid
0000334A  4EF9 00003388           2784      JMP         CLR_END
00003350                          2785  CLR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003350  4EB8 28FE               2786      JSR         EA_INVALID          ; Opcode word is Invalid
00003354  4EF9 00003388           2787      JMP         CLR_END
0000335A                          2788  CLR_MODE_111: ; The rest (not all valid, validated by register number)
0000335A  BE3C 0000               2789      CMP.B       #$00, D7            ; Test for absolute word address
0000335E  6700 0014               2790      BEQ         CLR_ABS_W
00003362  BE3C 0001               2791      CMP.B       #$01, D7            ; Test for absolute long address
00003366  6700 0016               2792      BEQ         CLR_ABS_L
0000336A  4EB8 28FE               2793      JSR         EA_INVALID          ; Else: invalid
0000336E  4EF9 00003388           2794      JMP         CLR_END
00003374                          2795  CLR_ABS_W:
00003374  4EB8 2AE0               2796      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003378  4EF9 00003388           2797      JMP         CLR_END
0000337E                          2798  CLR_ABS_L:
0000337E  4EB8 2AD4               2799      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003382  4EF9 00003388           2800      JMP         CLR_END
00003388                          2801  CLR_END:
00003388  4EB8 2908               2802      JSR         EA_UPDATE_POINTER   ; Updates global pointer
0000338C  4CDF 3FFF               2803      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003390  4E75                    2804      RTS
00003392                          2805  EA_CMP:
00003392  48E7 FFFC               2806      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003396  4EB8 2914               2807      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000339A  4EB8 2918               2808      JSR         EA_DEFAULT_COMBO
0000339E  41F9 000033AC           2809      LEA         CMP_MODE, A0       ; Set index '0' for jump table
000033A4  CCFC 0006               2810      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000033A8  4EF0 6000               2811      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000033AC                          2812  CMP_MODE:
000033AC  4EF9 000033DC           2813      JMP         CMP_MODE_000       ; Dn
000033B2  4EF9 000033E6           2814      JMP         CMP_MODE_001       ; An
000033B8  4EF9 000033F0           2815      JMP         CMP_MODE_010       ; (An)
000033BE  4EF9 000033FA           2816      JMP         CMP_MODE_011       ; (An)+
000033C4  4EF9 00003404           2817      JMP         CMP_MODE_100       ; -(An)
000033CA  4EF9 0000340E           2818      JMP         CMP_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
000033D0  4EF9 00003418           2819      JMP         CMP_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000033D6  4EF9 00003422           2820      JMP         CMP_MODE_111       ; The rest (not all valid, validated by register number)
000033DC                          2821  CMP_MODE_000: ; Dn
000033DC  4EB8 2976               2822      JSR         EA_PRINT_DN         ; Print data register direct operand
000033E0  4EF9 00003450           2823      JMP         CMP_MODE_END        ; End evaluation of ea mode
000033E6                          2824  CMP_MODE_001: ; An
000033E6  4EB8 29B6               2825      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
000033EA  4EF9 00003450           2826      JMP         CMP_MODE_END        ; End evaluation of ea mode
000033F0                          2827  CMP_MODE_010: ; (An)
000033F0  4EB8 29F6               2828      JSR         EA_PRINT_IND        ; Print address register indirect
000033F4  4EF9 00003450           2829      JMP         CMP_MODE_END        ; End evaluation of ea mode
000033FA                          2830  CMP_MODE_011: ; (An)+
000033FA  4EB8 2A54               2831      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000033FE  4EF9 00003450           2832      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003404                          2833  CMP_MODE_100: ; -(An)
00003404  4EB8 2A94               2834      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003408  4EF9 00003450           2835      JMP         CMP_MODE_END        ; End evaluation of ea mode
0000340E                          2836  CMP_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000340E  4EB8 28FE               2837      JSR         EA_INVALID          ; Opcode word is Invalid
00003412  4EF9 00003458           2838      JMP         CMP_END
00003418                          2839  CMP_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003418  4EB8 28FE               2840      JSR         EA_INVALID          ; Opcode word is Invalid
0000341C  4EF9 00003458           2841      JMP         CMP_END
00003422                          2842  CMP_MODE_111: ; The rest (not all valid, validated by register number)
00003422  BE3C 0000               2843      CMP.B       #$00, D7            ; Test for absolute word address
00003426  6700 0014               2844      BEQ         CMP_ABS_W
0000342A  BE3C 0001               2845      CMP.B       #$01, D7            ; Test for absolute long address
0000342E  6700 0016               2846      BEQ         CMP_ABS_L
00003432  4EB8 28FE               2847      JSR         EA_INVALID          ; Opcode word is Invalid
00003436  4EF9 00003458           2848      JMP         CMP_END
0000343C                          2849  CMP_ABS_W:
0000343C  4EB8 2AE0               2850      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003440  4EF9 00003450           2851      JMP         CMP_MODE_END
00003446                          2852  CMP_ABS_L:
00003446  4EB8 2AD4               2853      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000344A  4EF9 00003450           2854      JMP         CMP_MODE_END
00003450                          2855  CMP_MODE_END:
00003450  4EB8 293E               2856      JSR         EA_OPMODE_COMBO     ; get register bits in D7, opmode bits not used
00003454  4EB8 2976               2857      JSR         EA_PRINT_DN         ; print register
00003458                          2858  CMP_END:
00003458  4EB8 2908               2859      JSR         EA_UPDATE_POINTER   ; Update global pointer
0000345C  4CDF 3FFF               2860      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003460  4E75                    2861      RTS
00003462                          2862  EA_DIVU_W:
00003462  48E7 FFFC               2863      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003466  4EB8 2914               2864      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000346A  4EB8 2918               2865      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
0000346E  41F9 0000347C           2866      LEA         DIVU_W_MODE, A0       ; Set index '0' for jump table
00003474  CCFC 0006               2867      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003478  4EF0 6000               2868      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000347C                          2869  DIVU_W_MODE:
0000347C  4EF9 000034AC           2870      JMP         DIVU_W_MODE_000     ; Dn
00003482  4EF9 000034B6           2871      JMP         DIVU_W_MODE_001     ; Invalid: An
00003488  4EF9 000034C0           2872      JMP         DIVU_W_MODE_010     ; (An)
0000348E  4EF9 000034CA           2873      JMP         DIVU_W_MODE_011     ; (An)+
00003494  4EF9 000034D4           2874      JMP         DIVU_W_MODE_100     ; -(An)
0000349A  4EF9 000034DE           2875      JMP         DIVU_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
000034A0  4EF9 000034E8           2876      JMP         DIVU_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000034A6  4EF9 000034F2           2877      JMP         DIVU_W_MODE_111     ; The rest (not all valid, validated by register number)
000034AC                          2878  DIVU_W_MODE_000: ; Dn
000034AC  4EB8 2976               2879      JSR         EA_PRINT_DN         ; Print data register direct operand
000034B0  4EF9 00003536           2880      JMP         DIVU_W_DEST         ; Go to: print destination operand
000034B6                          2881  DIVU_W_MODE_001: ; Invalid: An
000034B6  4EB8 28FE               2882      JSR         EA_INVALID          ; Address register direct is invalid mode
000034BA  4EF9 00003548           2883      JMP         DIVU_W_END
000034C0                          2884  DIVU_W_MODE_010: ; (An)
000034C0  4EB8 29F6               2885      JSR         EA_PRINT_IND         ; Print address register indirect
000034C4  4EF9 00003536           2886      JMP         DIVU_W_DEST
000034CA                          2887  DIVU_W_MODE_011: ; (An)+
000034CA  4EB8 2A54               2888      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000034CE  4EF9 00003536           2889      JMP         DIVU_W_DEST
000034D4                          2890  DIVU_W_MODE_100: ; -(An)
000034D4  4EB8 2A94               2891      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000034D8  4EF9 00003536           2892      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000034DE                          2893  DIVU_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000034DE  4EB8 28FE               2894      JSR         EA_INVALID          ; Opcode word is Invalid
000034E2  4EF9 00003548           2895      JMP         DIVU_W_END
000034E8                          2896  DIVU_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000034E8  4EB8 28FE               2897      JSR         EA_INVALID          ; Opcode word is Invalid
000034EC  4EF9 00003548           2898      JMP         DIVU_W_END
000034F2                          2899  DIVU_W_MODE_111: ; The rest (not all valid, validated by register number)
000034F2  BE3C 0000               2900      CMP.B       #$00, D7            ; Test for absolute word address
000034F6  6700 001C               2901      BEQ         DIVU_W_ABS_W
000034FA  BE3C 0001               2902      CMP.B       #$01, D7            ; Test for absolute long address
000034FE  6700 001E               2903      BEQ         DIVU_W_ABS_L
00003502  BE3C 0004               2904      CMP.B       #$04, D7            ; Test for immediate data
00003506  6700 0020               2905      BEQ         DIVU_W_IMM
0000350A  4EB8 28FE               2906      JSR         EA_INVALID          ; Else: invalid
0000350E  4EF9 00003548           2907      JMP         DIVU_W_END
00003514                          2908  DIVU_W_ABS_W:
00003514  4EB8 2AE0               2909      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003518  4EF9 00003536           2910      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
0000351E                          2911  DIVU_W_ABS_L:
0000351E  4EB8 2AD4               2912      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003522  4EF9 00003536           2913      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
00003528                          2914  DIVU_W_IMM:
00003528  1A3C 0002               2915      MOVE.B      #2, D5              ; Size is word
0000352C  4EB8 2A36               2916      JSR         EA_PRINT_IMM        ; Print immediate data
00003530  4EF9 00003536           2917      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
00003536                          2918  DIVU_W_DEST:
00003536                          2919      *print EA_MSG_COMMA
00003536                          2920      *Get destination register
00003536  3E16                    2921      MOVE.W      (A6), D7            ; Load word at current pointer to D1
00003538  143C 0004               2922      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
0000353C  E56F                    2923      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
0000353E  143C 000D               2924      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
00003542  E46F                    2925      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003544  4EB8 2976               2926      JSR         EA_PRINT_DN         ; Print data register direct operand
00003548                          2927  DIVU_W_END:
00003548  4EB8 2908               2928      JSR         EA_UPDATE_POINTER   ; Update global pointer
0000354C  4CDF 3FFF               2929      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003550  4E75                    2930      RTS
00003552                          2931  EA_JSR:
00003552  48E7 FFFC               2932      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003556  4EB8 2914               2933      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
0000355A  4EB8 2918               2934      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
0000355E  41F9 0000356C           2935      LEA         JSR_MODE, A0        ; Set index '0' for jump table
00003564  CCFC 0006               2936      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003568  4EF0 6000               2937      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000356C                          2938  JSR_MODE:
0000356C  4EF9 0000359C           2939      JMP         JSR_MODE_000        ; Invalid: Dn
00003572  4EF9 000035A6           2940      JMP         JSR_MODE_001        ; Invalid: An
00003578  4EF9 000035B0           2941      JMP         JSR_MODE_010        ; (An)
0000357E  4EF9 000035BA           2942      JMP         JSR_MODE_011        ; Invalid: (An)+
00003584  4EF9 000035C4           2943      JMP         JSR_MODE_100        ; Invalid: -(An)
0000358A  4EF9 000035CE           2944      JMP         JSR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003590  4EF9 000035D8           2945      JMP         JSR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003596  4EF9 000035E2           2946      JMP         JSR_MODE_111        ; The rest (not all valid, validated by register number)
0000359C                          2947  JSR_MODE_000: ; Invalid: Dn
0000359C  4EB8 28FE               2948      JSR         EA_INVALID          ; Data register direct is invalid mode
000035A0  4EF9 00003610           2949      JMP         JSR_END
000035A6                          2950  JSR_MODE_001: ; Invalid: An
000035A6  4EB8 28FE               2951      JSR         EA_INVALID          ; Address register direct is invalid mode
000035AA  4EF9 00003610           2952      JMP         JSR_END
000035B0                          2953  JSR_MODE_010: ; (An)
000035B0  4EB8 29F6               2954      JSR         EA_PRINT_IND         ; Print address register indirect
000035B4  4EF9 00003610           2955      JMP         JSR_END
000035BA                          2956  JSR_MODE_011: ; (An)+
000035BA  4EB8 28FE               2957      JSR         EA_INVALID          ; Address register indirect w/ post increment is invalid mode
000035BE  4EF9 00003610           2958      JMP         JSR_END
000035C4                          2959  JSR_MODE_100: ; -(An)
000035C4  4EB8 28FE               2960      JSR         EA_INVALID          ; Address register indirect w/ pre decrement is invalid mode
000035C8  4EF9 00003610           2961      JMP         JSR_END
000035CE                          2962  JSR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000035CE  4EB8 28FE               2963      JSR         EA_INVALID          ; Opcode word is Invalid
000035D2  4EF9 00003610           2964      JMP         JSR_END
000035D8                          2965  JSR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000035D8  4EB8 28FE               2966      JSR         EA_INVALID          ; Opcode word is Invalid
000035DC  4EF9 00003610           2967      JMP         JSR_END
000035E2                          2968  JSR_MODE_111: ; The rest (not all valid, validated by register number)
000035E2  BE3C 0000               2969      CMP.B       #$00, D7            ; Test for absolute word address
000035E6  6700 0014               2970      BEQ         JSR_ABS_W
000035EA  BE3C 0001               2971      CMP.B       #$01, D7            ; Test for absolute long address
000035EE  6700 0016               2972      BEQ         JSR_ABS_L
000035F2  4EB8 28FE               2973      JSR         EA_INVALID          ; Else: invalid
000035F6  4EF9 00003610           2974      JMP         JSR_END
000035FC                          2975  JSR_ABS_W:
000035FC  4EB8 2AE0               2976      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003600  4EF9 00003610           2977      JMP         JSR_END
00003606                          2978  JSR_ABS_L:
00003606  4EB8 2AD4               2979      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000360A  4EF9 00003610           2980      JMP         JSR_END
00003610                          2981  JSR_END:
00003610  4EB8 2908               2982      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003614  4CDF 3FFF               2983      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003618  4E75                    2984      RTS
0000361A                          2985  EA_LEA:
0000361A  48E7 FFFC               2986      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000361E  4EB8 2914               2987      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003622  4EB8 2918               2988      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003626  41F9 00003634           2989      LEA         LEA_MODE, A0        ; Set index '0' for jump table
0000362C  CCFC 0006               2990      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003630  4EF0 6000               2991      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003634                          2992  LEA_MODE:
00003634  4EF9 00003664           2993      JMP         LEA_MODE_000        ; Dn
0000363A  4EF9 0000366E           2994      JMP         LEA_MODE_001        ; Invalid: An
00003640  4EF9 00003678           2995      JMP         LEA_MODE_010        ; (An)
00003646  4EF9 00003682           2996      JMP         LEA_MODE_011        ; (An)+
0000364C  4EF9 0000368C           2997      JMP         LEA_MODE_100        ; -(An)
00003652  4EF9 00003696           2998      JMP         LEA_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003658  4EF9 000036A0           2999      JMP         LEA_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000365E  4EF9 000036AA           3000      JMP         LEA_MODE_111        ; The rest (not all valid, validated by register number)
00003664                          3001  LEA_MODE_000: ; Invalid: Dn
00003664  4EB8 28FE               3002      JSR         EA_INVALID          ; Data register direct is invalid mode
00003668  4EF9 000036E0           3003      JMP         LEA_END
0000366E                          3004  LEA_MODE_001: ; Invalid: An
0000366E  4EB8 28FE               3005      JSR         EA_INVALID          ; Address register direct is invalid mode
00003672  4EF9 000036E0           3006      JMP         LEA_END
00003678                          3007  LEA_MODE_010: ; (An)
00003678  4EB8 29F6               3008      JSR         EA_PRINT_IND         ; Print address register indirect
0000367C  4EF9 000036D8           3009      JMP         LEA_DEST
00003682                          3010  LEA_MODE_011: ; (An)+
00003682  4EB8 28FE               3011      JSR         EA_INVALID          ; Address register indirect with post increment is invalid
00003686  4EF9 000036E0           3012      JMP         LEA_END
0000368C                          3013  LEA_MODE_100: ; -(An)
0000368C  4EB8 28FE               3014      JSR         EA_INVALID          ; Adress register indirect with pre decrement is invalid
00003690  4EF9 000036E0           3015      JMP         LEA_END             ; Continue with parsing destination operand
00003696                          3016  LEA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003696  4EB8 28FE               3017      JSR         EA_INVALID          ; Opcode word is Invalid
0000369A  4EF9 000036E0           3018      JMP         LEA_END
000036A0                          3019  LEA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000036A0  4EB8 28FE               3020      JSR         EA_INVALID          ; Opcode word is Invalid
000036A4  4EF9 000036E0           3021      JMP         LEA_END
000036AA                          3022  LEA_MODE_111: ; The rest (not all valid, validated by register number)
000036AA  BE3C 0000               3023      CMP.B       #$00, D7            ; Test for absolute word address
000036AE  6700 0014               3024      BEQ         LEA_ABS_W
000036B2  BE3C 0001               3025      CMP.B       #$01, D7            ; Test for absolute long address
000036B6  6700 0016               3026      BEQ         LEA_ABS_L
000036BA  4EB8 28FE               3027      JSR         EA_INVALID          ; Else: invalid
000036BE  4EF9 000036D8           3028      JMP         LEA_DEST
000036C4                          3029  LEA_ABS_W:
000036C4  4EB8 2AE0               3030      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000036C8  4EF9 000036D8           3031      JMP         LEA_DEST
000036CE                          3032  LEA_ABS_L:
000036CE  4EB8 2AD4               3033      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000036D2  4EF9 000036D8           3034      JMP         LEA_DEST
000036D8                          3035  LEA_DEST:
000036D8                          3036      *print comma TODO
000036D8  4EB8 293E               3037      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, opmode bits unused
000036DC  4EB8 29B6               3038      JSR         EA_PRINT_AN         ; Print address register
000036E0                          3039  LEA_END:
000036E0  4EB8 2908               3040      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000036E4  4CDF 3FFF               3041      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000036E8  4E75                    3042      RTS
000036EA                          3043  EA_LSd:
000036EA  48E7 FFFC               3044      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000036EE  4EB8 2914               3045      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000036F2  4EB8 2964               3046      JSR         EA_SIZE_BITS        ; get size bits in D7
000036F6  BE3C 0003               3047      CMP.B       #$03, D7            ; test if memory shift
000036FA  6700 0042               3048      BEQ         LSd_MEM
000036FE  6000 0002               3049      BRA         LSd_REG             ; else, register shfit
00003702                          3050  LSd_REG:
00003702  3E16                    3051      MOVE.W      (A6), D7            ; read opcode word in memory and save,
00003704                          3052                                      ; (using D7 because EA_PRINT_DN uses D7)
00003704  143C 0004               3053      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
00003708  E56F                    3054      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
0000370A  143C 000D               3055      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
0000370E  E46F                    3056      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003710  3016                    3057      MOVE.W      (A6), D0            ; read opcode word in memory and save
00003712  143C 000A               3058      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
00003716  E568                    3059      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00003718  143C 000F               3060      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
0000371C  E468                    3061      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
0000371E  B03C 0000               3062      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
00003722  6700 000C               3063      BEQ         LSd_REG_COUNT
00003726                          3064  LSd_REG_REG:                        ; Else, count/register field contains register number
00003726  4EB8 2976               3065      JSR         EA_PRINT_DN         ; Print register value, stored in D7
0000372A  4EF9 00003730           3066      JMP         LSd_REG_END         ; Jump to end of LSd_REG
00003730                          3067  LSd_REG_COUNT:
00003730                          3068      *print hash todo
00003730                          3069      *print hex value in D7 as byte todo, continue on to LSd_REG_END
00003730                          3070  LSd_REG_END:
00003730                          3071      *PRINT COMMA todo
00003730  4EB8 2918               3072      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
00003734  4EB8 2976               3073      JSR         EA_PRINT_DN         ; Print register value in D7
00003738  4EF9 000037F4           3074      JMP         LSd_END
0000373E                          3075  LSd_MEM:
0000373E  4EB8 2918               3076      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003742  41F9 00003750           3077      LEA         LSd_MEM_MODE, A0    ; Set index '0' for jump table
00003748  CCFC 0006               3078      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000374C  4EF0 6000               3079      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003750                          3080  LSd_MEM_MODE:
00003750  4EF9 00003780           3081      JMP         LSd_MEM_MODE_000     ; Invalid: Dn
00003756  4EF9 0000378A           3082      JMP         LSd_MEM_MODE_001     ; Invalid: An
0000375C  4EF9 00003794           3083      JMP         LSd_MEM_MODE_010     ; (An)
00003762  4EF9 0000379E           3084      JMP         LSd_MEM_MODE_011     ; (An)+
00003768  4EF9 000037A8           3085      JMP         LSd_MEM_MODE_100     ; -(An)
0000376E  4EF9 000037B2           3086      JMP         LSd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003774  4EF9 000037BC           3087      JMP         LSd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000377A  4EF9 000037C6           3088      JMP         LSd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00003780                          3089  LSd_MEM_MODE_000: ; Invalid: Dn
00003780  4EB8 28FE               3090      JSR         EA_INVALID          ; Data register direct is invalid mode
00003784  4EF9 000037F4           3091      JMP         LSd_END
0000378A                          3092  LSd_MEM_MODE_001: ; Invalid: An
0000378A  4EB8 28FE               3093      JSR         EA_INVALID          ; Address register direct is invalid mode
0000378E  4EF9 000037F4           3094      JMP         LSd_END
00003794                          3095  LSd_MEM_MODE_010: ; (An)
00003794  4EB8 29F6               3096      JSR         EA_PRINT_IND         ; Print address register indirect
00003798  4EF9 000037F4           3097      JMP         LSd_END
0000379E                          3098  LSd_MEM_MODE_011: ; (An)+
0000379E  4EB8 2A54               3099      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000037A2  4EF9 000037F4           3100      JMP         LSd_END
000037A8                          3101  LSd_MEM_MODE_100: ; -(An)
000037A8  4EB8 2A94               3102      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000037AC  4EF9 000037F4           3103      JMP         LSd_END         ; Continue with parsing destination operand
000037B2                          3104  LSd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000037B2  4EB8 28FE               3105      JSR         EA_INVALID          ; Opcode word is Invalid
000037B6  4EF9 000037F4           3106      JMP         LSd_END
000037BC                          3107  LSd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000037BC  4EB8 28FE               3108      JSR         EA_INVALID          ; Opcode word is Invalid
000037C0  4EF9 000037F4           3109      JMP         LSd_END
000037C6                          3110  LSd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
000037C6  BE3C 0000               3111      CMP.B       #$00, D7            ; Test for absolute word address
000037CA  6700 0014               3112      BEQ         LSd_MEM_ABS_W
000037CE  BE3C 0001               3113      CMP.B       #$01, D7            ; Test for absolute long address
000037D2  6700 0016               3114      BEQ         LSd_MEM_ABS_L
000037D6  4EB8 28FE               3115      JSR         EA_INVALID          ; Else: invalid
000037DA  4EF9 000037F4           3116      JMP         LSd_END
000037E0                          3117  LSd_MEM_ABS_W:
000037E0  4EB8 2AE0               3118      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000037E4  4EF9 000037F4           3119      JMP         LSd_END
000037EA                          3120  LSd_MEM_ABS_L:
000037EA  4EB8 2AD4               3121      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000037EE  4EF9 000037F4           3122      JMP         LSd_END
000037F4                          3123  LSd_END:
000037F4  4EB8 2908               3124      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000037F8  4CDF 3FFF               3125      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000037FC  4E75                    3126      RTS
000037FE                          3127  EA_MOVE:
000037FE  48E7 FFFC               3128      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003802  4EB8 2914               3129      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003806  2A16                    3130      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
00003808  143C 0002               3131      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
0000380C  E56D                    3132      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
0000380E  143C 000E               3133      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
00003812  E46D                    3134      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
00003814  BA3C 0003               3135      CMP.B       #$03, D5            ; if size bits are 11, correct D5
00003818                          3136                                      ; to 10 for use with immediate data subroutine
00003818  6700 0010               3137      BEQ         MOVE_ADJUST_W
0000381C  BA3C 0002               3138      CMP.B       #$02, D5            ; if size bits are 10, correct D5
00003820                          3139                                      ; to 11 for use with immediate data subroutine
00003820  6700 0012               3140      BEQ         MOVE_ADJUST_L
00003824  4EF9 0000383E           3141      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
0000382A                          3142  MOVE_ADJUST_W:
0000382A  1A3C 0002               3143      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
0000382E  4EF9 0000383E           3144      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003834                          3145  MOVE_ADJUST_L:
00003834  1A3C 0003               3146      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
00003838  4EF9 0000383E           3147      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
0000383E                          3148  MOVE_SOURCE:
0000383E  48E7 FFFC               3149      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003842  4EB8 2914               3150      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003846  4EB8 2918               3151      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
0000384A  41F9 00003858           3152      LEA         MOVE_SRC_MODE, A0   ; Set index '0' for jump table
00003850  CCFC 0006               3153      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003854  4EF0 6000               3154      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003858                          3155  MOVE_SRC_MODE:
00003858  4EF9 00003888           3156      JMP         MOVE_SRC_MODE_000   ; Dn
0000385E  4EF9 00003892           3157      JMP         MOVE_SRC_MODE_001   ; An
00003864  4EF9 0000389C           3158      JMP         MOVE_SRC_MODE_010   ; (An)
0000386A  4EF9 000038A6           3159      JMP         MOVE_SRC_MODE_011   ; (An)+
00003870  4EF9 000038B0           3160      JMP         MOVE_SRC_MODE_100   ; -(An)
00003876  4EF9 000038BA           3161      JMP         MOVE_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
0000387C  4EF9 000038C4           3162      JMP         MOVE_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003882  4EF9 000038CE           3163      JMP         MOVE_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003888                          3164  MOVE_SRC_MODE_000: ; Dn
00003888  4EB8 2976               3165      JSR         EA_PRINT_DN         ; Print data register in D7
0000388C  4EF9 0000390E           3166      JMP         MOVE_DESTINATION
00003892                          3167  MOVE_SRC_MODE_001: ; Invalid: An
00003892  4EB8 29B6               3168      JSR         EA_PRINT_AN         ; Print address register in D7
00003896  4EF9 0000390E           3169      JMP         MOVE_DESTINATION
0000389C                          3170  MOVE_SRC_MODE_010: ; (An)
0000389C  4EB8 29F6               3171      JSR         EA_PRINT_IND         ; Print address register indirect
000038A0  4EF9 0000390E           3172      JMP         MOVE_DESTINATION
000038A6                          3173  MOVE_SRC_MODE_011: ; (An)+
000038A6  4EB8 2A54               3174      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000038AA  4EF9 0000390E           3175      JMP         MOVE_DESTINATION
000038B0                          3176  MOVE_SRC_MODE_100: ; -(An)
000038B0  4EB8 2A94               3177      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000038B4  4EF9 0000390E           3178      JMP         MOVE_DESTINATION    ; Continue with parsing destination operand
000038BA                          3179  MOVE_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000038BA  4EB8 28FE               3180      JSR         EA_INVALID          ; Opcode word is Invalid
000038BE  4EF9 000039CC           3181      JMP         MOVE_END
000038C4                          3182  MOVE_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000038C4  4EB8 28FE               3183      JSR         EA_INVALID          ; Opcode word is Invalid
000038C8  4EF9 000039CC           3184      JMP         MOVE_END
000038CE                          3185  MOVE_SRC_MODE_111: ; The rest (not all valid, validated by register number)
000038CE  BE3C 0000               3186      CMP.B       #$00, D7            ; Test for absolute word address
000038D2  6700 001C               3187      BEQ         MOVE_SRC_ABS_W
000038D6  BE3C 0001               3188      CMP.B       #$01, D7            ; Test for absolute long address
000038DA  6700 001E               3189      BEQ         MOVE_SRC_ABS_L
000038DE  BE3C 0004               3190      CMP.B       #$04, D7            ; Test for immediate data
000038E2  6700 0020               3191      BEQ         MOVE_SRC_IMM
000038E6  4EB8 28FE               3192      JSR         EA_INVALID          ; Else: invalid
000038EA  4EF9 000039CC           3193      JMP         MOVE_END
000038F0                          3194  MOVE_SRC_ABS_W:
000038F0  4EB8 2AE0               3195      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000038F4  4EF9 0000390E           3196      JMP         MOVE_DESTINATION
000038FA                          3197  MOVE_SRC_ABS_L:
000038FA  4EB8 2AD4               3198      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000038FE  4EF9 0000390E           3199      JMP         MOVE_DESTINATION
00003904                          3200  MOVE_SRC_IMM:
00003904  4EB8 2A36               3201      JSR         EA_PRINT_IMM        ; Print immediate data
00003908  4EF9 0000390E           3202      JMP         MOVE_DESTINATION
0000390E                          3203  MOVE_DESTINATION:
0000390E                          3204      *PRINT COMMA TODO
0000390E  48E7 FFFC               3205      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003912  4EB8 2914               3206      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003916  4EB8 293E               3207      JSR         EA_OPMODE_COMBO     ; mode: D6, register: D7 (destination bits)
0000391A  41F9 00003928           3208      LEA         MOVE_DST_MODE, A0   ; Set index '0' for jump table
00003920  CCFC 0006               3209      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003924  4EF0 6000               3210      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003928                          3211  MOVE_DST_MODE:
00003928  4EF9 00003958           3212      JMP         MOVE_DST_MODE_000   ; Dn
0000392E  4EF9 00003962           3213      JMP         MOVE_DST_MODE_001   ; Invalid: An
00003934  4EF9 0000396C           3214      JMP         MOVE_DST_MODE_010   ; (An)
0000393A  4EF9 00003976           3215      JMP         MOVE_DST_MODE_011   ; (An)+
00003940  4EF9 00003980           3216      JMP         MOVE_DST_MODE_100   ; -(An)
00003946  4EF9 0000398A           3217      JMP         MOVE_DST_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
0000394C  4EF9 00003994           3218      JMP         MOVE_DST_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003952  4EF9 0000399E           3219      JMP         MOVE_DST_MODE_111   ; The rest (not all valid, validated by register number)
00003958                          3220  MOVE_DST_MODE_000: ; Dn
00003958  4EB8 2976               3221      JSR         EA_PRINT_DN         ; Print data register in D7
0000395C  4EF9 000039CC           3222      JMP         MOVE_END
00003962                          3223  MOVE_DST_MODE_001: ; Invalid: An
00003962  4EB8 28FE               3224      JSR         EA_INVALID          ; Print address register in D7
00003966  4EF9 000039CC           3225      JMP         MOVE_END
0000396C                          3226  MOVE_DST_MODE_010: ; (An)
0000396C  4EB8 29F6               3227      JSR         EA_PRINT_IND         ; Print address register indirect
00003970  4EF9 000039CC           3228      JMP         MOVE_END
00003976                          3229  MOVE_DST_MODE_011: ; (An)+
00003976  4EB8 2A54               3230      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000397A  4EF9 000039CC           3231      JMP         MOVE_END
00003980                          3232  MOVE_DST_MODE_100: ; -(An)
00003980  4EB8 2A94               3233      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003984  4EF9 000039CC           3234      JMP         MOVE_END    ; Continue with parsing destination operand
0000398A                          3235  MOVE_DST_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000398A  4EB8 28FE               3236      JSR         EA_INVALID          ; Opcode word is Invalid
0000398E  4EF9 000039CC           3237      JMP         MOVE_END
00003994                          3238  MOVE_DST_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003994  4EB8 28FE               3239      JSR         EA_INVALID          ; Opcode word is Invalid
00003998  4EF9 000039CC           3240      JMP         MOVE_END
0000399E                          3241  MOVE_DST_MODE_111: ; The rest (not all valid, validated by register number)
0000399E  BE3C 0000               3242      CMP.B       #$00, D7            ; Test for absolute word address
000039A2  6700 0014               3243      BEQ         MOVE_DST_ABS_W
000039A6  BE3C 0001               3244      CMP.B       #$01, D7            ; Test for absolute long address
000039AA  6700 0016               3245      BEQ         MOVE_DST_ABS_L
000039AE  4EB8 28FE               3246      JSR         EA_INVALID          ; Else: invalid
000039B2  4EF9 000039CC           3247      JMP         MOVE_END
000039B8                          3248  MOVE_DST_ABS_W:
000039B8  4EB8 2AE0               3249      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000039BC  4EF9 000039CC           3250      JMP         MOVE_END
000039C2                          3251  MOVE_DST_ABS_L:
000039C2  4EB8 2AD4               3252      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000039C6  4EF9 000039CC           3253      JMP         MOVE_END
000039CC                          3254  MOVE_END:
000039CC  4EB8 2908               3255      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000039D0  4CDF 3FFF               3256      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000039D4  4E75                    3257      RTS
000039D6                          3258  EA_MOVEA:
000039D6  48E7 FFFC               3259      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000039DA  4EB8 2914               3260      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000039DE  2A16                    3261      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
000039E0  143C 0002               3262      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
000039E4  E56D                    3263      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
000039E6  143C 000E               3264      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
000039EA  E46D                    3265      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
000039EC  BA3C 0003               3266      CMP.B       #$03, D5            ; if size bits are 11, correct D5
000039F0                          3267                                      ; to 10 for use with immediate data subroutine
000039F0  6700 0010               3268      BEQ         MOVEA_ADJUST_W
000039F4  BA3C 0002               3269      CMP.B       #$02, D5            ; if size bits are 10, correct D5
000039F8                          3270                                      ; to 11 for use with immediate data subroutine
000039F8  6700 0012               3271      BEQ         MOVEA_ADJUST_L
000039FC  4EF9 00003A16           3272      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003A02                          3273  MOVEA_ADJUST_W:
00003A02  1A3C 0002               3274      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
00003A06  4EF9 00003A16           3275      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003A0C                          3276  MOVEA_ADJUST_L:
00003A0C  1A3C 0003               3277      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
00003A10  4EF9 00003A16           3278      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003A16                          3279  MOVEA_SOURCE:
00003A16  48E7 FFFC               3280      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003A1A  4EB8 2914               3281      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003A1E  4EB8 2918               3282      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003A22  41F9 00003A30           3283      LEA         MOVEA_SRC_MODE, A0   ; Set index '0' for jump table
00003A28  CCFC 0006               3284      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003A2C  4EF0 6000               3285      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003A30                          3286  MOVEA_SRC_MODE:
00003A30  4EF9 00003A60           3287      JMP         MOVEA_SRC_MODE_000   ; Dn
00003A36  4EF9 00003A6A           3288      JMP         MOVEA_SRC_MODE_001   ; An
00003A3C  4EF9 00003A74           3289      JMP         MOVEA_SRC_MODE_010   ; (An)
00003A42  4EF9 00003A7E           3290      JMP         MOVEA_SRC_MODE_011   ; (An)+
00003A48  4EF9 00003A88           3291      JMP         MOVEA_SRC_MODE_100   ; -(An)
00003A4E  4EF9 00003A92           3292      JMP         MOVEA_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003A54  4EF9 00003A9C           3293      JMP         MOVEA_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A5A  4EF9 00003AA6           3294      JMP         MOVEA_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003A60                          3295  MOVEA_SRC_MODE_000: ; Dn
00003A60  4EB8 2976               3296      JSR         EA_PRINT_DN         ; Print data register in D7
00003A64  4EF9 00003AE6           3297      JMP         MOVEA_DESTINATION
00003A6A                          3298  MOVEA_SRC_MODE_001: ; Invalid: An
00003A6A  4EB8 29B6               3299      JSR         EA_PRINT_AN         ; Print address register in D7
00003A6E  4EF9 00003AE6           3300      JMP         MOVEA_DESTINATION
00003A74                          3301  MOVEA_SRC_MODE_010: ; (An)
00003A74  4EB8 29F6               3302      JSR         EA_PRINT_IND         ; Print address register indirect
00003A78  4EF9 00003AE6           3303      JMP         MOVEA_DESTINATION
00003A7E                          3304  MOVEA_SRC_MODE_011: ; (An)+
00003A7E  4EB8 2A54               3305      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003A82  4EF9 00003AE6           3306      JMP         MOVEA_DESTINATION
00003A88                          3307  MOVEA_SRC_MODE_100: ; -(An)
00003A88  4EB8 2A94               3308      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003A8C  4EF9 00003AE6           3309      JMP         MOVEA_DESTINATION    ; Continue with parsing destination operand
00003A92                          3310  MOVEA_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003A92  4EB8 28FE               3311      JSR         EA_INVALID          ; Opcode word is Invalid
00003A96  4EF9 00003AF6           3312      JMP         MOVEA_END
00003A9C                          3313  MOVEA_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A9C  4EB8 28FE               3314      JSR         EA_INVALID          ; Opcode word is Invalid
00003AA0  4EF9 00003AF6           3315      JMP         MOVEA_END
00003AA6                          3316  MOVEA_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003AA6  BE3C 0000               3317      CMP.B       #$00, D7            ; Test for absolute word address
00003AAA  6700 001C               3318      BEQ         MOVEA_SRC_ABS_W
00003AAE  BE3C 0001               3319      CMP.B       #$01, D7            ; Test for absolute long address
00003AB2  6700 001E               3320      BEQ         MOVEA_SRC_ABS_L
00003AB6  BE3C 0004               3321      CMP.B       #$04, D7            ; Test for immediate data
00003ABA  6700 0020               3322      BEQ         MOVEA_SRC_IMM
00003ABE  4EB8 28FE               3323      JSR         EA_INVALID          ; Else: invalid
00003AC2  4EF9 00003AF6           3324      JMP         MOVEA_END
00003AC8                          3325  MOVEA_SRC_ABS_W:
00003AC8  4EB8 2AE0               3326      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003ACC  4EF9 00003AE6           3327      JMP         MOVEA_DESTINATION
00003AD2                          3328  MOVEA_SRC_ABS_L:
00003AD2  4EB8 2AD4               3329      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003AD6  4EF9 00003AE6           3330      JMP         MOVEA_DESTINATION
00003ADC                          3331  MOVEA_SRC_IMM:
00003ADC  4EB8 2A36               3332      JSR         EA_PRINT_IMM        ; Print immediate data
00003AE0  4EF9 00003AE6           3333      JMP         MOVEA_DESTINATION
00003AE6                          3334  MOVEA_DESTINATION:
00003AE6                          3335      *PRINT COMMA TODO
00003AE6  48E7 FFFC               3336      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003AEA  4EB8 2914               3337      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003AEE  4EB8 293E               3338      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003AF2  4EB8 29B6               3339      JSR         EA_PRINT_AN         ; Print address register, continue to end
00003AF6                          3340  MOVEA_END:
00003AF6  4EB8 2908               3341      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003AFA  4CDF 3FFF               3342      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003AFE  4E75                    3343      RTS
00003B00                          3344  EA_MOVEM:
00003B00                          3345      *seems complicated, todo
00003B00  4EB8 28FA               3346      JSR         EA_UNIMPLEMENTED
00003B04  4E75                    3347      RTS
00003B06                          3348  EA_MOVEQ:
00003B06  48E7 FFFC               3349      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003B0A  4EB8 2914               3350      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003B0E  2216                    3351      MOVE.L      (A6), D1            ; Load opcode to data register 1
00003B10  143C 0008               3352      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003B14  E569                    3353      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00003B16  143C 0008               3354      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine data bits
00003B1A  E469                    3355      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00003B1C  2616                    3356      MOVE.L      (A6), D3            ; Save mode bits to D6
00003B1E  143C 0008               3357      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003B22  E56B                    3358      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
00003B24  143C 000F               3359      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
00003B28  E46B                    3360      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003B2A  B63C 0000               3361      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003B2E  6700 0008               3362      BEQ         MOVEQ_PRINT_DATA
00003B32  0681 FFFFFF00           3363      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
00003B38                          3364  MOVEQ_PRINT_DATA:
00003B38                          3365      *print hash TODO
00003B38                          3366      *print data in
00003B38                          3367      *PRINT COMMA TODO
00003B38  4EB8 293E               3368      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003B3C  4EB8 2976               3369      JSR         EA_PRINT_DN         ; Print data register
00003B40  4EB8 2908               3370      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003B44  4CDF 3FFF               3371      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003B48  4E75                    3372      RTS
00003B4A                          3373  EA_MULS_W:
00003B4A  48E7 FFFC               3374      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003B4E  4EB8 2914               3375      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003B52  4EB8 2918               3376      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003B56  41F9 00003B64           3377      LEA         MULS_W_MODE, A0     ; Set index '0' for jump table
00003B5C  CCFC 0006               3378      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003B60  4EF0 6000               3379      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003B64                          3380  MULS_W_MODE:
00003B64  4EF9 00003B94           3381      JMP         MULS_W_MODE_000     ; Dn
00003B6A  4EF9 00003B9E           3382      JMP         MULS_W_MODE_001     ; Invalid: An
00003B70  4EF9 00003BA8           3383      JMP         MULS_W_MODE_010     ; (An)
00003B76  4EF9 00003BB2           3384      JMP         MULS_W_MODE_011     ; (An)+
00003B7C  4EF9 00003BBC           3385      JMP         MULS_W_MODE_100     ; -(An)
00003B82  4EF9 00003BC6           3386      JMP         MULS_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003B88  4EF9 00003BD0           3387      JMP         MULS_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003B8E  4EF9 00003BDA           3388      JMP         MULS_W_MODE_111     ; The rest (not all valid, validated by register number)
00003B94                          3389  MULS_W_MODE_000: ; Dn
00003B94  4EB8 2976               3390      JSR         EA_PRINT_DN         ; Print data register direct operand
00003B98  4EF9 00003C1E           3391      JMP         MULS_W_DEST         ; Go to: print destination operand
00003B9E                          3392  MULS_W_MODE_001: ; Invalid: An
00003B9E  4EB8 28FE               3393      JSR         EA_INVALID          ; Address register direct is invalid mode
00003BA2  4EF9 00003C30           3394      JMP         MULS_W_END
00003BA8                          3395  MULS_W_MODE_010: ; (An)
00003BA8  4EB8 29F6               3396      JSR         EA_PRINT_IND         ; Print address register indirect
00003BAC  4EF9 00003C1E           3397      JMP         MULS_W_DEST
00003BB2                          3398  MULS_W_MODE_011: ; (An)+
00003BB2  4EB8 2A54               3399      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003BB6  4EF9 00003C1E           3400      JMP         MULS_W_DEST
00003BBC                          3401  MULS_W_MODE_100: ; -(An)
00003BBC  4EB8 2A94               3402      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003BC0  4EF9 00003C1E           3403      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003BC6                          3404  MULS_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003BC6  4EB8 28FE               3405      JSR         EA_INVALID          ; Opcode word is Invalid
00003BCA  4EF9 00003C30           3406      JMP         MULS_W_END
00003BD0                          3407  MULS_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003BD0  4EB8 28FE               3408      JSR         EA_INVALID          ; Opcode word is Invalid
00003BD4  4EF9 00003C30           3409      JMP         MULS_W_END
00003BDA                          3410  MULS_W_MODE_111: ; The rest (not all valid, validated by register number)
00003BDA  BE3C 0000               3411      CMP.B       #$00, D7            ; Test for absolute word address
00003BDE  6700 001C               3412      BEQ         MULS_W_ABS_W
00003BE2  BE3C 0001               3413      CMP.B       #$01, D7            ; Test for absolute long address
00003BE6  6700 001E               3414      BEQ         MULS_W_ABS_L
00003BEA  BE3C 0004               3415      CMP.B       #$04, D7            ; Test for immediate data
00003BEE  6700 0020               3416      BEQ         MULS_W_IMM
00003BF2  4EB8 28FE               3417      JSR         EA_INVALID          ; Else: invalid
00003BF6  4EF9 00003C30           3418      JMP         MULS_W_END
00003BFC                          3419  MULS_W_ABS_W:
00003BFC  4EB8 2AE0               3420      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003C00  4EF9 00003C1E           3421      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003C06                          3422  MULS_W_ABS_L:
00003C06  4EB8 2AD4               3423      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003C0A  4EF9 00003C1E           3424      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003C10                          3425  MULS_W_IMM:
00003C10  1A3C 0002               3426      MOVE.B      #2, D5              ; Size is word
00003C14  4EB8 2A36               3427      JSR         EA_PRINT_IMM        ; Print immediate data
00003C18  4EF9 00003C1E           3428      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003C1E                          3429  MULS_W_DEST:
00003C1E                          3430      *print EA_MSG_COMMA
00003C1E                          3431      *Get destination register
00003C1E  3E16                    3432      MOVE.W      (A6), D7            ; Load word at current pointer to D1
00003C20  143C 0004               3433      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00003C24  E56F                    3434      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003C26  143C 000D               3435      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
00003C2A  E46F                    3436      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003C2C  4EB8 2976               3437      JSR         EA_PRINT_DN         ; Print data register direct operand
00003C30                          3438  MULS_W_END:
00003C30  4EB8 2908               3439      JSR         EA_UPDATE_POINTER   ; Update global pointer
00003C34  4CDF 3FFF               3440      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003C38  4E75                    3441      RTS
00003C3A                          3442  
00003C3A                          3443  EA_OR:
00003C3A  48E7 FFFC               3444      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003C3E  4EB8 2914               3445      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003C42  4EB8 293E               3446      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00003C46  41F9 00003C54           3447      LEA         OR_OPMODE, A0       ; Set index '0' for jump table
00003C4C  CCFC 0006               3448      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003C50  4EF0 6000               3449      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003C54                          3450  OR_OPMODE:
00003C54  4EF9 00003C84           3451      JMP         OR_OPMODE_000       ; mode 1, byte
00003C5A  4EF9 00003C8E           3452      JMP         OR_OPMODE_001       ; mode 1, word
00003C60  4EF9 00003C98           3453      JMP         OR_OPMODE_010       ; mode 1, long
00003C66  4EF9 00003CA2           3454      JMP         OR_OPMODE_011       ; Invalid value
00003C6C  4EF9 00003CAC           3455      JMP         OR_OPMODE_100       ; mode 2, byte
00003C72  4EF9 00003CB6           3456      JMP         OR_OPMODE_101       ; mode 2, word
00003C78  4EF9 00003CC0           3457      JMP         OR_OPMODE_110       ; mode 2, long
00003C7E  4EF9 00003CCA           3458      JMP         OR_OPMODE_111       ; Invalid value
00003C84                          3459  OR_OPMODE_000: ; mode 1, byte
00003C84  1A3C 0001               3460      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003C88  4EF9 00003CD4           3461      JMP         OR_MODE_1
00003C8E                          3462  OR_OPMODE_001: ; mode 1, word
00003C8E  1A3C 0002               3463      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00003C92  4EF9 00003CD4           3464      JMP         OR_MODE_1
00003C98                          3465  OR_OPMODE_010: ; mode 1, long
00003C98  1A3C 0003               3466      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00003C9C  4EF9 00003CD4           3467      JMP         OR_MODE_1
00003CA2                          3468  OR_OPMODE_011: ; Invalid value
00003CA2  4EB8 28FE               3469      JSR         EA_INVALID
00003CA6  4EF9 00003DDC           3470      JMP         OR_END
00003CAC                          3471  OR_OPMODE_100: ; mode 2, byte
00003CAC  1A3C 0001               3472      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003CB0  4EF9 00003CF2           3473      JMP         OR_MODE_2
00003CB6                          3474  OR_OPMODE_101: ; mode 2, word
00003CB6  1A3C 0001               3475      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003CBA  4EF9 00003CF2           3476      JMP         OR_MODE_2
00003CC0                          3477  OR_OPMODE_110: ; mode 2, long
00003CC0  1A3C 0001               3478      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003CC4  4EF9 00003CF2           3479      JMP         OR_MODE_2
00003CCA                          3480  OR_OPMODE_111: ; Invalid value
00003CCA  4EB8 28FE               3481      JSR         EA_INVALID
00003CCE  4EF9 00003DDC           3482      JMP         OR_END
00003CD4                          3483  OR_MODE_1:
00003CD4  4280                    3484      CLR.L       D0                  ; Clear data register 0
00003CD6  103C 0001               3485      MOVE.B      #1, D0              ; Save mode number to D0
00003CDA  3207                    3486      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003CDC  4EB8 2918               3487      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003CE0  4EB9 00003D0C           3488      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
00003CE6                          3489      *PRINT COMMA TODO
00003CE6  3E01                    3490      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003CE8  4EB8 2976               3491      JSR         EA_PRINT_DN         ; Print data register
00003CEC  4EF9 00003DDC           3492      JMP         OR_END
00003CF2                          3493  OR_MODE_2:
00003CF2  4280                    3494      CLR.L       D0                  ; Clear data register 0
00003CF4  103C 0002               3495      MOVE.B      #2, D0              ; Save mode number to D0
00003CF8  4EB8 2976               3496      JSR         EA_PRINT_DN         ; Print data register
00003CFC                          3497      *PRINT COMMA TODO
00003CFC  4EB8 2918               3498      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003D00  4EB9 00003D0C           3499      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
00003D06  4EF9 00003DDC           3500      JMP         OR_END
00003D0C                          3501  OR_EVAL_EA:
00003D0C  41F9 00003D1A           3502      LEA         OR_MODE, A0         ; Set index '0' for jump table
00003D12  CCFC 0006               3503      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003D16  4EF0 6000               3504      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003D1A                          3505  OR_MODE:
00003D1A  4EF9 00003D4A           3506      JMP         OR_MODE_000         ; Invalid: Dn
00003D20  4EF9 00003D54           3507      JMP         OR_MODE_001         ; An (invalid if opmode 2)
00003D26  4EF9 00003D66           3508      JMP         OR_MODE_010         ; (An)
00003D2C  4EF9 00003D70           3509      JMP         OR_MODE_011         ; (An)+
00003D32  4EF9 00003D7A           3510      JMP         OR_MODE_100         ; -(An)
00003D38  4EF9 00003D84           3511      JMP         OR_MODE_101         ; Invalid: Address Register Indirect with Displacement Mode
00003D3E  4EF9 00003D8A           3512      JMP         OR_MODE_110         ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003D44  4EF9 00003D90           3513      JMP         OR_MODE_111         ; The rest (not all valid, validated by register number)
00003D4A                          3514  OR_MODE_000: ; Invalid: Dn
00003D4A  4EB8 28FE               3515      JSR         EA_INVALID          ; Invalid for both opmodes
00003D4E  4EF9 00003DD4           3516      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D54                          3517  OR_MODE_001: ; An (invalid if opmode 2)
00003D54  B07C 0002               3518      CMP         #2, D0
00003D58  6700 007C               3519      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
00003D5C  4EB8 29B6               3520      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00003D60  4EF9 00003DD4           3521      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D66                          3522  OR_MODE_010: ; (An)
00003D66  4EB8 29F6               3523      JSR         EA_PRINT_IND         ; Print address register indirect
00003D6A  4EF9 00003DD4           3524      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D70                          3525  OR_MODE_011: ; (An)+
00003D70  4EB8 2A54               3526      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003D74  4EF9 00003DD4           3527      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D7A                          3528  OR_MODE_100: ; -(An)
00003D7A  4EB8 2A94               3529      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003D7E  4EF9 00003DD4           3530      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D84                          3531  OR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003D84  4EF9 00003DD6           3532      JMP         OR_MODE_INVALID
00003D8A                          3533  OR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003D8A  4EF9 00003DD6           3534      JMP         OR_MODE_INVALID
00003D90                          3535  OR_MODE_111: ; The rest (not all valid, validated by register number)
00003D90  BE3C 0000               3536      CMP.B       #$00, D7            ; Test for absolute word address
00003D94  6700 0018               3537      BEQ         OR_ABS_W
00003D98  BE3C 0001               3538      CMP.B       #$01, D7            ; Test for absolute long address
00003D9C  6700 001A               3539      BEQ         OR_ABS_L
00003DA0  BE3C 0004               3540      CMP.B       #$04, D7            ; Test for immediate data
00003DA4  6700 001C               3541      BEQ         OR_IMM
00003DA8  4EF9 00003DD6           3542      JMP         OR_MODE_INVALID     ; else, invalid
00003DAE                          3543  OR_ABS_W:
00003DAE  4EB8 2AE0               3544      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003DB2  4EF9 00003DD4           3545      JMP         OR_MODE_END
00003DB8                          3546  OR_ABS_L:
00003DB8  4EB8 2AD4               3547      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003DBC  4EF9 00003DD4           3548      JMP         OR_MODE_END
00003DC2                          3549  OR_IMM: ; invalid if opmode is 2
00003DC2  B07C 0002               3550      CMP         #2, D0
00003DC6  6700 000E               3551      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
00003DCA  4EB8 2A36               3552      JSR         EA_PRINT_IMM        ; Print immediate data
00003DCE  4EF9 00003DD4           3553      JMP         OR_MODE_END
00003DD4                          3554  OR_MODE_END:
00003DD4  4E75                    3555      RTS                             ; Finish evaluating EA bits
00003DD6                          3556  OR_MODE_INVALID:
00003DD6  4EB8 28FE               3557      JSR         EA_INVALID          ; Opcode word is Invalid
00003DDA  4E75                    3558      RTS
00003DDC                          3559  OR_END:
00003DDC  4EB8 2908               3560      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003DE0  4CDF 3FFF               3561      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003DE4  4E75                    3562      RTS
00003DE6                          3563  EA_ROd:
00003DE6  48E7 FFFC               3564      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003DEA  4EB8 2914               3565      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003DEE  4EB8 2964               3566      JSR         EA_SIZE_BITS        ; get size bits in D7
00003DF2  BE3C 0003               3567      CMP.B       #$03, D7            ; test if memory shift
00003DF6  6700 0042               3568      BEQ         ROd_MEM
00003DFA  6000 0002               3569      BRA         ROd_REG             ; else, register shfit
00003DFE                          3570  ROd_REG:
00003DFE  3E16                    3571      MOVE.W      (A6), D7            ; read opcode word in memory and save,
00003E00                          3572                                      ; (using D7 because EA_PRINT_DN uses D7)
00003E00  143C 0004               3573      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
00003E04  E56F                    3574      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003E06  143C 000D               3575      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
00003E0A  E46F                    3576      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003E0C  3016                    3577      MOVE.W      (A6), D0            ; read opcode word in memory and save
00003E0E  143C 000A               3578      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
00003E12  E568                    3579      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00003E14  143C 000F               3580      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
00003E18  E468                    3581      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00003E1A  B03C 0000               3582      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
00003E1E  6700 000C               3583      BEQ         ROd_REG_COUNT
00003E22                          3584  ROd_REG_REG:                        ; Else, count/register field contains register number
00003E22  4EB8 2976               3585      JSR         EA_PRINT_DN         ; Print register value, stored in D7
00003E26  4EF9 00003E2C           3586      JMP         ROd_REG_END         ; Jump to end of ROd_REG
00003E2C                          3587  ROd_REG_COUNT:
00003E2C                          3588      *print hash todo
00003E2C                          3589      *print hex value in D7 as byte todo, continue on to ROd_REG_END
00003E2C                          3590  ROd_REG_END:
00003E2C                          3591      *PRINT COMMA todo
00003E2C  4EB8 2918               3592      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
00003E30  4EB8 2976               3593      JSR         EA_PRINT_DN         ; Print register value in D7
00003E34  4EF9 00003EF0           3594      JMP         ROd_END
00003E3A                          3595  ROd_MEM:
00003E3A  4EB8 2918               3596      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003E3E  41F9 00003E4C           3597      LEA         ROd_MEM_MODE, A0    ; Set index '0' for jump table
00003E44  CCFC 0006               3598      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003E48  4EF0 6000               3599      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003E4C                          3600  ROd_MEM_MODE:
00003E4C  4EF9 00003E7C           3601      JMP         ROd_MEM_MODE_000     ; Invalid: Dn
00003E52  4EF9 00003E86           3602      JMP         ROd_MEM_MODE_001     ; Invalid: An
00003E58  4EF9 00003E90           3603      JMP         ROd_MEM_MODE_010     ; (An)
00003E5E  4EF9 00003E9A           3604      JMP         ROd_MEM_MODE_011     ; (An)+
00003E64  4EF9 00003EA4           3605      JMP         ROd_MEM_MODE_100     ; -(An)
00003E6A  4EF9 00003EAE           3606      JMP         ROd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003E70  4EF9 00003EB8           3607      JMP         ROd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E76  4EF9 00003EC2           3608      JMP         ROd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00003E7C                          3609  ROd_MEM_MODE_000: ; Invalid: Dn
00003E7C  4EB8 28FE               3610      JSR         EA_INVALID          ; Data register direct is invalid mode
00003E80  4EF9 00003EF0           3611      JMP         ROd_END
00003E86                          3612  ROd_MEM_MODE_001: ; Invalid: An
00003E86  4EB8 28FE               3613      JSR         EA_INVALID          ; Address register direct is invalid mode
00003E8A  4EF9 00003EF0           3614      JMP         ROd_END
00003E90                          3615  ROd_MEM_MODE_010: ; (An)
00003E90  4EB8 29F6               3616      JSR         EA_PRINT_IND         ; Print address register indirect
00003E94  4EF9 00003EF0           3617      JMP         ROd_END
00003E9A                          3618  ROd_MEM_MODE_011: ; (An)+
00003E9A  4EB8 2A54               3619      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003E9E  4EF9 00003EF0           3620      JMP         ROd_END
00003EA4                          3621  ROd_MEM_MODE_100: ; -(An)
00003EA4  4EB8 2A94               3622      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003EA8  4EF9 00003EF0           3623      JMP         ROd_END         ; Continue with parsing destination operand
00003EAE                          3624  ROd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003EAE  4EB8 28FE               3625      JSR         EA_INVALID          ; Opcode word is Invalid
00003EB2  4EF9 00003EF0           3626      JMP         ROd_END
00003EB8                          3627  ROd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003EB8  4EB8 28FE               3628      JSR         EA_INVALID          ; Opcode word is Invalid
00003EBC  4EF9 00003EF0           3629      JMP         ROd_END
00003EC2                          3630  ROd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
00003EC2  BE3C 0000               3631      CMP.B       #$00, D7            ; Test for absolute word address
00003EC6  6700 0014               3632      BEQ         ROd_MEM_ABS_W
00003ECA  BE3C 0001               3633      CMP.B       #$01, D7            ; Test for absolute long address
00003ECE  6700 0016               3634      BEQ         ROd_MEM_ABS_L
00003ED2  4EB8 28FE               3635      JSR         EA_INVALID          ; Else: invalid
00003ED6  4EF9 00003EF0           3636      JMP         ROd_END
00003EDC                          3637  ROd_MEM_ABS_W:
00003EDC  4EB8 2AE0               3638      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003EE0  4EF9 00003EF0           3639      JMP         ROd_END
00003EE6                          3640  ROd_MEM_ABS_L:
00003EE6  4EB8 2AD4               3641      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003EEA  4EF9 00003EF0           3642      JMP         ROd_END
00003EF0                          3643  ROd_END:
00003EF0  4EB8 2908               3644      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003EF4  4CDF 3FFF               3645      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003EF8  4E75                    3646      RTS
00003EFA                          3647  EA_SUB:
00003EFA  4EB8 293E               3648      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00003EFE  41F9 00003F0C           3649      LEA         SUB_OPMODE, A0      ; Set index '0' for jump table
00003F04  CCFC 0006               3650      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003F08  4EF0 6000               3651      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003F0C                          3652  SUB_OPMODE:
00003F0C  4EF9 00003F3C           3653      JMP         SUB_OPMODE_000      ; mode 1, byte
00003F12  4EF9 00003F46           3654      JMP         SUB_OPMODE_001      ; mode 1, word
00003F18  4EF9 00003F50           3655      JMP         SUB_OPMODE_010      ; mode 1, long
00003F1E  4EF9 00003F5A           3656      JMP         SUB_OPMODE_011      ; Invalid value
00003F24  4EF9 00003F64           3657      JMP         SUB_OPMODE_100      ; mode 2, byte
00003F2A  4EF9 00003F6E           3658      JMP         SUB_OPMODE_101      ; mode 2, word
00003F30  4EF9 00003F78           3659      JMP         SUB_OPMODE_110      ; mode 2, long
00003F36  4EF9 00003F82           3660      JMP         SUB_OPMODE_111      ; Invalid value
00003F3C                          3661  SUB_OPMODE_000: ; mode 1, byte
00003F3C  1A3C 0001               3662      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F40  4EF9 00003F8C           3663      JMP         SUB_MODE_1
00003F46                          3664  SUB_OPMODE_001: ; mode 1, word
00003F46  1A3C 0002               3665      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00003F4A  4EF9 00003F8C           3666      JMP         SUB_MODE_1
00003F50                          3667  SUB_OPMODE_010: ; mode 1, long
00003F50  1A3C 0003               3668      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00003F54  4EF9 00003F8C           3669      JMP         SUB_MODE_1
00003F5A                          3670  SUB_OPMODE_011: ; Invalid value
00003F5A  4EB8 28FE               3671      JSR         EA_INVALID
00003F5E  4EF9 0000409C           3672      JMP         SUB_END
00003F64                          3673  SUB_OPMODE_100: ; mode 2, byte
00003F64  1A3C 0001               3674      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F68  4EF9 00003FAA           3675      JMP         SUB_MODE_2
00003F6E                          3676  SUB_OPMODE_101: ; mode 2, word
00003F6E  1A3C 0001               3677      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F72  4EF9 00003FAA           3678      JMP         SUB_MODE_2
00003F78                          3679  SUB_OPMODE_110: ; mode 2, long
00003F78  1A3C 0001               3680      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F7C  4EF9 00003FAA           3681      JMP         SUB_MODE_2
00003F82                          3682  SUB_OPMODE_111: ; Invalid value
00003F82  4EB8 28FE               3683      JSR         EA_INVALID
00003F86  4EF9 0000409C           3684      JMP         SUB_END
00003F8C                          3685  SUB_MODE_1:
00003F8C  4280                    3686      CLR.L       D0                  ; Clear data register 0
00003F8E  103C 0001               3687      MOVE.B      #1, D0              ; Save mode number to D0
00003F92  3207                    3688      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003F94  4EB8 2918               3689      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003F98  4EB9 00003FC4           3690      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
00003F9E  3E01                    3691      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003FA0  4EB8 2976               3692      JSR         EA_PRINT_DN         ; Print data register
00003FA4  4EF9 0000409C           3693      JMP         SUB_END
00003FAA                          3694  SUB_MODE_2:
00003FAA  4280                    3695      CLR.L       D0                  ; Clear data register 0
00003FAC  103C 0002               3696      MOVE.B      #2, D0              ; Save mode number to D0
00003FB0  4EB8 2976               3697      JSR         EA_PRINT_DN         ; Print data register
00003FB4  4EB8 2918               3698      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003FB8  4EB9 00003FC4           3699      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
00003FBE  4EF9 0000409C           3700      JMP         SUB_END
00003FC4                          3701  SUB_EVAL_EA:
00003FC4  41F9 00003FD2           3702      LEA         SUB_MODE, A0        ; Set index '0' for jump table
00003FCA  CCFC 0006               3703      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003FCE  4EF0 6000               3704      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003FD2                          3705  SUB_MODE:
00003FD2  4EF9 00004002           3706      JMP         SUB_MODE_000        ; Dn (invalid if opmode 2)
00003FD8  4EF9 00004014           3707      JMP         SUB_MODE_001        ; An (invalid if opmode 2)
00003FDE  4EF9 00004026           3708      JMP         SUB_MODE_010        ; (An)
00003FE4  4EF9 00004030           3709      JMP         SUB_MODE_011        ; (An)+
00003FEA  4EF9 0000403A           3710      JMP         SUB_MODE_100        ; -(An)
00003FF0  4EF9 00004044           3711      JMP         SUB_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003FF6  4EF9 0000404A           3712      JMP         SUB_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003FFC  4EF9 00004050           3713      JMP         SUB_MODE_111        ; The rest (not all valid, validated by register number)
00004002                          3714  SUB_MODE_000: ; Dn (invalid if opmode 2)
00004002  B07C 0002               3715      CMP         #2, D0
00004006  6700 008E               3716      BEQ         SUB_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
0000400A  4EB8 2976               3717      JSR         EA_PRINT_DN         ; Print data register direct operand
0000400E  4EF9 00004094           3718      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004014                          3719  SUB_MODE_001: ; An (invalid if opmode 2)
00004014  B07C 0002               3720      CMP         #2, D0
00004018  6700 007C               3721      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
0000401C  4EB8 29B6               3722      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00004020  4EF9 00004094           3723      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004026                          3724  SUB_MODE_010: ; (An)
00004026  4EB8 29F6               3725      JSR         EA_PRINT_IND         ; Print address register indirect
0000402A  4EF9 00004094           3726      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004030                          3727  SUB_MODE_011: ; (An)+
00004030  4EB8 2A54               3728      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00004034  4EF9 00004094           3729      JMP         SUB_MODE_END        ; End evaluation of ea mode
0000403A                          3730  SUB_MODE_100: ; -(An)
0000403A  4EB8 2A94               3731      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000403E  4EF9 00004094           3732      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004044                          3733  SUB_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00004044  4EF9 00004096           3734      JMP         SUB_MODE_INVALID
0000404A                          3735  SUB_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000404A  4EF9 00004096           3736      JMP         SUB_MODE_INVALID
00004050                          3737  SUB_MODE_111: ; The rest (not all valid, validated by register number)
00004050  BE3C 0000               3738      CMP.B       #$00, D7            ; Test for absolute word address
00004054  6700 0018               3739      BEQ         SUB_ABS_W
00004058  BE3C 0001               3740      CMP.B       #$01, D7            ; Test for absolute long address
0000405C  6700 001A               3741      BEQ         SUB_ABS_L
00004060  BE3C 0004               3742      CMP.B       #$04, D7            ; Test for immediate data
00004064  6700 001C               3743      BEQ         SUB_IMM
00004068  4EF9 00004096           3744      JMP         SUB_MODE_INVALID    ; else, invalid
0000406E                          3745  SUB_ABS_W:
0000406E  4EB8 2AE0               3746      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00004072  4EF9 00004094           3747      JMP         SUB_MODE_END
00004078                          3748  SUB_ABS_L:
00004078  4EB8 2AD4               3749      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000407C  4EF9 00004094           3750      JMP         SUB_MODE_END
00004082                          3751  SUB_IMM: ; invalid if opmode is 2
00004082  B07C 0002               3752      CMP         #2, D0
00004086  6700 000E               3753      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
0000408A  4EB8 2A36               3754      JSR         EA_PRINT_IMM        ; Print immediate data
0000408E  4EF9 00004094           3755      JMP         SUB_MODE_END
00004094                          3756  SUB_MODE_END:
00004094  4E75                    3757      RTS                             ; Finish evaluating EA bits
00004096                          3758  SUB_MODE_INVALID:
00004096  4EB8 28FE               3759      JSR         EA_INVALID          ; Opcode word is Invalid
0000409A  4E75                    3760      RTS
0000409C                          3761  SUB_END:
0000409C  4EB8 2908               3762      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000040A0  4CDF 3FFF               3763      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000040A4  4E75                    3764      RTS
000040A6                          3765  
000040A6                          3766  
000040A6                          3767  
000040A6                          3768  -------------------- end include --------------------
000040A6                          3769      INCLUDE 'EndProgram.X68'
000040A6                          3770  
000040A6                          3771  
000040A6                          3772  
000040A6  =00000059               3773  UPYES     EQU   'Y'
000040A6  =00000079               3774  LOWYES    EQU   'y'
000040A6                          3775  
000040A6                          3776  
000040A6                          3777  
000040A6                          3778  KEEP_RUNNING
000040A6  6100 0004               3779      BSR.W       RERUN               * Run welcome subroutine
000040AA  4E75                    3780      RTS                             * Return to Disassembler
000040AC                          3781      
000040AC                          3782  
000040AC                          3783  
000040AC                          3784             
000040AC                          3785  
000040AC                          3786  RERUN 
000040AC  43F9 000040E0           3787      LEA         ENDQUESTION,A1      * Loads message into A1
000040B2  103C 000E               3788      MOVE.B      #14,D0              * Moves the Task 14 into D0
000040B6  4E4F                    3789      TRAP        #15                 * Displays Intro Message
000040B8                          3790      
000040B8  103C 0005               3791      MOVE.B      #5,D0               * Move task 5 to read one char
000040BC  4E4F                    3792      TRAP        #15                 * Trap 15 for IO
000040BE                          3793      
000040BE  0C01 0059               3794      CMPI.B      #UPYES,D1           * Is char = Y
000040C2  6700 0012               3795      BEQ         NOTDONE             * If yes, notdone
000040C6  0C01 0079               3796      CMPI.B      #LOWYES,D1          * Is char = y   
000040CA  6700 000A               3797      BEQ         NOTDONE             * If yes, notdone
000040CE  11FC 0000 6000          3798      MOVE.B      #0,(RUNAGAIN)       * 0 for false to end program
000040D4  4E75                    3799      RTS 
000040D6                          3800      
000040D6                          3801  NOTDONE
000040D6  11FC 0001 6000          3802      MOVE.B      #1,(RUNAGAIN)       * 1 for true to rerun program
000040DC  6000 D1F2               3803      BRA.W       CLEARSCRN           * Clear screen and return from subroutine         
000040E0                          3804          
000040E0                          3805  
000040E0                          3806  
000040E0                          3807  
000040E0= 57 4F 55 4C 44 20 ...   3808  ENDQUESTION     DC.B 'WOULD YOU LIKE TO RUN THE PROGRAM AGAIN (Y/N)? ',0
00004110                          3809  
00004110                          3810  
00004110                          3811  
00004110                          3812  -------------------- end include --------------------
00004110                          3813  
00004110                          3814  *********** END INCLUDES *****************************************************
00004110                          3815  
00004110                          3816  
00004110                          3817  ******************************************************************************
00004110                          3818  *           BEGIN CODE                                                       *
00004110                          3819  ******************************************************************************
00004110                          3820  
00004110                          3821  *---------- START ------------------------------------------------------------
00004110                          3822  * Begins program's logical flow. Similar to main in C/C++
00004110                          3823  *-----------------------------------------------------------------------------
00004110                          3824  START
00004110  4FF8 7000               3825      LEA         STACK,SP            * SP is stored in A7
00004114  4EB8 1000               3826      JSR         GET_ADDRESSES       * Runs GET_ADDRESSES and IO_WELCOME
00004118  2C78 5000               3827      MOVEA.L     BEGINADDR,A6        * Assign beginning address to A6 for use
0000411C                          3828  
0000411C                          3829  LOOP
0000411C                          3830      * OC_PARSE Command doesn't work due to issues in the Opcode include
0000411C                          3831      * many errors need to be fixed. Same with EA include
0000411C                          3832      *JSR         OC_PARSE            * Determine if there is an initial opcode match
0000411C  4EB8 12EE               3833      JSR         INVALID_DATA
00004120                          3834      * decrement row count
00004120                          3835      * if at 0, prompt for next page
00004120                          3836      * else, continue
00004120  548E                    3837      ADDA.L      #$00000002,A6            * Advance address to test LOOP (test only)
00004122                          3838  
00004122                          3839  LOOP_CHECK
00004122                          3840      * Changed the following code from:
00004122                          3841      * CMPA        A6, ENDADDR
00004122                          3842      * to:
00004122                          3843      * CMPA      (ENDADDR),A6
00004122                          3844      * When using the CMPA, destination must be an address so A6
00004122  BDF8 5010               3845      CMPA.L      ENDADDR,A6          * Is pointer at end of address range?
00004126                          3846  
00004126  6E00 0004               3847      BGT         END_LOOP            * If yes, END_LOOP
0000412A                          3848      ; in case this resets status register, do another compare TODO
0000412A                          3849  
0000412A  66F0                    3850      BNE         LOOP                * If not, continue processing addresses
0000412C                          3851      ; If at end of address range, check if user wants to continue
0000412C                          3852      ; if user wants to continue, restart
0000412C                          3853      ; else, end
0000412C                          3854  
0000412C                          3855  END_LOOP
0000412C  4EB8 40A6               3856      JSR         KEEP_RUNNING        * Does the user want to run program again
00004130  0C38 0001 6000          3857      CMPI.B      #1,(RUNAGAIN)       * Does RUNAGAIN = TRUE?
00004136  67D8                    3858      BEQ         START               * If yes, rerun program
00004138  4E72 3000               3859      STOP        #$3000              * Else, end program
0000413C                          3860  
0000413C                          3861  *---------- END - START ------------------------------------------------------
0000413C                          3862  
0000413C                          3863  *********** END BEGIN CODE ***************************************************
0000413C                          3864  
0000413C                          3865  
0000413C                          3866  ******************************************************************************
0000413C                          3867  *           VARIABLES AND CONSTANTS                                          *
0000413C                          3868  ******************************************************************************
0000413C                          3869  
0000413C                          3870  
0000413C                          3871  
0000413C                          3872  *---------- Reserved Registers -----------------------------
0000413C                          3873  *   A7: stack pointer
0000413C                          3874  *   A6: current address (updated by subroutines)
0000413C                          3875  *   D0: instruction validity flag (reset by main control
0000413C                          3876  *       code, can be set to false by subroutines)
0000413C                          3877  *-----------------------------------------------------------
0000413C                          3878  
0000413C                          3879  *---------- End --------------------------------------------
0000413C                          3880                 END  START          * Last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDA_ABS_L          2D50
ADDA_ABS_W          2D46
ADDA_END            2D7A
ADDA_IMM            2D5A
ADDA_MODE           2CBA
ADDA_MODE_000       2CEA
ADDA_MODE_001       2CF4
ADDA_MODE_010       2CFE
ADDA_MODE_011       2D08
ADDA_MODE_100       2D12
ADDA_MODE_101       2D1C
ADDA_MODE_110       2D22
ADDA_MODE_111       2D28
ADDA_MODE_END       2D72
ADDA_MODE_INVALID   2D68
ADDCODE000          1CE2
ADDCODE001          1CEA
ADDCODE010          1CF2
ADDCODE011          1CFA
ADDCODE100          1D02
ADDCODE101          1D0A
ADDCODE110          1D12
ADDCODE111          1D1A
ADDIBCODE00         2140
ADDILCODE10         2150
ADDILCODE11         2158
ADDIWCODE01         2148
ADDI_ABS_L          2E8C
ADDI_ABS_W          2E82
ADDI_B              2DB2
ADDI_BORADDI_WORADDI_L  210A
ADDI_END            2E96
ADDI_GET_DEST       2DE0
ADDI_L              2DDA
ADDI_MODE           2DF2
ADDI_MODE_000       2E22
ADDI_MODE_001       2E2C
ADDI_MODE_010       2E36
ADDI_MODE_011       2E40
ADDI_MODE_100       2E4A
ADDI_MODE_101       2E54
ADDI_MODE_110       2E5E
ADDI_MODE_111       2E68
ADDI_W              2DCC
ADDQCODE00          1E3C
ADDQCODE01          1E44
ADDQCODE10          1E4C
ADDQCODE11          1E54
ADDQ_ABS_L          2F6E
ADDQ_ABS_W          2F64
ADDQ_BORADDQ_WORADDQ_L  1E06
ADDQ_END            2F78
ADDQ_MODE           2ED4
ADDQ_MODE_000       2F04
ADDQ_MODE_001       2F0E
ADDQ_MODE_010       2F18
ADDQ_MODE_011       2F22
ADDQ_MODE_100       2F2C
ADDQ_MODE_101       2F36
ADDQ_MODE_110       2F40
ADDQ_MODE_111       2F4A
ADDQ_PRINT_IMM      2EC2
ADDRESS_ERR         12DC
ADD_ABS_L           2C72
ADD_ABS_W           2C68
ADD_BORADD_WORADD_L  1C94
ADD_END             2C96
ADD_EVAL_EA         2BBE
ADD_IMM             2C7C
ADD_MODE            2BCC
ADD_MODE_000        2BFC
ADD_MODE_001        2C0E
ADD_MODE_010        2C20
ADD_MODE_011        2C2A
ADD_MODE_1          2B86
ADD_MODE_100        2C34
ADD_MODE_101        2C3E
ADD_MODE_110        2C44
ADD_MODE_111        2C4A
ADD_MODE_2          2BA4
ADD_MODE_END        2C8E
ADD_MODE_INVALID    2C90
ADD_OPMODE          2B06
ADD_OPMODE_000      2B36
ADD_OPMODE_001      2B40
ADD_OPMODE_010      2B4A
ADD_OPMODE_011      2B54
ADD_OPMODE_100      2B5E
ADD_OPMODE_101      2B68
ADD_OPMODE_110      2B72
ADD_OPMODE_111      2B7C
ADR_ERR_NOTLT       1446
ANDCODE000          1C54
ANDCODE001          1C5C
ANDCODE010          1C64
ANDCODE011          1C6C
ANDCODE100          1C74
ANDCODE101          1C7C
ANDCODE110          1C84
ANDCODE111          1C8C
AND_ABS_L           30FA
AND_ABS_W           30F0
AND_BORAND_WORAND_LORMULS_W  1C06
AND_END             311E
AND_EVAL_EA         3052
AND_IMM             3104
AND_MODE            3060
AND_MODE_000        3090
AND_MODE_001        30A2
AND_MODE_010        30A8
AND_MODE_011        30B2
AND_MODE_1          301A
AND_MODE_100        30BC
AND_MODE_101        30C6
AND_MODE_110        30CC
AND_MODE_111        30D2
AND_MODE_2          3038
AND_MODE_END        3116
AND_MODE_INVALID    3118
AND_OPMODE          2F9A
AND_OPMODE_000      2FCA
AND_OPMODE_001      2FD4
AND_OPMODE_010      2FDE
AND_OPMODE_011      2FE8
AND_OPMODE_100      2FF2
AND_OPMODE_101      2FFC
AND_OPMODE_110      3006
AND_OPMODE_111      3010
AN_000              29F4
AN_001              29F4
AN_010              29F4
AN_011              29F4
AN_100              29F4
AN_101              29F4
AN_110              29F4
AN_111              29F4
AN_JMP              29C4
ASCII_TO_HEX        1124
ASD_END             3232
ASD_MEM             317C
ASD_MEM_ABS_L       3228
ASD_MEM_ABS_W       321E
ASD_MEM_MODE        318E
ASD_MEM_MODE_000    31BE
ASD_MEM_MODE_001    31C8
ASD_MEM_MODE_010    31D2
ASD_MEM_MODE_011    31DC
ASD_MEM_MODE_100    31E6
ASD_MEM_MODE_101    31F0
ASD_MEM_MODE_110    31FA
ASD_MEM_MODE_111    3204
ASD_REG             3140
ASD_REG_COUNT       316E
ASD_REG_END         316E
ASD_REG_REG         3164
ASLCODE00           199C
ASLCODE01           19A4
ASLCODE10           19AC
ASLCODE11           19B4
ASL_ASR             1B80
ASL_ASRCODE0        1BAA
ASL_ASRCODE1        1BB0
ASRCODE00           1946
ASRCODE01           194E
ASRCODE10           1956
ASRCODE11           195E
BCCORBGTORBLE       182C
BCCORBGTORBLECODE00  1862
BCCORBGTORBLECODE01  186A
BCCORBGTORBLECODE10  1872
BCCORBGTORBLECODE11  187A
BCC_B               326A
BCC_DISPLAY         32BE
BCC_L               32B0
BCC_W               328E
BEGINADDR           5000
BMESSAGE            13FE
CHECK_BADDR_IS_LESS_THAN_EADDR  10A4
CLEAR               10D8
CLEARSCRN           12D0
CLRCODE00           1E92
CLRCODE01           1E9A
CLRCODE10           1EA2
CLRCODE11           1EAA
CLR_ABS_L           337E
CLR_ABS_W           3374
CLR_END             3388
CLR_MODE            32E4
CLR_MODE_000        3314
CLR_MODE_001        331E
CLR_MODE_010        3328
CLR_MODE_011        3332
CLR_MODE_100        333C
CLR_MODE_101        3346
CLR_MODE_110        3350
CLR_MODE_111        335A
CMPCODE00           1DE6
CMPCODE01           1DEE
CMPCODE10           1DF6
CMPCODE11           1DFE
CMP_ABS_L           3446
CMP_ABS_W           343C
CMP_BORCMP_WORCMP_L  1DB0
CMP_END             3458
CMP_MODE            33AC
CMP_MODE_000        33DC
CMP_MODE_001        33E6
CMP_MODE_010        33F0
CMP_MODE_011        33FA
CMP_MODE_100        3404
CMP_MODE_101        340E
CMP_MODE_110        3418
CMP_MODE_111        3422
CMP_MODE_END        3450
CODE0000            1780
CODE0001            1786
CODE0010            1792
CODE0011            1798
CODE0100            179E
CODE0101            17AA
CODE0110            17B6
CODE0111            17C2
CODE1000            17CE
CODE1001            17DA
CODE1010            17E6
CODE1011            17EE
CODE1100            17FA
CODE1101            1806
CODE1110            1812
CODE1111            181E
CR                  D
DATA                14F1
DIVU_W_ABS_L        351E
DIVU_W_ABS_W        3514
DIVU_W_DEST         3536
DIVU_W_END          3548
DIVU_W_IMM          3528
DIVU_W_MODE         347C
DIVU_W_MODE_000     34AC
DIVU_W_MODE_001     34B6
DIVU_W_MODE_010     34C0
DIVU_W_MODE_011     34CA
DIVU_W_MODE_100     34D4
DIVU_W_MODE_101     34DE
DIVU_W_MODE_110     34E8
DIVU_W_MODE_111     34F2
DN_000              29B4
DN_001              29B4
DN_010              29B4
DN_011              29B4
DN_100              29B4
DN_101              29B4
DN_110              29B4
DN_111              29B4
DOLLAR              1444
DONE                1826
EA_ADD              2AEC
EA_ADDA             2CA0
EA_ADDI             2D84
EA_ADDQ             2EA0
EA_AND              2F82
EA_ASD              3128
EA_BCC              323C
EA_CLR              32CA
EA_CMP              3392
EA_COPY_PTR         2914
EA_DEFAULT_COMBO    2918
EA_DIVU_W           3462
EA_INVALID          28FE
EA_JSR              3552
EA_LEA              361A
EA_LSD              36EA
EA_MOVE             37FE
EA_MOVEA            39D6
EA_MOVEM            3B00
EA_MOVEQ            3B06
EA_MSG_A0           28EA
EA_MSG_A1           28EC
EA_MSG_A2           28EE
EA_MSG_A3           28F0
EA_MSG_A4           28F2
EA_MSG_A5           28F4
EA_MSG_A6           28F6
EA_MSG_A7           28F8
EA_MSG_CLOSEPAREN   28D5
EA_MSG_COMMA        28D2
EA_MSG_D0           28DA
EA_MSG_D1           28DC
EA_MSG_D2           28DE
EA_MSG_D3           28E0
EA_MSG_D4           28E2
EA_MSG_D5           28E4
EA_MSG_D6           28E6
EA_MSG_D7           28E8
EA_MSG_HASH         28D8
EA_MSG_HEX          28D9
EA_MSG_MIN          28D6
EA_MSG_NULL         28D0
EA_MSG_OPENPAREN    28D4
EA_MSG_PLUS         28D7
EA_MSG_SPACE        28D1
EA_MULS_W           3B4A
EA_OPMODE_COMBO     293E
EA_OR               3C3A
EA_PRINT_ABS_L      2AD4
EA_PRINT_ABS_W      2AE0
EA_PRINT_AN         29B6
EA_PRINT_AN_END     29F4
EA_PRINT_DN         2976
EA_PRINT_DN_END     29B4
EA_PRINT_DN_JMP     2984
EA_PRINT_IMM        2A36
EA_PRINT_IND        29F6
EA_PRINT_IND_END    2A34
EA_PRINT_PD_END     2AD2
EA_PRINT_PI_END     2A92
EA_PRINT_POSTINC    2A54
EA_PRINT_PREDEC     2A94
EA_ROD              3DE6
EA_SIZE_BITS        2964
EA_SUB              3EFA
EA_UNIMPLEMENTED    28FA
EA_UPDATE_POINTER   2908
EMESSAGE            141D
ENDADDR             5010
ENDL                143C
ENDQUESTION         40E0
END_LOOP            412C
FINISHED            10C2
FOUND               11E0
GET_ADDRESSES       1000
GET_FIRST_ADDRESS   100C
GET_HEXSTRING       10F2
GET_SECOND_ADDRESS  1058
HEXA                1230
HEXB                1238
HEXC                1240
HEXD                1248
HEXE                1250
HEXEIGHT            1224
HEXF                1258
HEXFIVE             1218
HEXFLAG             5021
HEXFOUR             1214
HEXNINE             1228
HEXONE              1208
HEXSEVEN            1220
HEXSIX              121C
HEXSTRING           14A1
HEXTHREE            1210
HEXTWO              120C
HEXVALUE            5030
HEXZERO             1200
IND_000             2A34
IND_001             2A34
IND_010             2A34
IND_011             2A34
IND_100             2A34
IND_101             2A34
IND_110             2A34
IND_111             2A34
IND_JMP             2A04
INITIAL_TABLE       1720
INTRO               1344
INVALID_DATA        12EE
IO_WELCOME          10C4
ISADDAL             2598
ISADDAW             257E
ISADDB              25B2
ISADDIB             28B6
ISADDIL             289C
ISADDIW             2882
ISADDL              25E6
ISADDQB             269C
ISADDQL             26D0
ISADDQW             26B6
ISADDW              25CC
ISANDB              2530
ISANDL              2564
ISANDW              254A
ISASLB              2390
ISASLL              23C4
ISASLW              23AA
ISASRB              2342
ISASRL              2376
ISASRW              235C
ISBCC               228C
ISBGT               22A6
ISBLE               22C0
ISCLR               27D0
ISCLRB              2704
ISCLRL              2738
ISCLRW              271E
ISCMPB              264E
ISCMPL              2682
ISCMPW              2668
ISDIVUW             22DA
ISJSR               27A0
ISLEA               2786
ISLSLB              242C
ISLSLL              2460
ISLSLW              2446
ISLSRB              23DE
ISLSRL              2412
ISLSRW              23F8
ISMOVEAL            284E
ISMOVEAW            281A
ISMOVEB             2868
ISMOVEL             2834
ISMOVEML            2752
ISMOVEMW            276C
ISMOVEQL            26EA
ISMOVEW             2800
ISMULSW             2516
ISNOP               27EA
ISORB               22F4
ISORL               2328
ISORW               230E
ISROLB              24C8
ISROLL              24FC
ISROLW              24E2
ISRORB              247A
ISRORL              24AE
ISRORW              2494
ISRTS               27BA
ISSUBB              2600
ISSUBL              2634
ISSUBW              261A
IS_HEX_EVEN         1280
IS_LESSTHAN         1260
JSRORCLRCODE0000    1F54
JSRORCLRCODE0001    1F5C
JSRORCLRCODE0010    1F64
JSRORCLRCODE0011    1F6A
JSRORCLRCODE0100    1F72
JSRORCLRCODE0101    1F7A
JSRORCLRCODE0110    1F82
JSRORCLRCODE0111    1F8A
JSRORCLRCODE1000    1F92
JSRORCLRCODE1001    1F9A
JSRORCLRCODE1010    1FA2
JSRORCLRCODE1011    1FAA
JSRORCLRCODE1100    1FB2
JSRORCLRCODE1101    1FBA
JSRORCLRCODE1110    1FC2
JSRORCLRCODE1111    1FCA
JSR_ABS_L           3606
JSR_ABS_W           35FC
JSR_END             3610
JSR_MODE            356C
JSR_MODE_000        359C
JSR_MODE_001        35A6
JSR_MODE_010        35B0
JSR_MODE_011        35BA
JSR_MODE_100        35C4
JSR_MODE_101        35CE
JSR_MODE_110        35D8
JSR_MODE_111        35E2
KEEP_RUNNING        40A6
LEA_ABS_L           36CE
LEA_ABS_W           36C4
LEA_DEST            36D8
LEA_END             36E0
LEA_MODE            3634
LEA_MODE_000        3664
LEA_MODE_001        366E
LEA_MODE_010        3678
LEA_MODE_011        3682
LEA_MODE_100        368C
LEA_MODE_101        3696
LEA_MODE_110        36A0
LEA_MODE_111        36AA
LF                  A
LOOP                411C
LOOP_CHECK          4122
LOTSCODE0000        2090
LOTSCODE0001        2098
LOTSCODE0010        20A0
LOTSCODE0011        20A6
LOTSCODE0100        20AE
LOTSCODE0101        20B6
LOTSCODE0110        20BE
LOTSCODE0111        20C6
LOTSCODE1000        20CE
LOTSCODE1001        20D4
LOTSCODE1010        20DC
LOTSCODE1011        20E2
LOTSCODE1100        20EA
LOTSCODE1101        20F2
LOTSCODE1110        20FA
LOTSCODE1111        2102
LOWYES              79
LSD_END             37F4
LSD_MEM             373E
LSD_MEM_ABS_L       37EA
LSD_MEM_ABS_W       37E0
LSD_MEM_MODE        3750
LSD_MEM_MODE_000    3780
LSD_MEM_MODE_001    378A
LSD_MEM_MODE_010    3794
LSD_MEM_MODE_011    379E
LSD_MEM_MODE_100    37A8
LSD_MEM_MODE_101    37B2
LSD_MEM_MODE_110    37BC
LSD_MEM_MODE_111    37C6
LSD_REG             3702
LSD_REG_COUNT       3730
LSD_REG_END         3730
LSD_REG_REG         3726
LSLCODE00           1A48
LSLCODE01           1A50
LSLCODE10           1A58
LSLCODE11           1A60
LSL_LSR             1B4A
LSL_LSRCODE0        1B74
LSL_LSRCODE1        1B7A
LSRCODE00           19F2
LSRCODE01           19FA
LSRCODE10           1A02
LSRCODE11           1A0A
LT                  1278
MESSAGEADDAL        15F6
MESSAGEADDAW        15ED
MESSAGEADDB         15D5
MESSAGEADDIB        1529
MESSAGEADDIL        1520
MESSAGEADDIW        1517
MESSAGEADDL         15E5
MESSAGEADDQB        158A
MESSAGEADDQL        159C
MESSAGEADDQW        1593
MESSAGEADDW         15DD
MESSAGEANDB         1609
MESSAGEANDL         1619
MESSAGEANDW         1611
MESSAGEASLB         1642
MESSAGEASLL         1652
MESSAGEASLW         164A
MESSAGEASRB         162A
MESSAGEASRL         163A
MESSAGEASRW         1632
MESSAGEBCC          16D8
MESSAGEBGT          16DE
MESSAGEBLE          16E4
MESSAGECLR          1560
MESSAGECLRB         1572
MESSAGECLRL         1582
MESSAGECLRW         157A
MESSAGECMPB         15A5
MESSAGECMPL         15B5
MESSAGECMPW         15AD
MESSAGEDIVUW        16CF
MESSAGEJSR          155A
MESSAGELEA          156C
MESSAGELSLB         16A2
MESSAGELSLL         16B2
MESSAGELSLW         16AA
MESSAGELSRB         168A
MESSAGELSRL         169A
MESSAGELSRW         1692
MESSAGEMOVEAL       1532
MESSAGEMOVEAW       153C
MESSAGEMOVEB        150E
MESSAGEMOVEL        1505
MESSAGEMOVEML       1546
MESSAGEMOVEMW       1550
MESSAGEMOVEQL       15FF
MESSAGEMOVEW        14FC
MESSAGEMULSW        1621
MESSAGENOP          14F6
MESSAGEOPCODE_INVALID  16EA
MESSAGEORB          16BA
MESSAGEORL          16C8
MESSAGEORW          16C1
MESSAGEROLB         1672
MESSAGEROLL         1682
MESSAGEROLW         167A
MESSAGERORB         165A
MESSAGERORL         166A
MESSAGERORW         1662
MESSAGERTS          1566
MESSAGESUBB         15BD
MESSAGESUBL         15CD
MESSAGESUBW         15C5
MOD                 2
MOVEACODE001        21B6
MOVEAWCODE001       2244
MOVEA_ADJUST_L      3A0C
MOVEA_ADJUST_W      3A02
MOVEA_DESTINATION   3AE6
MOVEA_END           3AF6
MOVEA_LORMOVE_L     2160
MOVEA_SOURCE        3A16
MOVEA_SRC_ABS_L     3AD2
MOVEA_SRC_ABS_W     3AC8
MOVEA_SRC_IMM       3ADC
MOVEA_SRC_MODE      3A30
MOVEA_SRC_MODE_000  3A60
MOVEA_SRC_MODE_001  3A6A
MOVEA_SRC_MODE_010  3A74
MOVEA_SRC_MODE_011  3A7E
MOVEA_SRC_MODE_100  3A88
MOVEA_SRC_MODE_101  3A92
MOVEA_SRC_MODE_110  3A9C
MOVEA_SRC_MODE_111  3AA6
MOVEA_WORMOVE_W     21EE
MOVECODE000         21AE
MOVECODE010         21BE
MOVECODE011         21C6
MOVECODE100         21CE
MOVECODE101         21D6
MOVECODE110         21DE
MOVECODE111         21E6
MOVEMCODE0          1FFC
MOVEMCODE1          2004
MOVEQ_PRINT_DATA    3B38
MOVEWCODE000        223C
MOVEWCODE010        224C
MOVEWCODE011        2254
MOVEWCODE100        225C
MOVEWCODE101        2264
MOVEWCODE110        226C
MOVEWCODE111        2274
MOVE_ADJUST_L       3834
MOVE_ADJUST_W       382A
MOVE_DESTINATION    390E
MOVE_DST_ABS_L      39C2
MOVE_DST_ABS_W      39B8
MOVE_DST_MODE       3928
MOVE_DST_MODE_000   3958
MOVE_DST_MODE_001   3962
MOVE_DST_MODE_010   396C
MOVE_DST_MODE_011   3976
MOVE_DST_MODE_100   3980
MOVE_DST_MODE_101   398A
MOVE_DST_MODE_110   3994
MOVE_DST_MODE_111   399E
MOVE_END            39CC
MOVE_SOURCE         383E
MOVE_SRC_ABS_L      38FA
MOVE_SRC_ABS_W      38F0
MOVE_SRC_IMM        3904
MOVE_SRC_MODE       3858
MOVE_SRC_MODE_000   3888
MOVE_SRC_MODE_001   3892
MOVE_SRC_MODE_010   389C
MOVE_SRC_MODE_011   38A6
MOVE_SRC_MODE_100   38B0
MOVE_SRC_MODE_101   38BA
MOVE_SRC_MODE_110   38C4
MOVE_SRC_MODE_111   38CE
MULS_W_ABS_L        3C06
MULS_W_ABS_W        3BFC
MULS_W_DEST         3C1E
MULS_W_END          3C30
MULS_W_IMM          3C10
MULS_W_MODE         3B64
MULS_W_MODE_000     3B94
MULS_W_MODE_001     3B9E
MULS_W_MODE_010     3BA8
MULS_W_MODE_011     3BB2
MULS_W_MODE_100     3BBC
MULS_W_MODE_101     3BC6
MULS_W_MODE_110     3BD0
MULS_W_MODE_111     3BDA
NEW_LINE            12C2
NOPCOMMAND          1F4C
NOPORCLRORRTSORJSR  1EB2
NOP_MOVEM_LEA_JSR_CLR_RTS  200C
NOTDONE             40D6
NOTEVEN             12AA
OC_PARSE            1703
OPCODE_INVALID      227C
OR_ABS_L            3DB8
OR_ABS_W            3DAE
OR_BOROR_WOROR_LORDIVU  1882
OR_DIVUCODE000      18D0
OR_DIVUCODE001      18D8
OR_DIVUCODE010      18E0
OR_DIVUCODE011      18E8
OR_DIVUCODE100      18F0
OR_DIVUCODE101      18F8
OR_DIVUCODE110      1900
OR_DIVUCODE111      1908
OR_END              3DDC
OR_EVAL_EA          3D0C
OR_IMM              3DC2
OR_MODE             3D1A
OR_MODE_000         3D4A
OR_MODE_001         3D54
OR_MODE_010         3D66
OR_MODE_011         3D70
OR_MODE_1           3CD4
OR_MODE_100         3D7A
OR_MODE_101         3D84
OR_MODE_110         3D8A
OR_MODE_111         3D90
OR_MODE_2           3CF2
OR_MODE_END         3DD4
OR_MODE_INVALID     3DD6
OR_OPMODE           3C54
OR_OPMODE_000       3C84
OR_OPMODE_001       3C8E
OR_OPMODE_010       3C98
OR_OPMODE_011       3CA2
OR_OPMODE_100       3CAC
OR_OPMODE_101       3CB6
OR_OPMODE_110       3CC0
OR_OPMODE_111       3CCA
POSTINC_000         2A92
POSTINC_001         2A92
POSTINC_010         2A92
POSTINC_011         2A92
POSTINC_100         2A92
POSTINC_101         2A92
POSTINC_110         2A92
POSTINC_111         2A92
POSTINC_JMP         2A62
PREDEC_000          2AD2
PREDEC_001          2AD2
PREDEC_010          2AD2
PREDEC_011          2AD2
PREDEC_100          2AD2
PREDEC_101          2AD2
PREDEC_110          2AD2
PREDEC_111          2AD2
PREDEC_JMP          2AA2
PRINT_HEXVALUE      12B4
PRINT_IMM_END       2A50
PRINT_IMM_L         2A4C
PS1                 136C
PS2                 13B6
REMAINDER           5050
REPEAT              128C
RERUN               40AC
ROD_END             3EF0
ROD_LSD_ASD         1BB6
ROD_LSD_ASDCODE00   1BEC
ROD_LSD_ASDCODE01   1BF2
ROD_LSD_ASDCODE10   1BF8
ROD_LSD_ASDCODE11   1C00
ROD_MEM             3E3A
ROD_MEM_ABS_L       3EE6
ROD_MEM_ABS_W       3EDC
ROD_MEM_MODE        3E4C
ROD_MEM_MODE_000    3E7C
ROD_MEM_MODE_001    3E86
ROD_MEM_MODE_010    3E90
ROD_MEM_MODE_011    3E9A
ROD_MEM_MODE_100    3EA4
ROD_MEM_MODE_101    3EAE
ROD_MEM_MODE_110    3EB8
ROD_MEM_MODE_111    3EC2
ROD_REG             3DFE
ROD_REG_COUNT       3E2C
ROD_REG_END         3E2C
ROD_REG_REG         3E22
ROLCODE00           1A9E
ROLCODE01           1AA6
ROLCODE10           1AAE
ROLCODE11           1AB6
ROL_ROR             1B14
ROL_RORCODE0        1B3E
ROL_RORCODE1        1B44
RORCODE00           1AF4
RORCODE01           1AFC
RORCODE10           1B04
RORCODE11           1B0C
RTSCOMMAND          1F44
RUNAGAIN            6000
SHIFTLEFT           11FA
SOMEASL             1966
SOMEASR             1910
SOMECLR             1E5C
SOMELSL             1A12
SOMELSR             19BC
SOMEMOVEM           1FD2
SOMEROL             1A68
SOMEROR             1ABE
STACK               7000
START               4110
STR_LEN             5020
SUBCODE000          1D70
SUBCODE001          1D78
SUBCODE010          1D80
SUBCODE011          1D88
SUBCODE100          1D90
SUBCODE101          1D98
SUBCODE110          1DA0
SUBCODE111          1DA8
SUB_ABS_L           4078
SUB_ABS_W           406E
SUB_BORSUB_WORSUB_L  1D22
SUB_END             409C
SUB_EVAL_EA         3FC4
SUB_IMM             4082
SUB_MODE            3FD2
SUB_MODE_000        4002
SUB_MODE_001        4014
SUB_MODE_010        4026
SUB_MODE_011        4030
SUB_MODE_1          3F8C
SUB_MODE_100        403A
SUB_MODE_101        4044
SUB_MODE_110        404A
SUB_MODE_111        4050
SUB_MODE_2          3FAA
SUB_MODE_END        4094
SUB_MODE_INVALID    4096
SUB_OPMODE          3F0C
SUB_OPMODE_000      3F3C
SUB_OPMODE_001      3F46
SUB_OPMODE_010      3F50
SUB_OPMODE_011      3F5A
SUB_OPMODE_100      3F64
SUB_OPMODE_101      3F6E
SUB_OPMODE_110      3F78
SUB_OPMODE_111      3F82
TAB                 143F
TABLEADDI_BORADDI_WORADDI_L  2128
TABLEADDQ_BORADDQ_WORADDQ_L  1E24
TABLEADD_BORADD_WORADD_L  1CB2
TABLEAND_BORAND_WORAND_LORMULS_W  1C24
TABLEASL_ASR        1B9E
TABLEBCCORBGTORBLE  184A
TABLECMP_BORCMP_WORCMP_L  1DCE
TABLELSL_LSR        1B68
TABLEMOVEA_LORMOVE_L  217E
TABLEMOVEA_WORMOVE_W  220C
TABLENOPORCLRORRTSORJSR  1EE4
TABLENOP_MOVEM_LEA_JSR_CLR_RTS  2030
TABLEOR_BOROR_WOROR_LORDIVU  18A0
TABLEROD_LSD_ASD    1BD4
TABLEROL_ROR        1B32
TABLESOMEASL        1984
TABLESOMEASR        192E
TABLESOMECLR        1E7A
TABLESOMELSL        1A30
TABLESOMELSR        19DA
TABLESOMEMOVEM      1FF0
TABLESOMEROL        1A86
TABLESOMEROR        1ADC
TABLESUB_BORSUB_WORSUB_L  1D40
UPDATE_PTR          2910
UPYES               59
