000040C4 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/2/2016 11:43:13 AM

00000000                             1  ******************************************************************************
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Brandon Authier (Hblkr), Jack S. Eldridge
00000000                             4  *              (JackScottie), Marijn Burger (marijnburger)
00000000                             5  * Date       : 16 May 2016
00000000                             6  * Description: An inverse assembler that will convert a memory
00000000                             7  *              image of instructions and data back to the display.
00000000                             8  *              The following will be decoded:
00000000                             9  *
00000000                            10  *              Addressing Modes
00000000                            11  *
00000000                            12  *                Data Register Direct
00000000                            13  *                Address Register Direct
00000000                            14  *                Address Register Indirect
00000000                            15  *                Immediate Data
00000000                            16  *                Address Register Indirect with Post Increment
00000000                            17  *                Address Register Indirect with Pre Decrement
00000000                            18  *                Absolute Long Address
00000000                            19  *                Absolute Word Address
00000000                            20  *
00000000                            21  *              Instructions
00000000                            22  *
00000000                            23  *                NOP
00000000                            24  *                MOVE
00000000                            25  *                MOVEA
00000000                            26  *                MOVEQ
00000000                            27  *                MOVEM
00000000                            28  *                ADD
00000000                            29  *                ADDA
00000000                            30  *                ADDI
00000000                            31  *                ADDQ
00000000                            32  *                SUB
00000000                            33  *                MULS
00000000                            34  *                DIVU
00000000                            35  *                LEA
00000000                            36  *                CLR
00000000                            37  *                AND
00000000                            38  *                OR
00000000                            39  *                LSL
00000000                            40  *                LSR
00000000                            41  *                ASR
00000000                            42  *                ASL
00000000                            43  *                ROL
00000000                            44  *                ROR
00000000                            45  *                CMP
00000000                            46  *                Bcc (BCC, BGT, BLE)
00000000                            47  *                JSR
00000000                            48  *                RTS
00000000                            49  *
00000000                            50  ******************************************************************************
00000000                            51  
00000000                            52  ******************************************************************************
00000000                            53  *           DEFINITIONS                                                      *
00000000                            54  ******************************************************************************
00000000  =00007000                 55  STACK     EQU   $7000               * Beginning address for stack pointer
00000000                            56  
00000000  =00005000                 57  BEGINADDR EQU   $5000               * Variable to hold beginning address value
00000000  =00005010                 58  ENDADDR   EQU   $5010               * Variable to hold ending address value
00000000                            59  
00000000  =00006000                 60  RUNAGAIN  EQU   $6000               * Value equivalent to 'true'
00000000                            61  
00001000                            62            ORG   $1000               * Program begins at address 1000
00001000                            63            
00001000                            64  *********** END DEFINITIONS **************************************************
00001000                            65  
00001000                            66            
00001000                            67  ******************************************************************************
00001000                            68  *           INCLUDES                                                         *
00001000                            69  ******************************************************************************
00001000                            70  
00001000                            71      INCLUDE 'IO.X68'
00001000                            72  
00001000                            73  
00001000                            74  
00001000  =00005020                 75  STR_LEN   EQU   $5020
00001000  =00005021                 76  HEXFLAG   EQU   $5021
00001000  =00005030                 77  HEXVALUE  EQU   $5030
00001000  =00005050                 78  REMAINDER EQU   $5050
00001000  =00000002                 79  MOD       EQU   2
00001000                            80  
00001000  =0000000D                 81  CR        EQU   $0D
00001000  =0000000A                 82  LF        EQU   $0A 
00001000                            83  
00001000                            84  
00001000                            85  GET_ADDRESSES
00001000  4EB9 000012CE             86      JSR         CLEARSCRN
00001006  4EB9 000010C4             87      JSR         IO_WELCOME          * Run welcome subroutine
0000100C                            88              
0000100C                            89  GET_FIRST_ADDRESS
0000100C  43F9 00001314             90      LEA         PS1,A1              * Loads message into A1
00001012  4EB9 000010F2             91      JSR         GET_HEXSTRING       * Get string from user
00001018  0C38 0001 5021            92      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000101E  66EC                      93      BNE         GET_FIRST_ADDRESS   * If no, get hex again
00001020                            94     
00001020  4EB9 00001122             95      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001026  0C38 0001 5021            96      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000102C  66DE                      97      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000102E                            98      
0000102E  4EB9 0000127E             99      JSR         IS_HEX_EVEN         * Check that hex value is even
00001034  0C38 0001 5021           100      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000103A  66D0                     101      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000103C                           102     
0000103C  21F8 5030 5000           103      MOVE.L      HEXVALUE,BEGINADDR  * Copy hex value to begin
00001042  43F9 000013A6            104      LEA         BMESSAGE,A1         * Load message in A1 for display
00001048  2238 5030                105      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display 
0000104C  4EB9 000012C0            106      JSR         NEW_LINE            * Space
00001052                           107      
00001052  4EB9 000010D8            108      JSR         CLEAR               * Clear values for next hex
00001058                           109      
00001058                           110  GET_SECOND_ADDRESS
00001058  43F9 0000135E            111      LEA         PS2,A1              * Loads message into A1
0000105E  4EB9 000010F2            112      JSR         GET_HEXSTRING       * Get string from user
00001064  0C38 0001 5021           113      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000106A  66EC                     114      BNE         GET_SECOND_ADDRESS  * If no, get hex again
0000106C                           115     
0000106C  4EB9 00001122            116      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001072  0C38 0001 5021           117      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001078  66DE                     118      BNE         GET_SECOND_ADDRESS  * If no, get hex again
0000107A                           119      
0000107A  4EB9 0000127E            120      JSR         IS_HEX_EVEN         * Check that hex value is even
00001080  0C38 0001 5021           121      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001086  66D0                     122      BNE         GET_SECOND_ADDRESS  * If no, get hex again
00001088                           123     
00001088  21F8 5030 5010           124      MOVE.L      HEXVALUE,ENDADDR    * Copy hex value to begin
0000108E  43F9 000013C5            125      LEA         EMESSAGE,A1         * Load message in A1 for display
00001094  2238 5030                126      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display
00001098  4EB9 000012C0            127      JSR         NEW_LINE            * Space
0000109E                           128      
0000109E  4EB9 000010D8            129      JSR         CLEAR               * Clear values for next hex
000010A4                           130      
000010A4                           131  CHECK_BADDR_IS_LESS_THAN_EADDR
000010A4  4EB9 0000125E            132      JSR         IS_LESSTHAN         *
000010AA  0C38 0001 5021           133      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000010B0  6700 0010                134      BEQ         FINISHED            * If yes, finished
000010B4  43F9 000013E7            135      LEA         ADR_ERR_NOTLT,A1    * Else, load error message
000010BA  6100 021E                136      BSR.W       ADDRESS_ERR
000010BE  6100 3004                137      BSR.W       START      
000010C2                           138  
000010C2                           139  
000010C2                           140  FINISHED
000010C2  4E75                     141      RTS                             * Return to Disassembler
000010C4                           142      
000010C4                           143         
000010C4                           144             
000010C4                           145             
000010C4                           146  
000010C4                           147  IO_WELCOME: 
000010C4  43F9 000012EC            148      LEA         INTRO,A1            * Loads message into A1
000010CA  103C 000E                149      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010CE  4E4F                     150      TRAP        #15                 * Displays Intro Message 
000010D0                           151        
000010D0  4EB9 000012C0            152      JSR         NEW_LINE            * Call Subroutine        
000010D6  4E75                     153      RTS                             * Return from subroutine
000010D8                           154          
000010D8                           155  
000010D8                           156  
000010D8                           157  CLEAR
000010D8  4286                     158      CLR.L       D6                   * Clear
000010DA  31FC FFFF 5020           159      MOVE.W      #$FFFF,STR_LEN       * Clear   
000010E0  21FC FFFFFFFF 5030       160      MOVE.L      #$FFFFFFFF,HEXVALUE  * Clear  
000010E8  21FC FFFFFFFF 5050       161      MOVE.L      #$FFFFFFFF,REMAINDER * Clear
000010F0  4E75                     162      RTS                              * Return to main to get hex
000010F2                           163  
000010F2                           164  
000010F2                           165          
000010F2                           166  GET_HEXSTRING
000010F2  103C 000E                167      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010F6  323C 004A                168      MOVE.W      #(PS2-PS1),D1       * The prompt string length
000010FA  4E4F                     169      TRAP        #15                 * Displays contents of A1
000010FC                           170   
000010FC  43F9 00001442            171      LEA         HEXSTRING,A1        * Pointer to store the sentence
00001102  103C 0002                172      MOVE.B      #2,D0               * Set up readstring function
00001106  4E4F                     173      TRAP        #15                 * Get string from keyboard
00001108  11C1 5020                174      MOVE.B      D1,STR_LEN          * Save length of input string
0000110C                           175      
0000110C  0C38 0008 5020           176      CMPI.B      #8,(STR_LEN)        * Is length > 8?
00001112  6EDE                     177      BGT         GET_HEXSTRING       * If yes, get hex again
00001114                           178         
00001114  41F9 00001442            179      LEA         HEXSTRING,A0        * Load address for verification     
0000111A  11FC 0001 5021           180      MOVE.B      #1,(HEXFLAG)   
00001120  4E75                     181      RTS                             * Return from subroutine
00001122                           182          
00001122                           183  
00001122                           184  
00001122                           185  ASCII_TO_HEX      
00001122  1618                     186      MOVE.B      (A0)+,D3            * Move first char into D3    
00001124  0C03 0030                187      CMPI.B      #'0',D3             * Is Char equal to 0?
00001128  6700 00D4                188      BEQ         HEXZERO            
0000112C  0C03 0031                189      CMPI.B      #'1',D3             * Is Char equal to 1?
00001130  6700 00D4                190      BEQ         HEXONE                   
00001134  0C03 0032                191      CMPI.B      #'2',D3             * Is Char equal to 2?
00001138  6700 00D0                192      BEQ         HEXTWO    
0000113C  0C03 0033                193      CMPI.B      #'3',D3             * Is Char equal to 3?
00001140  6700 00CC                194      BEQ         HEXTHREE    
00001144  0C03 0034                195      CMPI.B      #'4',D3             * Is Char equal to 4?
00001148  6700 00C8                196      BEQ         HEXFOUR    
0000114C  0C03 0035                197      CMPI.B      #'5',D3             * Is Char equal to 5?
00001150  6700 00C4                198      BEQ         HEXFIVE    
00001154  0C03 0036                199      CMPI.B      #'6',D3             * Is Char equal to 6?
00001158  6700 00C0                200      BEQ         HEXSIX
0000115C  0C03 0037                201      CMPI.B      #'7',D3             * Is Char equal to 7?
00001160  6700 00BC                202      BEQ         HEXSEVEN
00001164  0C03 0038                203      CMPI.B      #'8',D3             * Is Char equal to 8?
00001168  6700 00B8                204      BEQ         HEXEIGHT
0000116C  0C03 0039                205      CMPI.B      #'9',D3             * Is Char equal to 9?
00001170  6700 00B4                206      BEQ         HEXNINE
00001174  0C03 0041                207      CMPI.B      #'A',D3             * Is Char equal to A?
00001178  6700 00B4                208      BEQ         HEXA                      
0000117C  0C03 0042                209      CMPI.B      #'B',D3             * Is Char equal to B?
00001180  6700 00B4                210      BEQ         HEXB
00001184  0C03 0043                211      CMPI.B      #'C',D3             * Is Char equal to C?
00001188  6700 00B4                212      BEQ         HEXC
0000118C  0C03 0044                213      CMPI.B      #'D',D3             * Is Char equal to D?
00001190  6700 00B4                214      BEQ         HEXD
00001194  0C03 0045                215      CMPI.B      #'E',D3             * Is Char equal to E?
00001198  6700 00B4                216      BEQ         HEXE
0000119C  0C03 0046                217      CMPI.B      #'F',D3             * Is Char equal to F?
000011A0  6700 00B4                218      BEQ         HEXF
000011A4  0C03 0061                219      CMPI.B      #'a',D3             * Is Char equal to a?
000011A8  6700 0084                220      BEQ         HEXA
000011AC  0C03 0062                221      CMPI.B      #'b',D3             * Is Char equal to b?
000011B0  6700 0084                222      BEQ         HEXB
000011B4  0C03 0063                223      CMPI.B      #'c',D3             * Is Char equal to c?
000011B8  6700 0084                224      BEQ         HEXC
000011BC  0C03 0064                225      CMPI.B      #'d',D3             * Is Char equal to d?
000011C0  6700 0084                226      BEQ         HEXD
000011C4  0C03 0065                227      CMPI.B      #'e',D3             * Is Char equal to e?
000011C8  6700 0084                228      BEQ         HEXE
000011CC  0C03 0066                229      CMPI.B      #'f',D3             * Is Char equal to f?
000011D0  6700 0084                230      BEQ         HEXF
000011D4                           231      
000011D4  11FC 0000 5021           232      MOVE.B      #0,HEXFLAG          * Set false    
000011DA  6000 FEFC                233      BRA         CLEAR               * Clear some values
000011DE                           234      
000011DE                           235  FOUND  
000011DE  5338 5020                236      SUBI.B      #1,STR_LEN          * Decrease string by one
000011E2  0C38 0000 5020           237      CMPI.B      #0,STR_LEN          * Is string = 0?
000011E8  6600 000E                238      BNE         SHIFTLEFT           * If no, shift value left 
000011EC  21C6 5030                239      MOVE.L      D6,HEXVALUE         * If yes, save hex value
000011F0  11FC 0001 5021           240      MOVE.B      #1,HEXFLAG          * Set true
000011F6  4E75                     241      RTS                             * Then, return to main
000011F8                           242  
000011F8                           243  SHIFTLEFT
000011F8  E98E                     244      LSL.L       #4,D6               * Shift the value left
000011FA  6000 FF26                245      BRA         ASCII_TO_HEX        * Check next char
000011FE                           246  
000011FE                           247  HEXZERO
000011FE  0686 00000000            248      ADD.L       #$0,D6              * Add value
00001204  60D8                     249      BRA         FOUND               * found, decrease strlen, shift value left    
00001206                           250  HEXONE
00001206  5286                     251      ADD.L       #$1,D6              * Add value
00001208  60D4                     252      BRA         FOUND               * found, decrease strlen, shift value left
0000120A                           253  HEXTWO
0000120A  5486                     254      ADD.L       #$2,D6              * Add value
0000120C  60D0                     255      BRA         FOUND               * found, decrease strlen, shift value left
0000120E                           256  HEXTHREE
0000120E  5686                     257      ADD.L       #$3,D6              * Add value
00001210  60CC                     258      BRA         FOUND               * found, decrease strlen, shift value left
00001212                           259  HEXFOUR
00001212  5886                     260      ADD.L       #$4,D6              * Add value
00001214  60C8                     261      BRA         FOUND               * found, decrease strlen, shift value left
00001216                           262  HEXFIVE
00001216  5A86                     263      ADD.L       #$5,D6              * Add value
00001218  60C4                     264      BRA         FOUND               * found, decrease strlen, shift value left
0000121A                           265  HEXSIX
0000121A  5C86                     266      ADD.L       #$6,D6              * Add value
0000121C  60C0                     267      BRA         FOUND               * found, decrease strlen, shift value left
0000121E                           268  HEXSEVEN
0000121E  5E86                     269      ADD.L       #$7,D6              * Add value
00001220  60BC                     270      BRA         FOUND               * found, decrease strlen, shift value left
00001222                           271  HEXEIGHT
00001222  5086                     272      ADD.L       #$8,D6              * Add value
00001224  60B8                     273      BRA         FOUND               * found, decrease strlen, shift value left
00001226                           274  HEXNINE
00001226  0686 00000009            275      ADD.L       #$9,D6              * Add value
0000122C  60B0                     276      BRA         FOUND               * found, decrease strlen, shift value left
0000122E                           277  HEXA
0000122E  0686 0000000A            278      ADD.L       #$A,D6              * Add value
00001234  60A8                     279      BRA         FOUND               * found, decrease strlen, shift value left    
00001236                           280  HEXB
00001236  0686 0000000B            281      ADD.L       #$B,D6              * Add value
0000123C  60A0                     282      BRA         FOUND               * found, decrease strlen, shift value left
0000123E                           283  HEXC
0000123E  0686 0000000C            284      ADD.L       #$C,D6              * Add value
00001244  6098                     285      BRA         FOUND               * found, decrease strlen, shift value left
00001246                           286  HEXD
00001246  0686 0000000D            287      ADD.L       #$D,D6              * Add value
0000124C  6090                     288      BRA         FOUND               * found, decrease strlen, shift value left
0000124E                           289  HEXE
0000124E  0686 0000000E            290      ADD.L       #$E,D6              * Add value
00001254  6088                     291      BRA         FOUND               * found, decrease strlen, shift value left
00001256                           292  HEXF
00001256  0686 0000000F            293      ADD.L       #$F,D6              * Add value
0000125C  6080                     294      BRA         FOUND               * found, decrease strlen, shift value left 
0000125E                           295     
0000125E                           296  
0000125E                           297  
0000125E                           298  IS_LESSTHAN
0000125E  2838 5000                299      MOVE.L      BEGINADDR,D4        * Store beginning address in D4
00001262  2C38 5010                300      MOVE.L      ENDADDR,D6          * Store ending address in D6
00001266  B886                     301      CMP.L       D6,D4               * Is D4 < D6
00001268  6D00 000C                302      BLT         LT                  * Yes, mark true return to main
0000126C  11FC 0000 5021           303      MOVE.B      #0,HEXFLAG          * No, mark false
00001272  6000 FE64                304      BRA         CLEAR               * Clear values, return to main
00001276                           305  
00001276                           306  LT
00001276  11FC 0001 5021           307      MOVE.B      #1,HEXFLAG          * Mark true
0000127C  4E75                     308      RTS                             * Return to main
0000127E                           309  
0000127E                           310  
0000127E                           311  
0000127E                           312  IS_HEX_EVEN      
0000127E  3606                     313      MOVE.W      D6,D3               * Move value to be modded into D3
00001280  3A3C 0002                314      MOVE.W      #MOD,D5             * Move mod value into D5
00001284  86C5                     315      DIVU        D5,D3               * Divide D3 by D5
00001286  123C 0003                316      MOVE.B      #3,D1               * Set counter to shift value into word 
0000128A                           317                                      * position    
0000128A                           318  REPEAT 
0000128A  E88B                     319      LSR.L       #4,D3               * Shift remainder to lower word
0000128C  57C9 FFFC                320      DBEQ        D1,REPEAT           * UNTIL [D0] = - 1
00001290  4241                     321      CLR         D1                  * Clear
00001292                           322      
00001292  B6BC 00000000            323      CMP.L       #0,D3               * Is hex even?
00001298  6600 000E                324      BNE         NOTEVEN             * No, clear and go back to get_hex
0000129C  31C3 5050                325      MOVE.W      D3,REMAINDER        * Save remainder
000012A0  11FC 0001 5021           326      MOVE.B      #1,HEXFLAG          * Set true
000012A6  4E75                     327      RTS                             * Return to main
000012A8                           328  
000012A8                           329  NOTEVEN
000012A8  11FC 0000 5021           330      MOVE.B      #0,HEXFLAG          * Set false
000012AE  6000 FE28                331      BRA         CLEAR               * Clear values
000012B2                           332  
000012B2                           333  
000012B2                           334  
000012B2                           335  PRINT_HEXVALUE
000012B2  103C 000E                336      MOVE.B      #14,D0              * Moves the Task 14 into D0
000012B6  4E4F                     337      TRAP        #15                 * Displays contents of A1
000012B8                           338      
000012B8                           339      
000012B8  103C 0003                340      MOVE.B      #3,D0               * Moves the Task 3 into D0
000012BC  4E4F                     341      TRAP        #15                 * Displays contents of D1
000012BE                           342      
000012BE  4E75                     343      RTS                             * Return from subroutine                                  
000012C0                           344  
000012C0                           345  
000012C0                           346  NEW_LINE
000012C0  43F9 000013E4            347      LEA         ENDL,A1             * Loads message into A1
000012C6  103C 000E                348      MOVE.B      #14,D0              * Moves the TRACK 14 into D0
000012CA  4E4F                     349      TRAP        #15                 * Displays New line
000012CC  4E75                     350      RTS                             * Return from subroutine
000012CE                           351  
000012CE                           352  
000012CE                           353  CLEARSCRN     
000012CE  103C 000B                354      MOVE.B      #11,D0              * Task 11 for clearing screen
000012D2  323C FF00                355      MOVE.W      #$FF00,D1           * FF00, Clear screen
000012D6  4E4F                     356      TRAP        #15                 * Wait for keystroke
000012D8  4E75                     357      RTS                             * Return from subroutine
000012DA                           358  
000012DA                           359  
000012DA                           360  
000012DA                           361  
000012DA                           362  ADDRESS_ERR
000012DA  6100 FFF2                363      BSR.W       CLEARSCRN           * Clear output before displaying error
000012DE  103C 000D                364      MOVE.B      #13,D0              * Moves the Task 13 into D0
000012E2  4E4F                     365      TRAP        #15                 * Displays contents of A1
000012E4  103C 0005                366      MOVE.B      #5,D0               * Read single character from 
000012E8  4E4F                     367      TRAP        #15                 * The keyboard into D1.B
000012EA  4E75                     368      RTS                             * Return from subroutine
000012EC                           369  
000012EC                           370  
000012EC                           371  
000012EC                           372  
000012EC= 57 45 4C 43 4F 4D ...    373  INTRO           DC.B 'WELCOME!',CR,LF,'THIS IS A 68K DISASSEMBLER.',CR,LF,0
00001314= 50 4C 45 41 53 45 ...    374  PS1             DC.B 'PLEASE ENTER THE STARTING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
0000135E= 50 4C 45 41 53 45 ...    375  PS2             DC.B 'PLEASE ENTER THE ENDING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000013A6= 0D 0A 42 45 47 49 ...    376  BMESSAGE        DC.B CR,LF,'BEGINNING ADDRESS GIVEN IS: ',0
000013C5= 0D 0A 45 4E 44 49 ...    377  EMESSAGE        DC.B CR,LF,'ENDING ADDRESS GIVEN IS   : ',0
000013E4= 0D 0A 00                 378  ENDL            DC.B CR,LF,0
000013E7                           379  
000013E7= 54 48 45 20 42 45 ...    380  ADR_ERR_NOTLT   DC.B 'THE BEGINNING ADDRESS MUST BE LESS THAN THE ENDING ADDRESS.',CR,LF,'PRESS ANY KEY TO TRY AGAIN...',0
00001442                           381  
00001442                           382  HEXSTRING       DS.B 80             * Var for hex string
00001492                           383  
00001492= 31 30 30 30 20 20 ...    384  ILLEGAL         DC.B '1000    DATA    $WXYZ',CR,LF,0
000014AA                           385  
000014AA                           386  
000014AA                           387  
000014AA                           388  
000014AA                           389  
000014AA                           390  
000014AA                           391  
000014AA                           392  
000014AA                           393  -------------------- end include --------------------
000014AA                           394      INCLUDE 'OpCodes.X68'
000014AA                           395  
000014AA                           396          INCLUDE 'OCMessages.X68'
000014AA                           397  
000014AA                           398  
000014AA  =0000000D                399  CR      EQU     $0D
000014AA  =0000000A                400  LF      EQU     $0A
000014AA= 4E 4F 50 0D 0A 00        401  MESSAGENOP DC.B    'NOP',CR,LF, 0
000014B0                           402  
000014B0= 4D 4F 56 45 2E 57 ...    403  MESSAGEMOVEW DC.B    'MOVE.W',CR,LF, 0
000014B9= 4D 4F 56 45 2E 4C ...    404  MESSAGEMOVEL DC.B    'MOVE.L',CR,LF, 0
000014C2= 4D 4F 56 45 2E 42 ...    405  MESSAGEMOVEB DC.B    'MOVE.B',CR,LF, 0
000014CB                           406  
000014CB= 41 44 44 49 2E 57 ...    407  MESSAGEADDIW DC.B    'ADDI.W',CR,LF, 0
000014D4= 41 44 44 49 2E 4C ...    408  MESSAGEADDIL DC.B    'ADDI.L',CR,LF, 0
000014DD= 41 44 44 49 2E 42 ...    409  MESSAGEADDIB DC.B    'ADDI.B',CR,LF, 0
000014E6                           410  
000014E6= 4D 4F 56 45 41 2E ...    411  MESSAGEMOVEAL DC.B    'MOVEA.L',CR,LF, 0
000014F0= 4D 4F 56 45 41 2E ...    412  MESSAGEMOVEAW DC.B    'MOVEA.W',CR,LF, 0
000014FA                           413  
000014FA= 4D 4F 56 45 4D 2E ...    414  MESSAGEMOVEML DC.B    'MOVEM.L',CR,LF, 0
00001504= 4D 4F 56 45 4D 2E ...    415  MESSAGEMOVEMW DC.B    'MOVEM.W',CR,LF, 0
0000150E                           416  
0000150E= 4A 53 52 0D 0A 00        417  MESSAGEJSR DC.B    'JSR',CR,LF, 0
00001514                           418  
00001514= 43 4C 52 0D 0A 00        419  MESSAGECLR DC.B    'CLR',CR,LF, 0
0000151A                           420  
0000151A= 52 54 53 0D 0A 00        421  MESSAGERTS DC.B    'RTS',CR,LF, 0
00001520                           422  
00001520= 4C 45 41 0D 0A 00        423  MESSAGELEA DC.B    'LEA',CR,LF, 0
00001526                           424  
00001526= 43 4C 52 2E 42 0D ...    425  MESSAGECLRB DC.B    'CLR.B',CR,LF, 0
0000152E= 43 4C 52 2E 57 0D ...    426  MESSAGECLRW DC.B    'CLR.W',CR,LF, 0
00001536= 43 4C 52 2E 4C 0D ...    427  MESSAGECLRL DC.B    'CLR.L',CR,LF, 0
0000153E                           428  
0000153E= 41 44 44 51 2E 42 ...    429  MESSAGEADDQB DC.B    'ADDQ.B',CR,LF, 0
00001547= 41 44 44 51 2E 57 ...    430  MESSAGEADDQW DC.B    'ADDQ.W',CR,LF, 0
00001550= 41 44 44 51 2E 4C ...    431  MESSAGEADDQL DC.B    'ADDQ.L',CR,LF, 0
00001559                           432  
00001559= 43 4D 50 2E 42 0D ...    433  MESSAGECMPB DC.B    'CMP.B',CR,LF, 0
00001561= 43 4D 50 2E 57 0D ...    434  MESSAGECMPW DC.B    'CMP.W',CR,LF, 0
00001569= 43 4D 50 2E 4C 0D ...    435  MESSAGECMPL DC.B    'CMP.L',CR,LF, 0
00001571                           436  
00001571= 53 55 42 2E 42 0D ...    437  MESSAGESUBB DC.B    'SUB.B',CR,LF, 0
00001579= 53 55 42 2E 57 0D ...    438  MESSAGESUBW DC.B    'SUB.W',CR,LF, 0
00001581= 53 55 42 2E 4C 0D ...    439  MESSAGESUBL DC.B    'SUB.L',CR,LF, 0
00001589                           440  
00001589= 41 44 44 2E 42 0D ...    441  MESSAGEADDB DC.B    'ADD.B',CR,LF, 0
00001591= 41 44 44 2E 57 0D ...    442  MESSAGEADDW DC.B    'ADD.W',CR,LF, 0
00001599= 41 44 44 2E 4C 0D ...    443  MESSAGEADDL DC.B    'ADD.L',CR,LF, 0
000015A1                           444  
000015A1= 41 44 44 41 2E 57 ...    445  MESSAGEADDAW DC.B    'ADDA.W',CR,LF, 0
000015AA= 41 44 44 41 2E 4C ...    446  MESSAGEADDAL DC.B    'ADDA.L',CR,LF, 0
000015B3                           447  
000015B3= 4D 4F 56 45 51 2E ...    448  MESSAGEMOVEQL DC.B    'MOVEQ.L',CR,LF, 0
000015BD                           449  
000015BD= 41 4E 44 2E 42 0D ...    450  MESSAGEANDB DC.B    'AND.B',CR,LF, 0
000015C5= 41 4E 44 2E 57 0D ...    451  MESSAGEANDW DC.B    'AND.W',CR,LF, 0
000015CD= 41 4E 44 2E 4C 0D ...    452  MESSAGEANDL DC.B    'AND.L',CR,LF, 0
000015D5                           453  
000015D5= 4D 55 4C 53 2E 57 ...    454  MESSAGEMULSW DC.B    'MULS.W',CR,LF, 0
000015DE                           455  
000015DE= 41 53 52 2E 42 0D ...    456  MESSAGEASRB DC.B    'ASR.B',CR,LF, 0
000015E6= 41 53 52 2E 57 0D ...    457  MESSAGEASRW DC.B    'ASR.W',CR,LF, 0
000015EE= 41 53 52 2E 4C 0D ...    458  MESSAGEASRL DC.B    'ASR.L',CR,LF, 0
000015F6                           459  
000015F6= 41 53 4C 2E 42 0D ...    460  MESSAGEASLB DC.B    'ASL.B',CR,LF, 0
000015FE= 41 53 4C 2E 57 0D ...    461  MESSAGEASLW DC.B    'ASL.W',CR,LF, 0
00001606= 41 53 4C 2E 4C 0D ...    462  MESSAGEASLL DC.B    'ASL.L',CR,LF, 0
0000160E                           463  
0000160E= 52 4F 52 2E 42 0D ...    464  MESSAGERORB DC.B    'ROR.B',CR,LF, 0
00001616= 52 4F 52 2E 57 0D ...    465  MESSAGERORW DC.B    'ROR.W',CR,LF, 0
0000161E= 52 4F 52 2E 4C 0D ...    466  MESSAGERORL DC.B    'ROR.L',CR,LF, 0
00001626                           467  
00001626= 52 4F 4C 2E 42 0D ...    468  MESSAGEROLB DC.B    'ROL.B',CR,LF, 0
0000162E= 52 4F 4C 2E 57 0D ...    469  MESSAGEROLW DC.B    'ROL.W',CR,LF, 0
00001636= 52 4F 4C 2E 4C 0D ...    470  MESSAGEROLL DC.B    'ROL.L',CR,LF, 0
0000163E                           471  
0000163E= 4C 53 52 2E 42 0D ...    472  MESSAGELSRB DC.B    'LSR.B',CR,LF, 0
00001646= 4C 53 52 2E 57 0D ...    473  MESSAGELSRW DC.B    'LSR.W',CR,LF, 0
0000164E= 4C 53 52 2E 4C 0D ...    474  MESSAGELSRL DC.B    'LSR.L',CR,LF, 0
00001656                           475  
00001656= 4C 53 4C 2E 42 0D ...    476  MESSAGELSLB DC.B    'LSL.B',CR,LF, 0
0000165E= 4C 53 4C 2E 57 0D ...    477  MESSAGELSLW DC.B    'LSL.W',CR,LF, 0
00001666= 4C 53 4C 2E 4C 0D ...    478  MESSAGELSLL DC.B    'LSL.L',CR,LF, 0
0000166E                           479  
0000166E= 4F 52 2E 42 0D 0A 00     480  MESSAGEORB DC.B    'OR.B',CR,LF, 0
00001675= 4F 52 2E 57 0D 0A 00     481  MESSAGEORW DC.B    'OR.W',CR,LF, 0
0000167C= 4F 52 2E 4C 0D 0A 00     482  MESSAGEORL DC.B    'OR.L',CR,LF, 0
00001683                           483  
00001683= 44 49 56 55 2E 57 ...    484  MESSAGEDIVUW DC.B    'DIVU.W',CR,LF, 0
0000168C                           485  
0000168C= 42 43 43 0D 0A 00        486  MESSAGEBCC DC.B    'BCC',CR,LF, 0
00001692= 42 47 54 0D 0A 00        487  MESSAGEBGT DC.B    'BGT',CR,LF, 0
00001698= 42 4C 45 0D 0A 00        488  MESSAGEBLE DC.B    'BLE',CR,LF, 0
0000169E                           489  
0000169E= 54 68 61 74 20 69 ...    490  MESSAGEOPCODE_INVALID DC.B    'That is not an opcode!',CR,LF, 0
000016B7                           491  
000016B7                           492  
000016B7                           493  
000016B7                           494  
000016B7                           495  -------------------- end include --------------------
000016B7                           496  
000016B7                           497  
000016B7                           498  OC_PARSE:
000016B8  48E7 FFFE                499          MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000016BC  41F9 000016D4            500          LEA         initial_table,A0 ; Index into the table
000016C2  4280                     501          CLR.L       D0              ; Zero it
000016C4  3012                     502          MOVE.W      (A2),D0         ; We'll play with it here
000016C6  123C 000C                503          MOVE.B      #12,D1          ; Shift 12 bits to the right
000016CA  E268                     504          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000016CC                           505                                      ; and the rest are zeroed out)
000016CC  C0FC 0006                506          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000016D0  4EF0 0000                507          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000016D4                           508  
000016D4                           509  initial_table:
000016D4  4EF9 00001734            510          JMP         code0000        ; ADDI.B, ADDI.W, or ADDI.L
000016DA  4EF9 0000173A            511          JMP         code0001        ; MOVE.B
000016E0  4EF9 00001746            512          JMP         code0010        ; MOVEA.L or MOVE.L
000016E6  4EF9 0000174C            513          JMP         code0011        ; MOVEA.W or MOVE.W
000016EC  4EF9 00001752            514          JMP         code0100        ; NOP or MOVEM.W or MOVEM.L or LEA or CLR.B or CLR.W or CLR.L or JSR or RTS or MULS.W
000016F2  4EF9 0000175E            515          JMP         code0101        ; ADDQ.B or ADDQ.W or ADDQ.L
000016F8  4EF9 0000176A            516          JMP         code0110        ; BCC or BGT or BLE
000016FE  4EF9 00001776            517          JMP         code0111        ; MOVEQ.L
00001704  4EF9 00001782            518          JMP         code1000        ; OR.B or OR.W or OR.L or DIVU (DIVU is either word or long depending on ea)
0000170A  4EF9 0000178E            519          JMP         code1001        ; SUB.B or SUB.W or SUB.L
00001710  4EF9 0000179A            520          JMP         code1010
00001716  4EF9 000017A2            521          JMP         code1011        ; CMP.B or CMP.W or CMP.L
0000171C  4EF9 000017AE            522          JMP         code1100        ; AND_BorAND_WorAND_LorMULS_W
00001722  4EF9 000017BA            523          JMP         code1101        ; ADD.B or ADD.W or ADD.L
00001728  4EF9 000017C6            524          JMP         code1110        ; ROd_LSd_ASd
0000172E  4EF9 000017D2            525          JMP         code1111
00001734                           526  
00001734  4EB9 000020BE            527  code0000 JSR        ADDI_BorADDI_WorADDI_L
0000173A  4EB9 00002820            528  code0001 JSR        ISMOVEB
00001740  4EB9 000017DA            529           JSR        DONE
00001746  4EB9 00002114            530  code0010 JSR        MOVEA_LorMOVE_L
0000174C  4EB9 000021A2            531  code0011 JSR        MOVEA_WorMOVE_W
00001752  4EB9 00001FC0            532  code0100 JSR        NOP_MOVEM_LEA_JSR_CLR_RTS
00001758  4EB9 000017DA            533           JSR        DONE
0000175E  4EB9 00001DBA            534  code0101 JSR        ADDQ_BorADDQ_WorADDQ_L
00001764  4EB9 000017DA            535           JSR        DONE
0000176A  4EB9 000017E0            536  code0110 JSR        BCCorBGTorBLE
00001770  4EB9 000017DA            537           JSR        DONE
00001776  4EB9 000026A2            538  code0111 JSR        ISMOVEQL
0000177C  4EB9 000017DA            539           JSR        DONE
00001782  4EB9 00001836            540  code1000 JSR        OR_BorOR_WorOR_LorDIVU
00001788  4EB9 000017DA            541           JSR        DONE
0000178E  4EB9 00001CD6            542  code1001 JSR        SUB_BorSUB_WorSUB_L
00001794  4EB9 000017DA            543           JSR        DONE
0000179A  4EB9 00002230            544  code1010 JSR    OPCODE_INVALID              ;INVALID
000017A0  4E75                     545           RTS
000017A2  4EB9 00001D64            546  code1011 JSR        CMP_BorCMP_WorCMP_L
000017A8  4EB9 000017DA            547           JSR        DONE
000017AE  4EB9 00001BBA            548  code1100 JSR        AND_BorAND_WorAND_LorMULS_W
000017B4  4EB9 000017DA            549           JSR        DONE
000017BA  4EB9 00001C48            550  code1101 JSR        ADD_BorADD_WorADD_L
000017C0  4EB9 000017DA            551           JSR        DONE
000017C6  4EB9 00001B6A            552  code1110 JSR        ROd_LSd_ASd
000017CC  4EB9 000017DA            553           JSR        DONE
000017D2  4EB9 00002230            554  code1111 JSR    OPCODE_INVALID              ;INVALID
000017D8  4E75                     555           RTS
000017DA  4CDF 7FFF                556  DONE    MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000017DE  4E75                     557          RTS
000017E0                           558  
000017E0  41F9 000017FE            559  BCCorBGTorBLE       LEA     tableBCCorBGTorBLE, A0            ; Index into the table
000017E6  4280                     560                      CLR.L   D0                  ; Zero it
000017E8  3016                     561                      MOVE.W  (A6),D0         ; We'll play with it here
000017EA  123C 0006                562                      MOVE.B  #6,D1           ; Shift 6 bits left
000017EE  E360                     563                      ASL.W   D1,D0
000017F0  123C 000E                564                      MOVE.B  #14,D1           ; Shift 14 bits to the right
000017F4  E268                     565                      LSR.W   D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
000017F6                           566                                      ; and the rest are zeroed out)
000017F6  C0FC 0006                567                      MULU    #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
000017FA  4EF0 0000                568                      JMP     0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
000017FE                           569  
000017FE  4EF9 00001816            570  tableBCCorBGTorBLE   JMP    BCCorBGTorBLEcode00   ; BCC
00001804  4EF9 0000181E            571                       JMP    BCCorBGTorBLEcode01   ;
0000180A  4EF9 00001826            572                       JMP    BCCorBGTorBLEcode10   ; BGT
00001810  4EF9 0000182E            573                       JMP    BCCorBGTorBLEcode11   ; BLE
00001816                           574  
00001816                           575  
00001816                           576  
00001816  4EB9 00002244            577  BCCorBGTorBLEcode00    JSR     ISBCC
0000181C  4E75                     578                         RTS
0000181E  4EB9 00002230            579  BCCorBGTorBLEcode01    JSR    OPCODE_INVALID              ;INVALID
00001824  4E75                     580                         RTS
00001826  4EB9 0000225E            581  BCCorBGTorBLEcode10    JSR     ISBGT
0000182C  4E75                     582                         RTS
0000182E  4EB9 00002278            583  BCCorBGTorBLEcode11    JSR     ISBLE
00001834  4E75                     584                         RTS
00001836                           585  
00001836                           586  
00001836                           587  OR_BorOR_WorOR_LorDIVU:
00001836  41F9 00001854            588          LEA         tableOR_BorOR_WorOR_LorDIVU, A0 ; Index into the table
0000183C  4280                     589          CLR.L       D0              ; Zero it
0000183E  3016                     590          MOVE.W      (A6),D0     ; We'll play with it here
00001840  123C 0007                591          MOVE.B      #7,D1           ; Shift 7 bits left
00001844  E360                     592          ASL.W       D1,D0
00001846  123C 000D                593          MOVE.B      #13,D1          ; Shift 13 bits to the right
0000184A  E268                     594          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000184C                           595                                      ; and the rest are zeroed out)
0000184C  C0FC 0006                596          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001850  4EF0 0000                597          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001854                           598  
00001854                           599  tableOR_BorOR_WorOR_LorDIVU
00001854  4EF9 00001884            600          JMP         OR_DIVUcode000  ; OR.B
0000185A  4EF9 0000188C            601          JMP         OR_DIVUcode001  ; OR.W
00001860  4EF9 00001894            602          JMP         OR_DIVUcode010  ; OR.L
00001866  4EF9 0000189C            603          JMP         OR_DIVUcode011  ; DIVU.W
0000186C  4EF9 000018A4            604          JMP         OR_DIVUcode100  ; OR.B
00001872  4EF9 000018AC            605          JMP         OR_DIVUcode101  ; OR.W
00001878  4EF9 000018B4            606          JMP         OR_DIVUcode110  ; OR.L
0000187E  4EF9 000018BC            607          JMP         OR_DIVUcode111  ; INVALID
00001884                           608  
00001884                           609  
00001884  4EB9 000022AC            610  OR_DIVUcode000 JSR  ISORB
0000188A  4E75                     611                 RTS
0000188C  4EB9 000022C6            612  OR_DIVUcode001 JSR  ISORW
00001892  4E75                     613                 RTS
00001894  4EB9 000022E0            614  OR_DIVUcode010 JSR  ISORL
0000189A  4E75                     615                 RTS
0000189C  4EB9 00002292            616  OR_DIVUcode011 JSR  ISDIVUW
000018A2  4E75                     617                 RTS
000018A4  4EB9 000022AC            618  OR_DIVUcode100 JSR  ISORB
000018AA  4E75                     619                 RTS
000018AC  4EB9 000022C6            620  OR_DIVUcode101 JSR  ISORW
000018B2  4E75                     621                 RTS
000018B4  4EB9 000022E0            622  OR_DIVUcode110 JSR  ISORL
000018BA  4E75                     623                 RTS
000018BC  4EB9 00002230            624  OR_DIVUcode111 JSR    OPCODE_INVALID              ;INVALID
000018C2  4E75                     625                 RTS
000018C4                           626  
000018C4                           627  
000018C4                           628  someASR:
000018C4  41F9 000018E2            629          LEA         tableSomeASR, A0 ; Index into the table
000018CA  4280                     630          CLR.L       D0              ; Zero it
000018CC  3016                     631          MOVE.W      (A6),D0         ; We'll play with it here
000018CE  123C 0008                632          MOVE.B      #8,D1           ; Shift 8 bits left
000018D2  E360                     633          ASL.W       D1,D0
000018D4  123C 000E                634          MOVE.B      #14,D1          ; Shift 14 bits to the right
000018D8  E268                     635          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000018DA                           636                                      ; and the rest are zeroed out)
000018DA  C0FC 0006                637          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000018DE  4EF0 0000                638          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000018E2                           639  
000018E2                           640  tableSomeASR:
000018E2  4EF9 000018FA            641          JMP         ASRcode00       *ASR.B
000018E8  4EF9 00001902            642          JMP         ASRcode01       *ASR.W
000018EE  4EF9 0000190A            643          JMP         ASRcode10       *ASR.L
000018F4  4EF9 00001912            644          JMP         ASRcode11       *ASR.W
000018FA                           645  
000018FA  4EB9 000022FA            646  ASRcode00 JSR       ISASRB
00001900  4E75                     647            RTS
00001902  4EB9 00002314            648  ASRcode01 JSR       ISASRW
00001908  4E75                     649            RTS
0000190A  4EB9 0000232E            650  ASRcode10 JSR       ISASRL
00001910  4E75                     651            RTS
00001912  4EB9 00002314            652  ASRcode11 JSR       ISASRW
00001918  4E75                     653            RTS
0000191A                           654  
0000191A                           655  someASL:
0000191A  41F9 00001938            656          LEA         tableSomeASL, A0 ; Index into the table
00001920  4280                     657          CLR.L       D0              ; Zero it
00001922  3016                     658          MOVE.W      (A6),D0     ; We'll play with it here
00001924  123C 0008                659          MOVE.B      #8,D1           ; Shift 8 bits left
00001928  E360                     660          ASL.W       D1,D0
0000192A  123C 000E                661          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000192E  E268                     662          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001930                           663                                      ; and the rest are zeroed out)
00001930  C0FC 0006                664          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001934  4EF0 0000                665          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001938                           666  
00001938                           667  tableSomeASL:
00001938  4EF9 00001950            668          JMP         ASLcode00       *ASL.B
0000193E  4EF9 00001958            669          JMP         ASLcode01       *ASL.W
00001944  4EF9 00001960            670          JMP         ASLcode10       *ASL.L
0000194A  4EF9 00001968            671          JMP         ASLcode11       *ASL.W
00001950                           672  
00001950  4EB9 00002348            673  ASLcode00 JSR       ISASLB
00001956  4E75                     674            RTS
00001958  4EB9 00002362            675  ASLcode01 JSR       ISASLW
0000195E  4E75                     676            RTS
00001960  4EB9 0000237C            677  ASLcode10 JSR       ISASLL
00001966  4E75                     678            RTS
00001968  4EB9 00002362            679  ASLcode11 JSR       ISASLW
0000196E  4E75                     680            RTS
00001970                           681  
00001970                           682  someLSR:
00001970  41F9 0000198E            683          LEA         tableSomeLSR, A0 ; Index into the table
00001976  4280                     684          CLR.L       D0              ; Zero it
00001978  3016                     685          MOVE.W      (A6),D0     ; We'll play with it here
0000197A  123C 0008                686          MOVE.B      #8,D1           ; Shift 8 bits left
0000197E  E360                     687          ASL.W       D1,D0
00001980  123C 000E                688          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001984  E268                     689          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001986                           690                                      ; and the rest are zeroed out)
00001986  C0FC 0006                691          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000198A  4EF0 0000                692          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000198E                           693  
0000198E                           694  tableSomeLSR:
0000198E  4EF9 000019A6            695          JMP         LSRcode00       *LSR.B
00001994  4EF9 000019AE            696          JMP         LSRcode01       *LSR.W
0000199A  4EF9 000019B6            697          JMP         LSRcode10       *LSR.L
000019A0  4EF9 000019BE            698          JMP         LSRcode11       *LSR.W
000019A6  4EB9 00002396            699  LSRcode00 JSR       ISLSRB
000019AC  4E75                     700            RTS
000019AE  4EB9 000023B0            701  LSRcode01 JSR       ISLSRW
000019B4  4E75                     702            RTS
000019B6  4EB9 000023CA            703  LSRcode10 JSR       ISLSRL
000019BC  4E75                     704            RTS
000019BE  4EB9 000023B0            705  LSRcode11 JSR       ISLSRW
000019C4  4E75                     706            RTS
000019C6                           707  
000019C6                           708  someLSL:
000019C6  41F9 000019E4            709          LEA         tableSomeLSL, A0 ; Index into the table
000019CC  4280                     710          CLR.L       D0              ; Zero it
000019CE  3016                     711          MOVE.W      (A6),D0     ; We'll play with it here
000019D0  123C 0008                712          MOVE.B      #8,D1           ; Shift 8 bits left
000019D4  E360                     713          ASL.W       D1,D0
000019D6  123C 000E                714          MOVE.B      #14,D1          ; Shift 14 bits to the right
000019DA  E268                     715          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000019DC                           716                                      ; and the rest are zeroed out)
000019DC  C0FC 0006                717          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000019E0  4EF0 0000                718          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000019E4                           719  
000019E4                           720  tableSomeLSL:
000019E4  4EF9 000019FC            721          JMP         LSLcode00       *LSL.B
000019EA  4EF9 00001A04            722          JMP         LSLcode01       *LSL.W
000019F0  4EF9 00001A0C            723          JMP         LSLcode10       *LSL.L
000019F6  4EF9 00001A14            724          JMP         LSLcode11       *LSL.W
000019FC                           725  
000019FC  4EB9 000023E4            726  LSLcode00 JSR       ISLSLB
00001A02  4E75                     727            RTS
00001A04  4EB9 000023FE            728  LSLcode01 JSR       ISLSLW
00001A0A  4E75                     729            RTS
00001A0C  4EB9 00002418            730  LSLcode10 JSR       ISLSLL
00001A12  4E75                     731            RTS
00001A14  4EB9 000023FE            732  LSLcode11 JSR       ISLSLW
00001A1A  4E75                     733            RTS
00001A1C                           734  
00001A1C                           735  someROL:
00001A1C  41F9 00001A3A            736          LEA         tableSomeROL, A0 ; Index into the table
00001A22  4280                     737          CLR.L       D0              ; Zero it
00001A24  3016                     738          MOVE.W      (A6),D0     ; We'll play with it here
00001A26  123C 0008                739          MOVE.B      #8,D1           ; Shift 8 bits left
00001A2A  E360                     740          ASL.W       D1,D0
00001A2C  123C 000E                741          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001A30  E268                     742          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001A32                           743                                      ; and the rest are zeroed out)
00001A32  C0FC 0006                744          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001A36  4EF0 0000                745          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A3A                           746  
00001A3A                           747  tableSomeROL:
00001A3A  4EF9 00001A52            748          JMP         ROLcode00       *ROL.B
00001A40  4EF9 00001A5A            749          JMP         ROLcode01       *ROL.W
00001A46  4EF9 00001A62            750          JMP         ROLcode10       *ROL.L
00001A4C  4EF9 00001A6A            751          JMP         ROLcode11       *ROL.W
00001A52                           752  
00001A52  4EB9 00002480            753  ROLcode00 JSR       ISROLB
00001A58  4E75                     754            RTS
00001A5A  4EB9 0000249A            755  ROLcode01 JSR       ISROLW
00001A60  4E75                     756            RTS
00001A62  4EB9 000024B4            757  ROLcode10 JSR       ISROLL
00001A68  4E75                     758            RTS
00001A6A  4EB9 0000249A            759  ROLcode11 JSR       ISROLW
00001A70  4E75                     760            RTS
00001A72                           761  
00001A72                           762  
00001A72                           763  someROR:
00001A72  41F9 00001A90            764          LEA         tableSomeROR, A0 ; Index into the table
00001A78  4280                     765          CLR.L       D0              ; Zero it
00001A7A  3016                     766          MOVE.W      (A6),D0     ; We'll play with it here
00001A7C  123C 0008                767          MOVE.B      #8,D1           ; Shift 8 bits left
00001A80  E360                     768          ASL.W       D1,D0
00001A82  123C 000E                769          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001A86  E268                     770          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001A88                           771                                      ; and the rest are zeroed out)
00001A88  C0FC 0006                772          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001A8C  4EF0 0000                773          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A90                           774  
00001A90                           775  tableSomeROR:
00001A90  4EF9 00001AA8            776          JMP         RORcode00       *ROR.B
00001A96  4EF9 00001AB0            777          JMP         RORcode01       *ROR.W
00001A9C  4EF9 00001AB8            778          JMP         RORcode10       *ROR.L
00001AA2  4EF9 00001AC0            779          JMP         RORcode11       *ROR.W
00001AA8                           780  
00001AA8  4EB9 00002432            781  RORcode00 JSR       ISRORB
00001AAE  4E75                     782            RTS
00001AB0  4EB9 0000244C            783  RORcode01 JSR       ISRORW
00001AB6  4E75                     784            RTS
00001AB8  4EB9 00002466            785  RORcode10 JSR       ISRORL
00001ABE  4E75                     786            RTS
00001AC0  4EB9 0000244C            787  RORcode11 JSR       ISRORW
00001AC6  4E75                     788            RTS
00001AC8                           789  
00001AC8                           790  ROL_ROR:
00001AC8  41F9 00001AE6            791          LEA         tableROL_ROR, A0 ; Index into the table
00001ACE  4280                     792          CLR.L       D0              ; Zero it
00001AD0  3016                     793          MOVE.W      (A6),D0     ; We'll play with it here
00001AD2  123C 0007                794          MOVE.B      #7,D1           ; Shift 7 bits left
00001AD6  E360                     795          ASL.W       D1,D0
00001AD8  123C 000F                796          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001ADC  E268                     797          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001ADE                           798                                      ; and the rest are zeroed out)
00001ADE  C0FC 0006                799          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001AE2  4EF0 0000                800          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001AE6                           801  
00001AE6                           802  tableROL_ROR:
00001AE6  4EF9 00001AF2            803          JMP         ROL_RORcode0    ; ROR
00001AEC  4EF9 00001AF8            804          JMP         ROL_RORcode1    ; ROL
00001AF2                           805  
00001AF2  4EB8 1A72                806  ROL_RORcode0 JSR    someROR
00001AF6  4E75                     807               RTS
00001AF8  4EB8 1A1C                808  ROL_RORcode1 JSR    someROL
00001AFC  4E75                     809               RTS
00001AFE                           810  
00001AFE                           811  LSL_LSR:
00001AFE  41F9 00001B1C            812          LEA         tableLSL_LSR, A0 ; Index into the table
00001B04  4280                     813          CLR.L       D0              ; Zero it
00001B06  3016                     814          MOVE.W      (A6),D0     ; We'll play with it here
00001B08  123C 0007                815          MOVE.B      #7,D1           ; Shift 7 bits left
00001B0C  E360                     816          ASL.W       D1,D0
00001B0E  123C 000F                817          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001B12  E268                     818          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B14                           819                                      ; and the rest are zeroed out)
00001B14  C0FC 0006                820          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B18  4EF0 0000                821          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B1C                           822  
00001B1C                           823  tableLSL_LSR:
00001B1C  4EF9 00001B28            824          JMP         LSL_LSRcode0    ; LSR
00001B22  4EF9 00001B2E            825          JMP         LSL_LSRcode1    ; LSL
00001B28                           826  
00001B28  4EB8 1970                827  LSL_LSRcode0 JSR    someLSR
00001B2C  4E75                     828               RTS
00001B2E  4EB8 19C6                829  LSL_LSRcode1 JSR    someLSL
00001B32  4E75                     830               RTS
00001B34                           831  
00001B34                           832  ASL_ASR:
00001B34  41F9 00001B52            833          LEA         tableASL_ASR, A0 ; Index into the table
00001B3A  4280                     834          CLR.L       D0              ; Zero it
00001B3C  3016                     835          MOVE.W      (A6),D0     ; We'll play with it here
00001B3E  123C 0007                836          MOVE.B      #7,D1           ; Shift 7 bits left
00001B42  E360                     837          ASL.W       D1,D0
00001B44  123C 000F                838          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001B48  E268                     839          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B4A                           840                                      ; and the rest are zeroed out)
00001B4A  C0FC 0006                841          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B4E  4EF0 0000                842          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B52                           843  
00001B52                           844  tableASL_ASR:
00001B52  4EF9 00001B5E            845          JMP         ASL_ASRcode0    ; ASR
00001B58  4EF9 00001B64            846          JMP         ASL_ASRcode1    ; ASL
00001B5E                           847  
00001B5E  4EB8 18C4                848  ASL_ASRcode0 JSR    someASR
00001B62  4E75                     849               RTS
00001B64  4EB8 191A                850  ASL_ASRcode1 JSR    someASL
00001B68  4E75                     851               RTS
00001B6A                           852  
00001B6A                           853  ROd_LSd_ASd:
00001B6A  41F9 00001B88            854          LEA         tableROd_LSd_ASd, A0 ; Index into the table
00001B70  4280                     855          CLR.L       D0              ; Zero it
00001B72  3016                     856          MOVE.W      (A6),D0     ; We'll play with it here
00001B74  123C 000B                857          MOVE.B      #11,D1          ; Shift 11 bits left
00001B78  E360                     858          ASL.W       D1,D0
00001B7A  123C 000F                859          MOVE.B      #15,D1          ; Shift 12 bits to the right
00001B7E  E268                     860          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B80                           861                                      ; and the rest are zeroed out)
00001B80  C0FC 0006                862          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B84  4EF0 0000                863          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B88                           864  
00001B88                           865  tableROd_LSd_ASd:
00001B88  4EF9 00001BA0            866          JMP         ROd_LSd_ASdcode00 ; ASL_ASR
00001B8E  4EF9 00001BA6            867          JMP         ROd_LSd_ASdcode01 ; LSL_LSR
00001B94  4EF9 00001BAC            868          JMP         ROd_LSd_ASdcode10
00001B9A  4EF9 00001BB4            869          JMP         ROd_LSd_ASdcode11 ; ROL_ROR
00001BA0                           870  
00001BA0  4EB8 1B34                871  ROd_LSd_ASdcode00 JSR ASL_ASR
00001BA4  4E75                     872                    RTS
00001BA6  4EB8 1AFE                873  ROd_LSd_ASdcode01 JSR LSL_LSR
00001BAA  4E75                     874                    RTS
00001BAC  4EB9 00002230            875  ROd_LSd_ASdcode10 JSR    OPCODE_INVALID              ;INVALID
00001BB2  4E75                     876                    RTS
00001BB4  4EB8 1AC8                877  ROd_LSd_ASdcode11 JSR ROL_ROR
00001BB8  4E75                     878                    RTS
00001BBA                           879  
00001BBA                           880  AND_BorAND_WorAND_LorMULS_W:
00001BBA  41F9 00001BD8            881          LEA         tableAND_BorAND_WorAND_LorMULS_W, A0            ; Index into the table
00001BC0  4280                     882          CLR.L       D0                  ; Zero it
00001BC2  3016                     883          MOVE.W      (A6),D0         ; We'll play with it here
00001BC4  123C 0007                884          MOVE.B      #7,D1           ; Shift 7 bits left
00001BC8  E360                     885          ASL.W       D1,D0
00001BCA  123C 000D                886          MOVE.B      #13,D1              ; Shift 13 bits to the right
00001BCE  E268                     887          LSR.W       D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001BD0                           888                                  ; and the rest are zeroed out)
00001BD0  C0FC 0006                889          MULU        #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001BD4  4EF0 0000                890          JMP         0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
00001BD8                           891  
00001BD8                           892  tableAND_BorAND_WorAND_LorMULS_W:
00001BD8  4EF9 00001C08            893          JMP         ANDcode000   ; AND.B
00001BDE  4EF9 00001C10            894          JMP         ANDcode001   ; AND.W
00001BE4  4EF9 00001C18            895          JMP         ANDcode010   ; AND.L
00001BEA  4EF9 00001C20            896          JMP         ANDcode011
00001BF0  4EF9 00001C28            897          JMP         ANDcode100   ; AND.B
00001BF6  4EF9 00001C30            898          JMP         ANDcode101   ; AND.W
00001BFC  4EF9 00001C38            899          JMP         ANDcode110   ; AND.L
00001C02  4EF9 00001C40            900          JMP         ANDcode111   ; MULS.W
00001C08                           901  
00001C08  4EB9 000024E8            902  ANDcode000 JSR      ISANDB
00001C0E  4E75                     903             RTS
00001C10  4EB9 00002502            904  ANDcode001 JSR      ISANDW
00001C16  4E75                     905             RTS
00001C18  4EB9 0000251C            906  ANDcode010 JSR      ISANDL
00001C1E  4E75                     907             RTS
00001C20  4EB9 00002230            908  ANDcode011 JSR    OPCODE_INVALID              ;INVALID
00001C26  4E75                     909             RTS
00001C28  4EB9 000024E8            910  ANDcode100 JSR      ISANDB
00001C2E  4E75                     911             RTS
00001C30  4EB9 00002502            912  ANDcode101 JSR      ISANDW
00001C36  4E75                     913             RTS
00001C38  4EB9 0000251C            914  ANDcode110 JSR      ISANDL
00001C3E  4E75                     915             RTS
00001C40  4EB9 000024CE            916  ANDcode111 JSR      ISMULSW
00001C46  4E75                     917             RTS
00001C48                           918  
00001C48                           919  ADD_BorADD_WorADD_L:
00001C48  41F9 00001C66            920          LEA         tableADD_BorADD_WorADD_L, A0 ; Index into the table
00001C4E  4280                     921          CLR.L       D0              ; Zero it
00001C50  3016                     922          MOVE.W      (A6),D0     ; We'll play with it here
00001C52  123C 0007                923          MOVE.B      #7,D1           ; Shift 7 bits left
00001C56  E360                     924          ASL.W       D1,D0
00001C58  123C 000D                925          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001C5C  E268                     926          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001C5E                           927                                      ; and the rest are zeroed out)
00001C5E  C0FC 0006                928          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001C62  4EF0 0000                929          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001C66                           930  
00001C66                           931  tableADD_BorADD_WorADD_L:
00001C66  4EF9 00001C96            932          JMP         ADDcode000      *ADD.B
00001C6C  4EF9 00001C9E            933          JMP         ADDcode001      *ADD.W
00001C72  4EF9 00001CA6            934          JMP         ADDcode010      *ADD.L
00001C78  4EF9 00001CAE            935          JMP         ADDcode011      *ADDA.W
00001C7E  4EF9 00001CB6            936          JMP         ADDcode100      *ADD.B
00001C84  4EF9 00001CBE            937          JMP         ADDcode101      *ADD.W
00001C8A  4EF9 00001CC6            938          JMP         ADDcode110      *ADD.L
00001C90  4EF9 00001CCE            939          JMP         ADDcode111      *ADDA.L
00001C96                           940  
00001C96  4EB9 0000256A            941  ADDcode000 JSR      ISADDB
00001C9C  4E75                     942             RTS
00001C9E  4EB9 00002584            943  ADDcode001 JSR      ISADDW
00001CA4  4E75                     944             RTS
00001CA6  4EB9 0000259E            945  ADDcode010 JSR      ISADDL
00001CAC  4E75                     946             RTS
00001CAE  4EB9 00002536            947  ADDcode011 JSR      ISADDAW
00001CB4  4E75                     948             RTS
00001CB6  4EB9 0000256A            949  ADDcode100 JSR      ISADDB
00001CBC  4E75                     950             RTS
00001CBE  4EB9 00002584            951  ADDcode101 JSR      ISADDW
00001CC4  4E75                     952             RTS
00001CC6  4EB9 0000259E            953  ADDcode110 JSR      ISADDL
00001CCC  4E75                     954             RTS
00001CCE  4EB9 00002550            955  ADDcode111 JSR      ISADDAL
00001CD4  4E75                     956             RTS
00001CD6                           957  
00001CD6                           958  SUB_BorSUB_WorSUB_L:
00001CD6  41F9 00001CF4            959          LEA         tableSUB_BorSUB_WorSUB_L, A0 ; Index into the table
00001CDC  4280                     960          CLR.L       D0              ; Zero it
00001CDE  3016                     961          MOVE.W      (A6),D0     ; We'll play with it here
00001CE0  123C 0007                962          MOVE.B      #7,D1           ; Shift 7 bits left
00001CE4  E360                     963          ASL.W       D1,D0
00001CE6  123C 000D                964          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001CEA  E268                     965          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001CEC                           966                                      ; and the rest are zeroed out)
00001CEC  C0FC 0006                967          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001CF0  4EF0 0000                968          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001CF4                           969  
00001CF4                           970  tableSUB_BorSUB_WorSUB_L:
00001CF4  4EF9 00001D24            971          JMP         SUBcode000      *SUB.B
00001CFA  4EF9 00001D2C            972          JMP         SUBcode001      *SUB.W
00001D00  4EF9 00001D34            973          JMP         SUBcode010      *SUB.L
00001D06  4EF9 00001D3C            974          JMP         SUBcode011
00001D0C  4EF9 00001D44            975          JMP         SUBcode100      *SUB.B
00001D12  4EF9 00001D4C            976          JMP         SUBcode101      *SUB.W
00001D18  4EF9 00001D54            977          JMP         SUBcode110      *SUB.L
00001D1E  4EF9 00001D5C            978          JMP         SUBcode111      ; INVALID
00001D24                           979  
00001D24  4EB9 000025B8            980  SUBcode000 JSR      ISSUBB
00001D2A  4E75                     981             RTS
00001D2C  4EB9 000025D2            982  SUBcode001 JSR      ISSUBW
00001D32  4E75                     983             RTS
00001D34  4EB9 000025EC            984  SUBcode010 JSR      ISSUBL
00001D3A  4E75                     985             RTS
00001D3C  4EB9 00002230            986  SUBcode011 JSR      OPCODE_INVALID              ;INVALID
00001D42  4E75                     987             RTS
00001D44  4EB9 000025B8            988  SUBcode100 JSR      ISSUBB
00001D4A  4E75                     989             RTS
00001D4C  4EB9 000025D2            990  SUBcode101 JSR      ISSUBW
00001D52  4E75                     991             RTS
00001D54  4EB9 000025EC            992  SUBcode110 JSR      ISSUBL
00001D5A  4E75                     993             RTS
00001D5C  4EB9 00002230            994  SUBcode111 JSR      OPCODE_INVALID              ;INVALID
00001D62  4E75                     995             RTS
00001D64                           996  
00001D64                           997  CMP_BorCMP_WorCMP_L:
00001D64  41F9 00001D82            998          LEA         tableCMP_BorCMP_WorCMP_L, A0 ; Index into the table
00001D6A  4280                     999          CLR.L       D0              ; Zero it
00001D6C  3016                    1000          MOVE.W      (A6),D0     ; We'll play with it here
00001D6E  123C 0008               1001          MOVE.B      #8,D1           ; Shift 8 bits left
00001D72  E360                    1002          ASL.W       D1,D0
00001D74  123C 000E               1003          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001D78  E268                    1004          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001D7A                          1005                                      ; and the rest are zeroed out)
00001D7A  C0FC 0006               1006          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001D7E  4EF0 0000               1007          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001D82                          1008  
00001D82                          1009  tableCMP_BorCMP_WorCMP_L:
00001D82  4EF9 00001D9A           1010          JMP         CMPcode00       *CMP.B
00001D88  4EF9 00001DA2           1011          JMP         CMPcode01       *CMP.W
00001D8E  4EF9 00001DAA           1012          JMP         CMPcode10       *CMP.L
00001D94  4EF9 00001DB2           1013          JMP         CMPcode11       ; INVALID
00001D9A                          1014  
00001D9A  4EB9 00002606           1015  CMPcode00   JSR      ISCMPB
00001DA0  4E75                    1016              RTS
00001DA2  4EB9 00002620           1017  CMPcode01   JSR      ISCMPW
00001DA8  4E75                    1018              RTS
00001DAA  4EB9 0000263A           1019  CMPcode10   JSR      ISCMPL
00001DB0  4E75                    1020              RTS
00001DB2  4EB9 00002230           1021  CMPcode11   JSR    OPCODE_INVALID              ;INVALID
00001DB8  4E75                    1022              RTS
00001DBA                          1023  
00001DBA                          1024  ADDQ_BorADDQ_WorADDQ_L:
00001DBA  41F9 00001DD8           1025          LEA         tableADDQ_BorADDQ_WorADDQ_L, A0 ; Index into the table
00001DC0  4280                    1026          CLR.L       D0              ; Zero it
00001DC2  3016                    1027          MOVE.W      (A6),D0     ; We'll play with it here
00001DC4  123C 0008               1028          MOVE.B      #8,D1           ; Shift 8 bits left
00001DC8  E360                    1029          ASL.W       D1,D0
00001DCA  123C 000E               1030          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001DCE  E268                    1031          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001DD0                          1032                                      ; and the rest are zeroed out)
00001DD0  C0FC 0006               1033          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001DD4  4EF0 0000               1034          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001DD8                          1035  
00001DD8                          1036  tableADDQ_BorADDQ_WorADDQ_L:
00001DD8  4EF9 00001DF0           1037          JMP         ADDQcode00      *ADDQ.B
00001DDE  4EF9 00001DF8           1038          JMP         ADDQcode01      *ADDQ.W
00001DE4  4EF9 00001E00           1039          JMP         ADDQcode10      *ADDQ.L
00001DEA  4EF9 00001E08           1040          JMP         ADDQcode11      ; INVALID
00001DF0                          1041  
00001DF0  4EB9 00002654           1042  ADDQcode00 JSR      ISADDQB
00001DF6  4E75                    1043             RTS
00001DF8  4EB9 0000266E           1044  ADDQcode01 JSR      ISADDQW
00001DFE  4E75                    1045             RTS
00001E00  4EB9 00002688           1046  ADDQcode10 JSR      ISADDQL
00001E06  4E75                    1047             RTS
00001E08  4EB9 00002230           1048  ADDQcode11   JSR    OPCODE_INVALID              ;INVALID
00001E0E  4E75                    1049              RTS
00001E10                          1050  
00001E10                          1051  someCLR:
00001E10  41F9 00001E2E           1052          LEA         tableSomeCLR, A0 ; Index into the table
00001E16  4280                    1053          CLR.L       D0              ; Zero it
00001E18  3016                    1054          MOVE.W      (A6),D0     ; We'll play with it here
00001E1A  123C 0008               1055          MOVE.B      #8,D1           ; Shift 8 bits left
00001E1E  E360                    1056          ASL.W       D1,D0
00001E20  123C 000E               1057          MOVE.B      #14,D1       ; Shift 12 bits to the right
00001E24  E268                    1058          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001E26                          1059                                      ; and the rest are zeroed out)
00001E26  C0FC 0006               1060          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001E2A  4EF0 0000               1061          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001E2E                          1062  
00001E2E                          1063  tableSomeCLR:
00001E2E  4EF9 00001E46           1064          JMP         CLRcode00       *CLR.B
00001E34  4EF9 00001E4E           1065          JMP         CLRcode01       *CLR.W
00001E3A  4EF9 00001E56           1066          JMP         CLRcode10       *CLR.L
00001E40  4EF9 00001E5E           1067          JMP         CLRcode11       ; INVALID
00001E46                          1068  
00001E46  4EB9 000026BC           1069  CLRcode00 JSR       ISCLRB
00001E4C  4E75                    1070            RTS
00001E4E  4EB9 000026D6           1071  CLRcode01 JSR       ISCLRW
00001E54  4E75                    1072            RTS
00001E56  4EB9 000026F0           1073  CLRcode10 JSR       ISCLRL
00001E5C  4E75                    1074            RTS
00001E5E  4EB9 00002230           1075  CLRcode11 JSR    OPCODE_INVALID              ;INVALID
00001E64  4E75                    1076            RTS
00001E66                          1077  
00001E66                          1078  NOPorCLRorRTSorJSR:
00001E66  41F9 00001E98           1079          LEA         tableNOPorCLRorRTSorJSR, A0 ; Index into the table
00001E6C  4280                    1080          CLR.L       D0              ; Zero it
00001E6E  3016                    1081          MOVE.W      (A6),D0     ; We'll play with it here
00001E70                          1082  
00001E70  323C 4E71               1083          MOVE.W      #%0100111001110001, D1 ; 0100111001110001 = NOP
00001E74  B240                    1084          CMP.W       D0, D1
00001E76  6700 0088               1085          BEQ         NOPcommand
00001E7A                          1086  
00001E7A  323C 4E75               1087          MOVE.W      #%0100111001110101, D1 ; 0100111001110101 = RTS
00001E7E  B240                    1088          CMP.W       D0, D1
00001E80  6700 0076               1089          BEQ         RTScommand
00001E84                          1090  
00001E84  123C 0004               1091          MOVE.B      #4,D1           ; Shift 4 bits left
00001E88  E360                    1092          ASL.W       D1,D0
00001E8A  123C 000C               1093          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001E8E  E268                    1094          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001E90                          1095                                      ; and the rest are zeroed out)
00001E90  C0FC 0006               1096          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001E94  4EF0 0000               1097          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001E98                          1098  
00001E98                          1099  tableNOPorCLRorRTSorJSR:
00001E98  4EF9 00001F08           1100          JMP         JSRorCLRcode0000
00001E9E  4EF9 00001F10           1101          JMP         JSRorCLRcode0001
00001EA4  4EF9 00001F18           1102          JMP         JSRorCLRcode0010
00001EAA  4EF9 00001F1E           1103          JMP         JSRorCLRcode0011
00001EB0  4EF9 00001F26           1104          JMP         JSRorCLRcode0100
00001EB6  4EF9 00001F2E           1105          JMP         JSRorCLRcode0101
00001EBC  4EF9 00001F36           1106          JMP         JSRorCLRcode0110
00001EC2  4EF9 00001F3E           1107          JMP         JSRorCLRcode0111
00001EC8  4EF9 00001F46           1108          JMP         JSRorCLRcode1000
00001ECE  4EF9 00001F4E           1109          JMP         JSRorCLRcode1001
00001ED4  4EF9 00001F56           1110          JMP         JSRorCLRcode1010
00001EDA  4EF9 00001F5E           1111          JMP         JSRorCLRcode1011
00001EE0  4EF9 00001F66           1112          JMP         JSRorCLRcode1100
00001EE6  4EF9 00001F6E           1113          JMP         JSRorCLRcode1101
00001EEC  4EF9 00001F76           1114          JMP         JSRorCLRcode1110
00001EF2  4EF9 00001F7E           1115          JMP         JSRorCLRcode1111
00001EF8                          1116  
00001EF8  4EB9 00002772           1117  RTScommand JSR      ISRTS
00001EFE  4E75                    1118             RTS
00001F00  4EB9 000027A2           1119  NOPcommand JSR      ISNOP
00001F06  4E75                    1120             RTS
00001F08  4EB9 00002230           1121  JSRorCLRcode0000 JSR    OPCODE_INVALID              ;INVALID
00001F0E  4E75                    1122                   RTS
00001F10  4EB9 00002230           1123  JSRorCLRcode0001 JSR    OPCODE_INVALID              ;INVALID
00001F16  4E75                    1124                   RTS
00001F18  4EB8 1E10               1125  JSRorCLRcode0010 JSR someCLR
00001F1C  4E75                    1126                   RTS
00001F1E  4EB9 00002230           1127  JSRorCLRcode0011 JSR    OPCODE_INVALID              ;INVALID
00001F24  4E75                    1128                   RTS
00001F26  4EB9 00002230           1129  JSRorCLRcode0100 JSR    OPCODE_INVALID              ;INVALID
00001F2C  4E75                    1130                   RTS
00001F2E  4EB9 00002230           1131  JSRorCLRcode0101 JSR    OPCODE_INVALID              ;INVALID
00001F34  4E75                    1132                   RTS
00001F36  4EB9 00002230           1133  JSRorCLRcode0110 JSR    OPCODE_INVALID              ;INVALID
00001F3C  4E75                    1134                   RTS
00001F3E  4EB9 00002230           1135  JSRorCLRcode0111 JSR    OPCODE_INVALID              ;INVALID
00001F44  4E75                    1136                   RTS
00001F46  4EB9 00002230           1137  JSRorCLRcode1000 JSR    OPCODE_INVALID              ;INVALID
00001F4C  4E75                    1138                   RTS
00001F4E  4EB9 00002230           1139  JSRorCLRcode1001 JSR    OPCODE_INVALID              ;INVALID
00001F54  4E75                    1140                   RTS
00001F56  4EB9 00002230           1141  JSRorCLRcode1010 JSR    OPCODE_INVALID              ;INVALID
00001F5C  4E75                    1142                   RTS
00001F5E  4EB9 00002230           1143  JSRorCLRcode1011 JSR    OPCODE_INVALID              ;INVALID
00001F64  4E75                    1144                   RTS
00001F66  4EB9 00002230           1145  JSRorCLRcode1100 JSR    OPCODE_INVALID              ;INVALID
00001F6C  4E75                    1146                   RTS
00001F6E  4EB9 00002230           1147  JSRorCLRcode1101 JSR    OPCODE_INVALID              ;INVALID
00001F74  4E75                    1148                   RTS
00001F76  4EB9 00002758           1149  JSRorCLRcode1110 JSR ISJSR
00001F7C  4E75                    1150                   RTS
00001F7E  4EB9 00002230           1151  JSRorCLRcode1111 JSR    OPCODE_INVALID              ;INVALID
00001F84  4E75                    1152                   RTS
00001F86                          1153  
00001F86                          1154  someMOVEM:
00001F86  41F9 00001FA4           1155          LEA         tableSomeMOVEM, A0 ; Index into the table
00001F8C  4280                    1156          CLR.L       D0              ; Zero it
00001F8E  3016                    1157          MOVE.W      (A6),D0     ; We'll play with it here
00001F90  123C 0009               1158          MOVE.B      #9,D1           ; Shift 9 bits left
00001F94  E360                    1159          ASL.W       D1,D0
00001F96  123C 000F               1160          MOVE.B      #15,D1       ; Shift 12 bits to the right
00001F9A  E268                    1161          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001F9C                          1162                                      ; and the rest are zeroed out)
00001F9C  C0FC 0006               1163          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001FA0  4EF0 0000               1164          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001FA4                          1165  
00001FA4                          1166  tableSomeMOVEM:
00001FA4  4EF9 00001FB0           1167          JMP         MOVEMcode0      ; MOVEM.W
00001FAA  4EF9 00001FB8           1168          JMP         MOVEMcode1      ; MOVEM.L
00001FB0                          1169  
00001FB0  4EB9 00002724           1170  MOVEMcode0 JSR      ISMOVEMW
00001FB6  4E75                    1171             RTS
00001FB8  4EB9 0000270A           1172  MOVEMcode1 JSR      ISMOVEML
00001FBE  4E75                    1173             RTS
00001FC0                          1174  
00001FC0                          1175  NOP_MOVEM_LEA_JSR_CLR_RTS:
00001FC0  41F9 00001FE4           1176          LEA         tableNOP_MOVEM_LEA_JSR_CLR_RTS, A0 ; Index into the table
00001FC6  4280                    1177          CLR.L       D0              ; Zero it
00001FC8  3016                    1178          MOVE.W      (A6),D0     ; We'll play with it here
00001FCA  123C 0007               1179          MOVE.B      #7,D1           ; Shift 7 bits right
00001FCE  E260                    1180          ASR.W       D1,D0
00001FD0  123C 000D               1181          MOVE.B      #13,D1          ; Shift 13 bits left
00001FD4  E360                    1182          ASL.W       D1,D0
00001FD6  123C 000C               1183          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001FDA  E268                    1184          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001FDC                          1185                                      ; and the rest are zeroed out)
00001FDC  C0FC 0006               1186          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001FE0  4EF0 0000               1187          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001FE4                          1188  
00001FE4                          1189  tableNOP_MOVEM_LEA_JSR_CLR_RTS:
00001FE4  4EF9 00002044           1190          JMP         LOTScode0000
00001FEA  4EF9 0000204C           1191          JMP         LOTScode0001
00001FF0  4EF9 00002054           1192          JMP         LOTScode0010
00001FF6  4EF9 0000205A           1193          JMP         LOTScode0011
00001FFC  4EF9 00002062           1194          JMP         LOTScode0100
00002002  4EF9 0000206A           1195          JMP         LOTScode0101
00002008  4EF9 00002072           1196          JMP         LOTScode0110
0000200E  4EF9 0000207A           1197          JMP         LOTScode0111
00002014  4EF9 00002082           1198          JMP         LOTScode1000
0000201A  4EF9 00002088           1199          JMP         LOTScode1001
00002020  4EF9 00002090           1200          JMP         LOTScode1010
00002026  4EF9 00002096           1201          JMP         LOTScode1011
0000202C  4EF9 0000209E           1202          JMP         LOTScode1100
00002032  4EF9 000020A6           1203          JMP         LOTScode1101
00002038  4EF9 000020AE           1204          JMP         LOTScode1110
0000203E  4EF9 000020B6           1205          JMP         LOTScode1111
00002044                          1206  
00002044  4EB9 00002230           1207  LOTScode0000 JSR    OPCODE_INVALID              ; MULS.L and DIVU.L are not supported for 68000 Disassember
0000204A  4E75                    1208               RTS
0000204C  4EB9 00002230           1209  LOTScode0001 JSR    OPCODE_INVALID              ;INVALID
00002052  4E75                    1210               RTS
00002054  4EB8 1F86               1211  LOTScode0010 JSR    someMOVEM
00002058  4E75                    1212               RTS
0000205A  4EB9 00002230           1213  LOTScode0011 JSR    OPCODE_INVALID              ;INVALID
00002060  4E75                    1214               RTS
00002062  4EB9 00002230           1215  LOTScode0100 JSR    OPCODE_INVALID              ;INVALID
00002068  4E75                    1216               RTS
0000206A  4EB9 00002230           1217  LOTScode0101 JSR    OPCODE_INVALID              ;INVALID
00002070  4E75                    1218               RTS
00002072  4EB9 0000273E           1219  LOTScode0110 JSR    ISLEA
00002078  4E75                    1220               RTS
0000207A  4EB9 00002230           1221  LOTScode0111 JSR    OPCODE_INVALID              ;INVALID
00002080  4E75                    1222               RTS
00002082  4EB8 1E66               1223  LOTScode1000 JSR    NOPorCLRorRTSorJSR
00002086  4E75                    1224               RTS
00002088  4EB9 00002230           1225  LOTScode1001 JSR    OPCODE_INVALID              ;INVALID
0000208E  4E75                    1226               RTS
00002090  4EB8 1E66               1227  LOTScode1010 JSR    NOPorCLRorRTSorJSR
00002094  4E75                    1228               RTS
00002096  4EB9 00002230           1229  LOTScode1011 JSR    OPCODE_INVALID              ;INVALID
0000209C  4E75                    1230               RTS
0000209E  4EB9 00002230           1231  LOTScode1100 JSR    OPCODE_INVALID              ;INVALID
000020A4  4E75                    1232               RTS
000020A6  4EB9 00002230           1233  LOTScode1101 JSR    OPCODE_INVALID              ;INVALID
000020AC  4E75                    1234               RTS
000020AE  4EB9 0000273E           1235  LOTScode1110 JSR    ISLEA
000020B4  4E75                    1236               RTS
000020B6  4EB9 00002230           1237  LOTScode1111 JSR    OPCODE_INVALID              ;INVALID
000020BC  4E75                    1238               RTS
000020BE                          1239  
000020BE                          1240  ADDI_BorADDI_WorADDI_L:
000020BE  41F9 000020DC           1241          LEA         tableADDI_BorADDI_WorADDI_L,A0 ; Index into the table
000020C4  4280                    1242          CLR.L       D0              ; Zero it
000020C6  3016                    1243          MOVE.W      (A6),D0     ; We'll play with it here
000020C8  123C 0007               1244          MOVE.B      #7,D1           ; Shift 7 bits left
000020CC  E360                    1245          ASL.W       D1,D0
000020CE  123C 000D               1246          MOVE.B      #13,D1          ; Shift 13 bits right
000020D2  E260                    1247          ASR.W       D1,D0
000020D4  C0FC 0006               1248          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000020D8  4EF0 0000               1249          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000020DC                          1250  
000020DC                          1251  tableADDI_BorADDI_WorADDI_L:
000020DC  4EF9 000020F4           1252          JMP         ADDIBcode00
000020E2  4EF9 000020FC           1253          JMP         ADDIWcode01
000020E8  4EF9 00002104           1254          JMP         ADDILcode10
000020EE  4EF9 0000210C           1255          JMP         ADDILcode11
000020F4                          1256  
000020F4  4EB9 0000286E           1257  ADDIBcode00 JSR     ISADDIB
000020FA  4E75                    1258              RTS
000020FC  4EB9 0000283A           1259  ADDIWcode01 JSR     ISADDIW
00002102  4E75                    1260              RTS
00002104  4EB9 00002854           1261  ADDILcode10 JSR     ISADDIL
0000210A  4E75                    1262              RTS
0000210C  4EB9 00002230           1263  ADDILcode11 JSR    OPCODE_INVALID              ;INVALID
00002112  4E75                    1264              RTS
00002114                          1265  
00002114                          1266  MOVEA_LorMOVE_L:
00002114  41F9 00002132           1267          LEA         tableMOVEA_LorMOVE_L,A0 ; Index into the table
0000211A  4280                    1268          CLR.L       D0              ; Zero it
0000211C  3016                    1269          MOVE.W      (A6),D0         ; We'll play with it here
0000211E  123C 0007               1270          MOVE.B      #7,D1           ; Shift 7 bits left
00002122  E360                    1271          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
00002124  123C 000D               1272          MOVE.B      #13,D1          ; Shift 13 bits right
00002128  E260                    1273          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
0000212A  C0FC 0006               1274          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000212E  4EF0 0000               1275          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00002132                          1276  
00002132                          1277  tableMOVEA_LorMOVE_L:
00002132  4EF9 00002162           1278          JMP         MOVEcode000
00002138  4EF9 0000216A           1279          JMP         MOVEAcode001
0000213E  4EF9 00002172           1280          JMP         MOVEcode010
00002144  4EF9 0000217A           1281          JMP         MOVEcode011
0000214A  4EF9 00002182           1282          JMP         MOVEcode100
00002150  4EF9 0000218A           1283          JMP         MOVEcode101
00002156  4EF9 00002192           1284          JMP         MOVEcode110
0000215C  4EF9 0000219A           1285          JMP         MOVEcode111
00002162                          1286  
00002162  4EB9 000027EC           1287  MOVEcode000 JSR     ISMOVEL
00002168  4E75                    1288              RTS
0000216A  4EB9 00002806           1289  MOVEAcode001 JSR    ISMOVEAL
00002170  4E75                    1290               RTS
00002172  4EB9 000027EC           1291  MOVEcode010 JSR     ISMOVEL
00002178  4E75                    1292              RTS
0000217A  4EB9 000027EC           1293  MOVEcode011 JSR     ISMOVEL
00002180  4E75                    1294              RTS
00002182  4EB9 000027EC           1295  MOVEcode100 JSR     ISMOVEL
00002188  4E75                    1296              RTS
0000218A  4EB9 000027EC           1297  MOVEcode101 JSR     ISMOVEL
00002190  4E75                    1298              RTS
00002192  4EB9 000027EC           1299  MOVEcode110 JSR     ISMOVEL
00002198  4E75                    1300              RTS
0000219A  4EB9 000027EC           1301  MOVEcode111 JSR     ISMOVEL
000021A0  4E75                    1302              RTS
000021A2                          1303  
000021A2                          1304  MOVEA_WorMOVE_W:
000021A2  41F9 000021C0           1305          LEA         tableMOVEA_WorMOVE_W,A0 ; Index into the table
000021A8  4280                    1306          CLR.L       D0              ; Zero it
000021AA  3016                    1307          MOVE.W      (A6),D0     ; We'll play with it here
000021AC  123C 0007               1308          MOVE.B      #7,D1           ; Shift 7 bits left
000021B0  E360                    1309          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
000021B2  123C 000D               1310          MOVE.B      #13,D1          ; Shift 13 bits right
000021B6  E260                    1311          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
000021B8  C0FC 0006               1312          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000021BC  4EF0 0000               1313          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000021C0                          1314  
000021C0                          1315  tableMOVEA_WorMOVE_W:
000021C0  4EF9 000021F0           1316          JMP         MOVEWcode000
000021C6  4EF9 000021F8           1317          JMP         MOVEAWcode001
000021CC  4EF9 00002200           1318          JMP         MOVEWcode010
000021D2  4EF9 00002208           1319          JMP         MOVEWcode011
000021D8  4EF9 00002210           1320          JMP         MOVEWcode100
000021DE  4EF9 00002218           1321          JMP         MOVEWcode101
000021E4  4EF9 00002220           1322          JMP         MOVEWcode110
000021EA  4EF9 00002228           1323          JMP         MOVEWcode111
000021F0                          1324  
000021F0  4EB9 000027B8           1325  MOVEWcode000 JSR    ISMOVEW
000021F6  4E75                    1326               RTS
000021F8  4EB9 000027D2           1327  MOVEAWcode001 JSR   ISMOVEAW
000021FE  4E75                    1328                RTS
00002200  4EB9 000027B8           1329  MOVEWcode010 JSR    ISMOVEW
00002206  4E75                    1330               RTS
00002208  4EB9 000027B8           1331  MOVEWcode011 JSR    ISMOVEW
0000220E  4E75                    1332               RTS
00002210  4EB9 000027B8           1333  MOVEWcode100 JSR    ISMOVEW
00002216  4E75                    1334               RTS
00002218  4EB9 000027B8           1335  MOVEWcode101 JSR    ISMOVEW
0000221E  4E75                    1336               RTS
00002220  4EB9 000027B8           1337  MOVEWcode110 JSR    ISMOVEW
00002226  4E75                    1338               RTS
00002228  4EB9 000027B8           1339  MOVEWcode111 JSR    ISMOVEW
0000222E  4E75                    1340               RTS
00002230                          1341  
00002230                          1342  ; TODO: adjust workflow to:
00002230                          1343  ;   1) save message address to buffer pointer
00002230  48E7 FFFE               1344  OPCODE_INVALID  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002234  43F8 169E               1345              LEA MESSAGEOPCODE_INVALID, A1
00002238  103C 000E               1346              MOVE.B  #14, D0
0000223C  4E4F                    1347              TRAP    #15
0000223E                          1348  
0000223E  4CDF 7FFF               1349              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00002242  4E75                    1350              RTS
00002244                          1351  
00002244  48E7 FFFE               1352  ISBCC  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002248  43F8 168C               1353              LEA MESSAGEBCC, A1
0000224C  103C 000E               1354              MOVE.B  #14, D0
00002250  4E4F                    1355              TRAP    #15
00002252  4EB9 000031F0           1356              JSR     EA_Bcc
00002258  4CDF 7FFF               1357              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
0000225C  4E75                    1358              RTS
0000225E  48E7 FFFE               1359  ISBGT  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002262  43F8 1692               1360              LEA MESSAGEBGT, A1
00002266  103C 000E               1361              MOVE.B  #14, D0
0000226A  4E4F                    1362              TRAP    #15
0000226C  4EB9 000031F0           1363              JSR     EA_Bcc
00002272  4CDF 7FFF               1364              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00002276  4E75                    1365              RTS
00002278                          1366  
00002278  48E7 FFFE               1367  ISBLE  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000227C  43F8 1698               1368              LEA MESSAGEBLE, A1
00002280  103C 000E               1369              MOVE.B  #14, D0
00002284  4E4F                    1370              TRAP    #15
00002286  4EB9 000031F0           1371              JSR     EA_Bcc
0000228C  4CDF 7FFF               1372              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00002290  4E75                    1373              RTS
00002292                          1374  
00002292  48E7 FFFE               1375  ISDIVUW     MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002296  43F8 1683               1376              LEA MESSAGEDIVUW, A1
0000229A  103C 000E               1377              MOVE.B  #14, D0
0000229E  4E4F                    1378              TRAP    #15
000022A0  4EB9 00003416           1379              JSR     EA_DIVU_W
000022A6  4CDF 7FFF               1380              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
000022AA  4E75                    1381              RTS
000022AC                          1382  
000022AC  48E7 FFFE               1383  ISORB   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022B0  43F8 166E               1384          LEA         MESSAGEORB, A1
000022B4  103C 000E               1385          MOVE.B      #14, D0
000022B8  4E4F                    1386          TRAP        #15
000022BA  4EB9 00003BEE           1387          JSR         EA_OR
000022C0  4CDF 7FFF               1388          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022C4  4E75                    1389          RTS
000022C6                          1390  
000022C6  48E7 FFFE               1391  ISORW   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022CA  43F8 1675               1392          LEA         MESSAGEORW, A1
000022CE  103C 000E               1393          MOVE.B      #14, D0
000022D2  4E4F                    1394          TRAP        #15
000022D4  4EB9 00003BEE           1395          JSR         EA_OR
000022DA  4CDF 7FFF               1396          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022DE  4E75                    1397          RTS
000022E0                          1398  
000022E0  48E7 FFFE               1399  ISORL   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022E4  43F8 167C               1400          LEA         MESSAGEORL, A1
000022E8  103C 000E               1401          MOVE.B      #14, D0
000022EC  4E4F                    1402          TRAP        #15
000022EE  4EB9 00003BEE           1403          JSR         EA_OR
000022F4  4CDF 7FFF               1404          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022F8  4E75                    1405          RTS
000022FA                          1406  
000022FA  48E7 FFFE               1407  ISASRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022FE  43F8 15DE               1408          LEA         MESSAGEASRB, A1
00002302  103C 000E               1409          MOVE.B      #14, D0
00002306  4E4F                    1410          TRAP        #15
00002308  4EB9 000030DC           1411          JSR         EA_ASd
0000230E  4CDF 7FFF               1412          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002312  4E75                    1413          RTS
00002314                          1414  
00002314  48E7 FFFE               1415  ISASRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002318  43F8 15E6               1416          LEA         MESSAGEASRW, A1
0000231C  103C 000E               1417          MOVE.B      #14, D0
00002320  4E4F                    1418          TRAP        #15
00002322  4EB9 000030DC           1419          JSR         EA_ASd
00002328  4CDF 7FFF               1420          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000232C  4E75                    1421          RTS
0000232E                          1422  
0000232E  48E7 FFFE               1423  ISASRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002332  43F8 15EE               1424          LEA         MESSAGEASRL, A1
00002336  103C 000E               1425          MOVE.B      #14, D0
0000233A  4E4F                    1426          TRAP        #15
0000233C  4EB9 000030DC           1427          JSR         EA_ASd
00002342  4CDF 7FFF               1428          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002346  4E75                    1429          RTS
00002348                          1430  
00002348  48E7 FFFE               1431  ISASLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000234C  43F8 15F6               1432          LEA         MESSAGEASLB, A1
00002350  103C 000E               1433          MOVE.B      #14, D0
00002354  4E4F                    1434          TRAP        #15
00002356  4EB9 000030DC           1435          JSR         EA_ASd
0000235C  4CDF 7FFF               1436          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002360  4E75                    1437          RTS
00002362                          1438  
00002362  48E7 FFFE               1439  ISASLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002366  43F8 15FE               1440          LEA         MESSAGEASLW, A1
0000236A  103C 000E               1441          MOVE.B      #14, D0
0000236E  4E4F                    1442          TRAP        #15
00002370  4EB9 000030DC           1443          JSR         EA_ASd
00002376  4CDF 7FFF               1444          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000237A  4E75                    1445          RTS
0000237C                          1446  
0000237C  48E7 FFFE               1447  ISASLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002380  43F8 1606               1448          LEA         MESSAGEASLL, A1
00002384  103C 000E               1449          MOVE.B      #14, D0
00002388  4E4F                    1450          TRAP        #15
0000238A  4EB9 000030DC           1451          JSR         EA_ASd
00002390  4CDF 7FFF               1452          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002394  4E75                    1453          RTS
00002396                          1454  
00002396  48E7 FFFE               1455  ISLSRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000239A  43F8 163E               1456          LEA         MESSAGELSRB, A1
0000239E  103C 000E               1457          MOVE.B      #14, D0
000023A2  4E4F                    1458          TRAP        #15
000023A4  4EB9 0000369E           1459          JSR         EA_LSd
000023AA  4CDF 7FFF               1460          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023AE  4E75                    1461          RTS
000023B0                          1462  
000023B0  48E7 FFFE               1463  ISLSRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023B4  43F8 1646               1464          LEA         MESSAGELSRW, A1
000023B8  103C 000E               1465          MOVE.B      #14, D0
000023BC  4E4F                    1466          TRAP        #15
000023BE  4EB9 0000369E           1467          JSR         EA_LSd
000023C4  4CDF 7FFF               1468          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023C8  4E75                    1469          RTS
000023CA                          1470  
000023CA  48E7 FFFE               1471  ISLSRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023CE  43F8 164E               1472          LEA         MESSAGELSRL, A1
000023D2  103C 000E               1473          MOVE.B      #14, D0
000023D6  4E4F                    1474          TRAP        #15
000023D8  4EB9 0000369E           1475          JSR         EA_LSd
000023DE  4CDF 7FFF               1476          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023E2  4E75                    1477          RTS
000023E4                          1478  
000023E4  48E7 FFFE               1479  ISLSLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023E8  43F8 1656               1480          LEA         MESSAGELSLB, A1
000023EC  103C 000E               1481          MOVE.B      #14, D0
000023F0  4E4F                    1482          TRAP        #15
000023F2  4EB9 0000369E           1483          JSR         EA_LSd
000023F8  4CDF 7FFF               1484          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023FC  4E75                    1485          RTS
000023FE                          1486  
000023FE  48E7 FFFE               1487  ISLSLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002402  43F8 165E               1488          LEA         MESSAGELSLW, A1
00002406  103C 000E               1489          MOVE.B      #14, D0
0000240A  4E4F                    1490          TRAP        #15
0000240C  4EB9 0000369E           1491          JSR         EA_LSd
00002412  4CDF 7FFF               1492          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002416  4E75                    1493          RTS
00002418                          1494  
00002418  48E7 FFFE               1495  ISLSLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000241C  43F8 1666               1496          LEA         MESSAGELSLL, A1
00002420  103C 000E               1497          MOVE.B      #14, D0
00002424  4E4F                    1498          TRAP        #15
00002426  4EB9 0000369E           1499          JSR         EA_LSd
0000242C  4CDF 7FFF               1500          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002430  4E75                    1501          RTS
00002432                          1502  
00002432  48E7 FFFE               1503  ISRORB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002436  43F8 160E               1504          LEA         MESSAGERORB, A1
0000243A  103C 000E               1505          MOVE.B      #14, D0
0000243E  4E4F                    1506          TRAP        #15
00002440  4EB9 00003D9A           1507          JSR         EA_ROd
00002446  4CDF 7FFF               1508          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000244A  4E75                    1509          RTS
0000244C                          1510  
0000244C  48E7 FFFE               1511  ISRORW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002450  43F8 1616               1512          LEA         MESSAGERORW, A1
00002454  103C 000E               1513          MOVE.B      #14, D0
00002458  4E4F                    1514          TRAP        #15
0000245A  4EB9 00003D9A           1515          JSR         EA_ROd
00002460  4CDF 7FFF               1516          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002464  4E75                    1517          RTS
00002466                          1518  
00002466  48E7 FFFE               1519  ISRORL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000246A  43F8 161E               1520          LEA         MESSAGERORL, A1
0000246E  103C 000E               1521          MOVE.B      #14, D0
00002472  4E4F                    1522          TRAP        #15
00002474  4EB9 00003D9A           1523          JSR         EA_ROd
0000247A  4CDF 7FFF               1524          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000247E  4E75                    1525          RTS
00002480                          1526  
00002480  48E7 FFFE               1527  ISROLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002484  43F8 1626               1528          LEA         MESSAGEROLB, A1
00002488  103C 000E               1529          MOVE.B      #14, D0
0000248C  4E4F                    1530          TRAP        #15
0000248E  4EB9 00003D9A           1531          JSR         EA_ROd
00002494  4CDF 7FFF               1532          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002498  4E75                    1533          RTS
0000249A                          1534  
0000249A  48E7 FFFE               1535  ISROLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000249E  43F8 162E               1536          LEA         MESSAGEROLW, A1
000024A2  103C 000E               1537          MOVE.B      #14, D0
000024A6  4E4F                    1538          TRAP        #15
000024A8  4EB9 00003D9A           1539          JSR         EA_ROd
000024AE  4CDF 7FFF               1540          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024B2  4E75                    1541          RTS
000024B4                          1542  
000024B4  48E7 FFFE               1543  ISROLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024B8  43F8 1636               1544          LEA         MESSAGEROLL, A1
000024BC  103C 000E               1545          MOVE.B      #14, D0
000024C0  4E4F                    1546          TRAP        #15
000024C2  4EB9 00003D9A           1547          JSR         EA_ROd
000024C8  4CDF 7FFF               1548          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024CC  4E75                    1549          RTS
000024CE                          1550  
000024CE  48E7 FFFE               1551  ISMULSW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024D2  43F8 15D5               1552          LEA         MESSAGEMULSW, A1 *OPCODE is MULS.W
000024D6  103C 000E               1553          MOVE.B      #14, D0
000024DA  4E4F                    1554          TRAP        #15
000024DC  4EB9 00003AFE           1555          JSR         EA_MULS_W
000024E2  4CDF 7FFF               1556          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024E6  4E75                    1557          RTS
000024E8                          1558  
000024E8  48E7 FFFE               1559  ISANDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024EC  43F8 15BD               1560          LEA         MESSAGEANDB, A1 *OPCODE is AND.B
000024F0  103C 000E               1561          MOVE.B      #14, D0
000024F4  4E4F                    1562          TRAP        #15
000024F6  4EB9 00002F36           1563          JSR         EA_AND
000024FC  4CDF 7FFF               1564          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002500  4E75                    1565          RTS
00002502                          1566  
00002502  48E7 FFFE               1567  ISANDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002506  43F8 15C5               1568          LEA         MESSAGEANDW, A1 *OPCODE is AND.W
0000250A  103C 000E               1569          MOVE.B      #14, D0
0000250E  4E4F                    1570          TRAP        #15
00002510  4EB9 00002F36           1571          JSR         EA_AND
00002516  4CDF 7FFF               1572          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000251A  4E75                    1573          RTS
0000251C                          1574  
0000251C  48E7 FFFE               1575  ISANDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002520  43F8 15CD               1576          LEA         MESSAGEANDL, A1 *OPCODE is AND.L
00002524  103C 000E               1577          MOVE.B      #14, D0
00002528  4E4F                    1578          TRAP        #15
0000252A  4EB9 00002F36           1579          JSR         EA_AND
00002530  4CDF 7FFF               1580          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002534  4E75                    1581          RTS
00002536                          1582  
00002536  48E7 FFFE               1583  ISADDAW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000253A  43F8 15A1               1584          LEA         MESSAGEADDAW, A1 *OPCODE is ADDA.W
0000253E  103C 000E               1585          MOVE.B      #14, D0
00002542  4E4F                    1586          TRAP        #15
00002544  4EB9 00002C54           1587          JSR         EA_ADDA
0000254A  4CDF 7FFF               1588          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000254E  4E75                    1589          RTS
00002550                          1590  
00002550  48E7 FFFE               1591  ISADDAL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002554  43F8 15AA               1592          LEA         MESSAGEADDAL, A1 *OPCODE is ADDA.L
00002558  103C 000E               1593          MOVE.B      #14, D0
0000255C  4E4F                    1594          TRAP        #15
0000255E  4EB9 00002C54           1595          JSR         EA_ADDA
00002564  4CDF 7FFF               1596          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002568  4E75                    1597          RTS
0000256A                          1598  
0000256A  48E7 FFFE               1599  ISADDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000256E  43F8 1589               1600          LEA         MESSAGEADDB, A1 *OPCODE is ADD.B
00002572  103C 000E               1601          MOVE.B      #14, D0
00002576  4E4F                    1602          TRAP        #15
00002578  4EB9 00002AA0           1603          JSR         EA_ADD
0000257E  4CDF 7FFF               1604          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002582  4E75                    1605          RTS
00002584                          1606  
00002584  48E7 FFFE               1607  ISADDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002588  43F8 1591               1608          LEA         MESSAGEADDW, A1 *OPCODE is ADD.W
0000258C  103C 000E               1609          MOVE.B      #14, D0
00002590  4E4F                    1610          TRAP        #15
00002592  4EB9 00002AA0           1611          JSR         EA_ADD
00002598  4CDF 7FFF               1612          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000259C  4E75                    1613          RTS
0000259E                          1614  
0000259E  48E7 FFFE               1615  ISADDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025A2  43F8 1599               1616          LEA         MESSAGEADDL, A1 *OPCODE is ADD.L
000025A6  103C 000E               1617          MOVE.B      #14, D0
000025AA  4E4F                    1618          TRAP        #15
000025AC  4EB9 00002AA0           1619          JSR         EA_ADD
000025B2  4CDF 7FFF               1620          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025B6  4E75                    1621          RTS
000025B8                          1622  
000025B8  48E7 FFFE               1623  ISSUBB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025BC  43F8 1571               1624          LEA         MESSAGESUBB, A1 *OPCODE is SUB.B
000025C0  103C 000E               1625          MOVE.B      #14, D0
000025C4  4E4F                    1626          TRAP        #15
000025C6  4EB9 00003EAE           1627          JSR         EA_SUB
000025CC  4CDF 7FFF               1628          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025D0  4E75                    1629          RTS
000025D2                          1630  
000025D2  48E7 FFFE               1631  ISSUBW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025D6  43F8 1579               1632          LEA         MESSAGESUBW, A1 *OPCODE is SUB.W
000025DA  103C 000E               1633          MOVE.B      #14, D0
000025DE  4E4F                    1634          TRAP        #15
000025E0  4EB9 00003EAE           1635          JSR         EA_SUB
000025E6  4CDF 7FFF               1636          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025EA  4E75                    1637          RTS
000025EC                          1638  
000025EC  48E7 FFFE               1639  ISSUBL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025F0  43F8 1581               1640          LEA         MESSAGESUBL, A1 *OPCODE is SUB.L
000025F4  103C 000E               1641          MOVE.B      #14, D0
000025F8  4E4F                    1642          TRAP        #15
000025FA  4EB9 00003EAE           1643          JSR         EA_SUB
00002600  4CDF 7FFF               1644          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002604  4E75                    1645          RTS
00002606                          1646  
00002606  48E7 FFFE               1647  ISCMPB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000260A  43F8 1559               1648          LEA         MESSAGECMPB, A1 *OPCODE is CMP.B
0000260E  103C 000E               1649          MOVE.B      #14, D0
00002612  4E4F                    1650          TRAP        #15
00002614  4EB9 00003346           1651          JSR         EA_CMP
0000261A  4CDF 7FFF               1652          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000261E  4E75                    1653          RTS
00002620                          1654  
00002620  48E7 FFFE               1655  ISCMPW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002624  43F8 1561               1656          LEA         MESSAGECMPW, A1 *OPCODE is CMP.W
00002628  103C 000E               1657          MOVE.B      #14, D0
0000262C  4E4F                    1658          TRAP        #15
0000262E  4EB9 00003346           1659          JSR         EA_CMP
00002634  4CDF 7FFF               1660          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002638  4E75                    1661          RTS
0000263A                          1662  
0000263A  48E7 FFFE               1663  ISCMPL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000263E  43F8 1569               1664          LEA         MESSAGECMPL, A1 *OPCODE is CMP.L
00002642  103C 000E               1665          MOVE.B      #14, D0
00002646  4E4F                    1666          TRAP        #15
00002648  4EB9 00003346           1667          JSR         EA_CMP
0000264E  4CDF 7FFF               1668          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002652  4E75                    1669          RTS
00002654                          1670  
00002654  48E7 FFFE               1671  ISADDQB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002658  43F8 153E               1672          LEA         MESSAGEADDQB, A1 *OPCODE is ADDQ.B
0000265C  103C 000E               1673          MOVE.B      #14, D0
00002660  4E4F                    1674          TRAP        #15
00002662  4EB9 00002E54           1675          JSR         EA_ADDQ
00002668  4CDF 7FFF               1676          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000266C  4E75                    1677          RTS
0000266E                          1678  
0000266E  48E7 FFFE               1679  ISADDQW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002672  43F8 1547               1680          LEA         MESSAGEADDQW, A1 *OPCODE is ADDQ.W
00002676  103C 000E               1681          MOVE.B      #14, D0
0000267A  4E4F                    1682          TRAP        #15
0000267C  4EB9 00002E54           1683          JSR         EA_ADDQ
00002682  4CDF 7FFF               1684          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002686  4E75                    1685          RTS
00002688                          1686  
00002688  48E7 FFFE               1687  ISADDQL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000268C  43F8 1550               1688          LEA         MESSAGEADDQL, A1 *OPCODE is ADDQ.L
00002690  103C 000E               1689          MOVE.B      #14, D0
00002694  4E4F                    1690          TRAP        #15
00002696  4EB9 00002E54           1691          JSR         EA_ADDQ
0000269C  4CDF 7FFF               1692          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026A0  4E75                    1693          RTS
000026A2                          1694  
000026A2  48E7 FFFE               1695  ISMOVEQL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000026A6  43F8 15B3               1696          LEA         MESSAGEMOVEQL, A1 *OPCODE is MOVEQ.L
000026AA  103C 000E               1697          MOVE.B      #14, D0
000026AE  4E4F                    1698          TRAP        #15
000026B0  4EB9 00003ABA           1699          JSR         EA_MOVEQ
000026B6  4CDF 7FFF               1700          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026BA  4E75                    1701          RTS
000026BC                          1702  
000026BC  48E7 FFFE               1703  ISCLRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026C0  43F8 1526               1704          LEA         MESSAGECLRB, A1 *OPCODE is CLR.B
000026C4  103C 000E               1705          MOVE.B      #14, D0
000026C8  4E4F                    1706          TRAP        #15
000026CA  4EB9 00003ABA           1707          JSR         EA_MOVEQ
000026D0  4CDF 7FFF               1708          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026D4  4E75                    1709          RTS
000026D6                          1710  
000026D6  48E7 FFFE               1711  ISCLRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026DA  43F8 152E               1712          LEA         MESSAGECLRW, A1 *OPCODE is CLR.W
000026DE  103C 000E               1713          MOVE.B      #14, D0
000026E2  4E4F                    1714          TRAP        #15
000026E4  4EB9 0000327E           1715          JSR         EA_CLR
000026EA  4CDF 7FFF               1716          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026EE  4E75                    1717          RTS
000026F0                          1718  
000026F0  48E7 FFFE               1719  ISCLRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026F4  43F8 1536               1720          LEA         MESSAGECLRL, A1 *OPCODE is CLR.L
000026F8  103C 000E               1721          MOVE.B      #14, D0
000026FC  4E4F                    1722          TRAP        #15
000026FE  4EB9 0000327E           1723          JSR         EA_CLR
00002704  4CDF 7FFF               1724          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002708  4E75                    1725          RTS
0000270A                          1726  
0000270A  48E7 FFFE               1727  ISMOVEML MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
0000270E  43F8 14FA               1728          LEA         MESSAGEMOVEML, A1 *OPCODE is MOVEM.L
00002712  103C 000E               1729          MOVE.B      #14, D0
00002716  4E4F                    1730          TRAP        #15
00002718  4EB9 00003AB4           1731          JSR         EA_MOVEM
0000271E  4CDF 7FFF               1732          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002722  4E75                    1733          RTS
00002724                          1734  
00002724  48E7 FFFE               1735  ISMOVEMW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
00002728  43F8 1504               1736          LEA         MESSAGEMOVEMW, A1 *OPCODE is MOVEM.W
0000272C  103C 000E               1737          MOVE.B      #14, D0
00002730  4E4F                    1738          TRAP        #15
00002732  4EB9 00003AB4           1739          JSR         EA_MOVEM
00002738  4CDF 7FFF               1740          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000273C  4E75                    1741          RTS
0000273E                          1742  
0000273E  48E7 FFFE               1743  ISLEA   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002742  43F8 1520               1744          LEA         MESSAGELEA, A1  *OPCODE is LEA so display LEA message
00002746  103C 000E               1745          MOVE.B      #14, D0
0000274A  4E4F                    1746          TRAP        #15
0000274C  4EB9 000035CE           1747          JSR         EA_LEA
00002752  4CDF 7FFF               1748          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002756  4E75                    1749          RTS                         ; Exit subroutine
00002758                          1750  
00002758  48E7 FFFE               1751  ISJSR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000275C  43F8 150E               1752          LEA         MESSAGEJSR, A1  *OPCODE is NOP so display NOP message
00002760  103C 000E               1753          MOVE.B      #14, D0
00002764  4E4F                    1754          TRAP        #15
00002766  4EB9 00003506           1755          JSR         EA_JSR
0000276C  4CDF 7FFF               1756          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002770  4E75                    1757          RTS                         ; Exit subroutine
00002772                          1758  
00002772  48E7 FFFE               1759  ISRTS   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002776  43F8 151A               1760          LEA         MESSAGERTS, A1  *OPCODE is RTS
0000277A  103C 000E               1761          MOVE.B      #14, D0
0000277E  4E4F                    1762          TRAP        #15
00002780  548E                    1763          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
00002782  4CDF 7FFF               1764          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002786  4E75                    1765          RTS
00002788                          1766  
00002788  48E7 FFFE               1767  ISCLR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000278C  43F8 1514               1768          LEA         MESSAGECLR, A1  *OPCODE is CLR
00002790  103C 000E               1769          MOVE.B      #14, D0
00002794  4E4F                    1770          TRAP        #15
00002796  4EB9 0000327E           1771          JSR         EA_CLR
0000279C  4CDF 7FFF               1772          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027A0  4E75                    1773          RTS
000027A2                          1774  
000027A2  48E7 FFFE               1775  ISNOP   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027A6  43F8 14AA               1776          LEA         MESSAGENOP, A1  *OPCODE is NOP so display NOP message
000027AA  103C 000E               1777          MOVE.B      #14, D0
000027AE  4E4F                    1778          TRAP        #15
000027B0  548E                    1779          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
000027B2  4CDF 7FFF               1780          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027B6  4E75                    1781          RTS                         ; Exit subroutine
000027B8                          1782  
000027B8  48E7 FFFE               1783  ISMOVEW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027BC  43F8 14B0               1784          LEA         MESSAGEMOVEW, A1 *OPCODE is MOVE.W so display MOVEW message
000027C0  103C 000E               1785          MOVE.B      #14, D0
000027C4  4E4F                    1786          TRAP        #15
000027C6  4EB9 000037B2           1787          JSR         EA_MOVE
000027CC  4CDF 7FFF               1788          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027D0  4E75                    1789          RTS                         ; Exit subroutine
000027D2                          1790  
000027D2  48E7 FFFE               1791  ISMOVEAW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000027D6  43F8 14F0               1792          LEA         MESSAGEMOVEAW, A1 *OPCODE is MOVEA.W so display MOVEA.W message
000027DA  103C 000E               1793          MOVE.B      #14, D0
000027DE  4E4F                    1794          TRAP        #15
000027E0  4EB9 0000398A           1795          JSR         EA_MOVEA
000027E6  4CDF 7FFF               1796          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027EA  4E75                    1797          RTS                         ; Exit subroutine
000027EC                          1798  
000027EC  48E7 FFFE               1799  ISMOVEL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027F0  43F8 14B9               1800          LEA         MESSAGEMOVEL, A1 *OPCODE is MOVE.L so display MOVE.L message
000027F4  103C 000E               1801          MOVE.B      #14, D0
000027F8  4E4F                    1802          TRAP        #15
000027FA  4EB9 000037B2           1803          JSR         EA_MOVE
00002800  4CDF 7FFF               1804          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002804  4E75                    1805          RTS                         ; Exit subroutine
00002806                          1806  
00002806  48E7 FFFE               1807  ISMOVEAL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
0000280A  43F8 14E6               1808          LEA         MESSAGEMOVEAL, A1 *OPCODE is MOVEA.L so display MOVEA.L message
0000280E  103C 000E               1809          MOVE.B      #14, D0
00002812  4E4F                    1810          TRAP        #15
00002814  4EB9 0000398A           1811          JSR         EA_MOVEA
0000281A  4CDF 7FFF               1812          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000281E  4E75                    1813          RTS                         ; Exit subroutine
00002820                          1814  
00002820  48E7 FFFE               1815  ISMOVEB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002824  43F8 14C2               1816          LEA         MESSAGEMOVEB, A1 *OPCODE is MOVE.B so display MOVEB message
00002828  103C 000E               1817          MOVE.B      #14, D0
0000282C  4E4F                    1818          TRAP        #15
0000282E  4EB9 000037B2           1819          JSR         EA_MOVE
00002834  4CDF 7FFF               1820          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002838  4E75                    1821          RTS                         ; Exit subroutine
0000283A                          1822  
0000283A  48E7 FFFE               1823  ISADDIW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000283E  43F8 14CB               1824          LEA         MESSAGEADDIW, A1 *OPCODE is ADDI.W so display ADDI.W message
00002842  103C 000E               1825          MOVE.B      #14, D0
00002846  4E4F                    1826          TRAP        #15
00002848  4EB9 00002D38           1827          JSR         EA_ADDI
0000284E  4CDF 7FFF               1828          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002852  4E75                    1829          RTS                         ; Exit subroutine
00002854                          1830  
00002854  48E7 FFFE               1831  ISADDIL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002858  43F8 14D4               1832          LEA         MESSAGEADDIL, A1 *OPCODE is ADDI.L so display ADDI.L message
0000285C  103C 000E               1833          MOVE.B      #14, D0
00002860  4E4F                    1834          TRAP        #15
00002862  4EB9 00002D38           1835          JSR         EA_ADDI
00002868  4CDF 7FFF               1836          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000286C  4E75                    1837          RTS                         ; Exit subroutine
0000286E                          1838  
0000286E  48E7 FFFE               1839  ISADDIB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002872  43F8 14DD               1840          LEA         MESSAGEADDIB, A1 *OPCODE is ADDI.B so display ADDI.B message
00002876  103C 000E               1841          MOVE.B      #14, D0
0000287A  4E4F                    1842          TRAP        #15
0000287C  4EB9 00002D38           1843          JSR         EA_ADDI
00002882  4CDF 7FFF               1844          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002886  4E75                    1845          RTS                         ; Exit subroutine
00002888                          1846  
00002888                          1847  
00002888                          1848  
00002888                          1849  
00002888                          1850  
00002888                          1851  
00002888                          1852  
00002888                          1853  -------------------- end include --------------------
00002888                          1854      INCLUDE 'EA.X68'
00002888                          1855  
00002888                          1856      INCLUDE 'EAMessages.X68'
00002888                          1857  
00002888= 00                      1858  EA_MSG_NULL         DC.B    0
00002889= 20                      1859  EA_MSG_SPACE        DC.B    ' '
0000288A= 2C 20                   1860  EA_MSG_COMMA        DC.B    ', '
0000288C= 28                      1861  EA_MSG_OPENPAREN    DC.B    '('
0000288D= 29                      1862  EA_MSG_CLOSEPAREN   DC.B    ')'
0000288E= 2D                      1863  EA_MSG_MIN          DC.B    '-'
0000288F= 2B                      1864  EA_MSG_PLUS         DC.B    '+'
00002890= 23                      1865  EA_MSG_HASH         DC.B    '#'
00002891= 24                      1866  EA_MSG_HEX          DC.B    '$'
00002892                          1867  
00002892= 44 30                   1868  EA_MSG_D0           DC.B    'D0'
00002894= 44 31                   1869  EA_MSG_D1           DC.B    'D1'
00002896= 44 32                   1870  EA_MSG_D2           DC.B    'D2'
00002898= 44 33                   1871  EA_MSG_D3           DC.B    'D3'
0000289A= 44 34                   1872  EA_MSG_D4           DC.B    'D4'
0000289C= 44 35                   1873  EA_MSG_D5           DC.B    'D5'
0000289E= 44 36                   1874  EA_MSG_D6           DC.B    'D6'
000028A0= 44 37                   1875  EA_MSG_D7           DC.B    'D7'
000028A2                          1876  
000028A2= 41 30                   1877  EA_MSG_A0           DC.B    'A0'
000028A4= 41 31                   1878  EA_MSG_A1           DC.B    'A1'
000028A6= 41 32                   1879  EA_MSG_A2           DC.B    'A2'
000028A8= 41 33                   1880  EA_MSG_A3           DC.B    'A3'
000028AA= 41 34                   1881  EA_MSG_A4           DC.B    'A4'
000028AC= 41 35                   1882  EA_MSG_A5           DC.B    'A5'
000028AE= 41 36                   1883  EA_MSG_A6           DC.B    'A6'
000028B0= 41 37                   1884  EA_MSG_A7           DC.B    'A7'
000028B2                          1885  
000028B2                          1886  
000028B2                          1887  -------------------- end include --------------------
000028B2                          1888      INCLUDE 'EA_UTIL.X68'
000028B2                          1889  
000028B2                          1890  
000028B2                          1891  EA_UNIMPLEMENTED:
000028B2  548E                    1892      ADDA.L      #$00000002, A6      ; Increment past current opcode word
000028B4                          1893      *print unimplemented message
000028B4  4E75                    1894      RTS
000028B6                          1895  
000028B6                          1896  EA_INVALID:
000028B6  2A4E                    1897      MOVEA.L     A6, A5              ; Copy global pointer
000028B8  548D                    1898      ADDA.L      #$00000002, A5      ; Increment past current opcode word
000028BA                          1899      *print or indicate invalidity
000028BA  4E75                    1900      RTS
000028BC                          1901  
000028BC                          1902  EA_UPDATE_POINTER:
000028BC  BDCD                    1903      CMP.L       A5, A6              ; Check if A5==A6
000028BE  6600 0004               1904      BNE         UPDATE_PTR          ; If NOT equal (a.k.a if any extra operands
000028C2                          1905                                      ; were read, and is already up to date),
000028C2                          1906                                      ; update global with current
000028C2  548D                    1907      ADDA.L      #$00000002, A5      ; Else, increment past current opcode word, then update
000028C4                          1908  UPDATE_PTR:
000028C4  2C4D                    1909      MOVEA.L     A5, A6              ; Update global pointer
000028C6  4E75                    1910      RTS
000028C8                          1911  
000028C8                          1912  EA_COPY_PTR:
000028C8  2A4E                    1913      MOVEA.L     A6, A5              ; Save global pointer
000028CA  4E75                    1914      RTS
000028CC                          1915  
000028CC                          1916  EA_DEFAULT_COMBO:
000028CC  4286                    1917      CLR.L       D6                  ; Clear space for mode bits
000028CE  4287                    1918      CLR.L       D7                  ; Clear space for register bits
000028D0  2216                    1919      MOVE.L      (A6), D1            ; Load opcode to data register 1
000028D2  143C 000A               1920      MOVE.B      #10, D2             ; Clear upper 10 bits of opcode word
000028D6  E569                    1921      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000028D8  143C 000D               1922      MOVE.B      #13, D2             ; 'Right-align' bits 3-5 to determine mode bits
000028DC  E469                    1923      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000028DE  1C01                    1924      MOVE.B      D1, D6              ; Save mode bits to D6
000028E0  2216                    1925      MOVE.L      (A6), D1            ; Reload opcode to data register 1
000028E2  143C 000D               1926      MOVE.B      #13, D2             ; Clear upper 13 bits of opcode word
000028E6  E569                    1927      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000028E8  143C 000D               1928      MOVE.B      #13, D2             ; 'Right-align' bits 0-2 to determine register bits
000028EC  E469                    1929      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000028EE  1E01                    1930      MOVE.B      D1, D7              ; Save register bits to D7
000028F0  4E75                    1931      RTS                             ; Return from subroutine
000028F2                          1932  
000028F2                          1933  EA_OPMODE_COMBO:
000028F2  4286                    1934      CLR.L       D6                  ; Clear space for mode bits
000028F4  4287                    1935      CLR.L       D7                  ; Clear space for register bits
000028F6  2216                    1936      MOVE.L      (A6), D1            ; Load opcode to data register 1
000028F8  143C 0007               1937      MOVE.B      #7, D2              ; Clear upper 7 bits of opcode word
000028FC  E569                    1938      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000028FE  143C 000D               1939      MOVE.B      #13, D2             ; 'Right-align' bits 6-8 to determine opmode bits
00002902  E469                    1940      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002904  1C01                    1941      MOVE.B      D1, D6              ; Save opmode bits to D6
00002906  2216                    1942      MOVE.L      (A6), D1            ; Reload opcode to data register 1
00002908  143C 0004               1943      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
0000290C  E569                    1944      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
0000290E  143C 000D               1945      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register bits
00002912  E469                    1946      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002914  1E01                    1947      MOVE.B      D1, D7              ; Save register bits to D7
00002916  4E75                    1948      RTS                             ; Return from subroutine
00002918                          1949  
00002918                          1950  EA_SIZE_BITS:
00002918  4287                    1951      CLR.L       D7
0000291A  2E16                    1952      MOVE.L      (A6), D7            ; Load opcode to data register 1
0000291C  143C 0008               1953      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00002920  E56F                    1954      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00002922  143C 000E               1955      MOVE.B      #14, D2             ; 'Right-align' bits 6-7 to determine size bits
00002926  E46F                    1956      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00002928  4E75                    1957      RTS
0000292A                          1958  
0000292A                          1959  
0000292A                          1960  EA_PRINT_DN:
0000292A  41F9 00002938           1961      LEA         EA_PRINT_DN_JMP, A0 ; Set index '0' for jump table
00002930  CEFC 0006               1962      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002934  4EF0 7000               1963      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002938                          1964  EA_PRINT_DN_JMP:
00002938  4EF9 00002968           1965      JMP         DN_000 ; D0
0000293E  4EF9 00002968           1966      JMP         DN_001 ; D1
00002944  4EF9 00002968           1967      JMP         DN_010 ; D2
0000294A  4EF9 00002968           1968      JMP         DN_011 ; D3
00002950  4EF9 00002968           1969      JMP         DN_100 ; D4
00002956  4EF9 00002968           1970      JMP         DN_101 ; D5
0000295C  4EF9 00002968           1971      JMP         DN_110 ; D6
00002962  4EF9 00002968           1972      JMP         DN_111 ; D7
00002968                          1973  DN_000: ; D0
00002968                          1974      *MOVE.L      #DREG0, A4
00002968                          1975      *JSR         WRITE_LINE
00002968                          1976  DN_001 ; D1
00002968                          1977  DN_010 ; D2
00002968                          1978  DN_011 ; D3
00002968                          1979  DN_100 ; D4
00002968                          1980  DN_101 ; D5
00002968                          1981  DN_110 ; D6
00002968                          1982  DN_111 ; D7
00002968                          1983  
00002968                          1984  EA_PRINT_DN_END:
00002968  4E75                    1985      RTS
0000296A                          1986  
0000296A                          1987  EA_PRINT_AN:
0000296A  41F9 00002978           1988      LEA         AN_JMP, A0          ; Set index '0' for jump table
00002970  CEFC 0006               1989      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002974  4EF0 7000               1990      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002978                          1991  AN_JMP:
00002978  4EF9 000029A8           1992      JMP         AN_000 ; A0
0000297E  4EF9 000029A8           1993      JMP         AN_001 ; A1
00002984  4EF9 000029A8           1994      JMP         AN_010 ; A2
0000298A  4EF9 000029A8           1995      JMP         AN_011 ; A3
00002990  4EF9 000029A8           1996      JMP         AN_100 ; A4
00002996  4EF9 000029A8           1997      JMP         AN_101 ; A5
0000299C  4EF9 000029A8           1998      JMP         AN_110 ; A6
000029A2  4EF9 000029A8           1999      JMP         AN_111 ; A7
000029A8                          2000  AN_000 ; A0
000029A8                          2001  AN_001 ; A1
000029A8                          2002  AN_010 ; A2
000029A8                          2003  AN_011 ; A3
000029A8                          2004  AN_100 ; A4
000029A8                          2005  AN_101 ; A5
000029A8                          2006  AN_110 ; A6
000029A8                          2007  AN_111 ; A7
000029A8                          2008  
000029A8                          2009  EA_PRINT_AN_END:
000029A8  4E75                    2010      RTS
000029AA                          2011  EA_PRINT_IND:
000029AA  41F9 000029B8           2012      LEA         IND_JMP, A0         ; Set index '0' for jump table
000029B0  CEFC 0006               2013      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000029B4  4EF0 7000               2014      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000029B8                          2015  IND_JMP:
000029B8  4EF9 000029E8           2016      JMP         IND_000 ; (A0)
000029BE  4EF9 000029E8           2017      JMP         IND_001 ; (A1)
000029C4  4EF9 000029E8           2018      JMP         IND_010 ; (A2)
000029CA  4EF9 000029E8           2019      JMP         IND_011 ; (A3)
000029D0  4EF9 000029E8           2020      JMP         IND_100 ; (A4)
000029D6  4EF9 000029E8           2021      JMP         IND_101 ; (A5)
000029DC  4EF9 000029E8           2022      JMP         IND_110 ; (A6)
000029E2  4EF9 000029E8           2023      JMP         IND_111 ; (A7)
000029E8                          2024  IND_000 ; (A0)
000029E8                          2025  IND_001 ; (A1)
000029E8                          2026  IND_010 ; (A2)
000029E8                          2027  IND_011 ; (A3)
000029E8                          2028  IND_100 ; (A4)
000029E8                          2029  IND_101 ; (A5)
000029E8                          2030  IND_110 ; (A6)
000029E8                          2031  IND_111 ; (A7)
000029E8                          2032  
000029E8                          2033  EA_PRINT_IND_END:
000029E8  4E75                    2034      RTS
000029EA                          2035  EA_PRINT_IMM:
000029EA  224D                    2036      MOVEA.L     A5, A1              ; copy pointer to temp
000029EC  5489                    2037      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
000029EE  BA7C 0003               2038      CMP         #3, D5
000029F2  6700 000C               2039      BEQ         PRINT_IMM_L         ; if L, branch
000029F6  3011                    2040      MOVE.W      (A1), D0            ; store value in a register (todo, register tbd)
000029F8                          2041      *print value TODO
000029F8  5489                    2042      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
000029FA  4EF9 00002A04           2043      JMP         PRINT_IMM_END
00002A00                          2044  PRINT_IMM_L:
00002A00  2011                    2045      MOVE.L      (A1), D0            ; store value in a register (todo, register tbd)
00002A02                          2046      *print value TODO
00002A02  5889                    2047      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002A04                          2048  PRINT_IMM_END:
00002A04  2A49                    2049      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002A06  4E75                    2050      RTS
00002A08                          2051  EA_PRINT_POSTINC:
00002A08  41F9 00002A16           2052      LEA         POSTINC_JMP, A0     ; Set index '0' for jump table
00002A0E  CEFC 0006               2053      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002A12  4EF0 7000               2054      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002A16                          2055  POSTINC_JMP:
00002A16  4EF9 00002A46           2056      JMP         POSTINC_000 ; (A0)+
00002A1C  4EF9 00002A46           2057      JMP         POSTINC_001 ; (A1)+
00002A22  4EF9 00002A46           2058      JMP         POSTINC_010 ; (A2)+
00002A28  4EF9 00002A46           2059      JMP         POSTINC_011 ; (A3)+
00002A2E  4EF9 00002A46           2060      JMP         POSTINC_100 ; (A4)+
00002A34  4EF9 00002A46           2061      JMP         POSTINC_101 ; (A5)+
00002A3A  4EF9 00002A46           2062      JMP         POSTINC_110 ; (A6)+
00002A40  4EF9 00002A46           2063      JMP         POSTINC_111 ; (A7)+
00002A46                          2064  POSTINC_000 ; (A0)+
00002A46                          2065  POSTINC_001 ; (A1)+
00002A46                          2066  POSTINC_010 ; (A2)+
00002A46                          2067  POSTINC_011 ; (A3)+
00002A46                          2068  POSTINC_100 ; (A4)+
00002A46                          2069  POSTINC_101 ; (A5)+
00002A46                          2070  POSTINC_110 ; (A6)+
00002A46                          2071  POSTINC_111 ; (A7)+
00002A46                          2072  
00002A46                          2073  EA_PRINT_PI_END:
00002A46  4E75                    2074      RTS
00002A48                          2075  EA_PRINT_PREDEC:
00002A48  41F9 00002A56           2076      LEA         PREDEC_JMP, A0      ; Set index '0' for jump table
00002A4E  CEFC 0006               2077      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002A52  4EF0 7000               2078      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002A56                          2079  PREDEC_JMP:
00002A56  4EF9 00002A86           2080      JMP         PREDEC_000 ; -(A0)
00002A5C  4EF9 00002A86           2081      JMP         PREDEC_001 ; -(A1)
00002A62  4EF9 00002A86           2082      JMP         PREDEC_010 ; -(A2)
00002A68  4EF9 00002A86           2083      JMP         PREDEC_011 ; -(A3)
00002A6E  4EF9 00002A86           2084      JMP         PREDEC_100 ; -(A4)
00002A74  4EF9 00002A86           2085      JMP         PREDEC_101 ; -(A5)
00002A7A  4EF9 00002A86           2086      JMP         PREDEC_110 ; -(A6)
00002A80  4EF9 00002A86           2087      JMP         PREDEC_111 ; -(A7)
00002A86                          2088  PREDEC_000 ; -(A0)
00002A86                          2089  PREDEC_001 ; -(A1)
00002A86                          2090  PREDEC_010 ; -(A2)
00002A86                          2091  PREDEC_011 ; -(A3)
00002A86                          2092  PREDEC_100 ; -(A4)
00002A86                          2093  PREDEC_101 ; -(A5)
00002A86                          2094  PREDEC_110 ; -(A6)
00002A86                          2095  PREDEC_111 ; -(A7)
00002A86                          2096  
00002A86                          2097  EA_PRINT_PD_END:
00002A86  4E75                    2098      RTS
00002A88                          2099  EA_PRINT_ABS_L:
00002A88  224D                    2100      MOVEA.L     A5, A1              ; copy pointer to temp
00002A8A  5489                    2101      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002A8C  2011                    2102      MOVE.L      (A1), D0            ; store longword address to print TODO
00002A8E                          2103      *print value TODO
00002A8E  5889                    2104      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002A90  2A49                    2105      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002A92  4E75                    2106      RTS
00002A94                          2107  EA_PRINT_ABS_W:
00002A94  224D                    2108      MOVEA.L     A5, A1              ; copy pointer to temp
00002A96  5489                    2109      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002A98  2011                    2110      MOVE.L      (A1), D0            ; store word address to print in TODO
00002A9A                          2111      *print value TODO
00002A9A  5489                    2112      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002A9C  2A49                    2113      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002A9E  4E75                    2114      RTS
00002AA0                          2115  
00002AA0                          2116  
00002AA0                          2117  -------------------- end include --------------------
00002AA0                          2118  
00002AA0                          2119  EA_ADD:
00002AA0  48E7 FFFC               2120      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002AA4  4EB8 28C8               2121      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002AA8  4EB8 28F2               2122      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00002AAC  41F9 00002ABA           2123      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
00002AB2  CCFC 0006               2124      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002AB6  4EF0 6000               2125      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002ABA                          2126  ADD_OPMODE:
00002ABA  4EF9 00002AEA           2127      JMP         ADD_OPMODE_000      ; mode 1, byte
00002AC0  4EF9 00002AF4           2128      JMP         ADD_OPMODE_001      ; mode 1, word
00002AC6  4EF9 00002AFE           2129      JMP         ADD_OPMODE_010      ; mode 1, long
00002ACC  4EF9 00002B08           2130      JMP         ADD_OPMODE_011      ; Invalid value
00002AD2  4EF9 00002B12           2131      JMP         ADD_OPMODE_100      ; mode 2, byte
00002AD8  4EF9 00002B1C           2132      JMP         ADD_OPMODE_101      ; mode 2, word
00002ADE  4EF9 00002B26           2133      JMP         ADD_OPMODE_110      ; mode 2, long
00002AE4  4EF9 00002B30           2134      JMP         ADD_OPMODE_111      ; Invalid value
00002AEA                          2135  ADD_OPMODE_000: ; mode 1, byte
00002AEA  1A3C 0001               2136      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002AEE  4EF9 00002B3A           2137      JMP         ADD_MODE_1
00002AF4                          2138  ADD_OPMODE_001: ; mode 1, word
00002AF4  1A3C 0002               2139      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00002AF8  4EF9 00002B3A           2140      JMP         ADD_MODE_1
00002AFE                          2141  ADD_OPMODE_010: ; mode 1, long
00002AFE  1A3C 0003               2142      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00002B02  4EF9 00002B3A           2143      JMP         ADD_MODE_1
00002B08                          2144  ADD_OPMODE_011: ; Invalid value
00002B08  4EB8 28B6               2145      JSR         EA_INVALID
00002B0C  4EF9 00002C4A           2146      JMP         ADD_END
00002B12                          2147  ADD_OPMODE_100: ; mode 2, byte
00002B12  1A3C 0001               2148      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002B16  4EF9 00002B58           2149      JMP         ADD_MODE_2
00002B1C                          2150  ADD_OPMODE_101: ; mode 2, word
00002B1C  1A3C 0001               2151      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002B20  4EF9 00002B58           2152      JMP         ADD_MODE_2
00002B26                          2153  ADD_OPMODE_110: ; mode 2, long
00002B26  1A3C 0001               2154      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002B2A  4EF9 00002B58           2155      JMP         ADD_MODE_2
00002B30                          2156  ADD_OPMODE_111: ; Invalid value
00002B30  4EB8 28B6               2157      JSR         EA_INVALID
00002B34  4EF9 00002C4A           2158      JMP         ADD_END
00002B3A                          2159  ADD_MODE_1:
00002B3A  4280                    2160      CLR.L       D0                  ; Clear data register 0
00002B3C  103C 0001               2161      MOVE.B      #1, D0              ; Save mode number to D0
00002B40  3207                    2162      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00002B42  4EB8 28CC               2163      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002B46  4EB9 00002B72           2164      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002B4C                          2165      *PRINT COMMA TODO
00002B4C  3E01                    2166      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00002B4E  4EB8 292A               2167      JSR         EA_PRINT_DN         ; Print data register
00002B52  4EF9 00002C4A           2168      JMP         ADD_END
00002B58                          2169  ADD_MODE_2:
00002B58  4280                    2170      CLR.L       D0                  ; Clear data register 0
00002B5A  103C 0002               2171      MOVE.B      #2, D0              ; Save mode number to D0
00002B5E  4EB8 292A               2172      JSR         EA_PRINT_DN         ; Print data register
00002B62                          2173      *PRINT COMMA TODO
00002B62  4EB8 28CC               2174      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002B66  4EB9 00002B72           2175      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002B6C  4EF9 00002C4A           2176      JMP         ADD_END
00002B72                          2177  ADD_EVAL_EA:
00002B72  41F9 00002B80           2178      LEA         ADD_MODE, A0        ; Set index '0' for jump table
00002B78  CCFC 0006               2179      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002B7C  4EF0 6000               2180      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002B80                          2181  ADD_MODE:
00002B80  4EF9 00002BB0           2182      JMP         ADD_MODE_000        ; Dn (invalid if opmode 2)
00002B86  4EF9 00002BC2           2183      JMP         ADD_MODE_001        ; An (invalid if opmode 2)
00002B8C  4EF9 00002BD4           2184      JMP         ADD_MODE_010        ; (An)
00002B92  4EF9 00002BDE           2185      JMP         ADD_MODE_011        ; (An)+
00002B98  4EF9 00002BE8           2186      JMP         ADD_MODE_100        ; -(An)
00002B9E  4EF9 00002BF2           2187      JMP         ADD_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00002BA4  4EF9 00002BF8           2188      JMP         ADD_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002BAA  4EF9 00002BFE           2189      JMP         ADD_MODE_111        ; The rest (not all valid, validated by register number)
00002BB0                          2190  ADD_MODE_000: ; Dn (invalid if opmode 2)
00002BB0  B07C 0002               2191      CMP         #2, D0
00002BB4  6700 008E               2192      BEQ         ADD_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00002BB8  4EB8 292A               2193      JSR         EA_PRINT_DN         ; Print data register direct operand
00002BBC  4EF9 00002C42           2194      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002BC2                          2195  ADD_MODE_001: ; An (invalid if opmode 2)
00002BC2  B07C 0002               2196      CMP         #2, D0
00002BC6  6700 007C               2197      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002BCA  4EB8 296A               2198      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002BCE  4EF9 00002C42           2199      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002BD4                          2200  ADD_MODE_010: ; (An)
00002BD4  4EB8 29AA               2201      JSR         EA_PRINT_IND         ; Print address register indirect
00002BD8  4EF9 00002C42           2202      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002BDE                          2203  ADD_MODE_011: ; (An)+
00002BDE  4EB8 2A08               2204      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002BE2  4EF9 00002C42           2205      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002BE8                          2206  ADD_MODE_100: ; -(An)
00002BE8  4EB8 2A48               2207      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002BEC  4EF9 00002C42           2208      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002BF2                          2209  ADD_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002BF2  4EF9 00002C44           2210      JMP         ADD_MODE_INVALID
00002BF8                          2211  ADD_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002BF8  4EF9 00002C44           2212      JMP         ADD_MODE_INVALID
00002BFE                          2213  ADD_MODE_111: ; The rest (not all valid, validated by register number)
00002BFE  BE3C 0000               2214      CMP.B       #$00, D7            ; Test for absolute word address
00002C02  6700 0018               2215      BEQ         ADD_ABS_W
00002C06  BE3C 0001               2216      CMP.B       #$01, D7            ; Test for absolute long address
00002C0A  6700 001A               2217      BEQ         ADD_ABS_L
00002C0E  BE3C 0004               2218      CMP.B       #$04, D7            ; Test for immediate data
00002C12  6700 001C               2219      BEQ         ADD_IMM
00002C16  4EF9 00002C44           2220      JMP         ADD_MODE_INVALID    ; else, invalid
00002C1C                          2221  ADD_ABS_W:
00002C1C  4EB8 2A94               2222      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002C20  4EF9 00002C42           2223      JMP         ADD_MODE_END
00002C26                          2224  ADD_ABS_L:
00002C26  4EB8 2A88               2225      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002C2A  4EF9 00002C42           2226      JMP         ADD_MODE_END
00002C30                          2227  ADD_IMM: ; invalid if opmode is 2
00002C30  B07C 0002               2228      CMP         #2, D0
00002C34  6700 000E               2229      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002C38  4EB8 29EA               2230      JSR         EA_PRINT_IMM        ; Print immediate data
00002C3C  4EF9 00002C42           2231      JMP         ADD_MODE_END
00002C42                          2232  ADD_MODE_END:
00002C42  4E75                    2233      RTS                             ; Finish evaluating EA bits
00002C44                          2234  ADD_MODE_INVALID:
00002C44  4EB8 28B6               2235      JSR         EA_INVALID          ; Opcode word is Invalid
00002C48  4E75                    2236      RTS                             ; Finish evaluating EA bits
00002C4A                          2237  ADD_END:
00002C4A  4EB8 28BC               2238      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00002C4E  4CDF 3FFF               2239      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002C52  4E75                    2240      RTS
00002C54                          2241  
00002C54                          2242  EA_ADDA:
00002C54  48E7 FFFC               2243      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002C58  4EB8 28C8               2244      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002C5C  4EB8 28CC               2245      JSR         EA_DEFAULT_COMBO    ; Mode: D6, register: D7
00002C60  41F9 00002C6E           2246      LEA         ADDA_MODE, A0       ; Set index '0' for jump table
00002C66  CCFC 0006               2247      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002C6A  4EF0 6000               2248      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002C6E                          2249  ADDA_MODE:
00002C6E  4EF9 00002C9E           2250      JMP         ADDA_MODE_000       ; Dn
00002C74  4EF9 00002CA8           2251      JMP         ADDA_MODE_001       ; An
00002C7A  4EF9 00002CB2           2252      JMP         ADDA_MODE_010       ; (An)
00002C80  4EF9 00002CBC           2253      JMP         ADDA_MODE_011       ; (An)+
00002C86  4EF9 00002CC6           2254      JMP         ADDA_MODE_100       ; -(An)
00002C8C  4EF9 00002CD0           2255      JMP         ADDA_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00002C92  4EF9 00002CD6           2256      JMP         ADDA_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002C98  4EF9 00002CDC           2257      JMP         ADDA_MODE_111       ; The rest (not all valid, validated by register number)
00002C9E                          2258  ADDA_MODE_000: ; Dn
00002C9E  4EB8 292A               2259      JSR         EA_PRINT_DN         ; Print data register direct operand
00002CA2  4EF9 00002D26           2260      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002CA8                          2261  ADDA_MODE_001: ; An
00002CA8  4EB8 296A               2262      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002CAC  4EF9 00002D26           2263      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002CB2                          2264  ADDA_MODE_010: ; (An)
00002CB2  4EB8 29AA               2265      JSR         EA_PRINT_IND         ; Print address register indirect
00002CB6  4EF9 00002D26           2266      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002CBC                          2267  ADDA_MODE_011: ; (An)+
00002CBC  4EB8 2A08               2268      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002CC0  4EF9 00002D26           2269      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002CC6                          2270  ADDA_MODE_100: ; -(An)
00002CC6  4EB8 2A48               2271      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002CCA  4EF9 00002D26           2272      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002CD0                          2273  ADDA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002CD0  4EF9 00002D1C           2274      JMP         ADDA_MODE_INVALID
00002CD6                          2275  ADDA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002CD6  4EF9 00002D1C           2276      JMP         ADDA_MODE_INVALID
00002CDC                          2277  ADDA_MODE_111: ; The rest (not all valid, validated by register number)
00002CDC  BE3C 0000               2278      CMP.B       #$00, D7            ; Test for absolute word address
00002CE0  6700 0018               2279      BEQ         ADDA_ABS_W
00002CE4  BE3C 0001               2280      CMP.B       #$01, D7            ; Test for absolute long address
00002CE8  6700 001A               2281      BEQ         ADDA_ABS_L
00002CEC  BE3C 0004               2282      CMP.B       #$04, D7            ; Test for immediate data
00002CF0  6700 001C               2283      BEQ         ADDA_IMM
00002CF4  4EF9 00002D1C           2284      JMP         ADDA_MODE_INVALID   ; Else, invalid
00002CFA                          2285  ADDA_ABS_W:
00002CFA  4EB8 2A94               2286      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002CFE  4EF9 00002D26           2287      JMP         ADDA_MODE_END
00002D04                          2288  ADDA_ABS_L:
00002D04  4EB8 2A88               2289      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002D08  4EF9 00002D26           2290      JMP         ADDA_MODE_END
00002D0E                          2291  ADDA_IMM:
00002D0E  4EB8 28F2               2292      JSR         EA_OPMODE_COMBO     ; Get opmode bits in
00002D12  4EB8 29EA               2293      JSR         EA_PRINT_IMM        ; Print immediate data
00002D16  4EF9 00002D26           2294      JMP         ADDA_MODE_END
00002D1C                          2295  ADDA_MODE_INVALID:
00002D1C  4EB8 28B6               2296      JSR         EA_INVALID          ; Opcode word is Invalid
00002D20  4EF9 00002D2E           2297      JMP         ADDA_END
00002D26                          2298  ADDA_MODE_END:
00002D26                          2299      *PRINT COMMA TODO
00002D26  4EB8 28F2               2300      JSR         EA_OPMODE_COMBO     ; Opmode: D6, register: D7
00002D2A  4EB8 296A               2301      JSR         EA_PRINT_AN         ; Print address register
00002D2E                          2302  ADDA_END:
00002D2E  4EB8 28BC               2303      JSR         EA_UPDATE_POINTER   ; Update global pointer
00002D32  4CDF 3FFF               2304      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002D36  4E75                    2305      RTS
00002D38                          2306  
00002D38                          2307  EA_ADDI:
00002D38  48E7 FFFC               2308      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002D3C  4EB8 28C8               2309      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002D40  4EB8 2918               2310      JSR         EA_SIZE_BITS        ; get size bits in D7
00002D44  BE3C 0000               2311      CMP.B       #$00, D7            ; Test if size: byte
00002D48  6700 001C               2312      BEQ         ADDI_B
00002D4C  BE3C 0001               2313      CMP.B       #$01, D7            ; Test if size: word
00002D50  6700 002E               2314      BEQ         ADDI_W
00002D54  BE3C 0002               2315      CMP.B       #$02, D7            ; Test if size: long
00002D58  6700 0034               2316      BEQ         ADDI_L
00002D5C  4EB8 28B6               2317      JSR         EA_INVALID          ; Else, invalid
00002D60  4EF9 00002E4A           2318      JMP         ADDI_END
00002D66                          2319  ADDI_B:
00002D66  548D                    2320      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002D68  4280                    2321      CLR.L       D0
00002D6A  3015                    2322      MOVE.W      (A5), D0            ; read next word in memory and save
00002D6C  143C 0008               2323      MOVE.B      #8, D2              ; Clear upper 8 bits of operand word
00002D70  E568                    2324      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00002D72  143C 0008               2325      MOVE.B      #8, D2             ; 'Right-align' bits 0-7 to get value
00002D76  E468                    2326      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00002D78                          2327      *print data
00002D78  548D                    2328      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
00002D7A  4EF9 00002D94           2329      JMP         ADDI_GET_DEST
00002D80                          2330  ADDI_W:
00002D80  548D                    2331      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002D82  4280                    2332      CLR.L       D0
00002D84  3015                    2333      MOVE.W      (A5), D0            ; read next word in memory and save
00002D86                          2334      *print data
00002D86  548D                    2335      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
00002D88  4EF9 00002D94           2336      JMP         ADDI_GET_DEST
00002D8E                          2337  ADDI_L:
00002D8E  548D                    2338      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002D90  2015                    2339      MOVE.L      (A5), D0            ; read next two words in memory and save
00002D92  588D                    2340      ADDA.L      #$00000004, A5      ; Increment A5 past operand longword
00002D94                          2341  ADDI_GET_DEST:
00002D94                          2342      *PRINT COMMA
00002D94  4EB8 28CC               2343      JSR         EA_DEFAULT_COMBO    ; get mode bits in D6, register bits in D7
00002D98  41F9 00002DA6           2344      LEA         ADDI_MODE, A0       ; Set index '0' for jump table
00002D9E  CCFC 0006               2345      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002DA2  4EF0 6000               2346      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002DA6                          2347  ADDI_MODE:
00002DA6  4EF9 00002DD6           2348      JMP         ADDI_MODE_000       ; Dn
00002DAC  4EF9 00002DE0           2349      JMP         ADDI_MODE_001       ; Invalid: An
00002DB2  4EF9 00002DEA           2350      JMP         ADDI_MODE_010       ; (An)
00002DB8  4EF9 00002DF4           2351      JMP         ADDI_MODE_011       ; (An)+
00002DBE  4EF9 00002DFE           2352      JMP         ADDI_MODE_100       ; -(An)
00002DC4  4EF9 00002E08           2353      JMP         ADDI_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00002DCA  4EF9 00002E12           2354      JMP         ADDI_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002DD0  4EF9 00002E1C           2355      JMP         ADDI_MODE_111       ; The rest (not all valid, validated by register number)
00002DD6                          2356  ADDI_MODE_000: ; Dn
00002DD6  4EB8 292A               2357      JSR         EA_PRINT_DN         ; Print data register direct operand
00002DDA  4EF9 00002E4A           2358      JMP         ADDI_END
00002DE0                          2359  ADDI_MODE_001: ; Invalid: An
00002DE0  4EB8 28B6               2360      JSR         EA_INVALID          ; Opcode word is Invalid
00002DE4  4EF9 00002E4A           2361      JMP         ADDI_END
00002DEA                          2362  ADDI_MODE_010: ; (An)
00002DEA  4EB8 29AA               2363      JSR         EA_PRINT_IND         ; Print address register indirect
00002DEE  4EF9 00002E4A           2364      JMP         ADDI_END            ; End evaluation of ea mode
00002DF4                          2365  ADDI_MODE_011: ; (An)+
00002DF4  4EB8 2A08               2366      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002DF8  4EF9 00002E4A           2367      JMP         ADDI_END            ; End evaluation of ea mode
00002DFE                          2368  ADDI_MODE_100: ; -(An)
00002DFE  4EB8 2A48               2369      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002E02  4EF9 00002E4A           2370      JMP         ADDI_END            ; End evaluation of ea mode
00002E08                          2371  ADDI_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002E08  4EB8 28B6               2372      JSR         EA_INVALID          ; Opcode word is Invalid
00002E0C  4EF9 00002E4A           2373      JMP         ADDI_END
00002E12                          2374  ADDI_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002E12  4EB8 28B6               2375      JSR         EA_INVALID          ; Opcode word is Invalid
00002E16  4EF9 00002E4A           2376      JMP         ADDI_END
00002E1C                          2377  ADDI_MODE_111: ; The rest (not all valid, validated by register number)
00002E1C  BE3C 0000               2378      CMP.B       #$00, D7            ; Test for absolute word address
00002E20  6700 0014               2379      BEQ         ADDI_ABS_W
00002E24  BE3C 0001               2380      CMP.B       #$01, D7            ; Test for absolute long address
00002E28  6700 0016               2381      BEQ         ADDI_ABS_L
00002E2C  4EB8 28B6               2382      JSR         EA_INVALID          ; else, invalid
00002E30  4EF9 00002E4A           2383      JMP         ADDI_END
00002E36                          2384  ADDI_ABS_W:
00002E36  4EB8 2A94               2385      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002E3A  4EF9 00002E4A           2386      JMP         ADDI_END
00002E40                          2387  ADDI_ABS_L:
00002E40  4EB8 2A88               2388      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002E44  4EF9 00002E4A           2389      JMP         ADDI_END
00002E4A                          2390  ADDI_END:
00002E4A  4EB8 28BC               2391      JSR         EA_UPDATE_POINTER   ; Update global pointer
00002E4E  4CDF 3FFF               2392      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002E52  4E75                    2393      RTS
00002E54                          2394  EA_ADDQ:
00002E54  48E7 FFFC               2395      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002E58  4EB8 28C8               2396      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002E5C  2216                    2397      MOVE.L      (A6), D1            ; Load opcode to data register 1
00002E5E  143C 0004               2398      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00002E62  E569                    2399      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002E64  143C 000D               2400      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine mode bits
00002E68  E469                    2401      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002E6A  B23C 0000               2402      CMP.B       #$00, D1            ; Check for special case (if imm. data is 0, value is actually 8)
00002E6E  6600 0006               2403      BNE         ADDQ_PRINT_IMM      ; If any value other than 0, print the data
00002E72  123C 0008               2404      MOVE.B      #$08, D1            ; Else, the value is 0 and therefore symbolic of the value 8, so replace with the value 8
00002E76                          2405  ADDQ_PRINT_IMM:
00002E76                          2406      *PRINT HASH TODO
00002E76                          2407      *PRINT IMM DATA IN D1 AS BYTE TODO
00002E76                          2408      *PRINT COMMA TODO
00002E76  4EB8 28CC               2409      JSR         EA_DEFAULT_COMBO
00002E7A  41F9 00002E88           2410      LEA         ADDQ_MODE, A0       ; Set index '0' for jump table
00002E80  CCFC 0006               2411      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002E84  4EF0 6000               2412      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002E88                          2413  ADDQ_MODE:
00002E88  4EF9 00002EB8           2414      JMP         ADDQ_MODE_000       ; Dn
00002E8E  4EF9 00002EC2           2415      JMP         ADDQ_MODE_001       ; An
00002E94  4EF9 00002ECC           2416      JMP         ADDQ_MODE_010       ; (An)
00002E9A  4EF9 00002ED6           2417      JMP         ADDQ_MODE_011       ; (An)+
00002EA0  4EF9 00002EE0           2418      JMP         ADDQ_MODE_100       ; -(An)
00002EA6  4EF9 00002EEA           2419      JMP         ADDQ_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00002EAC  4EF9 00002EF4           2420      JMP         ADDQ_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002EB2  4EF9 00002EFE           2421      JMP         ADDQ_MODE_111       ; The rest (not all valid, validated by register number)
00002EB8                          2422  ADDQ_MODE_000: ; Dn
00002EB8  4EB8 292A               2423      JSR         EA_PRINT_DN         ; Print data register direct operand
00002EBC  4EF9 00002F2C           2424      JMP         ADDQ_END            ; End evaluation of ea mode
00002EC2                          2425  ADDQ_MODE_001: ; An
00002EC2  4EB8 296A               2426      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002EC6  4EF9 00002F2C           2427      JMP         ADDQ_END            ; End evaluation of ea mode
00002ECC                          2428  ADDQ_MODE_010: ; (An)
00002ECC  4EB8 29AA               2429      JSR         EA_PRINT_IND         ; Print address register indirect
00002ED0  4EF9 00002F2C           2430      JMP         ADDQ_END            ; End evaluation of ea mode
00002ED6                          2431  ADDQ_MODE_011: ; (An)+
00002ED6  4EB8 2A08               2432      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002EDA  4EF9 00002F2C           2433      JMP         ADDQ_END            ; End evaluation of ea mode
00002EE0                          2434  ADDQ_MODE_100: ; -(An)
00002EE0  4EB8 2A48               2435      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002EE4  4EF9 00002F2C           2436      JMP         ADDQ_END            ; End evaluation of ea mode
00002EEA                          2437  ADDQ_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002EEA  4EB8 28B6               2438      JSR         EA_INVALID          ; Opcode word is Invalid
00002EEE  4EF9 00002F2C           2439      JMP         ADDQ_END
00002EF4                          2440  ADDQ_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002EF4  4EB8 28B6               2441      JSR         EA_INVALID          ; Opcode word is Invalid
00002EF8  4EF9 00002F2C           2442      JMP         ADDQ_END
00002EFE                          2443  ADDQ_MODE_111: ; The rest (not all valid, validated by register number)
00002EFE  BE3C 0000               2444      CMP.B       #$00, D7            ; Test for absolute word address
00002F02  6700 0014               2445      BEQ         ADDQ_ABS_W
00002F06  BE3C 0001               2446      CMP.B       #$01, D7            ; Test for absolute long address
00002F0A  6700 0016               2447      BEQ         ADDQ_ABS_L
00002F0E  4EB8 28B6               2448      JSR         EA_INVALID          ; Opcode word is Invalid
00002F12  4EF9 00002F2C           2449      JMP         ADDQ_END
00002F18                          2450  ADDQ_ABS_W:
00002F18  4EB8 2A94               2451      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002F1C  4EF9 00002F2C           2452      JMP         ADDQ_END
00002F22                          2453  ADDQ_ABS_L:
00002F22  4EB8 2A88               2454      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002F26  4EF9 00002F2C           2455      JMP         ADDQ_END
00002F2C                          2456  
00002F2C                          2457  ADDQ_END:
00002F2C  4EB8 28BC               2458      JSR         EA_UPDATE_POINTER   ; Update global pointer
00002F30  4CDF 3FFF               2459      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002F34  4E75                    2460      RTS
00002F36                          2461  EA_AND:
00002F36  48E7 FFFC               2462      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002F3A  4EB8 28C8               2463      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002F3E  4EB8 28F2               2464      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00002F42  41F8 2ABA               2465      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
00002F46  CCFC 0006               2466      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002F4A  4EF0 6000               2467      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002F4E                          2468  AND_OPMODE:
00002F4E  4EF9 00002F7E           2469      JMP         AND_OPMODE_000      ; mode 1, byte
00002F54  4EF9 00002F88           2470      JMP         AND_OPMODE_001      ; mode 1, word
00002F5A  4EF9 00002F92           2471      JMP         AND_OPMODE_010      ; mode 1, long
00002F60  4EF9 00002F9C           2472      JMP         AND_OPMODE_011      ; Invalid value
00002F66  4EF9 00002FA6           2473      JMP         AND_OPMODE_100      ; mode 2, byte
00002F6C  4EF9 00002FB0           2474      JMP         AND_OPMODE_101      ; mode 2, word
00002F72  4EF9 00002FBA           2475      JMP         AND_OPMODE_110      ; mode 2, long
00002F78  4EF9 00002FC4           2476      JMP         AND_OPMODE_111      ; Invalid value
00002F7E                          2477  AND_OPMODE_000: ; mode 1, byte
00002F7E  1A3C 0001               2478      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002F82  4EF9 00002FCE           2479      JMP         AND_MODE_1
00002F88                          2480  AND_OPMODE_001: ; mode 1, word
00002F88  1A3C 0002               2481      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00002F8C  4EF9 00002FCE           2482      JMP         AND_MODE_1
00002F92                          2483  AND_OPMODE_010: ; mode 1, long
00002F92  1A3C 0003               2484      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00002F96  4EF9 00002FCE           2485      JMP         AND_MODE_1
00002F9C                          2486  AND_OPMODE_011: ; Invalid value
00002F9C  4EB8 28B6               2487      JSR         EA_INVALID
00002FA0  4EF9 000030D2           2488      JMP         AND_END
00002FA6                          2489  AND_OPMODE_100: ; mode 2, byte
00002FA6  1A3C 0001               2490      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002FAA  4EF9 00002FEC           2491      JMP         AND_MODE_2
00002FB0                          2492  AND_OPMODE_101: ; mode 2, word
00002FB0  1A3C 0001               2493      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002FB4  4EF9 00002FEC           2494      JMP         AND_MODE_2
00002FBA                          2495  AND_OPMODE_110: ; mode 2, long
00002FBA  1A3C 0001               2496      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002FBE  4EF9 00002FEC           2497      JMP         AND_MODE_2
00002FC4                          2498  AND_OPMODE_111: ; Invalid value
00002FC4  4EB8 28B6               2499      JSR         EA_INVALID
00002FC8  4EF9 000030D2           2500      JMP         AND_END
00002FCE                          2501  AND_MODE_1:
00002FCE  4280                    2502      CLR.L       D0                  ; Clear data register 0
00002FD0  103C 0001               2503      MOVE.B      #1, D0              ; Save mode number to D0
00002FD4  3207                    2504      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00002FD6  4EB8 28CC               2505      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002FDA  4EB9 00003006           2506      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
00002FE0                          2507      *PRINT COMMA TODO
00002FE0  3E01                    2508      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00002FE2  4EB8 292A               2509      JSR         EA_PRINT_DN         ; Print data register
00002FE6  4EF9 000030D2           2510      JMP         AND_END
00002FEC                          2511  AND_MODE_2:
00002FEC  4280                    2512      CLR.L       D0                  ; Clear data register 0
00002FEE  103C 0002               2513      MOVE.B      #2, D0              ; Save mode number to D0
00002FF2  4EB8 292A               2514      JSR         EA_PRINT_DN         ; Print data register
00002FF6                          2515      *PRINT COMMA TODO
00002FF6  4EB8 28CC               2516      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002FFA  4EB9 00003006           2517      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
00003000  4EF9 000030D2           2518      JMP         AND_END
00003006                          2519  AND_EVAL_EA:
00003006  41F9 00003014           2520      LEA         AND_MODE, A0        ; Set index '0' for jump table
0000300C  CCFC 0006               2521      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003010  4EF0 6000               2522      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003014                          2523  AND_MODE:
00003014  4EF9 00003044           2524      JMP         AND_MODE_000        ; Dn (invalid if opmode 2)
0000301A  4EF9 00003056           2525      JMP         AND_MODE_001        ; Invalid: An
00003020  4EF9 0000305C           2526      JMP         AND_MODE_010        ; (An)
00003026  4EF9 00003066           2527      JMP         AND_MODE_011        ; (An)+
0000302C  4EF9 00003070           2528      JMP         AND_MODE_100        ; -(An)
00003032  4EF9 0000307A           2529      JMP         AND_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003038  4EF9 00003080           2530      JMP         AND_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000303E  4EF9 00003086           2531      JMP         AND_MODE_111        ; The rest (not all valid, validated by register number)
00003044                          2532  AND_MODE_000: ; Dn (invalid if opmode 2)
00003044  B07C 0002               2533      CMP         #2, D0
00003048  6700 0082               2534      BEQ         AND_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
0000304C  4EB8 292A               2535      JSR         EA_PRINT_DN         ; Print data register direct operand
00003050  4EF9 000030CA           2536      JMP         AND_MODE_END        ; End evaluation of ea mode
00003056                          2537  AND_MODE_001: ; Invalid: An
00003056  4EF9 000030CC           2538      JMP         AND_MODE_INVALID
0000305C                          2539  AND_MODE_010: ; (An)
0000305C  4EB8 29AA               2540      JSR         EA_PRINT_IND         ; Print address register indirect
00003060  4EF9 000030CA           2541      JMP         AND_MODE_END        ; End evaluation of ea mode
00003066                          2542  AND_MODE_011: ; (An)+
00003066  4EB8 2A08               2543      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000306A  4EF9 000030CA           2544      JMP         AND_MODE_END        ; End evaluation of ea mode
00003070                          2545  AND_MODE_100: ; -(An)
00003070  4EB8 2A48               2546      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003074  4EF9 000030CA           2547      JMP         AND_MODE_END        ; End evaluation of ea mode
0000307A                          2548  AND_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000307A  4EF9 000030CC           2549      JMP         AND_MODE_INVALID
00003080                          2550  AND_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003080  4EF9 000030CC           2551      JMP         AND_MODE_INVALID
00003086                          2552  AND_MODE_111: ; The rest (not all valid, validated by register number)
00003086  BE3C 0000               2553      CMP.B       #$00, D7            ; Test for absolute word address
0000308A  6700 0018               2554      BEQ         AND_ABS_W
0000308E  BE3C 0001               2555      CMP.B       #$01, D7            ; Test for absolute long address
00003092  6700 001A               2556      BEQ         AND_ABS_L
00003096  BE3C 0004               2557      CMP.B       #$04, D7            ; Test for immediate data
0000309A  6700 001C               2558      BEQ         AND_IMM
0000309E  4EF9 000030CC           2559      JMP         AND_MODE_INVALID    ; else, invalid
000030A4                          2560  AND_ABS_W:
000030A4  4EB8 2A94               2561      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000030A8  4EF9 000030CA           2562      JMP         AND_MODE_END
000030AE                          2563  AND_ABS_L:
000030AE  4EB8 2A88               2564      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000030B2  4EF9 000030CA           2565      JMP         AND_MODE_END
000030B8                          2566  AND_IMM: ; invalid if opmode is 2
000030B8  B07C 0002               2567      CMP         #2, D0
000030BC  6700 000E               2568      BEQ         AND_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
000030C0  4EB8 29EA               2569      JSR         EA_PRINT_IMM        ; Print immediate data
000030C4  4EF9 000030CA           2570      JMP         AND_MODE_END
000030CA                          2571  AND_MODE_END:
000030CA  4E75                    2572      RTS                             ; Finish evaluating EA bits
000030CC                          2573  AND_MODE_INVALID:
000030CC  4EB8 28B6               2574      JSR         EA_INVALID          ; Opcode word is Invalid
000030D0  4E75                    2575      RTS                             ; Finish evaluating EA bits
000030D2                          2576  AND_END:
000030D2  4EB8 28BC               2577      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000030D6  4CDF 3FFF               2578      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000030DA  4E75                    2579      RTS
000030DC                          2580  EA_ASd:
000030DC  48E7 FFFC               2581      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000030E0  4EB8 28C8               2582      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000030E4  4EB8 2918               2583      JSR         EA_SIZE_BITS        ; get size bits in D7
000030E8  BE3C 0003               2584      CMP.B       #$03, D7            ; test if memory shift
000030EC  6700 0042               2585      BEQ         ASd_MEM
000030F0  6000 0002               2586      BRA         ASd_REG             ; else, register shfit
000030F4                          2587  ASd_REG:
000030F4  3E16                    2588      MOVE.W      (A6), D7            ; read opcode word in memory and save,
000030F6                          2589                                      ; (using D7 because EA_PRINT_DN uses D7)
000030F6  143C 0004               2590      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
000030FA  E56F                    2591      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000030FC  143C 000D               2592      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
00003100  E46F                    2593      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003102  3016                    2594      MOVE.W      (A6), D0            ; read opcode word in memory and save
00003104  143C 000A               2595      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
00003108  E568                    2596      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
0000310A  143C 000F               2597      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
0000310E  E468                    2598      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00003110  B03C 0000               2599      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
00003114  6700 000C               2600      BEQ         ASd_REG_COUNT
00003118                          2601  ASd_REG_REG:                        ; Else, count/register field contains register number
00003118  4EB8 292A               2602      JSR         EA_PRINT_DN         ; Print register value, stored in D7
0000311C  4EF9 00003122           2603      JMP         ASd_REG_END         ; Jump to end of ASd_REG
00003122                          2604  ASd_REG_COUNT:
00003122                          2605      *print hash todo
00003122                          2606      *print hex value in D7 as byte todo, continue on to ASd_REG_END
00003122                          2607  ASd_REG_END:
00003122                          2608      *PRINT COMMA todo
00003122  4EB8 28CC               2609      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
00003126  4EB8 292A               2610      JSR         EA_PRINT_DN         ; Print register value in D7
0000312A  4EF9 000031E6           2611      JMP         ASd_END
00003130                          2612  ASd_MEM:
00003130  4EB8 28CC               2613      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003134  41F9 00003142           2614      LEA         ASd_MEM_MODE, A0    ; Set index '0' for jump table
0000313A  CCFC 0006               2615      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000313E  4EF0 6000               2616      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003142                          2617  ASd_MEM_MODE:
00003142  4EF9 00003172           2618      JMP         ASd_MEM_MODE_000     ; Invalid: Dn
00003148  4EF9 0000317C           2619      JMP         ASd_MEM_MODE_001     ; Invalid: An
0000314E  4EF9 00003186           2620      JMP         ASd_MEM_MODE_010     ; (An)
00003154  4EF9 00003190           2621      JMP         ASd_MEM_MODE_011     ; (An)+
0000315A  4EF9 0000319A           2622      JMP         ASd_MEM_MODE_100     ; -(An)
00003160  4EF9 000031A4           2623      JMP         ASd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003166  4EF9 000031AE           2624      JMP         ASd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000316C  4EF9 000031B8           2625      JMP         ASd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00003172                          2626  ASd_MEM_MODE_000: ; Invalid: Dn
00003172  4EB8 28B6               2627      JSR         EA_INVALID          ; Data register direct is invalid mode
00003176  4EF9 000031E6           2628      JMP         ASd_END
0000317C                          2629  ASd_MEM_MODE_001: ; Invalid: An
0000317C  4EB8 28B6               2630      JSR         EA_INVALID          ; Address register direct is invalid mode
00003180  4EF9 000031E6           2631      JMP         ASd_END
00003186                          2632  ASd_MEM_MODE_010: ; (An)
00003186  4EB8 29AA               2633      JSR         EA_PRINT_IND         ; Print address register indirect
0000318A  4EF9 000031E6           2634      JMP         ASd_END
00003190                          2635  ASd_MEM_MODE_011: ; (An)+
00003190  4EB8 2A08               2636      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003194  4EF9 000031E6           2637      JMP         ASd_END
0000319A                          2638  ASd_MEM_MODE_100: ; -(An)
0000319A  4EB8 2A48               2639      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000319E  4EF9 000031E6           2640      JMP         ASd_END         ; Continue with parsing destination operand
000031A4                          2641  ASd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000031A4  4EB8 28B6               2642      JSR         EA_INVALID          ; Opcode word is Invalid
000031A8  4EF9 000031E6           2643      JMP         ASd_END
000031AE                          2644  ASd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000031AE  4EB8 28B6               2645      JSR         EA_INVALID          ; Opcode word is Invalid
000031B2  4EF9 000031E6           2646      JMP         ASd_END
000031B8                          2647  ASd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
000031B8  BE3C 0000               2648      CMP.B       #$00, D7            ; Test for absolute word address
000031BC  6700 0014               2649      BEQ         ASd_MEM_ABS_W
000031C0  BE3C 0001               2650      CMP.B       #$01, D7            ; Test for absolute long address
000031C4  6700 0016               2651      BEQ         ASd_MEM_ABS_L
000031C8  4EB8 28B6               2652      JSR         EA_INVALID          ; Else: invalid
000031CC  4EF9 000031E6           2653      JMP         ASd_END
000031D2                          2654  ASd_MEM_ABS_W:
000031D2  4EB8 2A94               2655      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000031D6  4EF9 000031E6           2656      JMP         ASd_END
000031DC                          2657  ASd_MEM_ABS_L:
000031DC  4EB8 2A88               2658      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000031E0  4EF9 000031E6           2659      JMP         ASd_END
000031E6                          2660  ASd_END:
000031E6  4EB8 28BC               2661      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000031EA  4CDF 3FFF               2662      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000031EE  4E75                    2663      RTS
000031F0                          2664  EA_Bcc: *ONLY BCC (0100), BGT (1110), BLE (1111)
000031F0                          2665          *two's complement and stuff. for later TODO
000031F0  48E7 FFFC               2666      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000031F4  4EB8 28C8               2667      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000031F8  2216                    2668      MOVE.L      (A6), D1            ; Load opcode to data register 1
000031FA  143C 0008               2669      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
000031FE  E569                    2670      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00003200  143C 0008               2671      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine condition
00003204  E469                    2672      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00003206                          2673      *save ultimate address to be printed
00003206  284E                    2674      MOVEA.L     A6, A4              ; Copy global pointer for dislay
00003208  B23C 0000               2675      CMP.B       #$00, D1            ; If value is zero, real value is next word in memory
0000320C  6700 0034               2676      BEQ         BCC_W
00003210  B23C 00FF               2677      CMP.B       #$FF, D1            ; If value is FF, real value is next longword
00003214  6700 004E               2678      BEQ         BCC_L
00003218  4EF9 0000321E           2679      JMP         BCC_B               ; Else, parse lower-order byte of opcode word
0000321E                          2680  BCC_B:
0000321E  548C                    2681      ADDA.L      #$00000002, A4      ; Increment display pointer past opcode word
00003220  3616                    2682      MOVE.W      (A6), D3            ; Save opcode word
00003222  143C 0008               2683      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003226  E56B                    2684      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
00003228  143C 000F               2685      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
0000322C  E46B                    2686      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
0000322E  B63C 0000               2687      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003232  6700 003E               2688      BEQ         BCC_DISPLAY
00003236  0681 FFFFFF00           2689      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
0000323C  4EF9 00003272           2690      JMP         BCC_DISPLAY
00003242                          2691  BCC_W:
00003242  588C                    2692      ADDA.L      #$00000004, A4      ; Increment display pointer past opcode word
00003244                          2693                                      ; and displacement word in memory
00003244  548D                    2694      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
00003246  3615                    2695      MOVE.W      (A5), D3            ; Read word displacement from memory
00003248  548D                    2696      ADDA.L      #$00000002, A5      ; Increment A5 past word read
0000324A  143C 000F               2697      MOVE.B      #15, D2             ; 'Right-align' bit 15 to determine MSB
0000324E  E46B                    2698      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003250  B63C 0000               2699      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003254  6700 001C               2700      BEQ         BCC_DISPLAY
00003258  0681 FFFF0000           2701      ADD.L       #$FFFF0000, D1      ; Else, sign extend data with F
0000325E  4EF9 00003272           2702      JMP         BCC_DISPLAY
00003264                          2703  BCC_L:
00003264  5C8C                    2704      ADDA.L      #$00000006, A4      ; Increment display pointer past opcode word
00003266                          2705                                      ; and displacement longword in memory
00003266  548D                    2706      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
00003268  2215                    2707      MOVE.L      (A5), D1            ; Read longword displacement from memory
0000326A  588D                    2708      ADDA.L      #$00000004, A5      ; Increment A5 past longword read
0000326C  4EF9 00003272           2709      JMP         BCC_DISPLAY
00003272                          2710  BCC_DISPLAY:
00003272  D9C1                    2711      ADDA.L      D1, A4              ; add displacement to current addressing
00003274                          2712      *print address in A4
00003274  4EB8 28BC               2713      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003278  4CDF 3FFF               2714      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000327C  4E75                    2715      RTS
0000327E                          2716  EA_CLR:
0000327E  48E7 FFFC               2717      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003282  4EB8 28C8               2718      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003286  4EB8 28CC               2719      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
0000328A  41F9 00003298           2720      LEA         CLR_MODE, A0        ; Set index '0' for jump table
00003290  CCFC 0006               2721      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003294  4EF0 6000               2722      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003298                          2723  CLR_MODE:
00003298  4EF9 000032C8           2724      JMP         CLR_MODE_000        ; Dn
0000329E  4EF9 000032D2           2725      JMP         CLR_MODE_001        ; Invalid: An
000032A4  4EF9 000032DC           2726      JMP         CLR_MODE_010        ; (An)
000032AA  4EF9 000032E6           2727      JMP         CLR_MODE_011        ; (An)+
000032B0  4EF9 000032F0           2728      JMP         CLR_MODE_100        ; -(An)
000032B6  4EF9 000032FA           2729      JMP         CLR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000032BC  4EF9 00003304           2730      JMP         CLR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000032C2  4EF9 0000330E           2731      JMP         CLR_MODE_111        ; The rest (not all valid, validated by register number)
000032C8                          2732  CLR_MODE_000: ; Dn
000032C8  4EB8 292A               2733      JSR         EA_PRINT_DN
000032CC  4EF9 0000333C           2734      JMP         CLR_END
000032D2                          2735  CLR_MODE_001: ; Invalid: An
000032D2  4EB8 28B6               2736      JSR         EA_INVALID          ; Address register direct is invalid mode
000032D6  4EF9 0000333C           2737      JMP         CLR_END
000032DC                          2738  CLR_MODE_010: ; (An)
000032DC  4EB8 29AA               2739      JSR         EA_PRINT_IND         ; Print address register indirect
000032E0  4EF9 0000333C           2740      JMP         CLR_END
000032E6                          2741  CLR_MODE_011: ; (An)+
000032E6  4EB8 2A08               2742      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000032EA  4EF9 0000333C           2743      JMP         CLR_END
000032F0                          2744  CLR_MODE_100: ; -(An)
000032F0  4EB8 2A48               2745      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000032F4  4EF9 0000333C           2746      JMP         CLR_END             ; Continue with parsing destination operand
000032FA                          2747  CLR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000032FA  4EB8 28B6               2748      JSR         EA_INVALID          ; Opcode word is Invalid
000032FE  4EF9 0000333C           2749      JMP         CLR_END
00003304                          2750  CLR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003304  4EB8 28B6               2751      JSR         EA_INVALID          ; Opcode word is Invalid
00003308  4EF9 0000333C           2752      JMP         CLR_END
0000330E                          2753  CLR_MODE_111: ; The rest (not all valid, validated by register number)
0000330E  BE3C 0000               2754      CMP.B       #$00, D7            ; Test for absolute word address
00003312  6700 0014               2755      BEQ         CLR_ABS_W
00003316  BE3C 0001               2756      CMP.B       #$01, D7            ; Test for absolute long address
0000331A  6700 0016               2757      BEQ         CLR_ABS_L
0000331E  4EB8 28B6               2758      JSR         EA_INVALID          ; Else: invalid
00003322  4EF9 0000333C           2759      JMP         CLR_END
00003328                          2760  CLR_ABS_W:
00003328  4EB8 2A94               2761      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000332C  4EF9 0000333C           2762      JMP         CLR_END
00003332                          2763  CLR_ABS_L:
00003332  4EB8 2A88               2764      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003336  4EF9 0000333C           2765      JMP         CLR_END
0000333C                          2766  CLR_END:
0000333C  4EB8 28BC               2767      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003340  4CDF 3FFF               2768      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003344  4E75                    2769      RTS
00003346                          2770  EA_CMP:
00003346  48E7 FFFC               2771      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000334A  4EB8 28C8               2772      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000334E  4EB8 28CC               2773      JSR         EA_DEFAULT_COMBO
00003352  41F9 00003360           2774      LEA         CMP_MODE, A0       ; Set index '0' for jump table
00003358  CCFC 0006               2775      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000335C  4EF0 6000               2776      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003360                          2777  CMP_MODE:
00003360  4EF9 00003390           2778      JMP         CMP_MODE_000       ; Dn
00003366  4EF9 0000339A           2779      JMP         CMP_MODE_001       ; An
0000336C  4EF9 000033A4           2780      JMP         CMP_MODE_010       ; (An)
00003372  4EF9 000033AE           2781      JMP         CMP_MODE_011       ; (An)+
00003378  4EF9 000033B8           2782      JMP         CMP_MODE_100       ; -(An)
0000337E  4EF9 000033C2           2783      JMP         CMP_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00003384  4EF9 000033CC           2784      JMP         CMP_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000338A  4EF9 000033D6           2785      JMP         CMP_MODE_111       ; The rest (not all valid, validated by register number)
00003390                          2786  CMP_MODE_000: ; Dn
00003390  4EB8 292A               2787      JSR         EA_PRINT_DN         ; Print data register direct operand
00003394  4EF9 00003404           2788      JMP         CMP_MODE_END        ; End evaluation of ea mode
0000339A                          2789  CMP_MODE_001: ; An
0000339A  4EB8 296A               2790      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
0000339E  4EF9 00003404           2791      JMP         CMP_MODE_END        ; End evaluation of ea mode
000033A4                          2792  CMP_MODE_010: ; (An)
000033A4  4EB8 29AA               2793      JSR         EA_PRINT_IND        ; Print address register indirect
000033A8  4EF9 00003404           2794      JMP         CMP_MODE_END        ; End evaluation of ea mode
000033AE                          2795  CMP_MODE_011: ; (An)+
000033AE  4EB8 2A08               2796      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000033B2  4EF9 00003404           2797      JMP         CMP_MODE_END        ; End evaluation of ea mode
000033B8                          2798  CMP_MODE_100: ; -(An)
000033B8  4EB8 2A48               2799      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000033BC  4EF9 00003404           2800      JMP         CMP_MODE_END        ; End evaluation of ea mode
000033C2                          2801  CMP_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000033C2  4EB8 28B6               2802      JSR         EA_INVALID          ; Opcode word is Invalid
000033C6  4EF9 0000340C           2803      JMP         CMP_END
000033CC                          2804  CMP_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000033CC  4EB8 28B6               2805      JSR         EA_INVALID          ; Opcode word is Invalid
000033D0  4EF9 0000340C           2806      JMP         CMP_END
000033D6                          2807  CMP_MODE_111: ; The rest (not all valid, validated by register number)
000033D6  BE3C 0000               2808      CMP.B       #$00, D7            ; Test for absolute word address
000033DA  6700 0014               2809      BEQ         CMP_ABS_W
000033DE  BE3C 0001               2810      CMP.B       #$01, D7            ; Test for absolute long address
000033E2  6700 0016               2811      BEQ         CMP_ABS_L
000033E6  4EB8 28B6               2812      JSR         EA_INVALID          ; Opcode word is Invalid
000033EA  4EF9 0000340C           2813      JMP         CMP_END
000033F0                          2814  CMP_ABS_W:
000033F0  4EB8 2A94               2815      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000033F4  4EF9 00003404           2816      JMP         CMP_MODE_END
000033FA                          2817  CMP_ABS_L:
000033FA  4EB8 2A88               2818      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000033FE  4EF9 00003404           2819      JMP         CMP_MODE_END
00003404                          2820  CMP_MODE_END:
00003404  4EB8 28F2               2821      JSR         EA_OPMODE_COMBO     ; get register bits in D7, opmode bits not used
00003408  4EB8 292A               2822      JSR         EA_PRINT_DN         ; print register
0000340C                          2823  CMP_END:
0000340C  4EB8 28BC               2824      JSR         EA_UPDATE_POINTER   ; Update global pointer
00003410  4CDF 3FFF               2825      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003414  4E75                    2826      RTS
00003416                          2827  EA_DIVU_W:
00003416  48E7 FFFC               2828      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000341A  4EB8 28C8               2829      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000341E  4EB8 28CC               2830      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003422  41F9 00003430           2831      LEA         DIVU_W_MODE, A0       ; Set index '0' for jump table
00003428  CCFC 0006               2832      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000342C  4EF0 6000               2833      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003430                          2834  DIVU_W_MODE:
00003430  4EF9 00003460           2835      JMP         DIVU_W_MODE_000     ; Dn
00003436  4EF9 0000346A           2836      JMP         DIVU_W_MODE_001     ; Invalid: An
0000343C  4EF9 00003474           2837      JMP         DIVU_W_MODE_010     ; (An)
00003442  4EF9 0000347E           2838      JMP         DIVU_W_MODE_011     ; (An)+
00003448  4EF9 00003488           2839      JMP         DIVU_W_MODE_100     ; -(An)
0000344E  4EF9 00003492           2840      JMP         DIVU_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003454  4EF9 0000349C           2841      JMP         DIVU_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000345A  4EF9 000034A6           2842      JMP         DIVU_W_MODE_111     ; The rest (not all valid, validated by register number)
00003460                          2843  DIVU_W_MODE_000: ; Dn
00003460  4EB8 292A               2844      JSR         EA_PRINT_DN         ; Print data register direct operand
00003464  4EF9 000034EA           2845      JMP         DIVU_W_DEST         ; Go to: print destination operand
0000346A                          2846  DIVU_W_MODE_001: ; Invalid: An
0000346A  4EB8 28B6               2847      JSR         EA_INVALID          ; Address register direct is invalid mode
0000346E  4EF9 000034FC           2848      JMP         DIVU_W_END
00003474                          2849  DIVU_W_MODE_010: ; (An)
00003474  4EB8 29AA               2850      JSR         EA_PRINT_IND         ; Print address register indirect
00003478  4EF9 000034EA           2851      JMP         DIVU_W_DEST
0000347E                          2852  DIVU_W_MODE_011: ; (An)+
0000347E  4EB8 2A08               2853      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003482  4EF9 000034EA           2854      JMP         DIVU_W_DEST
00003488                          2855  DIVU_W_MODE_100: ; -(An)
00003488  4EB8 2A48               2856      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000348C  4EF9 000034EA           2857      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
00003492                          2858  DIVU_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003492  4EB8 28B6               2859      JSR         EA_INVALID          ; Opcode word is Invalid
00003496  4EF9 000034FC           2860      JMP         DIVU_W_END
0000349C                          2861  DIVU_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000349C  4EB8 28B6               2862      JSR         EA_INVALID          ; Opcode word is Invalid
000034A0  4EF9 000034FC           2863      JMP         DIVU_W_END
000034A6                          2864  DIVU_W_MODE_111: ; The rest (not all valid, validated by register number)
000034A6  BE3C 0000               2865      CMP.B       #$00, D7            ; Test for absolute word address
000034AA  6700 001C               2866      BEQ         DIVU_W_ABS_W
000034AE  BE3C 0001               2867      CMP.B       #$01, D7            ; Test for absolute long address
000034B2  6700 001E               2868      BEQ         DIVU_W_ABS_L
000034B6  BE3C 0004               2869      CMP.B       #$04, D7            ; Test for immediate data
000034BA  6700 0020               2870      BEQ         DIVU_W_IMM
000034BE  4EB8 28B6               2871      JSR         EA_INVALID          ; Else: invalid
000034C2  4EF9 000034FC           2872      JMP         DIVU_W_END
000034C8                          2873  DIVU_W_ABS_W:
000034C8  4EB8 2A94               2874      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000034CC  4EF9 000034EA           2875      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000034D2                          2876  DIVU_W_ABS_L:
000034D2  4EB8 2A88               2877      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000034D6  4EF9 000034EA           2878      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000034DC                          2879  DIVU_W_IMM:
000034DC  1A3C 0002               2880      MOVE.B      #2, D5              ; Size is word
000034E0  4EB8 29EA               2881      JSR         EA_PRINT_IMM        ; Print immediate data
000034E4  4EF9 000034EA           2882      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000034EA                          2883  DIVU_W_DEST:
000034EA                          2884      *print EA_MSG_COMMA
000034EA                          2885      *Get destination register
000034EA  3E16                    2886      MOVE.W      (A6), D7            ; Load word at current pointer to D1
000034EC  143C 0004               2887      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
000034F0  E56F                    2888      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000034F2  143C 000D               2889      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
000034F6  E46F                    2890      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000034F8  4EB8 292A               2891      JSR         EA_PRINT_DN         ; Print data register direct operand
000034FC                          2892  DIVU_W_END:
000034FC  4EB8 28BC               2893      JSR         EA_UPDATE_POINTER   ; Update global pointer
00003500  4CDF 3FFF               2894      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003504  4E75                    2895      RTS
00003506                          2896  EA_JSR:
00003506  48E7 FFFC               2897      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000350A  4EB8 28C8               2898      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
0000350E  4EB8 28CC               2899      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003512  41F9 00003520           2900      LEA         JSR_MODE, A0        ; Set index '0' for jump table
00003518  CCFC 0006               2901      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000351C  4EF0 6000               2902      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003520                          2903  JSR_MODE:
00003520  4EF9 00003550           2904      JMP         JSR_MODE_000        ; Invalid: Dn
00003526  4EF9 0000355A           2905      JMP         JSR_MODE_001        ; Invalid: An
0000352C  4EF9 00003564           2906      JMP         JSR_MODE_010        ; (An)
00003532  4EF9 0000356E           2907      JMP         JSR_MODE_011        ; Invalid: (An)+
00003538  4EF9 00003578           2908      JMP         JSR_MODE_100        ; Invalid: -(An)
0000353E  4EF9 00003582           2909      JMP         JSR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003544  4EF9 0000358C           2910      JMP         JSR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000354A  4EF9 00003596           2911      JMP         JSR_MODE_111        ; The rest (not all valid, validated by register number)
00003550                          2912  JSR_MODE_000: ; Invalid: Dn
00003550  4EB8 28B6               2913      JSR         EA_INVALID          ; Data register direct is invalid mode
00003554  4EF9 000035C4           2914      JMP         JSR_END
0000355A                          2915  JSR_MODE_001: ; Invalid: An
0000355A  4EB8 28B6               2916      JSR         EA_INVALID          ; Address register direct is invalid mode
0000355E  4EF9 000035C4           2917      JMP         JSR_END
00003564                          2918  JSR_MODE_010: ; (An)
00003564  4EB8 29AA               2919      JSR         EA_PRINT_IND         ; Print address register indirect
00003568  4EF9 000035C4           2920      JMP         JSR_END
0000356E                          2921  JSR_MODE_011: ; (An)+
0000356E  4EB8 28B6               2922      JSR         EA_INVALID          ; Address register indirect w/ post increment is invalid mode
00003572  4EF9 000035C4           2923      JMP         JSR_END
00003578                          2924  JSR_MODE_100: ; -(An)
00003578  4EB8 28B6               2925      JSR         EA_INVALID          ; Address register indirect w/ pre decrement is invalid mode
0000357C  4EF9 000035C4           2926      JMP         JSR_END
00003582                          2927  JSR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003582  4EB8 28B6               2928      JSR         EA_INVALID          ; Opcode word is Invalid
00003586  4EF9 000035C4           2929      JMP         JSR_END
0000358C                          2930  JSR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000358C  4EB8 28B6               2931      JSR         EA_INVALID          ; Opcode word is Invalid
00003590  4EF9 000035C4           2932      JMP         JSR_END
00003596                          2933  JSR_MODE_111: ; The rest (not all valid, validated by register number)
00003596  BE3C 0000               2934      CMP.B       #$00, D7            ; Test for absolute word address
0000359A  6700 0014               2935      BEQ         JSR_ABS_W
0000359E  BE3C 0001               2936      CMP.B       #$01, D7            ; Test for absolute long address
000035A2  6700 0016               2937      BEQ         JSR_ABS_L
000035A6  4EB8 28B6               2938      JSR         EA_INVALID          ; Else: invalid
000035AA  4EF9 000035C4           2939      JMP         JSR_END
000035B0                          2940  JSR_ABS_W:
000035B0  4EB8 2A94               2941      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000035B4  4EF9 000035C4           2942      JMP         JSR_END
000035BA                          2943  JSR_ABS_L:
000035BA  4EB8 2A88               2944      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000035BE  4EF9 000035C4           2945      JMP         JSR_END
000035C4                          2946  JSR_END:
000035C4  4EB8 28BC               2947      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000035C8  4CDF 3FFF               2948      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000035CC  4E75                    2949      RTS
000035CE                          2950  EA_LEA:
000035CE  48E7 FFFC               2951      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000035D2  4EB8 28C8               2952      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000035D6  4EB8 28CC               2953      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000035DA  41F9 000035E8           2954      LEA         LEA_MODE, A0        ; Set index '0' for jump table
000035E0  CCFC 0006               2955      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000035E4  4EF0 6000               2956      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000035E8                          2957  LEA_MODE:
000035E8  4EF9 00003618           2958      JMP         LEA_MODE_000        ; Dn
000035EE  4EF9 00003622           2959      JMP         LEA_MODE_001        ; Invalid: An
000035F4  4EF9 0000362C           2960      JMP         LEA_MODE_010        ; (An)
000035FA  4EF9 00003636           2961      JMP         LEA_MODE_011        ; (An)+
00003600  4EF9 00003640           2962      JMP         LEA_MODE_100        ; -(An)
00003606  4EF9 0000364A           2963      JMP         LEA_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
0000360C  4EF9 00003654           2964      JMP         LEA_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003612  4EF9 0000365E           2965      JMP         LEA_MODE_111        ; The rest (not all valid, validated by register number)
00003618                          2966  LEA_MODE_000: ; Invalid: Dn
00003618  4EB8 28B6               2967      JSR         EA_INVALID          ; Data register direct is invalid mode
0000361C  4EF9 00003694           2968      JMP         LEA_END
00003622                          2969  LEA_MODE_001: ; Invalid: An
00003622  4EB8 28B6               2970      JSR         EA_INVALID          ; Address register direct is invalid mode
00003626  4EF9 00003694           2971      JMP         LEA_END
0000362C                          2972  LEA_MODE_010: ; (An)
0000362C  4EB8 29AA               2973      JSR         EA_PRINT_IND         ; Print address register indirect
00003630  4EF9 0000368C           2974      JMP         LEA_DEST
00003636                          2975  LEA_MODE_011: ; (An)+
00003636  4EB8 28B6               2976      JSR         EA_INVALID          ; Address register indirect with post increment is invalid
0000363A  4EF9 00003694           2977      JMP         LEA_END
00003640                          2978  LEA_MODE_100: ; -(An)
00003640  4EB8 28B6               2979      JSR         EA_INVALID          ; Adress register indirect with pre decrement is invalid
00003644  4EF9 00003694           2980      JMP         LEA_END             ; Continue with parsing destination operand
0000364A                          2981  LEA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000364A  4EB8 28B6               2982      JSR         EA_INVALID          ; Opcode word is Invalid
0000364E  4EF9 00003694           2983      JMP         LEA_END
00003654                          2984  LEA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003654  4EB8 28B6               2985      JSR         EA_INVALID          ; Opcode word is Invalid
00003658  4EF9 00003694           2986      JMP         LEA_END
0000365E                          2987  LEA_MODE_111: ; The rest (not all valid, validated by register number)
0000365E  BE3C 0000               2988      CMP.B       #$00, D7            ; Test for absolute word address
00003662  6700 0014               2989      BEQ         LEA_ABS_W
00003666  BE3C 0001               2990      CMP.B       #$01, D7            ; Test for absolute long address
0000366A  6700 0016               2991      BEQ         LEA_ABS_L
0000366E  4EB8 28B6               2992      JSR         EA_INVALID          ; Else: invalid
00003672  4EF9 0000368C           2993      JMP         LEA_DEST
00003678                          2994  LEA_ABS_W:
00003678  4EB8 2A94               2995      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000367C  4EF9 0000368C           2996      JMP         LEA_DEST
00003682                          2997  LEA_ABS_L:
00003682  4EB8 2A88               2998      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003686  4EF9 0000368C           2999      JMP         LEA_DEST
0000368C                          3000  LEA_DEST:
0000368C                          3001      *print comma TODO
0000368C  4EB8 28F2               3002      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, opmode bits unused
00003690  4EB8 296A               3003      JSR         EA_PRINT_AN         ; Print address register
00003694                          3004  LEA_END:
00003694  4EB8 28BC               3005      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003698  4CDF 3FFF               3006      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000369C  4E75                    3007      RTS
0000369E                          3008  EA_LSd:
0000369E  48E7 FFFC               3009      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000036A2  4EB8 28C8               3010      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000036A6  4EB8 2918               3011      JSR         EA_SIZE_BITS        ; get size bits in D7
000036AA  BE3C 0003               3012      CMP.B       #$03, D7            ; test if memory shift
000036AE  6700 0042               3013      BEQ         LSd_MEM
000036B2  6000 0002               3014      BRA         LSd_REG             ; else, register shfit
000036B6                          3015  LSd_REG:
000036B6  3E16                    3016      MOVE.W      (A6), D7            ; read opcode word in memory and save,
000036B8                          3017                                      ; (using D7 because EA_PRINT_DN uses D7)
000036B8  143C 0004               3018      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
000036BC  E56F                    3019      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000036BE  143C 000D               3020      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
000036C2  E46F                    3021      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000036C4  3016                    3022      MOVE.W      (A6), D0            ; read opcode word in memory and save
000036C6  143C 000A               3023      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
000036CA  E568                    3024      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
000036CC  143C 000F               3025      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
000036D0  E468                    3026      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
000036D2  B03C 0000               3027      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
000036D6  6700 000C               3028      BEQ         LSd_REG_COUNT
000036DA                          3029  LSd_REG_REG:                        ; Else, count/register field contains register number
000036DA  4EB8 292A               3030      JSR         EA_PRINT_DN         ; Print register value, stored in D7
000036DE  4EF9 000036E4           3031      JMP         LSd_REG_END         ; Jump to end of LSd_REG
000036E4                          3032  LSd_REG_COUNT:
000036E4                          3033      *print hash todo
000036E4                          3034      *print hex value in D7 as byte todo, continue on to LSd_REG_END
000036E4                          3035  LSd_REG_END:
000036E4                          3036      *PRINT COMMA todo
000036E4  4EB8 28CC               3037      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
000036E8  4EB8 292A               3038      JSR         EA_PRINT_DN         ; Print register value in D7
000036EC  4EF9 000037A8           3039      JMP         LSd_END
000036F2                          3040  LSd_MEM:
000036F2  4EB8 28CC               3041      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000036F6  41F9 00003704           3042      LEA         LSd_MEM_MODE, A0    ; Set index '0' for jump table
000036FC  CCFC 0006               3043      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003700  4EF0 6000               3044      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003704                          3045  LSd_MEM_MODE:
00003704  4EF9 00003734           3046      JMP         LSd_MEM_MODE_000     ; Invalid: Dn
0000370A  4EF9 0000373E           3047      JMP         LSd_MEM_MODE_001     ; Invalid: An
00003710  4EF9 00003748           3048      JMP         LSd_MEM_MODE_010     ; (An)
00003716  4EF9 00003752           3049      JMP         LSd_MEM_MODE_011     ; (An)+
0000371C  4EF9 0000375C           3050      JMP         LSd_MEM_MODE_100     ; -(An)
00003722  4EF9 00003766           3051      JMP         LSd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003728  4EF9 00003770           3052      JMP         LSd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000372E  4EF9 0000377A           3053      JMP         LSd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00003734                          3054  LSd_MEM_MODE_000: ; Invalid: Dn
00003734  4EB8 28B6               3055      JSR         EA_INVALID          ; Data register direct is invalid mode
00003738  4EF9 000037A8           3056      JMP         LSd_END
0000373E                          3057  LSd_MEM_MODE_001: ; Invalid: An
0000373E  4EB8 28B6               3058      JSR         EA_INVALID          ; Address register direct is invalid mode
00003742  4EF9 000037A8           3059      JMP         LSd_END
00003748                          3060  LSd_MEM_MODE_010: ; (An)
00003748  4EB8 29AA               3061      JSR         EA_PRINT_IND         ; Print address register indirect
0000374C  4EF9 000037A8           3062      JMP         LSd_END
00003752                          3063  LSd_MEM_MODE_011: ; (An)+
00003752  4EB8 2A08               3064      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003756  4EF9 000037A8           3065      JMP         LSd_END
0000375C                          3066  LSd_MEM_MODE_100: ; -(An)
0000375C  4EB8 2A48               3067      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003760  4EF9 000037A8           3068      JMP         LSd_END         ; Continue with parsing destination operand
00003766                          3069  LSd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003766  4EB8 28B6               3070      JSR         EA_INVALID          ; Opcode word is Invalid
0000376A  4EF9 000037A8           3071      JMP         LSd_END
00003770                          3072  LSd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003770  4EB8 28B6               3073      JSR         EA_INVALID          ; Opcode word is Invalid
00003774  4EF9 000037A8           3074      JMP         LSd_END
0000377A                          3075  LSd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
0000377A  BE3C 0000               3076      CMP.B       #$00, D7            ; Test for absolute word address
0000377E  6700 0014               3077      BEQ         LSd_MEM_ABS_W
00003782  BE3C 0001               3078      CMP.B       #$01, D7            ; Test for absolute long address
00003786  6700 0016               3079      BEQ         LSd_MEM_ABS_L
0000378A  4EB8 28B6               3080      JSR         EA_INVALID          ; Else: invalid
0000378E  4EF9 000037A8           3081      JMP         LSd_END
00003794                          3082  LSd_MEM_ABS_W:
00003794  4EB8 2A94               3083      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003798  4EF9 000037A8           3084      JMP         LSd_END
0000379E                          3085  LSd_MEM_ABS_L:
0000379E  4EB8 2A88               3086      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000037A2  4EF9 000037A8           3087      JMP         LSd_END
000037A8                          3088  LSd_END:
000037A8  4EB8 28BC               3089      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000037AC  4CDF 3FFF               3090      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000037B0  4E75                    3091      RTS
000037B2                          3092  EA_MOVE:
000037B2  48E7 FFFC               3093      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000037B6  4EB8 28C8               3094      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000037BA  2A16                    3095      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
000037BC  143C 0002               3096      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
000037C0  E56D                    3097      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
000037C2  143C 000E               3098      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
000037C6  E46D                    3099      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
000037C8  BA3C 0003               3100      CMP.B       #$03, D5            ; if size bits are 11, correct D5
000037CC                          3101                                      ; to 10 for use with immediate data subroutine
000037CC  6700 0010               3102      BEQ         MOVE_ADJUST_W
000037D0  BA3C 0002               3103      CMP.B       #$02, D5            ; if size bits are 10, correct D5
000037D4                          3104                                      ; to 11 for use with immediate data subroutine
000037D4  6700 0012               3105      BEQ         MOVE_ADJUST_L
000037D8  4EF9 000037F2           3106      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
000037DE                          3107  MOVE_ADJUST_W:
000037DE  1A3C 0002               3108      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
000037E2  4EF9 000037F2           3109      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
000037E8                          3110  MOVE_ADJUST_L:
000037E8  1A3C 0003               3111      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
000037EC  4EF9 000037F2           3112      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
000037F2                          3113  MOVE_SOURCE:
000037F2  48E7 FFFC               3114      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000037F6  4EB8 28C8               3115      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000037FA  4EB8 28CC               3116      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000037FE  41F9 0000380C           3117      LEA         MOVE_SRC_MODE, A0   ; Set index '0' for jump table
00003804  CCFC 0006               3118      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003808  4EF0 6000               3119      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000380C                          3120  MOVE_SRC_MODE:
0000380C  4EF9 0000383C           3121      JMP         MOVE_SRC_MODE_000   ; Dn
00003812  4EF9 00003846           3122      JMP         MOVE_SRC_MODE_001   ; An
00003818  4EF9 00003850           3123      JMP         MOVE_SRC_MODE_010   ; (An)
0000381E  4EF9 0000385A           3124      JMP         MOVE_SRC_MODE_011   ; (An)+
00003824  4EF9 00003864           3125      JMP         MOVE_SRC_MODE_100   ; -(An)
0000382A  4EF9 0000386E           3126      JMP         MOVE_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003830  4EF9 00003878           3127      JMP         MOVE_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003836  4EF9 00003882           3128      JMP         MOVE_SRC_MODE_111   ; The rest (not all valid, validated by register number)
0000383C                          3129  MOVE_SRC_MODE_000: ; Dn
0000383C  4EB8 292A               3130      JSR         EA_PRINT_DN         ; Print data register in D7
00003840  4EF9 000038C2           3131      JMP         MOVE_DESTINATION
00003846                          3132  MOVE_SRC_MODE_001: ; Invalid: An
00003846  4EB8 296A               3133      JSR         EA_PRINT_AN         ; Print address register in D7
0000384A  4EF9 000038C2           3134      JMP         MOVE_DESTINATION
00003850                          3135  MOVE_SRC_MODE_010: ; (An)
00003850  4EB8 29AA               3136      JSR         EA_PRINT_IND         ; Print address register indirect
00003854  4EF9 000038C2           3137      JMP         MOVE_DESTINATION
0000385A                          3138  MOVE_SRC_MODE_011: ; (An)+
0000385A  4EB8 2A08               3139      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000385E  4EF9 000038C2           3140      JMP         MOVE_DESTINATION
00003864                          3141  MOVE_SRC_MODE_100: ; -(An)
00003864  4EB8 2A48               3142      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003868  4EF9 000038C2           3143      JMP         MOVE_DESTINATION    ; Continue with parsing destination operand
0000386E                          3144  MOVE_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000386E  4EB8 28B6               3145      JSR         EA_INVALID          ; Opcode word is Invalid
00003872  4EF9 00003980           3146      JMP         MOVE_END
00003878                          3147  MOVE_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003878  4EB8 28B6               3148      JSR         EA_INVALID          ; Opcode word is Invalid
0000387C  4EF9 00003980           3149      JMP         MOVE_END
00003882                          3150  MOVE_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003882  BE3C 0000               3151      CMP.B       #$00, D7            ; Test for absolute word address
00003886  6700 001C               3152      BEQ         MOVE_SRC_ABS_W
0000388A  BE3C 0001               3153      CMP.B       #$01, D7            ; Test for absolute long address
0000388E  6700 001E               3154      BEQ         MOVE_SRC_ABS_L
00003892  BE3C 0004               3155      CMP.B       #$04, D7            ; Test for immediate data
00003896  6700 0020               3156      BEQ         MOVE_SRC_IMM
0000389A  4EB8 28B6               3157      JSR         EA_INVALID          ; Else: invalid
0000389E  4EF9 00003980           3158      JMP         MOVE_END
000038A4                          3159  MOVE_SRC_ABS_W:
000038A4  4EB8 2A94               3160      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000038A8  4EF9 000038C2           3161      JMP         MOVE_DESTINATION
000038AE                          3162  MOVE_SRC_ABS_L:
000038AE  4EB8 2A88               3163      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000038B2  4EF9 000038C2           3164      JMP         MOVE_DESTINATION
000038B8                          3165  MOVE_SRC_IMM:
000038B8  4EB8 29EA               3166      JSR         EA_PRINT_IMM        ; Print immediate data
000038BC  4EF9 000038C2           3167      JMP         MOVE_DESTINATION
000038C2                          3168  MOVE_DESTINATION:
000038C2                          3169      *PRINT COMMA TODO
000038C2  48E7 FFFC               3170      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000038C6  4EB8 28C8               3171      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000038CA  4EB8 28F2               3172      JSR         EA_OPMODE_COMBO     ; mode: D6, register: D7 (destination bits)
000038CE  41F9 000038DC           3173      LEA         MOVE_DST_MODE, A0   ; Set index '0' for jump table
000038D4  CCFC 0006               3174      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000038D8  4EF0 6000               3175      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000038DC                          3176  MOVE_DST_MODE:
000038DC  4EF9 0000390C           3177      JMP         MOVE_DST_MODE_000   ; Dn
000038E2  4EF9 00003916           3178      JMP         MOVE_DST_MODE_001   ; Invalid: An
000038E8  4EF9 00003920           3179      JMP         MOVE_DST_MODE_010   ; (An)
000038EE  4EF9 0000392A           3180      JMP         MOVE_DST_MODE_011   ; (An)+
000038F4  4EF9 00003934           3181      JMP         MOVE_DST_MODE_100   ; -(An)
000038FA  4EF9 0000393E           3182      JMP         MOVE_DST_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003900  4EF9 00003948           3183      JMP         MOVE_DST_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003906  4EF9 00003952           3184      JMP         MOVE_DST_MODE_111   ; The rest (not all valid, validated by register number)
0000390C                          3185  MOVE_DST_MODE_000: ; Dn
0000390C  4EB8 292A               3186      JSR         EA_PRINT_DN         ; Print data register in D7
00003910  4EF9 00003980           3187      JMP         MOVE_END
00003916                          3188  MOVE_DST_MODE_001: ; Invalid: An
00003916  4EB8 28B6               3189      JSR         EA_INVALID          ; Print address register in D7
0000391A  4EF9 00003980           3190      JMP         MOVE_END
00003920                          3191  MOVE_DST_MODE_010: ; (An)
00003920  4EB8 29AA               3192      JSR         EA_PRINT_IND         ; Print address register indirect
00003924  4EF9 00003980           3193      JMP         MOVE_END
0000392A                          3194  MOVE_DST_MODE_011: ; (An)+
0000392A  4EB8 2A08               3195      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000392E  4EF9 00003980           3196      JMP         MOVE_END
00003934                          3197  MOVE_DST_MODE_100: ; -(An)
00003934  4EB8 2A48               3198      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003938  4EF9 00003980           3199      JMP         MOVE_END    ; Continue with parsing destination operand
0000393E                          3200  MOVE_DST_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000393E  4EB8 28B6               3201      JSR         EA_INVALID          ; Opcode word is Invalid
00003942  4EF9 00003980           3202      JMP         MOVE_END
00003948                          3203  MOVE_DST_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003948  4EB8 28B6               3204      JSR         EA_INVALID          ; Opcode word is Invalid
0000394C  4EF9 00003980           3205      JMP         MOVE_END
00003952                          3206  MOVE_DST_MODE_111: ; The rest (not all valid, validated by register number)
00003952  BE3C 0000               3207      CMP.B       #$00, D7            ; Test for absolute word address
00003956  6700 0014               3208      BEQ         MOVE_DST_ABS_W
0000395A  BE3C 0001               3209      CMP.B       #$01, D7            ; Test for absolute long address
0000395E  6700 0016               3210      BEQ         MOVE_DST_ABS_L
00003962  4EB8 28B6               3211      JSR         EA_INVALID          ; Else: invalid
00003966  4EF9 00003980           3212      JMP         MOVE_END
0000396C                          3213  MOVE_DST_ABS_W:
0000396C  4EB8 2A94               3214      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003970  4EF9 00003980           3215      JMP         MOVE_END
00003976                          3216  MOVE_DST_ABS_L:
00003976  4EB8 2A88               3217      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000397A  4EF9 00003980           3218      JMP         MOVE_END
00003980                          3219  MOVE_END:
00003980  4EB8 28BC               3220      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003984  4CDF 3FFF               3221      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003988  4E75                    3222      RTS
0000398A                          3223  EA_MOVEA:
0000398A  48E7 FFFC               3224      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000398E  4EB8 28C8               3225      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003992  2A16                    3226      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
00003994  143C 0002               3227      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
00003998  E56D                    3228      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
0000399A  143C 000E               3229      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
0000399E  E46D                    3230      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
000039A0  BA3C 0003               3231      CMP.B       #$03, D5            ; if size bits are 11, correct D5
000039A4                          3232                                      ; to 10 for use with immediate data subroutine
000039A4  6700 0010               3233      BEQ         MOVEA_ADJUST_W
000039A8  BA3C 0002               3234      CMP.B       #$02, D5            ; if size bits are 10, correct D5
000039AC                          3235                                      ; to 11 for use with immediate data subroutine
000039AC  6700 0012               3236      BEQ         MOVEA_ADJUST_L
000039B0  4EF9 000039CA           3237      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
000039B6                          3238  MOVEA_ADJUST_W:
000039B6  1A3C 0002               3239      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
000039BA  4EF9 000039CA           3240      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
000039C0                          3241  MOVEA_ADJUST_L:
000039C0  1A3C 0003               3242      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
000039C4  4EF9 000039CA           3243      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
000039CA                          3244  MOVEA_SOURCE:
000039CA  48E7 FFFC               3245      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000039CE  4EB8 28C8               3246      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000039D2  4EB8 28CC               3247      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000039D6  41F9 000039E4           3248      LEA         MOVEA_SRC_MODE, A0   ; Set index '0' for jump table
000039DC  CCFC 0006               3249      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000039E0  4EF0 6000               3250      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000039E4                          3251  MOVEA_SRC_MODE:
000039E4  4EF9 00003A14           3252      JMP         MOVEA_SRC_MODE_000   ; Dn
000039EA  4EF9 00003A1E           3253      JMP         MOVEA_SRC_MODE_001   ; An
000039F0  4EF9 00003A28           3254      JMP         MOVEA_SRC_MODE_010   ; (An)
000039F6  4EF9 00003A32           3255      JMP         MOVEA_SRC_MODE_011   ; (An)+
000039FC  4EF9 00003A3C           3256      JMP         MOVEA_SRC_MODE_100   ; -(An)
00003A02  4EF9 00003A46           3257      JMP         MOVEA_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003A08  4EF9 00003A50           3258      JMP         MOVEA_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A0E  4EF9 00003A5A           3259      JMP         MOVEA_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003A14                          3260  MOVEA_SRC_MODE_000: ; Dn
00003A14  4EB8 292A               3261      JSR         EA_PRINT_DN         ; Print data register in D7
00003A18  4EF9 00003A9A           3262      JMP         MOVEA_DESTINATION
00003A1E                          3263  MOVEA_SRC_MODE_001: ; Invalid: An
00003A1E  4EB8 296A               3264      JSR         EA_PRINT_AN         ; Print address register in D7
00003A22  4EF9 00003A9A           3265      JMP         MOVEA_DESTINATION
00003A28                          3266  MOVEA_SRC_MODE_010: ; (An)
00003A28  4EB8 29AA               3267      JSR         EA_PRINT_IND         ; Print address register indirect
00003A2C  4EF9 00003A9A           3268      JMP         MOVEA_DESTINATION
00003A32                          3269  MOVEA_SRC_MODE_011: ; (An)+
00003A32  4EB8 2A08               3270      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003A36  4EF9 00003A9A           3271      JMP         MOVEA_DESTINATION
00003A3C                          3272  MOVEA_SRC_MODE_100: ; -(An)
00003A3C  4EB8 2A48               3273      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003A40  4EF9 00003A9A           3274      JMP         MOVEA_DESTINATION    ; Continue with parsing destination operand
00003A46                          3275  MOVEA_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003A46  4EB8 28B6               3276      JSR         EA_INVALID          ; Opcode word is Invalid
00003A4A  4EF9 00003AAA           3277      JMP         MOVEA_END
00003A50                          3278  MOVEA_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A50  4EB8 28B6               3279      JSR         EA_INVALID          ; Opcode word is Invalid
00003A54  4EF9 00003AAA           3280      JMP         MOVEA_END
00003A5A                          3281  MOVEA_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003A5A  BE3C 0000               3282      CMP.B       #$00, D7            ; Test for absolute word address
00003A5E  6700 001C               3283      BEQ         MOVEA_SRC_ABS_W
00003A62  BE3C 0001               3284      CMP.B       #$01, D7            ; Test for absolute long address
00003A66  6700 001E               3285      BEQ         MOVEA_SRC_ABS_L
00003A6A  BE3C 0004               3286      CMP.B       #$04, D7            ; Test for immediate data
00003A6E  6700 0020               3287      BEQ         MOVEA_SRC_IMM
00003A72  4EB8 28B6               3288      JSR         EA_INVALID          ; Else: invalid
00003A76  4EF9 00003AAA           3289      JMP         MOVEA_END
00003A7C                          3290  MOVEA_SRC_ABS_W:
00003A7C  4EB8 2A94               3291      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003A80  4EF9 00003A9A           3292      JMP         MOVEA_DESTINATION
00003A86                          3293  MOVEA_SRC_ABS_L:
00003A86  4EB8 2A88               3294      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003A8A  4EF9 00003A9A           3295      JMP         MOVEA_DESTINATION
00003A90                          3296  MOVEA_SRC_IMM:
00003A90  4EB8 29EA               3297      JSR         EA_PRINT_IMM        ; Print immediate data
00003A94  4EF9 00003A9A           3298      JMP         MOVEA_DESTINATION
00003A9A                          3299  MOVEA_DESTINATION:
00003A9A                          3300      *PRINT COMMA TODO
00003A9A  48E7 FFFC               3301      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003A9E  4EB8 28C8               3302      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003AA2  4EB8 28F2               3303      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003AA6  4EB8 296A               3304      JSR         EA_PRINT_AN         ; Print address register, continue to end
00003AAA                          3305  MOVEA_END:
00003AAA  4EB8 28BC               3306      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003AAE  4CDF 3FFF               3307      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003AB2  4E75                    3308      RTS
00003AB4                          3309  EA_MOVEM:
00003AB4                          3310      *seems complicated, todo
00003AB4  4EB8 28B2               3311      JSR         EA_UNIMPLEMENTED
00003AB8  4E75                    3312      RTS
00003ABA                          3313  EA_MOVEQ:
00003ABA  48E7 FFFC               3314      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003ABE  4EB8 28C8               3315      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003AC2  2216                    3316      MOVE.L      (A6), D1            ; Load opcode to data register 1
00003AC4  143C 0008               3317      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003AC8  E569                    3318      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00003ACA  143C 0008               3319      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine data bits
00003ACE  E469                    3320      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00003AD0  2616                    3321      MOVE.L      (A6), D3            ; Save mode bits to D6
00003AD2  143C 0008               3322      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003AD6  E56B                    3323      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
00003AD8  143C 000F               3324      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
00003ADC  E46B                    3325      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003ADE  B63C 0000               3326      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003AE2  6700 0008               3327      BEQ         MOVEQ_PRINT_DATA
00003AE6  0681 FFFFFF00           3328      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
00003AEC                          3329  MOVEQ_PRINT_DATA:
00003AEC                          3330      *print hash TODO
00003AEC                          3331      *print data in
00003AEC                          3332      *PRINT COMMA TODO
00003AEC  4EB8 28F2               3333      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003AF0  4EB8 292A               3334      JSR         EA_PRINT_DN         ; Print data register
00003AF4  4EB8 28BC               3335      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003AF8  4CDF 3FFF               3336      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003AFC  4E75                    3337      RTS
00003AFE                          3338  EA_MULS_W:
00003AFE  48E7 FFFC               3339      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003B02  4EB8 28C8               3340      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003B06  4EB8 28CC               3341      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003B0A  41F9 00003B18           3342      LEA         MULS_W_MODE, A0     ; Set index '0' for jump table
00003B10  CCFC 0006               3343      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003B14  4EF0 6000               3344      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003B18                          3345  MULS_W_MODE:
00003B18  4EF9 00003B48           3346      JMP         MULS_W_MODE_000     ; Dn
00003B1E  4EF9 00003B52           3347      JMP         MULS_W_MODE_001     ; Invalid: An
00003B24  4EF9 00003B5C           3348      JMP         MULS_W_MODE_010     ; (An)
00003B2A  4EF9 00003B66           3349      JMP         MULS_W_MODE_011     ; (An)+
00003B30  4EF9 00003B70           3350      JMP         MULS_W_MODE_100     ; -(An)
00003B36  4EF9 00003B7A           3351      JMP         MULS_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003B3C  4EF9 00003B84           3352      JMP         MULS_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003B42  4EF9 00003B8E           3353      JMP         MULS_W_MODE_111     ; The rest (not all valid, validated by register number)
00003B48                          3354  MULS_W_MODE_000: ; Dn
00003B48  4EB8 292A               3355      JSR         EA_PRINT_DN         ; Print data register direct operand
00003B4C  4EF9 00003BD2           3356      JMP         MULS_W_DEST         ; Go to: print destination operand
00003B52                          3357  MULS_W_MODE_001: ; Invalid: An
00003B52  4EB8 28B6               3358      JSR         EA_INVALID          ; Address register direct is invalid mode
00003B56  4EF9 00003BE4           3359      JMP         MULS_W_END
00003B5C                          3360  MULS_W_MODE_010: ; (An)
00003B5C  4EB8 29AA               3361      JSR         EA_PRINT_IND         ; Print address register indirect
00003B60  4EF9 00003BD2           3362      JMP         MULS_W_DEST
00003B66                          3363  MULS_W_MODE_011: ; (An)+
00003B66  4EB8 2A08               3364      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003B6A  4EF9 00003BD2           3365      JMP         MULS_W_DEST
00003B70                          3366  MULS_W_MODE_100: ; -(An)
00003B70  4EB8 2A48               3367      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003B74  4EF9 00003BD2           3368      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003B7A                          3369  MULS_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003B7A  4EB8 28B6               3370      JSR         EA_INVALID          ; Opcode word is Invalid
00003B7E  4EF9 00003BE4           3371      JMP         MULS_W_END
00003B84                          3372  MULS_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003B84  4EB8 28B6               3373      JSR         EA_INVALID          ; Opcode word is Invalid
00003B88  4EF9 00003BE4           3374      JMP         MULS_W_END
00003B8E                          3375  MULS_W_MODE_111: ; The rest (not all valid, validated by register number)
00003B8E  BE3C 0000               3376      CMP.B       #$00, D7            ; Test for absolute word address
00003B92  6700 001C               3377      BEQ         MULS_W_ABS_W
00003B96  BE3C 0001               3378      CMP.B       #$01, D7            ; Test for absolute long address
00003B9A  6700 001E               3379      BEQ         MULS_W_ABS_L
00003B9E  BE3C 0004               3380      CMP.B       #$04, D7            ; Test for immediate data
00003BA2  6700 0020               3381      BEQ         MULS_W_IMM
00003BA6  4EB8 28B6               3382      JSR         EA_INVALID          ; Else: invalid
00003BAA  4EF9 00003BE4           3383      JMP         MULS_W_END
00003BB0                          3384  MULS_W_ABS_W:
00003BB0  4EB8 2A94               3385      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003BB4  4EF9 00003BD2           3386      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003BBA                          3387  MULS_W_ABS_L:
00003BBA  4EB8 2A88               3388      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003BBE  4EF9 00003BD2           3389      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003BC4                          3390  MULS_W_IMM:
00003BC4  1A3C 0002               3391      MOVE.B      #2, D5              ; Size is word
00003BC8  4EB8 29EA               3392      JSR         EA_PRINT_IMM        ; Print immediate data
00003BCC  4EF9 00003BD2           3393      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003BD2                          3394  MULS_W_DEST:
00003BD2                          3395      *print EA_MSG_COMMA
00003BD2                          3396      *Get destination register
00003BD2  3E16                    3397      MOVE.W      (A6), D7            ; Load word at current pointer to D1
00003BD4  143C 0004               3398      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00003BD8  E56F                    3399      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003BDA  143C 000D               3400      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
00003BDE  E46F                    3401      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003BE0  4EB8 292A               3402      JSR         EA_PRINT_DN         ; Print data register direct operand
00003BE4                          3403  MULS_W_END:
00003BE4  4EB8 28BC               3404      JSR         EA_UPDATE_POINTER   ; Update global pointer
00003BE8  4CDF 3FFF               3405      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003BEC  4E75                    3406      RTS
00003BEE                          3407  
00003BEE                          3408  EA_OR:
00003BEE  48E7 FFFC               3409      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003BF2  4EB8 28C8               3410      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003BF6  4EB8 28F2               3411      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00003BFA  41F9 00003C08           3412      LEA         OR_OPMODE, A0       ; Set index '0' for jump table
00003C00  CCFC 0006               3413      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003C04  4EF0 6000               3414      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003C08                          3415  OR_OPMODE:
00003C08  4EF9 00003C38           3416      JMP         OR_OPMODE_000       ; mode 1, byte
00003C0E  4EF9 00003C42           3417      JMP         OR_OPMODE_001       ; mode 1, word
00003C14  4EF9 00003C4C           3418      JMP         OR_OPMODE_010       ; mode 1, long
00003C1A  4EF9 00003C56           3419      JMP         OR_OPMODE_011       ; Invalid value
00003C20  4EF9 00003C60           3420      JMP         OR_OPMODE_100       ; mode 2, byte
00003C26  4EF9 00003C6A           3421      JMP         OR_OPMODE_101       ; mode 2, word
00003C2C  4EF9 00003C74           3422      JMP         OR_OPMODE_110       ; mode 2, long
00003C32  4EF9 00003C7E           3423      JMP         OR_OPMODE_111       ; Invalid value
00003C38                          3424  OR_OPMODE_000: ; mode 1, byte
00003C38  1A3C 0001               3425      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003C3C  4EF9 00003C88           3426      JMP         OR_MODE_1
00003C42                          3427  OR_OPMODE_001: ; mode 1, word
00003C42  1A3C 0002               3428      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00003C46  4EF9 00003C88           3429      JMP         OR_MODE_1
00003C4C                          3430  OR_OPMODE_010: ; mode 1, long
00003C4C  1A3C 0003               3431      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00003C50  4EF9 00003C88           3432      JMP         OR_MODE_1
00003C56                          3433  OR_OPMODE_011: ; Invalid value
00003C56  4EB8 28B6               3434      JSR         EA_INVALID
00003C5A  4EF9 00003D90           3435      JMP         OR_END
00003C60                          3436  OR_OPMODE_100: ; mode 2, byte
00003C60  1A3C 0001               3437      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003C64  4EF9 00003CA6           3438      JMP         OR_MODE_2
00003C6A                          3439  OR_OPMODE_101: ; mode 2, word
00003C6A  1A3C 0001               3440      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003C6E  4EF9 00003CA6           3441      JMP         OR_MODE_2
00003C74                          3442  OR_OPMODE_110: ; mode 2, long
00003C74  1A3C 0001               3443      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003C78  4EF9 00003CA6           3444      JMP         OR_MODE_2
00003C7E                          3445  OR_OPMODE_111: ; Invalid value
00003C7E  4EB8 28B6               3446      JSR         EA_INVALID
00003C82  4EF9 00003D90           3447      JMP         OR_END
00003C88                          3448  OR_MODE_1:
00003C88  4280                    3449      CLR.L       D0                  ; Clear data register 0
00003C8A  103C 0001               3450      MOVE.B      #1, D0              ; Save mode number to D0
00003C8E  3207                    3451      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003C90  4EB8 28CC               3452      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003C94  4EB9 00003CC0           3453      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
00003C9A                          3454      *PRINT COMMA TODO
00003C9A  3E01                    3455      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003C9C  4EB8 292A               3456      JSR         EA_PRINT_DN         ; Print data register
00003CA0  4EF9 00003D90           3457      JMP         OR_END
00003CA6                          3458  OR_MODE_2:
00003CA6  4280                    3459      CLR.L       D0                  ; Clear data register 0
00003CA8  103C 0002               3460      MOVE.B      #2, D0              ; Save mode number to D0
00003CAC  4EB8 292A               3461      JSR         EA_PRINT_DN         ; Print data register
00003CB0                          3462      *PRINT COMMA TODO
00003CB0  4EB8 28CC               3463      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003CB4  4EB9 00003CC0           3464      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
00003CBA  4EF9 00003D90           3465      JMP         OR_END
00003CC0                          3466  OR_EVAL_EA:
00003CC0  41F9 00003CCE           3467      LEA         OR_MODE, A0         ; Set index '0' for jump table
00003CC6  CCFC 0006               3468      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003CCA  4EF0 6000               3469      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003CCE                          3470  OR_MODE:
00003CCE  4EF9 00003CFE           3471      JMP         OR_MODE_000         ; Invalid: Dn
00003CD4  4EF9 00003D08           3472      JMP         OR_MODE_001         ; An (invalid if opmode 2)
00003CDA  4EF9 00003D1A           3473      JMP         OR_MODE_010         ; (An)
00003CE0  4EF9 00003D24           3474      JMP         OR_MODE_011         ; (An)+
00003CE6  4EF9 00003D2E           3475      JMP         OR_MODE_100         ; -(An)
00003CEC  4EF9 00003D38           3476      JMP         OR_MODE_101         ; Invalid: Address Register Indirect with Displacement Mode
00003CF2  4EF9 00003D3E           3477      JMP         OR_MODE_110         ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003CF8  4EF9 00003D44           3478      JMP         OR_MODE_111         ; The rest (not all valid, validated by register number)
00003CFE                          3479  OR_MODE_000: ; Invalid: Dn
00003CFE  4EB8 28B6               3480      JSR         EA_INVALID          ; Invalid for both opmodes
00003D02  4EF9 00003D88           3481      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D08                          3482  OR_MODE_001: ; An (invalid if opmode 2)
00003D08  B07C 0002               3483      CMP         #2, D0
00003D0C  6700 007C               3484      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
00003D10  4EB8 296A               3485      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00003D14  4EF9 00003D88           3486      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D1A                          3487  OR_MODE_010: ; (An)
00003D1A  4EB8 29AA               3488      JSR         EA_PRINT_IND         ; Print address register indirect
00003D1E  4EF9 00003D88           3489      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D24                          3490  OR_MODE_011: ; (An)+
00003D24  4EB8 2A08               3491      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003D28  4EF9 00003D88           3492      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D2E                          3493  OR_MODE_100: ; -(An)
00003D2E  4EB8 2A48               3494      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003D32  4EF9 00003D88           3495      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D38                          3496  OR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003D38  4EF9 00003D8A           3497      JMP         OR_MODE_INVALID
00003D3E                          3498  OR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003D3E  4EF9 00003D8A           3499      JMP         OR_MODE_INVALID
00003D44                          3500  OR_MODE_111: ; The rest (not all valid, validated by register number)
00003D44  BE3C 0000               3501      CMP.B       #$00, D7            ; Test for absolute word address
00003D48  6700 0018               3502      BEQ         OR_ABS_W
00003D4C  BE3C 0001               3503      CMP.B       #$01, D7            ; Test for absolute long address
00003D50  6700 001A               3504      BEQ         OR_ABS_L
00003D54  BE3C 0004               3505      CMP.B       #$04, D7            ; Test for immediate data
00003D58  6700 001C               3506      BEQ         OR_IMM
00003D5C  4EF9 00003D8A           3507      JMP         OR_MODE_INVALID     ; else, invalid
00003D62                          3508  OR_ABS_W:
00003D62  4EB8 2A94               3509      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003D66  4EF9 00003D88           3510      JMP         OR_MODE_END
00003D6C                          3511  OR_ABS_L:
00003D6C  4EB8 2A88               3512      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003D70  4EF9 00003D88           3513      JMP         OR_MODE_END
00003D76                          3514  OR_IMM: ; invalid if opmode is 2
00003D76  B07C 0002               3515      CMP         #2, D0
00003D7A  6700 000E               3516      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
00003D7E  4EB8 29EA               3517      JSR         EA_PRINT_IMM        ; Print immediate data
00003D82  4EF9 00003D88           3518      JMP         OR_MODE_END
00003D88                          3519  OR_MODE_END:
00003D88  4E75                    3520      RTS                             ; Finish evaluating EA bits
00003D8A                          3521  OR_MODE_INVALID:
00003D8A  4EB8 28B6               3522      JSR         EA_INVALID          ; Opcode word is Invalid
00003D8E  4E75                    3523      RTS
00003D90                          3524  OR_END:
00003D90  4EB8 28BC               3525      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003D94  4CDF 3FFF               3526      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003D98  4E75                    3527      RTS
00003D9A                          3528  EA_ROd:
00003D9A  48E7 FFFC               3529      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003D9E  4EB8 28C8               3530      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003DA2  4EB8 2918               3531      JSR         EA_SIZE_BITS        ; get size bits in D7
00003DA6  BE3C 0003               3532      CMP.B       #$03, D7            ; test if memory shift
00003DAA  6700 0042               3533      BEQ         ROd_MEM
00003DAE  6000 0002               3534      BRA         ROd_REG             ; else, register shfit
00003DB2                          3535  ROd_REG:
00003DB2  3E16                    3536      MOVE.W      (A6), D7            ; read opcode word in memory and save,
00003DB4                          3537                                      ; (using D7 because EA_PRINT_DN uses D7)
00003DB4  143C 0004               3538      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
00003DB8  E56F                    3539      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003DBA  143C 000D               3540      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
00003DBE  E46F                    3541      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003DC0  3016                    3542      MOVE.W      (A6), D0            ; read opcode word in memory and save
00003DC2  143C 000A               3543      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
00003DC6  E568                    3544      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00003DC8  143C 000F               3545      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
00003DCC  E468                    3546      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00003DCE  B03C 0000               3547      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
00003DD2  6700 000C               3548      BEQ         ROd_REG_COUNT
00003DD6                          3549  ROd_REG_REG:                        ; Else, count/register field contains register number
00003DD6  4EB8 292A               3550      JSR         EA_PRINT_DN         ; Print register value, stored in D7
00003DDA  4EF9 00003DE0           3551      JMP         ROd_REG_END         ; Jump to end of ROd_REG
00003DE0                          3552  ROd_REG_COUNT:
00003DE0                          3553      *print hash todo
00003DE0                          3554      *print hex value in D7 as byte todo, continue on to ROd_REG_END
00003DE0                          3555  ROd_REG_END:
00003DE0                          3556      *PRINT COMMA todo
00003DE0  4EB8 28CC               3557      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
00003DE4  4EB8 292A               3558      JSR         EA_PRINT_DN         ; Print register value in D7
00003DE8  4EF9 00003EA4           3559      JMP         ROd_END
00003DEE                          3560  ROd_MEM:
00003DEE  4EB8 28CC               3561      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003DF2  41F9 00003E00           3562      LEA         ROd_MEM_MODE, A0    ; Set index '0' for jump table
00003DF8  CCFC 0006               3563      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003DFC  4EF0 6000               3564      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003E00                          3565  ROd_MEM_MODE:
00003E00  4EF9 00003E30           3566      JMP         ROd_MEM_MODE_000     ; Invalid: Dn
00003E06  4EF9 00003E3A           3567      JMP         ROd_MEM_MODE_001     ; Invalid: An
00003E0C  4EF9 00003E44           3568      JMP         ROd_MEM_MODE_010     ; (An)
00003E12  4EF9 00003E4E           3569      JMP         ROd_MEM_MODE_011     ; (An)+
00003E18  4EF9 00003E58           3570      JMP         ROd_MEM_MODE_100     ; -(An)
00003E1E  4EF9 00003E62           3571      JMP         ROd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003E24  4EF9 00003E6C           3572      JMP         ROd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E2A  4EF9 00003E76           3573      JMP         ROd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00003E30                          3574  ROd_MEM_MODE_000: ; Invalid: Dn
00003E30  4EB8 28B6               3575      JSR         EA_INVALID          ; Data register direct is invalid mode
00003E34  4EF9 00003EA4           3576      JMP         ROd_END
00003E3A                          3577  ROd_MEM_MODE_001: ; Invalid: An
00003E3A  4EB8 28B6               3578      JSR         EA_INVALID          ; Address register direct is invalid mode
00003E3E  4EF9 00003EA4           3579      JMP         ROd_END
00003E44                          3580  ROd_MEM_MODE_010: ; (An)
00003E44  4EB8 29AA               3581      JSR         EA_PRINT_IND         ; Print address register indirect
00003E48  4EF9 00003EA4           3582      JMP         ROd_END
00003E4E                          3583  ROd_MEM_MODE_011: ; (An)+
00003E4E  4EB8 2A08               3584      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003E52  4EF9 00003EA4           3585      JMP         ROd_END
00003E58                          3586  ROd_MEM_MODE_100: ; -(An)
00003E58  4EB8 2A48               3587      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003E5C  4EF9 00003EA4           3588      JMP         ROd_END         ; Continue with parsing destination operand
00003E62                          3589  ROd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003E62  4EB8 28B6               3590      JSR         EA_INVALID          ; Opcode word is Invalid
00003E66  4EF9 00003EA4           3591      JMP         ROd_END
00003E6C                          3592  ROd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E6C  4EB8 28B6               3593      JSR         EA_INVALID          ; Opcode word is Invalid
00003E70  4EF9 00003EA4           3594      JMP         ROd_END
00003E76                          3595  ROd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
00003E76  BE3C 0000               3596      CMP.B       #$00, D7            ; Test for absolute word address
00003E7A  6700 0014               3597      BEQ         ROd_MEM_ABS_W
00003E7E  BE3C 0001               3598      CMP.B       #$01, D7            ; Test for absolute long address
00003E82  6700 0016               3599      BEQ         ROd_MEM_ABS_L
00003E86  4EB8 28B6               3600      JSR         EA_INVALID          ; Else: invalid
00003E8A  4EF9 00003EA4           3601      JMP         ROd_END
00003E90                          3602  ROd_MEM_ABS_W:
00003E90  4EB8 2A94               3603      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003E94  4EF9 00003EA4           3604      JMP         ROd_END
00003E9A                          3605  ROd_MEM_ABS_L:
00003E9A  4EB8 2A88               3606      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003E9E  4EF9 00003EA4           3607      JMP         ROd_END
00003EA4                          3608  ROd_END:
00003EA4  4EB8 28BC               3609      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003EA8  4CDF 3FFF               3610      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003EAC  4E75                    3611      RTS
00003EAE                          3612  EA_SUB:
00003EAE  4EB8 28F2               3613      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00003EB2  41F9 00003EC0           3614      LEA         SUB_OPMODE, A0      ; Set index '0' for jump table
00003EB8  CCFC 0006               3615      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003EBC  4EF0 6000               3616      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003EC0                          3617  SUB_OPMODE:
00003EC0  4EF9 00003EF0           3618      JMP         SUB_OPMODE_000      ; mode 1, byte
00003EC6  4EF9 00003EFA           3619      JMP         SUB_OPMODE_001      ; mode 1, word
00003ECC  4EF9 00003F04           3620      JMP         SUB_OPMODE_010      ; mode 1, long
00003ED2  4EF9 00003F0E           3621      JMP         SUB_OPMODE_011      ; Invalid value
00003ED8  4EF9 00003F18           3622      JMP         SUB_OPMODE_100      ; mode 2, byte
00003EDE  4EF9 00003F22           3623      JMP         SUB_OPMODE_101      ; mode 2, word
00003EE4  4EF9 00003F2C           3624      JMP         SUB_OPMODE_110      ; mode 2, long
00003EEA  4EF9 00003F36           3625      JMP         SUB_OPMODE_111      ; Invalid value
00003EF0                          3626  SUB_OPMODE_000: ; mode 1, byte
00003EF0  1A3C 0001               3627      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003EF4  4EF9 00003F40           3628      JMP         SUB_MODE_1
00003EFA                          3629  SUB_OPMODE_001: ; mode 1, word
00003EFA  1A3C 0002               3630      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00003EFE  4EF9 00003F40           3631      JMP         SUB_MODE_1
00003F04                          3632  SUB_OPMODE_010: ; mode 1, long
00003F04  1A3C 0003               3633      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00003F08  4EF9 00003F40           3634      JMP         SUB_MODE_1
00003F0E                          3635  SUB_OPMODE_011: ; Invalid value
00003F0E  4EB8 28B6               3636      JSR         EA_INVALID
00003F12  4EF9 00004050           3637      JMP         SUB_END
00003F18                          3638  SUB_OPMODE_100: ; mode 2, byte
00003F18  1A3C 0001               3639      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F1C  4EF9 00003F5E           3640      JMP         SUB_MODE_2
00003F22                          3641  SUB_OPMODE_101: ; mode 2, word
00003F22  1A3C 0001               3642      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F26  4EF9 00003F5E           3643      JMP         SUB_MODE_2
00003F2C                          3644  SUB_OPMODE_110: ; mode 2, long
00003F2C  1A3C 0001               3645      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F30  4EF9 00003F5E           3646      JMP         SUB_MODE_2
00003F36                          3647  SUB_OPMODE_111: ; Invalid value
00003F36  4EB8 28B6               3648      JSR         EA_INVALID
00003F3A  4EF9 00004050           3649      JMP         SUB_END
00003F40                          3650  SUB_MODE_1:
00003F40  4280                    3651      CLR.L       D0                  ; Clear data register 0
00003F42  103C 0001               3652      MOVE.B      #1, D0              ; Save mode number to D0
00003F46  3207                    3653      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003F48  4EB8 28CC               3654      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003F4C  4EB9 00003F78           3655      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
00003F52  3E01                    3656      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003F54  4EB8 292A               3657      JSR         EA_PRINT_DN         ; Print data register
00003F58  4EF9 00004050           3658      JMP         SUB_END
00003F5E                          3659  SUB_MODE_2:
00003F5E  4280                    3660      CLR.L       D0                  ; Clear data register 0
00003F60  103C 0002               3661      MOVE.B      #2, D0              ; Save mode number to D0
00003F64  4EB8 292A               3662      JSR         EA_PRINT_DN         ; Print data register
00003F68  4EB8 28CC               3663      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003F6C  4EB9 00003F78           3664      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
00003F72  4EF9 00004050           3665      JMP         SUB_END
00003F78                          3666  SUB_EVAL_EA:
00003F78  41F9 00003F86           3667      LEA         SUB_MODE, A0        ; Set index '0' for jump table
00003F7E  CCFC 0006               3668      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003F82  4EF0 6000               3669      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003F86                          3670  SUB_MODE:
00003F86  4EF9 00003FB6           3671      JMP         SUB_MODE_000        ; Dn (invalid if opmode 2)
00003F8C  4EF9 00003FC8           3672      JMP         SUB_MODE_001        ; An (invalid if opmode 2)
00003F92  4EF9 00003FDA           3673      JMP         SUB_MODE_010        ; (An)
00003F98  4EF9 00003FE4           3674      JMP         SUB_MODE_011        ; (An)+
00003F9E  4EF9 00003FEE           3675      JMP         SUB_MODE_100        ; -(An)
00003FA4  4EF9 00003FF8           3676      JMP         SUB_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003FAA  4EF9 00003FFE           3677      JMP         SUB_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003FB0  4EF9 00004004           3678      JMP         SUB_MODE_111        ; The rest (not all valid, validated by register number)
00003FB6                          3679  SUB_MODE_000: ; Dn (invalid if opmode 2)
00003FB6  B07C 0002               3680      CMP         #2, D0
00003FBA  6700 008E               3681      BEQ         SUB_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00003FBE  4EB8 292A               3682      JSR         EA_PRINT_DN         ; Print data register direct operand
00003FC2  4EF9 00004048           3683      JMP         SUB_MODE_END        ; End evaluation of ea mode
00003FC8                          3684  SUB_MODE_001: ; An (invalid if opmode 2)
00003FC8  B07C 0002               3685      CMP         #2, D0
00003FCC  6700 007C               3686      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00003FD0  4EB8 296A               3687      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00003FD4  4EF9 00004048           3688      JMP         SUB_MODE_END        ; End evaluation of ea mode
00003FDA                          3689  SUB_MODE_010: ; (An)
00003FDA  4EB8 29AA               3690      JSR         EA_PRINT_IND         ; Print address register indirect
00003FDE  4EF9 00004048           3691      JMP         SUB_MODE_END        ; End evaluation of ea mode
00003FE4                          3692  SUB_MODE_011: ; (An)+
00003FE4  4EB8 2A08               3693      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003FE8  4EF9 00004048           3694      JMP         SUB_MODE_END        ; End evaluation of ea mode
00003FEE                          3695  SUB_MODE_100: ; -(An)
00003FEE  4EB8 2A48               3696      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003FF2  4EF9 00004048           3697      JMP         SUB_MODE_END        ; End evaluation of ea mode
00003FF8                          3698  SUB_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003FF8  4EF9 0000404A           3699      JMP         SUB_MODE_INVALID
00003FFE                          3700  SUB_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003FFE  4EF9 0000404A           3701      JMP         SUB_MODE_INVALID
00004004                          3702  SUB_MODE_111: ; The rest (not all valid, validated by register number)
00004004  BE3C 0000               3703      CMP.B       #$00, D7            ; Test for absolute word address
00004008  6700 0018               3704      BEQ         SUB_ABS_W
0000400C  BE3C 0001               3705      CMP.B       #$01, D7            ; Test for absolute long address
00004010  6700 001A               3706      BEQ         SUB_ABS_L
00004014  BE3C 0004               3707      CMP.B       #$04, D7            ; Test for immediate data
00004018  6700 001C               3708      BEQ         SUB_IMM
0000401C  4EF9 0000404A           3709      JMP         SUB_MODE_INVALID    ; else, invalid
00004022                          3710  SUB_ABS_W:
00004022  4EB8 2A94               3711      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00004026  4EF9 00004048           3712      JMP         SUB_MODE_END
0000402C                          3713  SUB_ABS_L:
0000402C  4EB8 2A88               3714      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00004030  4EF9 00004048           3715      JMP         SUB_MODE_END
00004036                          3716  SUB_IMM: ; invalid if opmode is 2
00004036  B07C 0002               3717      CMP         #2, D0
0000403A  6700 000E               3718      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
0000403E  4EB8 29EA               3719      JSR         EA_PRINT_IMM        ; Print immediate data
00004042  4EF9 00004048           3720      JMP         SUB_MODE_END
00004048                          3721  SUB_MODE_END:
00004048  4E75                    3722      RTS                             ; Finish evaluating EA bits
0000404A                          3723  SUB_MODE_INVALID:
0000404A  4EB8 28B6               3724      JSR         EA_INVALID          ; Opcode word is Invalid
0000404E  4E75                    3725      RTS
00004050                          3726  SUB_END:
00004050  4EB8 28BC               3727      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00004054  4CDF 3FFF               3728      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00004058  4E75                    3729      RTS
0000405A                          3730  
0000405A                          3731  
0000405A                          3732  
0000405A                          3733  -------------------- end include --------------------
0000405A                          3734      INCLUDE 'EndProgram.X68'
0000405A                          3735  
0000405A                          3736  
0000405A                          3737  
0000405A  =00000059               3738  UPYES     EQU   'Y'
0000405A  =00000079               3739  LOWYES    EQU   'y'
0000405A                          3740  
0000405A                          3741  
0000405A                          3742  
0000405A                          3743  KEEP_RUNNING
0000405A  6100 0004               3744      BSR.W       RERUN               * Run welcome subroutine
0000405E  4E75                    3745      RTS                             * Return to Disassembler
00004060                          3746      
00004060                          3747  
00004060                          3748  
00004060                          3749             
00004060                          3750  
00004060                          3751  RERUN 
00004060  43F9 00004094           3752      LEA         ENDQUESTION,A1      * Loads message into A1
00004066  103C 000E               3753      MOVE.B      #14,D0              * Moves the Task 14 into D0
0000406A  4E4F                    3754      TRAP        #15                 * Displays Intro Message
0000406C                          3755      
0000406C  103C 0005               3756      MOVE.B      #5,D0               * Move task 5 to read one char
00004070  4E4F                    3757      TRAP        #15                 * Trap 15 for IO
00004072                          3758      
00004072  0C01 0059               3759      CMPI.B      #UPYES,D1           * Is char = Y
00004076  6700 0012               3760      BEQ         NOTDONE             * If yes, notdone
0000407A  0C01 0079               3761      CMPI.B      #LOWYES,D1          * Is char = y   
0000407E  6700 000A               3762      BEQ         NOTDONE             * If yes, notdone
00004082  11FC 0000 6000          3763      MOVE.B      #0,(RUNAGAIN)       * 0 for false to end program
00004088  4E75                    3764      RTS 
0000408A                          3765      
0000408A                          3766  NOTDONE
0000408A  11FC 0001 6000          3767      MOVE.B      #1,(RUNAGAIN)       * 1 for true to rerun program
00004090  6000 D23C               3768      BRA.W       CLEARSCRN           * Clear screen and return from subroutine         
00004094                          3769          
00004094                          3770  
00004094                          3771  
00004094                          3772  
00004094= 57 4F 55 4C 44 20 ...   3773  ENDQUESTION     DC.B 'WOULD YOU LIKE TO RUN THE PROGRAM AGAIN (Y/N)? ',0
000040C4                          3774  
000040C4                          3775  
000040C4                          3776  
000040C4                          3777  -------------------- end include --------------------
000040C4                          3778  
000040C4                          3779  *********** END INCLUDES *****************************************************    
000040C4                          3780        
000040C4                          3781        
000040C4                          3782  ******************************************************************************
000040C4                          3783  *           BEGIN CODE                                                       *
000040C4                          3784  ******************************************************************************
000040C4                          3785  
000040C4                          3786  *---------- START ------------------------------------------------------------
000040C4                          3787  * Begins program's logical flow. Similar to main in C/C++
000040C4                          3788  *-----------------------------------------------------------------------------
000040C4                          3789  START
000040C4  4FF8 7000               3790      LEA         STACK,SP            * SP is stored in A7
000040C8  4EB8 1000               3791      JSR         GET_ADDRESSES       * Runs GET_ADDRESSES and IO_WELCOME
000040CC  2C78 5000               3792      MOVEA.L     BEGINADDR,A6        * Assign beginning address to A6 for use
000040D0                          3793  
000040D0                          3794  LOOP
000040D0                          3795      * OC_PARSE Command doesn't work due to issues in the Opcode include
000040D0                          3796      * many errors need to be fixed. Same with EA include
000040D0                          3797      *JSR         OC_PARSE            * Determine if there is an initial opcode match
000040D0                          3798      * decrement row count
000040D0                          3799      * if at 0, prompt for next page
000040D0                          3800      * else, continue
000040D0  584E                    3801      ADDA.W      #$4,A6            * Advance address to test LOOP (test only)
000040D2                          3802      
000040D2                          3803  LOOP_CHECK
000040D2                          3804      * Changed the following code from: 
000040D2                          3805      * CMPA        A6, ENDADDR         
000040D2                          3806      * to:
000040D2                          3807      * CMPA      (ENDADDR),A6 
000040D2                          3808      * When using the CMPA, destination must be an address so A6
000040D2  BDF8 5010               3809      CMPA.L      ENDADDR,A6          * Is pointer at end of address range?
000040D6                          3810      
000040D6  6E00 0004               3811      BGT         END_LOOP            * If yes, END_LOOP
000040DA                          3812      ; in case this resets status register, do another compare TODO
000040DA                          3813      
000040DA  66F4                    3814      BNE         LOOP                * If not, continue processing addresses
000040DC                          3815      ; If at end of address range, check if user wants to continue
000040DC                          3816      ; if user wants to continue, restart
000040DC                          3817      ; else, end    
000040DC                          3818  
000040DC                          3819  END_LOOP
000040DC  4EB8 405A               3820      JSR         KEEP_RUNNING        * Does the user want to run program again
000040E0  0C38 0001 6000          3821      CMPI.B      #1,(RUNAGAIN)       * Does RUNAGAIN = TRUE?
000040E6  67DC                    3822      BEQ         START               * If yes, rerun program
000040E8  4E72 3000               3823      STOP        #$3000              * Else, end program
000040EC                          3824      
000040EC                          3825  *---------- END - START ------------------------------------------------------
000040EC                          3826  
000040EC                          3827  *********** END BEGIN CODE ***************************************************
000040EC                          3828  
000040EC                          3829  
000040EC                          3830  ******************************************************************************
000040EC                          3831  *           VARIABLES AND CONSTANTS                                          *
000040EC                          3832  ******************************************************************************
000040EC                          3833  
000040EC                          3834  
000040EC                          3835  
000040EC                          3836  *---------- Reserved Registers -----------------------------
000040EC                          3837  *   A7: stack pointer
000040EC                          3838  *   A6: current address (updated by subroutines)
000040EC                          3839  *   D0: instruction validity flag (reset by main control
000040EC                          3840  *       code, can be set to false by subroutines)
000040EC                          3841  *-----------------------------------------------------------
000040EC                          3842  
000040EC                          3843  *---------- End --------------------------------------------
000040EC                          3844                 END  START          * Last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDA_ABS_L          2D04
ADDA_ABS_W          2CFA
ADDA_END            2D2E
ADDA_IMM            2D0E
ADDA_MODE           2C6E
ADDA_MODE_000       2C9E
ADDA_MODE_001       2CA8
ADDA_MODE_010       2CB2
ADDA_MODE_011       2CBC
ADDA_MODE_100       2CC6
ADDA_MODE_101       2CD0
ADDA_MODE_110       2CD6
ADDA_MODE_111       2CDC
ADDA_MODE_END       2D26
ADDA_MODE_INVALID   2D1C
ADDCODE000          1C96
ADDCODE001          1C9E
ADDCODE010          1CA6
ADDCODE011          1CAE
ADDCODE100          1CB6
ADDCODE101          1CBE
ADDCODE110          1CC6
ADDCODE111          1CCE
ADDIBCODE00         20F4
ADDILCODE10         2104
ADDILCODE11         210C
ADDIWCODE01         20FC
ADDI_ABS_L          2E40
ADDI_ABS_W          2E36
ADDI_B              2D66
ADDI_BORADDI_WORADDI_L  20BE
ADDI_END            2E4A
ADDI_GET_DEST       2D94
ADDI_L              2D8E
ADDI_MODE           2DA6
ADDI_MODE_000       2DD6
ADDI_MODE_001       2DE0
ADDI_MODE_010       2DEA
ADDI_MODE_011       2DF4
ADDI_MODE_100       2DFE
ADDI_MODE_101       2E08
ADDI_MODE_110       2E12
ADDI_MODE_111       2E1C
ADDI_W              2D80
ADDQCODE00          1DF0
ADDQCODE01          1DF8
ADDQCODE10          1E00
ADDQCODE11          1E08
ADDQ_ABS_L          2F22
ADDQ_ABS_W          2F18
ADDQ_BORADDQ_WORADDQ_L  1DBA
ADDQ_END            2F2C
ADDQ_MODE           2E88
ADDQ_MODE_000       2EB8
ADDQ_MODE_001       2EC2
ADDQ_MODE_010       2ECC
ADDQ_MODE_011       2ED6
ADDQ_MODE_100       2EE0
ADDQ_MODE_101       2EEA
ADDQ_MODE_110       2EF4
ADDQ_MODE_111       2EFE
ADDQ_PRINT_IMM      2E76
ADDRESS_ERR         12DA
ADD_ABS_L           2C26
ADD_ABS_W           2C1C
ADD_BORADD_WORADD_L  1C48
ADD_END             2C4A
ADD_EVAL_EA         2B72
ADD_IMM             2C30
ADD_MODE            2B80
ADD_MODE_000        2BB0
ADD_MODE_001        2BC2
ADD_MODE_010        2BD4
ADD_MODE_011        2BDE
ADD_MODE_1          2B3A
ADD_MODE_100        2BE8
ADD_MODE_101        2BF2
ADD_MODE_110        2BF8
ADD_MODE_111        2BFE
ADD_MODE_2          2B58
ADD_MODE_END        2C42
ADD_MODE_INVALID    2C44
ADD_OPMODE          2ABA
ADD_OPMODE_000      2AEA
ADD_OPMODE_001      2AF4
ADD_OPMODE_010      2AFE
ADD_OPMODE_011      2B08
ADD_OPMODE_100      2B12
ADD_OPMODE_101      2B1C
ADD_OPMODE_110      2B26
ADD_OPMODE_111      2B30
ADR_ERR_NOTLT       13E7
ANDCODE000          1C08
ANDCODE001          1C10
ANDCODE010          1C18
ANDCODE011          1C20
ANDCODE100          1C28
ANDCODE101          1C30
ANDCODE110          1C38
ANDCODE111          1C40
AND_ABS_L           30AE
AND_ABS_W           30A4
AND_BORAND_WORAND_LORMULS_W  1BBA
AND_END             30D2
AND_EVAL_EA         3006
AND_IMM             30B8
AND_MODE            3014
AND_MODE_000        3044
AND_MODE_001        3056
AND_MODE_010        305C
AND_MODE_011        3066
AND_MODE_1          2FCE
AND_MODE_100        3070
AND_MODE_101        307A
AND_MODE_110        3080
AND_MODE_111        3086
AND_MODE_2          2FEC
AND_MODE_END        30CA
AND_MODE_INVALID    30CC
AND_OPMODE          2F4E
AND_OPMODE_000      2F7E
AND_OPMODE_001      2F88
AND_OPMODE_010      2F92
AND_OPMODE_011      2F9C
AND_OPMODE_100      2FA6
AND_OPMODE_101      2FB0
AND_OPMODE_110      2FBA
AND_OPMODE_111      2FC4
AN_000              29A8
AN_001              29A8
AN_010              29A8
AN_011              29A8
AN_100              29A8
AN_101              29A8
AN_110              29A8
AN_111              29A8
AN_JMP              2978
ASCII_TO_HEX        1122
ASD_END             31E6
ASD_MEM             3130
ASD_MEM_ABS_L       31DC
ASD_MEM_ABS_W       31D2
ASD_MEM_MODE        3142
ASD_MEM_MODE_000    3172
ASD_MEM_MODE_001    317C
ASD_MEM_MODE_010    3186
ASD_MEM_MODE_011    3190
ASD_MEM_MODE_100    319A
ASD_MEM_MODE_101    31A4
ASD_MEM_MODE_110    31AE
ASD_MEM_MODE_111    31B8
ASD_REG             30F4
ASD_REG_COUNT       3122
ASD_REG_END         3122
ASD_REG_REG         3118
ASLCODE00           1950
ASLCODE01           1958
ASLCODE10           1960
ASLCODE11           1968
ASL_ASR             1B34
ASL_ASRCODE0        1B5E
ASL_ASRCODE1        1B64
ASRCODE00           18FA
ASRCODE01           1902
ASRCODE10           190A
ASRCODE11           1912
BCCORBGTORBLE       17E0
BCCORBGTORBLECODE00  1816
BCCORBGTORBLECODE01  181E
BCCORBGTORBLECODE10  1826
BCCORBGTORBLECODE11  182E
BCC_B               321E
BCC_DISPLAY         3272
BCC_L               3264
BCC_W               3242
BEGINADDR           5000
BMESSAGE            13A6
CHECK_BADDR_IS_LESS_THAN_EADDR  10A4
CLEAR               10D8
CLEARSCRN           12CE
CLRCODE00           1E46
CLRCODE01           1E4E
CLRCODE10           1E56
CLRCODE11           1E5E
CLR_ABS_L           3332
CLR_ABS_W           3328
CLR_END             333C
CLR_MODE            3298
CLR_MODE_000        32C8
CLR_MODE_001        32D2
CLR_MODE_010        32DC
CLR_MODE_011        32E6
CLR_MODE_100        32F0
CLR_MODE_101        32FA
CLR_MODE_110        3304
CLR_MODE_111        330E
CMPCODE00           1D9A
CMPCODE01           1DA2
CMPCODE10           1DAA
CMPCODE11           1DB2
CMP_ABS_L           33FA
CMP_ABS_W           33F0
CMP_BORCMP_WORCMP_L  1D64
CMP_END             340C
CMP_MODE            3360
CMP_MODE_000        3390
CMP_MODE_001        339A
CMP_MODE_010        33A4
CMP_MODE_011        33AE
CMP_MODE_100        33B8
CMP_MODE_101        33C2
CMP_MODE_110        33CC
CMP_MODE_111        33D6
CMP_MODE_END        3404
CODE0000            1734
CODE0001            173A
CODE0010            1746
CODE0011            174C
CODE0100            1752
CODE0101            175E
CODE0110            176A
CODE0111            1776
CODE1000            1782
CODE1001            178E
CODE1010            179A
CODE1011            17A2
CODE1100            17AE
CODE1101            17BA
CODE1110            17C6
CODE1111            17D2
CR                  D
DIVU_W_ABS_L        34D2
DIVU_W_ABS_W        34C8
DIVU_W_DEST         34EA
DIVU_W_END          34FC
DIVU_W_IMM          34DC
DIVU_W_MODE         3430
DIVU_W_MODE_000     3460
DIVU_W_MODE_001     346A
DIVU_W_MODE_010     3474
DIVU_W_MODE_011     347E
DIVU_W_MODE_100     3488
DIVU_W_MODE_101     3492
DIVU_W_MODE_110     349C
DIVU_W_MODE_111     34A6
DN_000              2968
DN_001              2968
DN_010              2968
DN_011              2968
DN_100              2968
DN_101              2968
DN_110              2968
DN_111              2968
DONE                17DA
EA_ADD              2AA0
EA_ADDA             2C54
EA_ADDI             2D38
EA_ADDQ             2E54
EA_AND              2F36
EA_ASD              30DC
EA_BCC              31F0
EA_CLR              327E
EA_CMP              3346
EA_COPY_PTR         28C8
EA_DEFAULT_COMBO    28CC
EA_DIVU_W           3416
EA_INVALID          28B6
EA_JSR              3506
EA_LEA              35CE
EA_LSD              369E
EA_MOVE             37B2
EA_MOVEA            398A
EA_MOVEM            3AB4
EA_MOVEQ            3ABA
EA_MSG_A0           28A2
EA_MSG_A1           28A4
EA_MSG_A2           28A6
EA_MSG_A3           28A8
EA_MSG_A4           28AA
EA_MSG_A5           28AC
EA_MSG_A6           28AE
EA_MSG_A7           28B0
EA_MSG_CLOSEPAREN   288D
EA_MSG_COMMA        288A
EA_MSG_D0           2892
EA_MSG_D1           2894
EA_MSG_D2           2896
EA_MSG_D3           2898
EA_MSG_D4           289A
EA_MSG_D5           289C
EA_MSG_D6           289E
EA_MSG_D7           28A0
EA_MSG_HASH         2890
EA_MSG_HEX          2891
EA_MSG_MIN          288E
EA_MSG_NULL         2888
EA_MSG_OPENPAREN    288C
EA_MSG_PLUS         288F
EA_MSG_SPACE        2889
EA_MULS_W           3AFE
EA_OPMODE_COMBO     28F2
EA_OR               3BEE
EA_PRINT_ABS_L      2A88
EA_PRINT_ABS_W      2A94
EA_PRINT_AN         296A
EA_PRINT_AN_END     29A8
EA_PRINT_DN         292A
EA_PRINT_DN_END     2968
EA_PRINT_DN_JMP     2938
EA_PRINT_IMM        29EA
EA_PRINT_IND        29AA
EA_PRINT_IND_END    29E8
EA_PRINT_PD_END     2A86
EA_PRINT_PI_END     2A46
EA_PRINT_POSTINC    2A08
EA_PRINT_PREDEC     2A48
EA_ROD              3D9A
EA_SIZE_BITS        2918
EA_SUB              3EAE
EA_UNIMPLEMENTED    28B2
EA_UPDATE_POINTER   28BC
EMESSAGE            13C5
ENDADDR             5010
ENDL                13E4
ENDQUESTION         4094
END_LOOP            40DC
FINISHED            10C2
FOUND               11DE
GET_ADDRESSES       1000
GET_FIRST_ADDRESS   100C
GET_HEXSTRING       10F2
GET_SECOND_ADDRESS  1058
HEXA                122E
HEXB                1236
HEXC                123E
HEXD                1246
HEXE                124E
HEXEIGHT            1222
HEXF                1256
HEXFIVE             1216
HEXFLAG             5021
HEXFOUR             1212
HEXNINE             1226
HEXONE              1206
HEXSEVEN            121E
HEXSIX              121A
HEXSTRING           1442
HEXTHREE            120E
HEXTWO              120A
HEXVALUE            5030
HEXZERO             11FE
ILLEGAL             1492
IND_000             29E8
IND_001             29E8
IND_010             29E8
IND_011             29E8
IND_100             29E8
IND_101             29E8
IND_110             29E8
IND_111             29E8
IND_JMP             29B8
INITIAL_TABLE       16D4
INTRO               12EC
IO_WELCOME          10C4
ISADDAL             2550
ISADDAW             2536
ISADDB              256A
ISADDIB             286E
ISADDIL             2854
ISADDIW             283A
ISADDL              259E
ISADDQB             2654
ISADDQL             2688
ISADDQW             266E
ISADDW              2584
ISANDB              24E8
ISANDL              251C
ISANDW              2502
ISASLB              2348
ISASLL              237C
ISASLW              2362
ISASRB              22FA
ISASRL              232E
ISASRW              2314
ISBCC               2244
ISBGT               225E
ISBLE               2278
ISCLR               2788
ISCLRB              26BC
ISCLRL              26F0
ISCLRW              26D6
ISCMPB              2606
ISCMPL              263A
ISCMPW              2620
ISDIVUW             2292
ISJSR               2758
ISLEA               273E
ISLSLB              23E4
ISLSLL              2418
ISLSLW              23FE
ISLSRB              2396
ISLSRL              23CA
ISLSRW              23B0
ISMOVEAL            2806
ISMOVEAW            27D2
ISMOVEB             2820
ISMOVEL             27EC
ISMOVEML            270A
ISMOVEMW            2724
ISMOVEQL            26A2
ISMOVEW             27B8
ISMULSW             24CE
ISNOP               27A2
ISORB               22AC
ISORL               22E0
ISORW               22C6
ISROLB              2480
ISROLL              24B4
ISROLW              249A
ISRORB              2432
ISRORL              2466
ISRORW              244C
ISRTS               2772
ISSUBB              25B8
ISSUBL              25EC
ISSUBW              25D2
IS_HEX_EVEN         127E
IS_LESSTHAN         125E
JSRORCLRCODE0000    1F08
JSRORCLRCODE0001    1F10
JSRORCLRCODE0010    1F18
JSRORCLRCODE0011    1F1E
JSRORCLRCODE0100    1F26
JSRORCLRCODE0101    1F2E
JSRORCLRCODE0110    1F36
JSRORCLRCODE0111    1F3E
JSRORCLRCODE1000    1F46
JSRORCLRCODE1001    1F4E
JSRORCLRCODE1010    1F56
JSRORCLRCODE1011    1F5E
JSRORCLRCODE1100    1F66
JSRORCLRCODE1101    1F6E
JSRORCLRCODE1110    1F76
JSRORCLRCODE1111    1F7E
JSR_ABS_L           35BA
JSR_ABS_W           35B0
JSR_END             35C4
JSR_MODE            3520
JSR_MODE_000        3550
JSR_MODE_001        355A
JSR_MODE_010        3564
JSR_MODE_011        356E
JSR_MODE_100        3578
JSR_MODE_101        3582
JSR_MODE_110        358C
JSR_MODE_111        3596
KEEP_RUNNING        405A
LEA_ABS_L           3682
LEA_ABS_W           3678
LEA_DEST            368C
LEA_END             3694
LEA_MODE            35E8
LEA_MODE_000        3618
LEA_MODE_001        3622
LEA_MODE_010        362C
LEA_MODE_011        3636
LEA_MODE_100        3640
LEA_MODE_101        364A
LEA_MODE_110        3654
LEA_MODE_111        365E
LF                  A
LOOP                40D0
LOOP_CHECK          40D2
LOTSCODE0000        2044
LOTSCODE0001        204C
LOTSCODE0010        2054
LOTSCODE0011        205A
LOTSCODE0100        2062
LOTSCODE0101        206A
LOTSCODE0110        2072
LOTSCODE0111        207A
LOTSCODE1000        2082
LOTSCODE1001        2088
LOTSCODE1010        2090
LOTSCODE1011        2096
LOTSCODE1100        209E
LOTSCODE1101        20A6
LOTSCODE1110        20AE
LOTSCODE1111        20B6
LOWYES              79
LSD_END             37A8
LSD_MEM             36F2
LSD_MEM_ABS_L       379E
LSD_MEM_ABS_W       3794
LSD_MEM_MODE        3704
LSD_MEM_MODE_000    3734
LSD_MEM_MODE_001    373E
LSD_MEM_MODE_010    3748
LSD_MEM_MODE_011    3752
LSD_MEM_MODE_100    375C
LSD_MEM_MODE_101    3766
LSD_MEM_MODE_110    3770
LSD_MEM_MODE_111    377A
LSD_REG             36B6
LSD_REG_COUNT       36E4
LSD_REG_END         36E4
LSD_REG_REG         36DA
LSLCODE00           19FC
LSLCODE01           1A04
LSLCODE10           1A0C
LSLCODE11           1A14
LSL_LSR             1AFE
LSL_LSRCODE0        1B28
LSL_LSRCODE1        1B2E
LSRCODE00           19A6
LSRCODE01           19AE
LSRCODE10           19B6
LSRCODE11           19BE
LT                  1276
MESSAGEADDAL        15AA
MESSAGEADDAW        15A1
MESSAGEADDB         1589
MESSAGEADDIB        14DD
MESSAGEADDIL        14D4
MESSAGEADDIW        14CB
MESSAGEADDL         1599
MESSAGEADDQB        153E
MESSAGEADDQL        1550
MESSAGEADDQW        1547
MESSAGEADDW         1591
MESSAGEANDB         15BD
MESSAGEANDL         15CD
MESSAGEANDW         15C5
MESSAGEASLB         15F6
MESSAGEASLL         1606
MESSAGEASLW         15FE
MESSAGEASRB         15DE
MESSAGEASRL         15EE
MESSAGEASRW         15E6
MESSAGEBCC          168C
MESSAGEBGT          1692
MESSAGEBLE          1698
MESSAGECLR          1514
MESSAGECLRB         1526
MESSAGECLRL         1536
MESSAGECLRW         152E
MESSAGECMPB         1559
MESSAGECMPL         1569
MESSAGECMPW         1561
MESSAGEDIVUW        1683
MESSAGEJSR          150E
MESSAGELEA          1520
MESSAGELSLB         1656
MESSAGELSLL         1666
MESSAGELSLW         165E
MESSAGELSRB         163E
MESSAGELSRL         164E
MESSAGELSRW         1646
MESSAGEMOVEAL       14E6
MESSAGEMOVEAW       14F0
MESSAGEMOVEB        14C2
MESSAGEMOVEL        14B9
MESSAGEMOVEML       14FA
MESSAGEMOVEMW       1504
MESSAGEMOVEQL       15B3
MESSAGEMOVEW        14B0
MESSAGEMULSW        15D5
MESSAGENOP          14AA
MESSAGEOPCODE_INVALID  169E
MESSAGEORB          166E
MESSAGEORL          167C
MESSAGEORW          1675
MESSAGEROLB         1626
MESSAGEROLL         1636
MESSAGEROLW         162E
MESSAGERORB         160E
MESSAGERORL         161E
MESSAGERORW         1616
MESSAGERTS          151A
MESSAGESUBB         1571
MESSAGESUBL         1581
MESSAGESUBW         1579
MOD                 2
MOVEACODE001        216A
MOVEAWCODE001       21F8
MOVEA_ADJUST_L      39C0
MOVEA_ADJUST_W      39B6
MOVEA_DESTINATION   3A9A
MOVEA_END           3AAA
MOVEA_LORMOVE_L     2114
MOVEA_SOURCE        39CA
MOVEA_SRC_ABS_L     3A86
MOVEA_SRC_ABS_W     3A7C
MOVEA_SRC_IMM       3A90
MOVEA_SRC_MODE      39E4
MOVEA_SRC_MODE_000  3A14
MOVEA_SRC_MODE_001  3A1E
MOVEA_SRC_MODE_010  3A28
MOVEA_SRC_MODE_011  3A32
MOVEA_SRC_MODE_100  3A3C
MOVEA_SRC_MODE_101  3A46
MOVEA_SRC_MODE_110  3A50
MOVEA_SRC_MODE_111  3A5A
MOVEA_WORMOVE_W     21A2
MOVECODE000         2162
MOVECODE010         2172
MOVECODE011         217A
MOVECODE100         2182
MOVECODE101         218A
MOVECODE110         2192
MOVECODE111         219A
MOVEMCODE0          1FB0
MOVEMCODE1          1FB8
MOVEQ_PRINT_DATA    3AEC
MOVEWCODE000        21F0
MOVEWCODE010        2200
MOVEWCODE011        2208
MOVEWCODE100        2210
MOVEWCODE101        2218
MOVEWCODE110        2220
MOVEWCODE111        2228
MOVE_ADJUST_L       37E8
MOVE_ADJUST_W       37DE
MOVE_DESTINATION    38C2
MOVE_DST_ABS_L      3976
MOVE_DST_ABS_W      396C
MOVE_DST_MODE       38DC
MOVE_DST_MODE_000   390C
MOVE_DST_MODE_001   3916
MOVE_DST_MODE_010   3920
MOVE_DST_MODE_011   392A
MOVE_DST_MODE_100   3934
MOVE_DST_MODE_101   393E
MOVE_DST_MODE_110   3948
MOVE_DST_MODE_111   3952
MOVE_END            3980
MOVE_SOURCE         37F2
MOVE_SRC_ABS_L      38AE
MOVE_SRC_ABS_W      38A4
MOVE_SRC_IMM        38B8
MOVE_SRC_MODE       380C
MOVE_SRC_MODE_000   383C
MOVE_SRC_MODE_001   3846
MOVE_SRC_MODE_010   3850
MOVE_SRC_MODE_011   385A
MOVE_SRC_MODE_100   3864
MOVE_SRC_MODE_101   386E
MOVE_SRC_MODE_110   3878
MOVE_SRC_MODE_111   3882
MULS_W_ABS_L        3BBA
MULS_W_ABS_W        3BB0
MULS_W_DEST         3BD2
MULS_W_END          3BE4
MULS_W_IMM          3BC4
MULS_W_MODE         3B18
MULS_W_MODE_000     3B48
MULS_W_MODE_001     3B52
MULS_W_MODE_010     3B5C
MULS_W_MODE_011     3B66
MULS_W_MODE_100     3B70
MULS_W_MODE_101     3B7A
MULS_W_MODE_110     3B84
MULS_W_MODE_111     3B8E
NEW_LINE            12C0
NOPCOMMAND          1F00
NOPORCLRORRTSORJSR  1E66
NOP_MOVEM_LEA_JSR_CLR_RTS  1FC0
NOTDONE             408A
NOTEVEN             12A8
OC_PARSE            16B7
OPCODE_INVALID      2230
OR_ABS_L            3D6C
OR_ABS_W            3D62
OR_BOROR_WOROR_LORDIVU  1836
OR_DIVUCODE000      1884
OR_DIVUCODE001      188C
OR_DIVUCODE010      1894
OR_DIVUCODE011      189C
OR_DIVUCODE100      18A4
OR_DIVUCODE101      18AC
OR_DIVUCODE110      18B4
OR_DIVUCODE111      18BC
OR_END              3D90
OR_EVAL_EA          3CC0
OR_IMM              3D76
OR_MODE             3CCE
OR_MODE_000         3CFE
OR_MODE_001         3D08
OR_MODE_010         3D1A
OR_MODE_011         3D24
OR_MODE_1           3C88
OR_MODE_100         3D2E
OR_MODE_101         3D38
OR_MODE_110         3D3E
OR_MODE_111         3D44
OR_MODE_2           3CA6
OR_MODE_END         3D88
OR_MODE_INVALID     3D8A
OR_OPMODE           3C08
OR_OPMODE_000       3C38
OR_OPMODE_001       3C42
OR_OPMODE_010       3C4C
OR_OPMODE_011       3C56
OR_OPMODE_100       3C60
OR_OPMODE_101       3C6A
OR_OPMODE_110       3C74
OR_OPMODE_111       3C7E
POSTINC_000         2A46
POSTINC_001         2A46
POSTINC_010         2A46
POSTINC_011         2A46
POSTINC_100         2A46
POSTINC_101         2A46
POSTINC_110         2A46
POSTINC_111         2A46
POSTINC_JMP         2A16
PREDEC_000          2A86
PREDEC_001          2A86
PREDEC_010          2A86
PREDEC_011          2A86
PREDEC_100          2A86
PREDEC_101          2A86
PREDEC_110          2A86
PREDEC_111          2A86
PREDEC_JMP          2A56
PRINT_HEXVALUE      12B2
PRINT_IMM_END       2A04
PRINT_IMM_L         2A00
PS1                 1314
PS2                 135E
REMAINDER           5050
REPEAT              128A
RERUN               4060
ROD_END             3EA4
ROD_LSD_ASD         1B6A
ROD_LSD_ASDCODE00   1BA0
ROD_LSD_ASDCODE01   1BA6
ROD_LSD_ASDCODE10   1BAC
ROD_LSD_ASDCODE11   1BB4
ROD_MEM             3DEE
ROD_MEM_ABS_L       3E9A
ROD_MEM_ABS_W       3E90
ROD_MEM_MODE        3E00
ROD_MEM_MODE_000    3E30
ROD_MEM_MODE_001    3E3A
ROD_MEM_MODE_010    3E44
ROD_MEM_MODE_011    3E4E
ROD_MEM_MODE_100    3E58
ROD_MEM_MODE_101    3E62
ROD_MEM_MODE_110    3E6C
ROD_MEM_MODE_111    3E76
ROD_REG             3DB2
ROD_REG_COUNT       3DE0
ROD_REG_END         3DE0
ROD_REG_REG         3DD6
ROLCODE00           1A52
ROLCODE01           1A5A
ROLCODE10           1A62
ROLCODE11           1A6A
ROL_ROR             1AC8
ROL_RORCODE0        1AF2
ROL_RORCODE1        1AF8
RORCODE00           1AA8
RORCODE01           1AB0
RORCODE10           1AB8
RORCODE11           1AC0
RTSCOMMAND          1EF8
RUNAGAIN            6000
SHIFTLEFT           11F8
SOMEASL             191A
SOMEASR             18C4
SOMECLR             1E10
SOMELSL             19C6
SOMELSR             1970
SOMEMOVEM           1F86
SOMEROL             1A1C
SOMEROR             1A72
STACK               7000
START               40C4
STR_LEN             5020
SUBCODE000          1D24
SUBCODE001          1D2C
SUBCODE010          1D34
SUBCODE011          1D3C
SUBCODE100          1D44
SUBCODE101          1D4C
SUBCODE110          1D54
SUBCODE111          1D5C
SUB_ABS_L           402C
SUB_ABS_W           4022
SUB_BORSUB_WORSUB_L  1CD6
SUB_END             4050
SUB_EVAL_EA         3F78
SUB_IMM             4036
SUB_MODE            3F86
SUB_MODE_000        3FB6
SUB_MODE_001        3FC8
SUB_MODE_010        3FDA
SUB_MODE_011        3FE4
SUB_MODE_1          3F40
SUB_MODE_100        3FEE
SUB_MODE_101        3FF8
SUB_MODE_110        3FFE
SUB_MODE_111        4004
SUB_MODE_2          3F5E
SUB_MODE_END        4048
SUB_MODE_INVALID    404A
SUB_OPMODE          3EC0
SUB_OPMODE_000      3EF0
SUB_OPMODE_001      3EFA
SUB_OPMODE_010      3F04
SUB_OPMODE_011      3F0E
SUB_OPMODE_100      3F18
SUB_OPMODE_101      3F22
SUB_OPMODE_110      3F2C
SUB_OPMODE_111      3F36
TABLEADDI_BORADDI_WORADDI_L  20DC
TABLEADDQ_BORADDQ_WORADDQ_L  1DD8
TABLEADD_BORADD_WORADD_L  1C66
TABLEAND_BORAND_WORAND_LORMULS_W  1BD8
TABLEASL_ASR        1B52
TABLEBCCORBGTORBLE  17FE
TABLECMP_BORCMP_WORCMP_L  1D82
TABLELSL_LSR        1B1C
TABLEMOVEA_LORMOVE_L  2132
TABLEMOVEA_WORMOVE_W  21C0
TABLENOPORCLRORRTSORJSR  1E98
TABLENOP_MOVEM_LEA_JSR_CLR_RTS  1FE4
TABLEOR_BOROR_WOROR_LORDIVU  1854
TABLEROD_LSD_ASD    1B88
TABLEROL_ROR        1AE6
TABLESOMEASL        1938
TABLESOMEASR        18E2
TABLESOMECLR        1E2E
TABLESOMELSL        19E4
TABLESOMELSR        198E
TABLESOMEMOVEM      1FA4
TABLESOMEROL        1A3A
TABLESOMEROR        1A90
TABLESUB_BORSUB_WORSUB_L  1CF4
UPDATE_PTR          28C4
UPYES               59
