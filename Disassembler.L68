00004748 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/2/2016 2:29:40 PM

00000000                             1  ******************************************************************************
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Brandon Authier (Hblkr), Jack S. Eldridge
00000000                             4  *              (JackScottie), Marijn Burger (marijnburger)
00000000                             5  * Date       : 16 May 2016
00000000                             6  * Description: An inverse assembler that will convert a memory
00000000                             7  *              image of instructions and data back to the display.
00000000                             8  *              The following will be decoded:
00000000                             9  *
00000000                            10  *              Addressing Modes
00000000                            11  *
00000000                            12  *                Data Register Direct
00000000                            13  *                Address Register Direct
00000000                            14  *                Address Register Indirect
00000000                            15  *                Immediate Data
00000000                            16  *                Address Register Indirect with Post Increment
00000000                            17  *                Address Register Indirect with Pre Decrement
00000000                            18  *                Absolute Long Address
00000000                            19  *                Absolute Word Address
00000000                            20  *
00000000                            21  *              Instructions
00000000                            22  *
00000000                            23  *                NOP
00000000                            24  *                MOVE
00000000                            25  *                MOVEA
00000000                            26  *                MOVEQ
00000000                            27  *                MOVEM
00000000                            28  *                ADD
00000000                            29  *                ADDA
00000000                            30  *                ADDI
00000000                            31  *                ADDQ
00000000                            32  *                SUB
00000000                            33  *                MULS
00000000                            34  *                DIVU
00000000                            35  *                LEA
00000000                            36  *                CLR
00000000                            37  *                AND
00000000                            38  *                OR
00000000                            39  *                LSL
00000000                            40  *                LSR
00000000                            41  *                ASR
00000000                            42  *                ASL
00000000                            43  *                ROL
00000000                            44  *                ROR
00000000                            45  *                CMP
00000000                            46  *                Bcc (BCC, BGT, BLE)
00000000                            47  *                JSR
00000000                            48  *                RTS
00000000                            49  *
00000000                            50  ******************************************************************************
00000000                            51  
00000000                            52  ******************************************************************************
00000000                            53  *           DEFINITIONS                                                      *
00000000                            54  ******************************************************************************
00000000  =00007000                 55  STACK     EQU   $7000               * Beginning address for stack pointer
00000000                            56  
00000000  =00005000                 57  BEGINADDR EQU   $5000               * Variable to hold beginning address value
00000000  =00005010                 58  ENDADDR   EQU   $5010               * Variable to hold ending address value
00000000                            59  
00000000  =00006000                 60  RUNAGAIN  EQU   $6000               * Value equivalent to 'true'
00000000                            61  
00001000                            62            ORG   $1000               * Program begins at address 1000
00001000                            63  
00001000                            64  *********** END DEFINITIONS **************************************************
00001000                            65  
00001000                            66  
00001000                            67  ******************************************************************************
00001000                            68  *           INCLUDES                                                         *
00001000                            69  ******************************************************************************
00001000                            70  
00001000                            71      INCLUDE 'IO.X68'
00001000                            72  
00001000                            73  
00001000                            74  
00001000  =00005020                 75  STR_LEN   EQU   $5020
00001000  =00005021                 76  HEXFLAG   EQU   $5021
00001000  =00005030                 77  HEXVALUE  EQU   $5030
00001000  =00005050                 78  REMAINDER EQU   $5050
00001000  =00000002                 79  MOD       EQU   2
00001000                            80  
00001000  =0000000D                 81  CR        EQU   $0D
00001000  =0000000A                 82  LF        EQU   $0A
00001000                            83  
00001000                            84  
00001000                            85  GET_ADDRESSES
00001000  4EB9 000012D0             86      JSR         CLEARSCRN
00001006  4EB9 000010C4             87      JSR         IO_WELCOME          * Run welcome subroutine
0000100C                            88  
0000100C                            89  GET_FIRST_ADDRESS
0000100C  43F9 0000136C             90      LEA         PS1,A1              * Loads message into A1
00001012  4EB9 000010F2             91      JSR         GET_HEXSTRING       * Get string from user
00001018  0C38 0001 5021            92      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000101E  66EC                      93      BNE         GET_FIRST_ADDRESS   * If no, get hex again
00001020                            94  
00001020  4EB9 00001124             95      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001026  0C38 0001 5021            96      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000102C  66DE                      97      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000102E                            98  
0000102E  4EB9 00001280             99      JSR         IS_HEX_EVEN         * Check that hex value is even
00001034  0C38 0001 5021           100      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000103A  66D0                     101      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000103C                           102  
0000103C  21F8 5030 5000           103      MOVE.L      HEXVALUE,BEGINADDR  * Copy hex value to begin
00001042  43F9 000013FE            104      LEA         BMESSAGE,A1         * Load message in A1 for display
00001048  2238 5030                105      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display
0000104C  4EB9 000012C2            106      JSR         NEW_LINE            * Space
00001052                           107  
00001052  4EB9 000010D8            108      JSR         CLEAR               * Clear values for next hex
00001058                           109  
00001058                           110  GET_SECOND_ADDRESS
00001058  43F9 000013B6            111      LEA         PS2,A1              * Loads message into A1
0000105E  4EB9 000010F2            112      JSR         GET_HEXSTRING       * Get string from user
00001064  0C38 0001 5021           113      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000106A  66EC                     114      BNE         GET_SECOND_ADDRESS  * If no, get hex again
0000106C                           115  
0000106C  4EB9 00001124            116      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001072  0C38 0001 5021           117      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001078  66DE                     118      BNE         GET_SECOND_ADDRESS  * If no, get hex again
0000107A                           119  
0000107A  4EB9 00001280            120      JSR         IS_HEX_EVEN         * Check that hex value is even
00001080  0C38 0001 5021           121      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001086  66D0                     122      BNE         GET_SECOND_ADDRESS  * If no, get hex again
00001088                           123  
00001088  21F8 5030 5010           124      MOVE.L      HEXVALUE,ENDADDR    * Copy hex value to begin
0000108E  43F9 0000141D            125      LEA         EMESSAGE,A1         * Load message in A1 for display
00001094  2238 5030                126      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display
00001098  4EB9 000012C2            127      JSR         NEW_LINE            * Space
0000109E                           128  
0000109E  4EB9 000010D8            129      JSR         CLEAR               * Clear values for next hex
000010A4                           130  
000010A4                           131  CHECK_BADDR_IS_LESS_THAN_EADDR
000010A4  4EB9 00001260            132      JSR         IS_LESSTHAN         *
000010AA  0C38 0001 5021           133      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000010B0  6700 0010                134      BEQ         FINISHED            * If yes, finished
000010B4  43F9 0000143C            135      LEA         ADR_ERR_NOTLT,A1    * Else, load error message
000010BA  6100 0220                136      BSR.W       ADDRESS_ERR
000010BE  6100 3687                137      BSR.W       START
000010C2                           138  
000010C2                           139  
000010C2                           140  FINISHED
000010C2  4E75                     141      RTS                             * Return to Disassembler
000010C4                           142  
000010C4                           143  
000010C4                           144  
000010C4                           145  
000010C4                           146  
000010C4                           147  IO_WELCOME:
000010C4  43F9 00001344            148      LEA         INTRO,A1            * Loads message into A1
000010CA  103C 000E                149      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010CE  4E4F                     150      TRAP        #15                 * Displays Intro Message
000010D0                           151  
000010D0  4EB9 000012C2            152      JSR         NEW_LINE            * Call Subroutine
000010D6  4E75                     153      RTS                             * Return from subroutine
000010D8                           154  
000010D8                           155  
000010D8                           156  
000010D8                           157  CLEAR
000010D8  4286                     158      CLR.L       D6                   * Clear
000010DA  31FC FFFF 5020           159      MOVE.W      #$FFFF,STR_LEN       * Clear
000010E0  21FC FFFFFFFF 5030       160      MOVE.L      #$FFFFFFFF,HEXVALUE  * Clear
000010E8  21FC FFFFFFFF 5050       161      MOVE.L      #$FFFFFFFF,REMAINDER * Clear
000010F0  4E75                     162      RTS                              * Return to main to get hex
000010F2                           163  
000010F2                           164  
000010F2                           165  
000010F2                           166  GET_HEXSTRING
000010F2  103C 000E                167      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010F6  323C 004A                168      MOVE.W      #(PS2-PS1),D1       * The prompt string length
000010FA  4E4F                     169      TRAP        #15                 * Displays contents of A1
000010FC                           170  
000010FC  43F9 00001497            171      LEA         HEXSTRING,A1        * Pointer to store the sentence
00001102  103C 0002                172      MOVE.B      #2,D0               * Set up readstring function
00001106  4E4F                     173      TRAP        #15                 * Get string from keyboard
00001108  11C1 5020                174      MOVE.B      D1,STR_LEN          * Save length of input string
0000110C                           175  
0000110C  0C38 0008 5020           176      CMPI.B      #8,(STR_LEN)        * Is length > 8?
00001112  6E00 FEF8                177      BGT         GET_FIRST_ADDRESS   * If yes, get hex again
00001116                           178  
00001116  41F9 00001497            179      LEA         HEXSTRING,A0        * Load address for verification
0000111C  11FC 0001 5021           180      MOVE.B      #1,(HEXFLAG)
00001122  4E75                     181      RTS                             * Return from subroutine
00001124                           182  
00001124                           183  
00001124                           184  
00001124                           185  ASCII_TO_HEX
00001124  1618                     186      MOVE.B      (A0)+,D3            * Move first char into D3
00001126  0C03 0030                187      CMPI.B      #'0',D3             * Is Char equal to 0?
0000112A  6700 00D4                188      BEQ         HEXZERO
0000112E  0C03 0031                189      CMPI.B      #'1',D3             * Is Char equal to 1?
00001132  6700 00D4                190      BEQ         HEXONE
00001136  0C03 0032                191      CMPI.B      #'2',D3             * Is Char equal to 2?
0000113A  6700 00D0                192      BEQ         HEXTWO
0000113E  0C03 0033                193      CMPI.B      #'3',D3             * Is Char equal to 3?
00001142  6700 00CC                194      BEQ         HEXTHREE
00001146  0C03 0034                195      CMPI.B      #'4',D3             * Is Char equal to 4?
0000114A  6700 00C8                196      BEQ         HEXFOUR
0000114E  0C03 0035                197      CMPI.B      #'5',D3             * Is Char equal to 5?
00001152  6700 00C4                198      BEQ         HEXFIVE
00001156  0C03 0036                199      CMPI.B      #'6',D3             * Is Char equal to 6?
0000115A  6700 00C0                200      BEQ         HEXSIX
0000115E  0C03 0037                201      CMPI.B      #'7',D3             * Is Char equal to 7?
00001162  6700 00BC                202      BEQ         HEXSEVEN
00001166  0C03 0038                203      CMPI.B      #'8',D3             * Is Char equal to 8?
0000116A  6700 00B8                204      BEQ         HEXEIGHT
0000116E  0C03 0039                205      CMPI.B      #'9',D3             * Is Char equal to 9?
00001172  6700 00B4                206      BEQ         HEXNINE
00001176  0C03 0041                207      CMPI.B      #'A',D3             * Is Char equal to A?
0000117A  6700 00B4                208      BEQ         HEXA
0000117E  0C03 0042                209      CMPI.B      #'B',D3             * Is Char equal to B?
00001182  6700 00B4                210      BEQ         HEXB
00001186  0C03 0043                211      CMPI.B      #'C',D3             * Is Char equal to C?
0000118A  6700 00B4                212      BEQ         HEXC
0000118E  0C03 0044                213      CMPI.B      #'D',D3             * Is Char equal to D?
00001192  6700 00B4                214      BEQ         HEXD
00001196  0C03 0045                215      CMPI.B      #'E',D3             * Is Char equal to E?
0000119A  6700 00B4                216      BEQ         HEXE
0000119E  0C03 0046                217      CMPI.B      #'F',D3             * Is Char equal to F?
000011A2  6700 00B4                218      BEQ         HEXF
000011A6  0C03 0061                219      CMPI.B      #'a',D3             * Is Char equal to a?
000011AA  6700 0084                220      BEQ         HEXA
000011AE  0C03 0062                221      CMPI.B      #'b',D3             * Is Char equal to b?
000011B2  6700 0084                222      BEQ         HEXB
000011B6  0C03 0063                223      CMPI.B      #'c',D3             * Is Char equal to c?
000011BA  6700 0084                224      BEQ         HEXC
000011BE  0C03 0064                225      CMPI.B      #'d',D3             * Is Char equal to d?
000011C2  6700 0084                226      BEQ         HEXD
000011C6  0C03 0065                227      CMPI.B      #'e',D3             * Is Char equal to e?
000011CA  6700 0084                228      BEQ         HEXE
000011CE  0C03 0066                229      CMPI.B      #'f',D3             * Is Char equal to f?
000011D2  6700 0084                230      BEQ         HEXF
000011D6                           231  
000011D6  11FC 0000 5021           232      MOVE.B      #0,HEXFLAG          * Set false
000011DC  6000 FEFA                233      BRA         CLEAR               * Clear some values
000011E0                           234  
000011E0                           235  FOUND
000011E0  5338 5020                236      SUBI.B      #1,STR_LEN          * Decrease string by one
000011E4  0C38 0000 5020           237      CMPI.B      #0,STR_LEN          * Is string = 0?
000011EA  6600 000E                238      BNE         SHIFTLEFT           * If no, shift value left
000011EE  21C6 5030                239      MOVE.L      D6,HEXVALUE         * If yes, save hex value
000011F2  11FC 0001 5021           240      MOVE.B      #1,HEXFLAG          * Set true
000011F8  4E75                     241      RTS                             * Then, return to main
000011FA                           242  
000011FA                           243  SHIFTLEFT
000011FA  E98E                     244      LSL.L       #4,D6               * Shift the value left
000011FC  6000 FF26                245      BRA         ASCII_TO_HEX        * Check next char
00001200                           246  
00001200                           247  HEXZERO
00001200  0686 00000000            248      ADD.L       #$0,D6              * Add value
00001206  60D8                     249      BRA         FOUND               * found, decrease strlen, shift value left
00001208                           250  HEXONE
00001208  5286                     251      ADD.L       #$1,D6              * Add value
0000120A  60D4                     252      BRA         FOUND               * found, decrease strlen, shift value left
0000120C                           253  HEXTWO
0000120C  5486                     254      ADD.L       #$2,D6              * Add value
0000120E  60D0                     255      BRA         FOUND               * found, decrease strlen, shift value left
00001210                           256  HEXTHREE
00001210  5686                     257      ADD.L       #$3,D6              * Add value
00001212  60CC                     258      BRA         FOUND               * found, decrease strlen, shift value left
00001214                           259  HEXFOUR
00001214  5886                     260      ADD.L       #$4,D6              * Add value
00001216  60C8                     261      BRA         FOUND               * found, decrease strlen, shift value left
00001218                           262  HEXFIVE
00001218  5A86                     263      ADD.L       #$5,D6              * Add value
0000121A  60C4                     264      BRA         FOUND               * found, decrease strlen, shift value left
0000121C                           265  HEXSIX
0000121C  5C86                     266      ADD.L       #$6,D6              * Add value
0000121E  60C0                     267      BRA         FOUND               * found, decrease strlen, shift value left
00001220                           268  HEXSEVEN
00001220  5E86                     269      ADD.L       #$7,D6              * Add value
00001222  60BC                     270      BRA         FOUND               * found, decrease strlen, shift value left
00001224                           271  HEXEIGHT
00001224  5086                     272      ADD.L       #$8,D6              * Add value
00001226  60B8                     273      BRA         FOUND               * found, decrease strlen, shift value left
00001228                           274  HEXNINE
00001228  0686 00000009            275      ADD.L       #$9,D6              * Add value
0000122E  60B0                     276      BRA         FOUND               * found, decrease strlen, shift value left
00001230                           277  HEXA
00001230  0686 0000000A            278      ADD.L       #$A,D6              * Add value
00001236  60A8                     279      BRA         FOUND               * found, decrease strlen, shift value left
00001238                           280  HEXB
00001238  0686 0000000B            281      ADD.L       #$B,D6              * Add value
0000123E  60A0                     282      BRA         FOUND               * found, decrease strlen, shift value left
00001240                           283  HEXC
00001240  0686 0000000C            284      ADD.L       #$C,D6              * Add value
00001246  6098                     285      BRA         FOUND               * found, decrease strlen, shift value left
00001248                           286  HEXD
00001248  0686 0000000D            287      ADD.L       #$D,D6              * Add value
0000124E  6090                     288      BRA         FOUND               * found, decrease strlen, shift value left
00001250                           289  HEXE
00001250  0686 0000000E            290      ADD.L       #$E,D6              * Add value
00001256  6088                     291      BRA         FOUND               * found, decrease strlen, shift value left
00001258                           292  HEXF
00001258  0686 0000000F            293      ADD.L       #$F,D6              * Add value
0000125E  6080                     294      BRA         FOUND               * found, decrease strlen, shift value left
00001260                           295  
00001260                           296  
00001260                           297  
00001260                           298  IS_LESSTHAN
00001260  2838 5000                299      MOVE.L      BEGINADDR,D4        * Store beginning address in D4
00001264  2C38 5010                300      MOVE.L      ENDADDR,D6          * Store ending address in D6
00001268  B886                     301      CMP.L       D6,D4               * Is D4 < D6
0000126A  6D00 000C                302      BLT         LT                  * Yes, mark true return to main
0000126E  11FC 0000 5021           303      MOVE.B      #0,HEXFLAG          * No, mark false
00001274  6000 FE62                304      BRA         CLEAR               * Clear values, return to main
00001278                           305  
00001278                           306  LT
00001278  11FC 0001 5021           307      MOVE.B      #1,HEXFLAG          * Mark true
0000127E  4E75                     308      RTS                             * Return to main
00001280                           309  
00001280                           310  
00001280                           311  
00001280                           312  IS_HEX_EVEN
00001280  3606                     313      MOVE.W      D6,D3               * Move value to be modded into D3
00001282  3A3C 0002                314      MOVE.W      #MOD,D5             * Move mod value into D5
00001286  86C5                     315      DIVU        D5,D3               * Divide D3 by D5
00001288  123C 0003                316      MOVE.B      #3,D1               * Set counter to shift value into word
0000128C                           317                                      * position
0000128C                           318  REPEAT
0000128C  E88B                     319      LSR.L       #4,D3               * Shift remainder to lower word
0000128E  57C9 FFFC                320      DBEQ        D1,REPEAT           * UNTIL [D0] = - 1
00001292  4241                     321      CLR         D1                  * Clear
00001294                           322  
00001294  B6BC 00000000            323      CMP.L       #0,D3               * Is hex even?
0000129A  6600 000E                324      BNE         NOTEVEN             * No, clear and go back to get_hex
0000129E  31C3 5050                325      MOVE.W      D3,REMAINDER        * Save remainder
000012A2  11FC 0001 5021           326      MOVE.B      #1,HEXFLAG          * Set true
000012A8  4E75                     327      RTS                             * Return to main
000012AA                           328  
000012AA                           329  NOTEVEN
000012AA  11FC 0000 5021           330      MOVE.B      #0,HEXFLAG          * Set false
000012B0  6000 FE26                331      BRA         CLEAR               * Clear values
000012B4                           332  
000012B4                           333  
000012B4                           334  
000012B4                           335  PRINT_HEXVALUE
000012B4  103C 000E                336      MOVE.B      #14,D0              * Moves the Task 14 into D0
000012B8  4E4F                     337      TRAP        #15                 * Displays contents of A1
000012BA                           338  
000012BA  103C 0003                339      MOVE.B      #3,D0               * Moves the Task 3 into D0
000012BE  4E4F                     340      TRAP        #15                 * Displays contents of D1
000012C0                           341  
000012C0  4E75                     342      RTS                             * Return from subroutine
000012C2                           343  
000012C2                           344  
000012C2                           345  NEW_LINE
000012C2  43F9 000046FE            346      LEA         ENDL,A1             * Loads message into A1
000012C8  103C 000E                347      MOVE.B      #14,D0              * Moves the TRACK 14 into D0
000012CC  4E4F                     348      TRAP        #15                 * Displays New line
000012CE  4E75                     349      RTS                             * Return from subroutine
000012D0                           350  
000012D0                           351  
000012D0                           352  CLEARSCRN
000012D0  103C 000B                353      MOVE.B      #11,D0              * Task 11 for clearing screen
000012D4  323C FF00                354      MOVE.W      #$FF00,D1           * FF00, Clear screen
000012D8  4E4F                     355      TRAP        #15                 * Wait for keystroke
000012DA  4E75                     356      RTS                             * Return from subroutine
000012DC                           357  
000012DC                           358  
000012DC                           359  
000012DC                           360  
000012DC                           361  ADDRESS_ERR
000012DC  6100 FFF2                362      BSR.W       CLEARSCRN           * Clear output before displaying error
000012E0  103C 000D                363      MOVE.B      #13,D0              * Moves the Task 13 into D0
000012E4  4E4F                     364      TRAP        #15                 * Displays contents of A1
000012E6  103C 0005                365      MOVE.B      #5,D0               * Read single character from
000012EA  4E4F                     366      TRAP        #15                 * The keyboard into D1.B
000012EC  4E75                     367      RTS                             * Return from subroutine
000012EE                           368  
000012EE                           369  
000012EE                           370  
000012EE                           371  INVALID_DATA
000012EE  220E                     372      MOVE.L      A6,D1               * Move the address location to D1
000012F0  143C 0010                373      MOVE.B      #16,D2              * Move base 16 to D2
000012F4  103C 000F                374      MOVE.B      #15,D0              * Moves Task 15 into D0
000012F8  4E4F                     375      TRAP        #15                 * Displays contents of D1
000012FA                           376  
000012FA  43F9 00004742            377      LEA         TAB,A1              * Load TAB to A1
00001300  103C 000E                378      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001304  4E4F                     379      TRAP        #15                 * Displays a tab of A1
00001306                           380  
00001306  43F9 000014E7            381      LEA         DATA,A1             * Load address location to A1
0000130C  103C 000E                382      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001310  4E4F                     383      TRAP        #15                 * Displays location of A1
00001312                           384  
00001312  43F9 00004742            385      LEA         TAB,A1              * Load TAB to A1
00001318  103C 000E                386      MOVE.B      #14,D0              * Moves the Task 14 into D0
0000131C  4E4F                     387      TRAP        #15                 * Displays a tab of A1
0000131E                           388  
0000131E  43F9 00004733            389      LEA         DOLLAR,A1           * Load TAB to A1
00001324  103C 000E                390      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001328  4E4F                     391      TRAP        #15                 * Displays a tab of A1
0000132A                           392  
0000132A  3216                     393      MOVE.W      (A6),D1             * Move the address value to D1
0000132C  143C 0010                394      MOVE.B      #16,D2              * Move base 16 to D2
00001330  103C 000F                395      MOVE.B      #15,D0              * Moves Task 15 into D0
00001334  4E4F                     396      TRAP        #15                 * Displays value of D1
00001336                           397  
00001336  43F9 000046FE            398      LEA         ENDL,A1             * Load TAB to A1
0000133C  103C 000E                399      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001340  4E4F                     400      TRAP        #15                 * Displays a tab of A1
00001342                           401  
00001342  4E75                     402      RTS                             * Return from subroutine
00001344                           403  
00001344                           404  
00001344                           405  
00001344                           406  
00001344= 57 45 4C 43 4F 4D ...    407  INTRO           DC.B 'WELCOME!',CR,LF,'THIS IS A 68K DISASSEMBLER.',CR,LF,0
0000136C= 50 4C 45 41 53 45 ...    408  PS1             DC.B 'PLEASE ENTER THE STARTING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000013B6= 50 4C 45 41 53 45 ...    409  PS2             DC.B 'PLEASE ENTER THE ENDING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000013FE= 0D 0A 42 45 47 49 ...    410  BMESSAGE        DC.B CR,LF,'BEGINNING ADDRESS GIVEN IS: ',0
0000141D= 0D 0A 45 4E 44 49 ...    411  EMESSAGE        DC.B CR,LF,'ENDING ADDRESS GIVEN IS   : ',0
0000143C                           412  
0000143C= 54 48 45 20 42 45 ...    413  ADR_ERR_NOTLT   DC.B 'THE BEGINNING ADDRESS MUST BE LESS THAN THE ENDING ADDRESS.',CR,LF,'PRESS ANY KEY TO TRY AGAIN...',0
00001497                           414  
00001497                           415  HEXSTRING       DS.B 80             * Var for hex string
000014E7                           416  
000014E7= 44 41 54 41 00           417  DATA            DC.B 'DATA',0
000014EC                           418  
000014EC                           419  
000014EC                           420  
000014EC                           421  
000014EC                           422  
000014EC                           423  
000014EC                           424  
000014EC                           425  
000014EC                           426  
000014EC                           427  -------------------- end include --------------------
000014EC                           428      INCLUDE 'OpCodes.X68'
000014EC                           429  
000014EC                           430          INCLUDE 'OCMessages.X68'
000014EC                           431  
000014EC                           432  
000014EC  =0000000D                433  CR      EQU     $0D
000014EC  =0000000A                434  LF      EQU     $0A
000014EC= 20 00                    435  MESSAGESPACE DC.B  ' ',0
000014EE= 4E 4F 50 00              436  MESSAGENOP DC.B    'NOP',0
000014F2                           437  
000014F2= 4D 4F 56 45 2E 57 00     438  MESSAGEMOVEW DC.B    'MOVE.W',0
000014F9= 4D 4F 56 45 2E 4C 00     439  MESSAGEMOVEL DC.B    'MOVE.L',0
00001500= 4D 4F 56 45 2E 42 00     440  MESSAGEMOVEB DC.B    'MOVE.B',0
00001507                           441  
00001507= 41 44 44 49 2E 57 00     442  MESSAGEADDIW DC.B    'ADDI.W',0
0000150E= 41 44 44 49 2E 4C 00     443  MESSAGEADDIL DC.B    'ADDI.L',0
00001515= 41 44 44 49 2E 42 00     444  MESSAGEADDIB DC.B    'ADDI.B',0
0000151C                           445  
0000151C= 4D 4F 56 45 41 2E ...    446  MESSAGEMOVEAL DC.B    'MOVEA.L',0
00001524= 4D 4F 56 45 41 2E ...    447  MESSAGEMOVEAW DC.B    'MOVEA.W',0
0000152C                           448  
0000152C= 4D 4F 56 45 4D 2E ...    449  MESSAGEMOVEML DC.B    'MOVEM.L',0
00001534= 4D 4F 56 45 4D 2E ...    450  MESSAGEMOVEMW DC.B    'MOVEM.W',0
0000153C                           451  
0000153C= 4A 53 52 00              452  MESSAGEJSR DC.B    'JSR',0
00001540                           453  
00001540= 43 4C 52 00              454  MESSAGECLR DC.B    'CLR',0
00001544                           455  
00001544= 52 54 53 00              456  MESSAGERTS DC.B    'RTS',0
00001548                           457  
00001548= 4C 45 41 00              458  MESSAGELEA DC.B    'LEA',0
0000154C                           459  
0000154C= 43 4C 52 2E 42 00        460  MESSAGECLRB DC.B    'CLR.B',0
00001552= 43 4C 52 2E 57 00        461  MESSAGECLRW DC.B    'CLR.W',0
00001558= 43 4C 52 2E 4C 00        462  MESSAGECLRL DC.B    'CLR.L',0
0000155E                           463  
0000155E= 41 44 44 51 2E 42 00     464  MESSAGEADDQB DC.B    'ADDQ.B',0
00001565= 41 44 44 51 2E 57 00     465  MESSAGEADDQW DC.B    'ADDQ.W',0
0000156C= 41 44 44 51 2E 4C 00     466  MESSAGEADDQL DC.B    'ADDQ.L',0
00001573                           467  
00001573= 43 4D 50 2E 42 00        468  MESSAGECMPB DC.B    'CMP.B',0
00001579= 43 4D 50 2E 57 00        469  MESSAGECMPW DC.B    'CMP.W',0
0000157F= 43 4D 50 2E 4C 00        470  MESSAGECMPL DC.B    'CMP.L',0
00001585                           471  
00001585= 53 55 42 2E 42 00        472  MESSAGESUBB DC.B    'SUB.B',0
0000158B= 53 55 42 2E 57 00        473  MESSAGESUBW DC.B    'SUB.W',0
00001591= 53 55 42 2E 4C 00        474  MESSAGESUBL DC.B    'SUB.L',0
00001597                           475  
00001597= 41 44 44 2E 42 00        476  MESSAGEADDB DC.B    'ADD.B',0
0000159D= 41 44 44 2E 57 00        477  MESSAGEADDW DC.B    'ADD.W',0
000015A3= 41 44 44 2E 4C 00        478  MESSAGEADDL DC.B    'ADD.L',0
000015A9                           479  
000015A9= 41 44 44 41 2E 57 00     480  MESSAGEADDAW DC.B    'ADDA.W',0
000015B0= 41 44 44 41 2E 4C 00     481  MESSAGEADDAL DC.B    'ADDA.L',0
000015B7                           482  
000015B7= 4D 4F 56 45 51 2E ...    483  MESSAGEMOVEQL DC.B    'MOVEQ.L',0
000015BF                           484  
000015BF= 41 4E 44 2E 42 00        485  MESSAGEANDB DC.B    'AND.B',0
000015C5= 41 4E 44 2E 57 00        486  MESSAGEANDW DC.B    'AND.W',0
000015CB= 41 4E 44 2E 4C 00        487  MESSAGEANDL DC.B    'AND.L',0
000015D1                           488  
000015D1= 4D 55 4C 53 2E 57 00     489  MESSAGEMULSW DC.B    'MULS.W',0
000015D8                           490  
000015D8= 41 53 52 2E 42 00        491  MESSAGEASRB DC.B    'ASR.B',0
000015DE= 41 53 52 2E 57 00        492  MESSAGEASRW DC.B    'ASR.W',0
000015E4= 41 53 52 2E 4C 00        493  MESSAGEASRL DC.B    'ASR.L',0
000015EA                           494  
000015EA= 41 53 4C 2E 42 00        495  MESSAGEASLB DC.B    'ASL.B',0
000015F0= 41 53 4C 2E 57 00        496  MESSAGEASLW DC.B    'ASL.W',0
000015F6= 41 53 4C 2E 4C 00        497  MESSAGEASLL DC.B    'ASL.L',0
000015FC                           498  
000015FC= 52 4F 52 2E 42 00        499  MESSAGERORB DC.B    'ROR.B',0
00001602= 52 4F 52 2E 57 00        500  MESSAGERORW DC.B    'ROR.W',0
00001608= 52 4F 52 2E 4C 00        501  MESSAGERORL DC.B    'ROR.L',0
0000160E                           502  
0000160E= 52 4F 4C 2E 42 00        503  MESSAGEROLB DC.B    'ROL.B',0
00001614= 52 4F 4C 2E 57 00        504  MESSAGEROLW DC.B    'ROL.W',0
0000161A= 52 4F 4C 2E 4C 00        505  MESSAGEROLL DC.B    'ROL.L',0
00001620                           506  
00001620= 4C 53 52 2E 42 00        507  MESSAGELSRB DC.B    'LSR.B',0
00001626= 4C 53 52 2E 57 00        508  MESSAGELSRW DC.B    'LSR.W',0
0000162C= 4C 53 52 2E 4C 00        509  MESSAGELSRL DC.B    'LSR.L',0
00001632                           510  
00001632= 4C 53 4C 2E 42 00        511  MESSAGELSLB DC.B    'LSL.B',0
00001638= 4C 53 4C 2E 57 00        512  MESSAGELSLW DC.B    'LSL.W',0
0000163E= 4C 53 4C 2E 4C 00        513  MESSAGELSLL DC.B    'LSL.L',0
00001644                           514  
00001644= 4F 52 2E 42 00           515  MESSAGEORB DC.B    'OR.B',0
00001649= 4F 52 2E 57 00           516  MESSAGEORW DC.B    'OR.W',0
0000164E= 4F 52 2E 4C 00           517  MESSAGEORL DC.B    'OR.L',0
00001653                           518  
00001653= 44 49 56 55 2E 57 00     519  MESSAGEDIVUW DC.B    'DIVU.W',0
0000165A                           520  
0000165A= 42 43 43 00              521  MESSAGEBCC DC.B    'BCC',0
0000165E= 42 47 54 00              522  MESSAGEBGT DC.B    'BGT',0
00001662= 42 4C 45 00              523  MESSAGEBLE DC.B    'BLE',0
00001666                           524  
00001666= 54 68 61 74 20 69 ...    525  MESSAGEOPCODE_INVALID DC.B    'That is not an opcode!', 0
0000167D                           526  
0000167D                           527  
0000167D                           528  
0000167D                           529  
0000167D                           530  -------------------- end include --------------------
0000167D                           531  
0000167D                           532  
0000167D                           533  OC_PARSE:
0000167E  48E7 FFFE                534          MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001682  41F9 0000169A            535          LEA         initial_table,A0 ; Index into the table
00001688  4280                     536          CLR.L       D0              ; Zero it
0000168A  3012                     537          MOVE.W      (A2),D0         ; We'll play with it here
0000168C  123C 000C                538          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001690  E268                     539          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001692                           540                                      ; and the rest are zeroed out)
00001692  C0FC 0006                541          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001696  4EF0 0000                542          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000169A                           543  
0000169A                           544  initial_table:
0000169A  4EF9 000016FA            545          JMP         code0000        ; ADDI.B, ADDI.W, or ADDI.L
000016A0  4EF9 00001700            546          JMP         code0001        ; MOVE.B
000016A6  4EF9 0000170C            547          JMP         code0010        ; MOVEA.L or MOVE.L
000016AC  4EF9 00001712            548          JMP         code0011        ; MOVEA.W or MOVE.W
000016B2  4EF9 00001718            549          JMP         code0100        ; NOP or MOVEM.W or MOVEM.L or LEA or CLR.B or CLR.W or CLR.L or JSR or RTS or MULS.W
000016B8  4EF9 00001724            550          JMP         code0101        ; ADDQ.B or ADDQ.W or ADDQ.L
000016BE  4EF9 00001730            551          JMP         code0110        ; BCC or BGT or BLE
000016C4  4EF9 0000173C            552          JMP         code0111        ; MOVEQ.L
000016CA  4EF9 00001748            553          JMP         code1000        ; OR.B or OR.W or OR.L or DIVU (DIVU is either word or long depending on ea)
000016D0  4EF9 00001754            554          JMP         code1001        ; SUB.B or SUB.W or SUB.L
000016D6  4EF9 00001760            555          JMP         code1010
000016DC  4EF9 00001768            556          JMP         code1011        ; CMP.B or CMP.W or CMP.L
000016E2  4EF9 00001774            557          JMP         code1100        ; AND_BorAND_WorAND_LorMULS_W
000016E8  4EF9 00001780            558          JMP         code1101        ; ADD.B or ADD.W or ADD.L
000016EE  4EF9 0000178C            559          JMP         code1110        ; ROd_LSd_ASd
000016F4  4EF9 00001798            560          JMP         code1111
000016FA                           561  
000016FA  4EB9 00002084            562  code0000 JSR        ADDI_BorADDI_WorADDI_L
00001700  4EB9 000029F4            563  code0001 JSR        ISMOVEB
00001706  4EB9 000017A0            564           JSR        DONE
0000170C  4EB9 000020DA            565  code0010 JSR        MOVEA_LorMOVE_L
00001712  4EB9 00002168            566  code0011 JSR        MOVEA_WorMOVE_W
00001718  4EB9 00001F86            567  code0100 JSR        NOP_MOVEM_LEA_JSR_CLR_RTS
0000171E  4EB9 000017A0            568           JSR        DONE
00001724  4EB9 00001D80            569  code0101 JSR        ADDQ_BorADDQ_WorADDQ_L
0000172A  4EB9 000017A0            570           JSR        DONE
00001730  4EB9 000017A6            571  code0110 JSR        BCCorBGTorBLE
00001736  4EB9 000017A0            572           JSR        DONE
0000173C  4EB9 000027EA            573  code0111 JSR        ISMOVEQL
00001742  4EB9 000017A0            574           JSR        DONE
00001748  4EB9 000017FC            575  code1000 JSR        OR_BorOR_WorOR_LorDIVU
0000174E  4EB9 000017A0            576           JSR        DONE
00001754  4EB9 00001C9C            577  code1001 JSR        SUB_BorSUB_WorSUB_L
0000175A  4EB9 000017A0            578           JSR        DONE
00001760  4EB9 000021F6            579  code1010 JSR    OPCODE_INVALID              ;INVALID
00001766  4E75                     580           RTS
00001768  4EB9 00001D2A            581  code1011 JSR        CMP_BorCMP_WorCMP_L
0000176E  4EB9 000017A0            582           JSR        DONE
00001774  4EB9 00001B80            583  code1100 JSR        AND_BorAND_WorAND_LorMULS_W
0000177A  4EB9 000017A0            584           JSR        DONE
00001780  4EB9 00001C0E            585  code1101 JSR        ADD_BorADD_WorADD_L
00001786  4EB9 000017A0            586           JSR        DONE
0000178C  4EB9 00001B30            587  code1110 JSR        ROd_LSd_ASd
00001792  4EB9 000017A0            588           JSR        DONE
00001798  4EB9 000021F6            589  code1111 JSR    OPCODE_INVALID              ;INVALID
0000179E  4E75                     590           RTS
000017A0  4CDF 7FFF                591  DONE    MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000017A4  4E75                     592          RTS
000017A6                           593  
000017A6  41F9 000017C4            594  BCCorBGTorBLE       LEA     tableBCCorBGTorBLE, A0            ; Index into the table
000017AC  4280                     595                      CLR.L   D0                  ; Zero it
000017AE  3016                     596                      MOVE.W  (A6),D0         ; We'll play with it here
000017B0  123C 0006                597                      MOVE.B  #6,D1           ; Shift 6 bits left
000017B4  E360                     598                      ASL.W   D1,D0
000017B6  123C 000E                599                      MOVE.B  #14,D1           ; Shift 14 bits to the right
000017BA  E268                     600                      LSR.W   D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
000017BC                           601                                      ; and the rest are zeroed out)
000017BC  C0FC 0006                602                      MULU    #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
000017C0  4EF0 0000                603                      JMP     0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
000017C4                           604  
000017C4  4EF9 000017DC            605  tableBCCorBGTorBLE   JMP    BCCorBGTorBLEcode00   ; BCC
000017CA  4EF9 000017E4            606                       JMP    BCCorBGTorBLEcode01   ;
000017D0  4EF9 000017EC            607                       JMP    BCCorBGTorBLEcode10   ; BGT
000017D6  4EF9 000017F4            608                       JMP    BCCorBGTorBLEcode11   ; BLE
000017DC                           609  
000017DC                           610  
000017DC                           611  
000017DC  4EB9 00002206            612  BCCorBGTorBLEcode00    JSR     ISBCC
000017E2  4E75                     613                         RTS
000017E4  4EB9 000021F6            614  BCCorBGTorBLEcode01    JSR    OPCODE_INVALID              ;INVALID
000017EA  4E75                     615                         RTS
000017EC  4EB9 0000222A            616  BCCorBGTorBLEcode10    JSR     ISBGT
000017F2  4E75                     617                         RTS
000017F4  4EB9 0000224E            618  BCCorBGTorBLEcode11    JSR     ISBLE
000017FA  4E75                     619                         RTS
000017FC                           620  
000017FC                           621  
000017FC                           622  OR_BorOR_WorOR_LorDIVU:
000017FC  41F9 0000181A            623          LEA         tableOR_BorOR_WorOR_LorDIVU, A0 ; Index into the table
00001802  4280                     624          CLR.L       D0              ; Zero it
00001804  3016                     625          MOVE.W      (A6),D0     ; We'll play with it here
00001806  123C 0007                626          MOVE.B      #7,D1           ; Shift 7 bits left
0000180A  E360                     627          ASL.W       D1,D0
0000180C  123C 000D                628          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001810  E268                     629          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001812                           630                                      ; and the rest are zeroed out)
00001812  C0FC 0006                631          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001816  4EF0 0000                632          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000181A                           633  
0000181A                           634  tableOR_BorOR_WorOR_LorDIVU
0000181A  4EF9 0000184A            635          JMP         OR_DIVUcode000  ; OR.B
00001820  4EF9 00001852            636          JMP         OR_DIVUcode001  ; OR.W
00001826  4EF9 0000185A            637          JMP         OR_DIVUcode010  ; OR.L
0000182C  4EF9 00001862            638          JMP         OR_DIVUcode011  ; DIVU.W
00001832  4EF9 0000186A            639          JMP         OR_DIVUcode100  ; OR.B
00001838  4EF9 00001872            640          JMP         OR_DIVUcode101  ; OR.W
0000183E  4EF9 0000187A            641          JMP         OR_DIVUcode110  ; OR.L
00001844  4EF9 00001882            642          JMP         OR_DIVUcode111  ; INVALID
0000184A                           643  
0000184A                           644  
0000184A  4EB9 00002296            645  OR_DIVUcode000 JSR  ISORB
00001850  4E75                     646                 RTS
00001852  4EB9 000022BA            647  OR_DIVUcode001 JSR  ISORW
00001858  4E75                     648                 RTS
0000185A  4EB9 000022DE            649  OR_DIVUcode010 JSR  ISORL
00001860  4E75                     650                 RTS
00001862  4EB9 00002272            651  OR_DIVUcode011 JSR  ISDIVUW
00001868  4E75                     652                 RTS
0000186A  4EB9 00002296            653  OR_DIVUcode100 JSR  ISORB
00001870  4E75                     654                 RTS
00001872  4EB9 000022BA            655  OR_DIVUcode101 JSR  ISORW
00001878  4E75                     656                 RTS
0000187A  4EB9 000022DE            657  OR_DIVUcode110 JSR  ISORL
00001880  4E75                     658                 RTS
00001882  4EB9 000021F6            659  OR_DIVUcode111 JSR    OPCODE_INVALID              ;INVALID
00001888  4E75                     660                 RTS
0000188A                           661  
0000188A                           662  
0000188A                           663  someASR:
0000188A  41F9 000018A8            664          LEA         tableSomeASR, A0 ; Index into the table
00001890  4280                     665          CLR.L       D0              ; Zero it
00001892  3016                     666          MOVE.W      (A6),D0         ; We'll play with it here
00001894  123C 0008                667          MOVE.B      #8,D1           ; Shift 8 bits left
00001898  E360                     668          ASL.W       D1,D0
0000189A  123C 000E                669          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000189E  E268                     670          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000018A0                           671                                      ; and the rest are zeroed out)
000018A0  C0FC 0006                672          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000018A4  4EF0 0000                673          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000018A8                           674  
000018A8                           675  tableSomeASR:
000018A8  4EF9 000018C0            676          JMP         ASRcode00       *ASR.B
000018AE  4EF9 000018C8            677          JMP         ASRcode01       *ASR.W
000018B4  4EF9 000018D0            678          JMP         ASRcode10       *ASR.L
000018BA  4EF9 000018D8            679          JMP         ASRcode11       *ASR.W
000018C0                           680  
000018C0  4EB9 00002302            681  ASRcode00 JSR       ISASRB
000018C6  4E75                     682            RTS
000018C8  4EB9 00002326            683  ASRcode01 JSR       ISASRW
000018CE  4E75                     684            RTS
000018D0  4EB9 0000234A            685  ASRcode10 JSR       ISASRL
000018D6  4E75                     686            RTS
000018D8  4EB9 00002326            687  ASRcode11 JSR       ISASRW
000018DE  4E75                     688            RTS
000018E0                           689  
000018E0                           690  someASL:
000018E0  41F9 000018FE            691          LEA         tableSomeASL, A0 ; Index into the table
000018E6  4280                     692          CLR.L       D0              ; Zero it
000018E8  3016                     693          MOVE.W      (A6),D0     ; We'll play with it here
000018EA  123C 0008                694          MOVE.B      #8,D1           ; Shift 8 bits left
000018EE  E360                     695          ASL.W       D1,D0
000018F0  123C 000E                696          MOVE.B      #14,D1          ; Shift 14 bits to the right
000018F4  E268                     697          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000018F6                           698                                      ; and the rest are zeroed out)
000018F6  C0FC 0006                699          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000018FA  4EF0 0000                700          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000018FE                           701  
000018FE                           702  tableSomeASL:
000018FE  4EF9 00001916            703          JMP         ASLcode00       *ASL.B
00001904  4EF9 0000191E            704          JMP         ASLcode01       *ASL.W
0000190A  4EF9 00001926            705          JMP         ASLcode10       *ASL.L
00001910  4EF9 0000192E            706          JMP         ASLcode11       *ASL.W
00001916                           707  
00001916  4EB9 0000236E            708  ASLcode00 JSR       ISASLB
0000191C  4E75                     709            RTS
0000191E  4EB9 00002392            710  ASLcode01 JSR       ISASLW
00001924  4E75                     711            RTS
00001926  4EB9 000023AC            712  ASLcode10 JSR       ISASLL
0000192C  4E75                     713            RTS
0000192E  4EB9 00002392            714  ASLcode11 JSR       ISASLW
00001934  4E75                     715            RTS
00001936                           716  
00001936                           717  someLSR:
00001936  41F9 00001954            718          LEA         tableSomeLSR, A0 ; Index into the table
0000193C  4280                     719          CLR.L       D0              ; Zero it
0000193E  3016                     720          MOVE.W      (A6),D0     ; We'll play with it here
00001940  123C 0008                721          MOVE.B      #8,D1           ; Shift 8 bits left
00001944  E360                     722          ASL.W       D1,D0
00001946  123C 000E                723          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000194A  E268                     724          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000194C                           725                                      ; and the rest are zeroed out)
0000194C  C0FC 0006                726          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001950  4EF0 0000                727          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001954                           728  
00001954                           729  tableSomeLSR:
00001954  4EF9 0000196C            730          JMP         LSRcode00       *LSR.B
0000195A  4EF9 00001974            731          JMP         LSRcode01       *LSR.W
00001960  4EF9 0000197C            732          JMP         LSRcode10       *LSR.L
00001966  4EF9 00001984            733          JMP         LSRcode11       *LSR.W
0000196C  4EB9 000023D0            734  LSRcode00 JSR       ISLSRB
00001972  4E75                     735            RTS
00001974  4EB9 000023F4            736  LSRcode01 JSR       ISLSRW
0000197A  4E75                     737            RTS
0000197C  4EB9 00002418            738  LSRcode10 JSR       ISLSRL
00001982  4E75                     739            RTS
00001984  4EB9 000023F4            740  LSRcode11 JSR       ISLSRW
0000198A  4E75                     741            RTS
0000198C                           742  
0000198C                           743  someLSL:
0000198C  41F9 000019AA            744          LEA         tableSomeLSL, A0 ; Index into the table
00001992  4280                     745          CLR.L       D0              ; Zero it
00001994  3016                     746          MOVE.W      (A6),D0     ; We'll play with it here
00001996  123C 0008                747          MOVE.B      #8,D1           ; Shift 8 bits left
0000199A  E360                     748          ASL.W       D1,D0
0000199C  123C 000E                749          MOVE.B      #14,D1          ; Shift 14 bits to the right
000019A0  E268                     750          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000019A2                           751                                      ; and the rest are zeroed out)
000019A2  C0FC 0006                752          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000019A6  4EF0 0000                753          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000019AA                           754  
000019AA                           755  tableSomeLSL:
000019AA  4EF9 000019C2            756          JMP         LSLcode00       *LSL.B
000019B0  4EF9 000019CA            757          JMP         LSLcode01       *LSL.W
000019B6  4EF9 000019D2            758          JMP         LSLcode10       *LSL.L
000019BC  4EF9 000019DA            759          JMP         LSLcode11       *LSL.W
000019C2                           760  
000019C2  4EB9 0000243C            761  LSLcode00 JSR       ISLSLB
000019C8  4E75                     762            RTS
000019CA  4EB9 00002456            763  LSLcode01 JSR       ISLSLW
000019D0  4E75                     764            RTS
000019D2  4EB9 0000247A            765  LSLcode10 JSR       ISLSLL
000019D8  4E75                     766            RTS
000019DA  4EB9 00002456            767  LSLcode11 JSR       ISLSLW
000019E0  4E75                     768            RTS
000019E2                           769  
000019E2                           770  someROL:
000019E2  41F9 00001A00            771          LEA         tableSomeROL, A0 ; Index into the table
000019E8  4280                     772          CLR.L       D0              ; Zero it
000019EA  3016                     773          MOVE.W      (A6),D0     ; We'll play with it here
000019EC  123C 0008                774          MOVE.B      #8,D1           ; Shift 8 bits left
000019F0  E360                     775          ASL.W       D1,D0
000019F2  123C 000E                776          MOVE.B      #14,D1          ; Shift 14 bits to the right
000019F6  E268                     777          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000019F8                           778                                      ; and the rest are zeroed out)
000019F8  C0FC 0006                779          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000019FC  4EF0 0000                780          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A00                           781  
00001A00                           782  tableSomeROL:
00001A00  4EF9 00001A18            783          JMP         ROLcode00       *ROL.B
00001A06  4EF9 00001A20            784          JMP         ROLcode01       *ROL.W
00001A0C  4EF9 00001A28            785          JMP         ROLcode10       *ROL.L
00001A12  4EF9 00001A30            786          JMP         ROLcode11       *ROL.W
00001A18                           787  
00001A18  4EB9 00002500            788  ROLcode00 JSR       ISROLB
00001A1E  4E75                     789            RTS
00001A20  4EB9 00002524            790  ROLcode01 JSR       ISROLW
00001A26  4E75                     791            RTS
00001A28  4EB9 00002548            792  ROLcode10 JSR       ISROLL
00001A2E  4E75                     793            RTS
00001A30  4EB9 00002524            794  ROLcode11 JSR       ISROLW
00001A36  4E75                     795            RTS
00001A38                           796  
00001A38                           797  
00001A38                           798  someROR:
00001A38  41F9 00001A56            799          LEA         tableSomeROR, A0 ; Index into the table
00001A3E  4280                     800          CLR.L       D0              ; Zero it
00001A40  3016                     801          MOVE.W      (A6),D0     ; We'll play with it here
00001A42  123C 0008                802          MOVE.B      #8,D1           ; Shift 8 bits left
00001A46  E360                     803          ASL.W       D1,D0
00001A48  123C 000E                804          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001A4C  E268                     805          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001A4E                           806                                      ; and the rest are zeroed out)
00001A4E  C0FC 0006                807          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001A52  4EF0 0000                808          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A56                           809  
00001A56                           810  tableSomeROR:
00001A56  4EF9 00001A6E            811          JMP         RORcode00       *ROR.B
00001A5C  4EF9 00001A76            812          JMP         RORcode01       *ROR.W
00001A62  4EF9 00001A7E            813          JMP         RORcode10       *ROR.L
00001A68  4EF9 00001A86            814          JMP         RORcode11       *ROR.W
00001A6E                           815  
00001A6E  4EB9 0000249E            816  RORcode00 JSR       ISRORB
00001A74  4E75                     817            RTS
00001A76  4EB9 000024C2            818  RORcode01 JSR       ISRORW
00001A7C  4E75                     819            RTS
00001A7E  4EB9 000024DC            820  RORcode10 JSR       ISRORL
00001A84  4E75                     821            RTS
00001A86  4EB9 000024C2            822  RORcode11 JSR       ISRORW
00001A8C  4E75                     823            RTS
00001A8E                           824  
00001A8E                           825  ROL_ROR:
00001A8E  41F9 00001AAC            826          LEA         tableROL_ROR, A0 ; Index into the table
00001A94  4280                     827          CLR.L       D0              ; Zero it
00001A96  3016                     828          MOVE.W      (A6),D0     ; We'll play with it here
00001A98  123C 0007                829          MOVE.B      #7,D1           ; Shift 7 bits left
00001A9C  E360                     830          ASL.W       D1,D0
00001A9E  123C 000F                831          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001AA2  E268                     832          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001AA4                           833                                      ; and the rest are zeroed out)
00001AA4  C0FC 0006                834          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001AA8  4EF0 0000                835          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001AAC                           836  
00001AAC                           837  tableROL_ROR:
00001AAC  4EF9 00001AB8            838          JMP         ROL_RORcode0    ; ROR
00001AB2  4EF9 00001ABE            839          JMP         ROL_RORcode1    ; ROL
00001AB8                           840  
00001AB8  4EB8 1A38                841  ROL_RORcode0 JSR    someROR
00001ABC  4E75                     842               RTS
00001ABE  4EB8 19E2                843  ROL_RORcode1 JSR    someROL
00001AC2  4E75                     844               RTS
00001AC4                           845  
00001AC4                           846  LSL_LSR:
00001AC4  41F9 00001AE2            847          LEA         tableLSL_LSR, A0 ; Index into the table
00001ACA  4280                     848          CLR.L       D0              ; Zero it
00001ACC  3016                     849          MOVE.W      (A6),D0     ; We'll play with it here
00001ACE  123C 0007                850          MOVE.B      #7,D1           ; Shift 7 bits left
00001AD2  E360                     851          ASL.W       D1,D0
00001AD4  123C 000F                852          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001AD8  E268                     853          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001ADA                           854                                      ; and the rest are zeroed out)
00001ADA  C0FC 0006                855          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001ADE  4EF0 0000                856          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001AE2                           857  
00001AE2                           858  tableLSL_LSR:
00001AE2  4EF9 00001AEE            859          JMP         LSL_LSRcode0    ; LSR
00001AE8  4EF9 00001AF4            860          JMP         LSL_LSRcode1    ; LSL
00001AEE                           861  
00001AEE  4EB8 1936                862  LSL_LSRcode0 JSR    someLSR
00001AF2  4E75                     863               RTS
00001AF4  4EB8 198C                864  LSL_LSRcode1 JSR    someLSL
00001AF8  4E75                     865               RTS
00001AFA                           866  
00001AFA                           867  ASL_ASR:
00001AFA  41F9 00001B18            868          LEA         tableASL_ASR, A0 ; Index into the table
00001B00  4280                     869          CLR.L       D0              ; Zero it
00001B02  3016                     870          MOVE.W      (A6),D0     ; We'll play with it here
00001B04  123C 0007                871          MOVE.B      #7,D1           ; Shift 7 bits left
00001B08  E360                     872          ASL.W       D1,D0
00001B0A  123C 000F                873          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001B0E  E268                     874          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B10                           875                                      ; and the rest are zeroed out)
00001B10  C0FC 0006                876          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B14  4EF0 0000                877          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B18                           878  
00001B18                           879  tableASL_ASR:
00001B18  4EF9 00001B24            880          JMP         ASL_ASRcode0    ; ASR
00001B1E  4EF9 00001B2A            881          JMP         ASL_ASRcode1    ; ASL
00001B24                           882  
00001B24  4EB8 188A                883  ASL_ASRcode0 JSR    someASR
00001B28  4E75                     884               RTS
00001B2A  4EB8 18E0                885  ASL_ASRcode1 JSR    someASL
00001B2E  4E75                     886               RTS
00001B30                           887  
00001B30                           888  ROd_LSd_ASd:
00001B30  41F9 00001B4E            889          LEA         tableROd_LSd_ASd, A0 ; Index into the table
00001B36  4280                     890          CLR.L       D0              ; Zero it
00001B38  3016                     891          MOVE.W      (A6),D0     ; We'll play with it here
00001B3A  123C 000B                892          MOVE.B      #11,D1          ; Shift 11 bits left
00001B3E  E360                     893          ASL.W       D1,D0
00001B40  123C 000F                894          MOVE.B      #15,D1          ; Shift 12 bits to the right
00001B44  E268                     895          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B46                           896                                      ; and the rest are zeroed out)
00001B46  C0FC 0006                897          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B4A  4EF0 0000                898          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B4E                           899  
00001B4E                           900  tableROd_LSd_ASd:
00001B4E  4EF9 00001B66            901          JMP         ROd_LSd_ASdcode00 ; ASL_ASR
00001B54  4EF9 00001B6C            902          JMP         ROd_LSd_ASdcode01 ; LSL_LSR
00001B5A  4EF9 00001B72            903          JMP         ROd_LSd_ASdcode10
00001B60  4EF9 00001B7A            904          JMP         ROd_LSd_ASdcode11 ; ROL_ROR
00001B66                           905  
00001B66  4EB8 1AFA                906  ROd_LSd_ASdcode00 JSR ASL_ASR
00001B6A  4E75                     907                    RTS
00001B6C  4EB8 1AC4                908  ROd_LSd_ASdcode01 JSR LSL_LSR
00001B70  4E75                     909                    RTS
00001B72  4EB9 000021F6            910  ROd_LSd_ASdcode10 JSR    OPCODE_INVALID              ;INVALID
00001B78  4E75                     911                    RTS
00001B7A  4EB8 1A8E                912  ROd_LSd_ASdcode11 JSR ROL_ROR
00001B7E  4E75                     913                    RTS
00001B80                           914  
00001B80                           915  AND_BorAND_WorAND_LorMULS_W:
00001B80  41F9 00001B9E            916          LEA         tableAND_BorAND_WorAND_LorMULS_W, A0            ; Index into the table
00001B86  4280                     917          CLR.L       D0                  ; Zero it
00001B88  3016                     918          MOVE.W      (A6),D0         ; We'll play with it here
00001B8A  123C 0007                919          MOVE.B      #7,D1           ; Shift 7 bits left
00001B8E  E360                     920          ASL.W       D1,D0
00001B90  123C 000D                921          MOVE.B      #13,D1              ; Shift 13 bits to the right
00001B94  E268                     922          LSR.W       D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B96                           923                                  ; and the rest are zeroed out)
00001B96  C0FC 0006                924          MULU        #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B9A  4EF0 0000                925          JMP         0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B9E                           926  
00001B9E                           927  tableAND_BorAND_WorAND_LorMULS_W:
00001B9E  4EF9 00001BCE            928          JMP         ANDcode000   ; AND.B
00001BA4  4EF9 00001BD6            929          JMP         ANDcode001   ; AND.W
00001BAA  4EF9 00001BDE            930          JMP         ANDcode010   ; AND.L
00001BB0  4EF9 00001BE6            931          JMP         ANDcode011
00001BB6  4EF9 00001BEE            932          JMP         ANDcode100   ; AND.B
00001BBC  4EF9 00001BF6            933          JMP         ANDcode101   ; AND.W
00001BC2  4EF9 00001BFE            934          JMP         ANDcode110   ; AND.L
00001BC8  4EF9 00001C06            935          JMP         ANDcode111   ; MULS.W
00001BCE                           936  
00001BCE  4EB9 00002590            937  ANDcode000 JSR      ISANDB
00001BD4  4E75                     938             RTS
00001BD6  4EB9 000025B4            939  ANDcode001 JSR      ISANDW
00001BDC  4E75                     940             RTS
00001BDE  4EB9 000025D8            941  ANDcode010 JSR      ISANDL
00001BE4  4E75                     942             RTS
00001BE6  4EB9 000021F6            943  ANDcode011 JSR    OPCODE_INVALID              ;INVALID
00001BEC  4E75                     944             RTS
00001BEE  4EB9 00002590            945  ANDcode100 JSR      ISANDB
00001BF4  4E75                     946             RTS
00001BF6  4EB9 000025B4            947  ANDcode101 JSR      ISANDW
00001BFC  4E75                     948             RTS
00001BFE  4EB9 000025D8            949  ANDcode110 JSR      ISANDL
00001C04  4E75                     950             RTS
00001C06  4EB9 0000256C            951  ANDcode111 JSR      ISMULSW
00001C0C  4E75                     952             RTS
00001C0E                           953  
00001C0E                           954  ADD_BorADD_WorADD_L:
00001C0E  41F9 00001C2C            955          LEA         tableADD_BorADD_WorADD_L, A0 ; Index into the table
00001C14  4280                     956          CLR.L       D0              ; Zero it
00001C16  3016                     957          MOVE.W      (A6),D0     ; We'll play with it here
00001C18  123C 0007                958          MOVE.B      #7,D1           ; Shift 7 bits left
00001C1C  E360                     959          ASL.W       D1,D0
00001C1E  123C 000D                960          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001C22  E268                     961          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001C24                           962                                      ; and the rest are zeroed out)
00001C24  C0FC 0006                963          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001C28  4EF0 0000                964          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001C2C                           965  
00001C2C                           966  tableADD_BorADD_WorADD_L:
00001C2C  4EF9 00001C5C            967          JMP         ADDcode000      *ADD.B
00001C32  4EF9 00001C64            968          JMP         ADDcode001      *ADD.W
00001C38  4EF9 00001C6C            969          JMP         ADDcode010      *ADD.L
00001C3E  4EF9 00001C74            970          JMP         ADDcode011      *ADDA.W
00001C44  4EF9 00001C7C            971          JMP         ADDcode100      *ADD.B
00001C4A  4EF9 00001C84            972          JMP         ADDcode101      *ADD.W
00001C50  4EF9 00001C8C            973          JMP         ADDcode110      *ADD.L
00001C56  4EF9 00001C94            974          JMP         ADDcode111      *ADDA.L
00001C5C                           975  
00001C5C  4EB9 00002644            976  ADDcode000 JSR      ISADDB
00001C62  4E75                     977             RTS
00001C64  4EB9 00002668            978  ADDcode001 JSR      ISADDW
00001C6A  4E75                     979             RTS
00001C6C  4EB9 0000268C            980  ADDcode010 JSR      ISADDL
00001C72  4E75                     981             RTS
00001C74  4EB9 000025FC            982  ADDcode011 JSR      ISADDAW
00001C7A  4E75                     983             RTS
00001C7C  4EB9 00002644            984  ADDcode100 JSR      ISADDB
00001C82  4E75                     985             RTS
00001C84  4EB9 00002668            986  ADDcode101 JSR      ISADDW
00001C8A  4E75                     987             RTS
00001C8C  4EB9 0000268C            988  ADDcode110 JSR      ISADDL
00001C92  4E75                     989             RTS
00001C94  4EB9 00002620            990  ADDcode111 JSR      ISADDAL
00001C9A  4E75                     991             RTS
00001C9C                           992  
00001C9C                           993  SUB_BorSUB_WorSUB_L:
00001C9C  41F9 00001CBA            994          LEA         tableSUB_BorSUB_WorSUB_L, A0 ; Index into the table
00001CA2  4280                     995          CLR.L       D0              ; Zero it
00001CA4  3016                     996          MOVE.W      (A6),D0     ; We'll play with it here
00001CA6  123C 0007                997          MOVE.B      #7,D1           ; Shift 7 bits left
00001CAA  E360                     998          ASL.W       D1,D0
00001CAC  123C 000D                999          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001CB0  E268                    1000          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001CB2                          1001                                      ; and the rest are zeroed out)
00001CB2  C0FC 0006               1002          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001CB6  4EF0 0000               1003          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001CBA                          1004  
00001CBA                          1005  tableSUB_BorSUB_WorSUB_L:
00001CBA  4EF9 00001CEA           1006          JMP         SUBcode000      *SUB.B
00001CC0  4EF9 00001CF2           1007          JMP         SUBcode001      *SUB.W
00001CC6  4EF9 00001CFA           1008          JMP         SUBcode010      *SUB.L
00001CCC  4EF9 00001D02           1009          JMP         SUBcode011
00001CD2  4EF9 00001D0A           1010          JMP         SUBcode100      *SUB.B
00001CD8  4EF9 00001D12           1011          JMP         SUBcode101      *SUB.W
00001CDE  4EF9 00001D1A           1012          JMP         SUBcode110      *SUB.L
00001CE4  4EF9 00001D22           1013          JMP         SUBcode111      ; INVALID
00001CEA                          1014  
00001CEA  4EB9 000026B0           1015  SUBcode000 JSR      ISSUBB
00001CF0  4E75                    1016             RTS
00001CF2  4EB9 000026D4           1017  SUBcode001 JSR      ISSUBW
00001CF8  4E75                    1018             RTS
00001CFA  4EB9 000026F8           1019  SUBcode010 JSR      ISSUBL
00001D00  4E75                    1020             RTS
00001D02  4EB9 000021F6           1021  SUBcode011 JSR      OPCODE_INVALID              ;INVALID
00001D08  4E75                    1022             RTS
00001D0A  4EB9 000026B0           1023  SUBcode100 JSR      ISSUBB
00001D10  4E75                    1024             RTS
00001D12  4EB9 000026D4           1025  SUBcode101 JSR      ISSUBW
00001D18  4E75                    1026             RTS
00001D1A  4EB9 000026F8           1027  SUBcode110 JSR      ISSUBL
00001D20  4E75                    1028             RTS
00001D22  4EB9 000021F6           1029  SUBcode111 JSR      OPCODE_INVALID              ;INVALID
00001D28  4E75                    1030             RTS
00001D2A                          1031  
00001D2A                          1032  CMP_BorCMP_WorCMP_L:
00001D2A  41F9 00001D48           1033          LEA         tableCMP_BorCMP_WorCMP_L, A0 ; Index into the table
00001D30  4280                    1034          CLR.L       D0              ; Zero it
00001D32  3016                    1035          MOVE.W      (A6),D0     ; We'll play with it here
00001D34  123C 0008               1036          MOVE.B      #8,D1           ; Shift 8 bits left
00001D38  E360                    1037          ASL.W       D1,D0
00001D3A  123C 000E               1038          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001D3E  E268                    1039          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001D40                          1040                                      ; and the rest are zeroed out)
00001D40  C0FC 0006               1041          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001D44  4EF0 0000               1042          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001D48                          1043  
00001D48                          1044  tableCMP_BorCMP_WorCMP_L:
00001D48  4EF9 00001D60           1045          JMP         CMPcode00       *CMP.B
00001D4E  4EF9 00001D68           1046          JMP         CMPcode01       *CMP.W
00001D54  4EF9 00001D70           1047          JMP         CMPcode10       *CMP.L
00001D5A  4EF9 00001D78           1048          JMP         CMPcode11       ; INVALID
00001D60                          1049  
00001D60  4EB9 0000271C           1050  CMPcode00   JSR      ISCMPB
00001D66  4E75                    1051              RTS
00001D68  4EB9 00002740           1052  CMPcode01   JSR      ISCMPW
00001D6E  4E75                    1053              RTS
00001D70  4EB9 00002764           1054  CMPcode10   JSR      ISCMPL
00001D76  4E75                    1055              RTS
00001D78  4EB9 000021F6           1056  CMPcode11   JSR    OPCODE_INVALID              ;INVALID
00001D7E  4E75                    1057              RTS
00001D80                          1058  
00001D80                          1059  ADDQ_BorADDQ_WorADDQ_L:
00001D80  41F9 00001D9E           1060          LEA         tableADDQ_BorADDQ_WorADDQ_L, A0 ; Index into the table
00001D86  4280                    1061          CLR.L       D0              ; Zero it
00001D88  3016                    1062          MOVE.W      (A6),D0     ; We'll play with it here
00001D8A  123C 0008               1063          MOVE.B      #8,D1           ; Shift 8 bits left
00001D8E  E360                    1064          ASL.W       D1,D0
00001D90  123C 000E               1065          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001D94  E268                    1066          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001D96                          1067                                      ; and the rest are zeroed out)
00001D96  C0FC 0006               1068          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001D9A  4EF0 0000               1069          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001D9E                          1070  
00001D9E                          1071  tableADDQ_BorADDQ_WorADDQ_L:
00001D9E  4EF9 00001DB6           1072          JMP         ADDQcode00      *ADDQ.B
00001DA4  4EF9 00001DBE           1073          JMP         ADDQcode01      *ADDQ.W
00001DAA  4EF9 00001DC6           1074          JMP         ADDQcode10      *ADDQ.L
00001DB0  4EF9 00001DCE           1075          JMP         ADDQcode11      ; INVALID
00001DB6                          1076  
00001DB6  4EB9 00002788           1077  ADDQcode00 JSR      ISADDQB
00001DBC  4E75                    1078             RTS
00001DBE  4EB9 000027AC           1079  ADDQcode01 JSR      ISADDQW
00001DC4  4E75                    1080             RTS
00001DC6  4EB9 000027D0           1081  ADDQcode10 JSR      ISADDQL
00001DCC  4E75                    1082             RTS
00001DCE  4EB9 000021F6           1083  ADDQcode11   JSR    OPCODE_INVALID              ;INVALID
00001DD4  4E75                    1084              RTS
00001DD6                          1085  
00001DD6                          1086  someCLR:
00001DD6  41F9 00001DF4           1087          LEA         tableSomeCLR, A0 ; Index into the table
00001DDC  4280                    1088          CLR.L       D0              ; Zero it
00001DDE  3016                    1089          MOVE.W      (A6),D0     ; We'll play with it here
00001DE0  123C 0008               1090          MOVE.B      #8,D1           ; Shift 8 bits left
00001DE4  E360                    1091          ASL.W       D1,D0
00001DE6  123C 000E               1092          MOVE.B      #14,D1       ; Shift 12 bits to the right
00001DEA  E268                    1093          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001DEC                          1094                                      ; and the rest are zeroed out)
00001DEC  C0FC 0006               1095          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001DF0  4EF0 0000               1096          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001DF4                          1097  
00001DF4                          1098  tableSomeCLR:
00001DF4  4EF9 00001E0C           1099          JMP         CLRcode00       *CLR.B
00001DFA  4EF9 00001E14           1100          JMP         CLRcode01       *CLR.W
00001E00  4EF9 00001E1C           1101          JMP         CLRcode10       *CLR.L
00001E06  4EF9 00001E24           1102          JMP         CLRcode11       ; INVALID
00001E0C                          1103  
00001E0C  4EB9 0000280E           1104  CLRcode00 JSR       ISCLRB
00001E12  4E75                    1105            RTS
00001E14  4EB9 00002832           1106  CLRcode01 JSR       ISCLRW
00001E1A  4E75                    1107            RTS
00001E1C  4EB9 00002856           1108  CLRcode10 JSR       ISCLRL
00001E22  4E75                    1109            RTS
00001E24  4EB9 000021F6           1110  CLRcode11 JSR    OPCODE_INVALID              ;INVALID
00001E2A  4E75                    1111            RTS
00001E2C                          1112  
00001E2C                          1113  NOPorCLRorRTSorJSR:
00001E2C  41F9 00001E5E           1114          LEA         tableNOPorCLRorRTSorJSR, A0 ; Index into the table
00001E32  4280                    1115          CLR.L       D0              ; Zero it
00001E34  3016                    1116          MOVE.W      (A6),D0     ; We'll play with it here
00001E36                          1117  
00001E36  323C 4E71               1118          MOVE.W      #%0100111001110001, D1 ; 0100111001110001 = NOP
00001E3A  B240                    1119          CMP.W       D0, D1
00001E3C  6700 0088               1120          BEQ         NOPcommand
00001E40                          1121  
00001E40  323C 4E75               1122          MOVE.W      #%0100111001110101, D1 ; 0100111001110101 = RTS
00001E44  B240                    1123          CMP.W       D0, D1
00001E46  6700 0076               1124          BEQ         RTScommand
00001E4A                          1125  
00001E4A  123C 0004               1126          MOVE.B      #4,D1           ; Shift 4 bits left
00001E4E  E360                    1127          ASL.W       D1,D0
00001E50  123C 000C               1128          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001E54  E268                    1129          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001E56                          1130                                      ; and the rest are zeroed out)
00001E56  C0FC 0006               1131          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001E5A  4EF0 0000               1132          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001E5E                          1133  
00001E5E                          1134  tableNOPorCLRorRTSorJSR:
00001E5E  4EF9 00001ECE           1135          JMP         JSRorCLRcode0000
00001E64  4EF9 00001ED6           1136          JMP         JSRorCLRcode0001
00001E6A  4EF9 00001EDE           1137          JMP         JSRorCLRcode0010
00001E70  4EF9 00001EE4           1138          JMP         JSRorCLRcode0011
00001E76  4EF9 00001EEC           1139          JMP         JSRorCLRcode0100
00001E7C  4EF9 00001EF4           1140          JMP         JSRorCLRcode0101
00001E82  4EF9 00001EFC           1141          JMP         JSRorCLRcode0110
00001E88  4EF9 00001F04           1142          JMP         JSRorCLRcode0111
00001E8E  4EF9 00001F0C           1143          JMP         JSRorCLRcode1000
00001E94  4EF9 00001F14           1144          JMP         JSRorCLRcode1001
00001E9A  4EF9 00001F1C           1145          JMP         JSRorCLRcode1010
00001EA0  4EF9 00001F24           1146          JMP         JSRorCLRcode1011
00001EA6  4EF9 00001F2C           1147          JMP         JSRorCLRcode1100
00001EAC  4EF9 00001F34           1148          JMP         JSRorCLRcode1101
00001EB2  4EF9 00001F3C           1149          JMP         JSRorCLRcode1110
00001EB8  4EF9 00001F44           1150          JMP         JSRorCLRcode1111
00001EBE                          1151  
00001EBE  4EB9 0000290A           1152  RTScommand JSR      ISRTS
00001EC4  4E75                    1153             RTS
00001EC6  4EB9 00002944           1154  NOPcommand JSR      ISNOP
00001ECC  4E75                    1155             RTS
00001ECE  4EB9 000021F6           1156  JSRorCLRcode0000 JSR    OPCODE_INVALID              ;INVALID
00001ED4  4E75                    1157                   RTS
00001ED6  4EB9 000021F6           1158  JSRorCLRcode0001 JSR    OPCODE_INVALID              ;INVALID
00001EDC  4E75                    1159                   RTS
00001EDE  4EB8 1DD6               1160  JSRorCLRcode0010 JSR someCLR
00001EE2  4E75                    1161                   RTS
00001EE4  4EB9 000021F6           1162  JSRorCLRcode0011 JSR    OPCODE_INVALID              ;INVALID
00001EEA  4E75                    1163                   RTS
00001EEC  4EB9 000021F6           1164  JSRorCLRcode0100 JSR    OPCODE_INVALID              ;INVALID
00001EF2  4E75                    1165                   RTS
00001EF4  4EB9 000021F6           1166  JSRorCLRcode0101 JSR    OPCODE_INVALID              ;INVALID
00001EFA  4E75                    1167                   RTS
00001EFC  4EB9 000021F6           1168  JSRorCLRcode0110 JSR    OPCODE_INVALID              ;INVALID
00001F02  4E75                    1169                   RTS
00001F04  4EB9 000021F6           1170  JSRorCLRcode0111 JSR    OPCODE_INVALID              ;INVALID
00001F0A  4E75                    1171                   RTS
00001F0C  4EB9 000021F6           1172  JSRorCLRcode1000 JSR    OPCODE_INVALID              ;INVALID
00001F12  4E75                    1173                   RTS
00001F14  4EB9 000021F6           1174  JSRorCLRcode1001 JSR    OPCODE_INVALID              ;INVALID
00001F1A  4E75                    1175                   RTS
00001F1C  4EB9 000021F6           1176  JSRorCLRcode1010 JSR    OPCODE_INVALID              ;INVALID
00001F22  4E75                    1177                   RTS
00001F24  4EB9 000021F6           1178  JSRorCLRcode1011 JSR    OPCODE_INVALID              ;INVALID
00001F2A  4E75                    1179                   RTS
00001F2C  4EB9 000021F6           1180  JSRorCLRcode1100 JSR    OPCODE_INVALID              ;INVALID
00001F32  4E75                    1181                   RTS
00001F34  4EB9 000021F6           1182  JSRorCLRcode1101 JSR    OPCODE_INVALID              ;INVALID
00001F3A  4E75                    1183                   RTS
00001F3C  4EB9 000028E6           1184  JSRorCLRcode1110 JSR ISJSR
00001F42  4E75                    1185                   RTS
00001F44  4EB9 000021F6           1186  JSRorCLRcode1111 JSR    OPCODE_INVALID              ;INVALID
00001F4A  4E75                    1187                   RTS
00001F4C                          1188  
00001F4C                          1189  someMOVEM:
00001F4C  41F9 00001F6A           1190          LEA         tableSomeMOVEM, A0 ; Index into the table
00001F52  4280                    1191          CLR.L       D0              ; Zero it
00001F54  3016                    1192          MOVE.W      (A6),D0     ; We'll play with it here
00001F56  123C 0009               1193          MOVE.B      #9,D1           ; Shift 9 bits left
00001F5A  E360                    1194          ASL.W       D1,D0
00001F5C  123C 000F               1195          MOVE.B      #15,D1       ; Shift 12 bits to the right
00001F60  E268                    1196          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001F62                          1197                                      ; and the rest are zeroed out)
00001F62  C0FC 0006               1198          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001F66  4EF0 0000               1199          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001F6A                          1200  
00001F6A                          1201  tableSomeMOVEM:
00001F6A  4EF9 00001F76           1202          JMP         MOVEMcode0      ; MOVEM.W
00001F70  4EF9 00001F7E           1203          JMP         MOVEMcode1      ; MOVEM.L
00001F76                          1204  
00001F76  4EB9 0000289E           1205  MOVEMcode0 JSR      ISMOVEMW
00001F7C  4E75                    1206             RTS
00001F7E  4EB9 0000287A           1207  MOVEMcode1 JSR      ISMOVEML
00001F84  4E75                    1208             RTS
00001F86                          1209  
00001F86                          1210  NOP_MOVEM_LEA_JSR_CLR_RTS:
00001F86  41F9 00001FAA           1211          LEA         tableNOP_MOVEM_LEA_JSR_CLR_RTS, A0 ; Index into the table
00001F8C  4280                    1212          CLR.L       D0              ; Zero it
00001F8E  3016                    1213          MOVE.W      (A6),D0     ; We'll play with it here
00001F90  123C 0007               1214          MOVE.B      #7,D1           ; Shift 7 bits right
00001F94  E260                    1215          ASR.W       D1,D0
00001F96  123C 000D               1216          MOVE.B      #13,D1          ; Shift 13 bits left
00001F9A  E360                    1217          ASL.W       D1,D0
00001F9C  123C 000C               1218          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001FA0  E268                    1219          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001FA2                          1220                                      ; and the rest are zeroed out)
00001FA2  C0FC 0006               1221          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001FA6  4EF0 0000               1222          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001FAA                          1223  
00001FAA                          1224  tableNOP_MOVEM_LEA_JSR_CLR_RTS:
00001FAA  4EF9 0000200A           1225          JMP         LOTScode0000
00001FB0  4EF9 00002012           1226          JMP         LOTScode0001
00001FB6  4EF9 0000201A           1227          JMP         LOTScode0010
00001FBC  4EF9 00002020           1228          JMP         LOTScode0011
00001FC2  4EF9 00002028           1229          JMP         LOTScode0100
00001FC8  4EF9 00002030           1230          JMP         LOTScode0101
00001FCE  4EF9 00002038           1231          JMP         LOTScode0110
00001FD4  4EF9 00002040           1232          JMP         LOTScode0111
00001FDA  4EF9 00002048           1233          JMP         LOTScode1000
00001FE0  4EF9 0000204E           1234          JMP         LOTScode1001
00001FE6  4EF9 00002056           1235          JMP         LOTScode1010
00001FEC  4EF9 0000205C           1236          JMP         LOTScode1011
00001FF2  4EF9 00002064           1237          JMP         LOTScode1100
00001FF8  4EF9 0000206C           1238          JMP         LOTScode1101
00001FFE  4EF9 00002074           1239          JMP         LOTScode1110
00002004  4EF9 0000207C           1240          JMP         LOTScode1111
0000200A                          1241  
0000200A  4EB9 000021F6           1242  LOTScode0000 JSR    OPCODE_INVALID              ; MULS.L and DIVU.L are not supported for 68000 Disassember
00002010  4E75                    1243               RTS
00002012  4EB9 000021F6           1244  LOTScode0001 JSR    OPCODE_INVALID              ;INVALID
00002018  4E75                    1245               RTS
0000201A  4EB8 1F4C               1246  LOTScode0010 JSR    someMOVEM
0000201E  4E75                    1247               RTS
00002020  4EB9 000021F6           1248  LOTScode0011 JSR    OPCODE_INVALID              ;INVALID
00002026  4E75                    1249               RTS
00002028  4EB9 000021F6           1250  LOTScode0100 JSR    OPCODE_INVALID              ;INVALID
0000202E  4E75                    1251               RTS
00002030  4EB9 000021F6           1252  LOTScode0101 JSR    OPCODE_INVALID              ;INVALID
00002036  4E75                    1253               RTS
00002038  4EB9 000028C2           1254  LOTScode0110 JSR    ISLEA
0000203E  4E75                    1255               RTS
00002040  4EB9 000021F6           1256  LOTScode0111 JSR    OPCODE_INVALID              ;INVALID
00002046  4E75                    1257               RTS
00002048  4EB8 1E2C               1258  LOTScode1000 JSR    NOPorCLRorRTSorJSR
0000204C  4E75                    1259               RTS
0000204E  4EB9 000021F6           1260  LOTScode1001 JSR    OPCODE_INVALID              ;INVALID
00002054  4E75                    1261               RTS
00002056  4EB8 1E2C               1262  LOTScode1010 JSR    NOPorCLRorRTSorJSR
0000205A  4E75                    1263               RTS
0000205C  4EB9 000021F6           1264  LOTScode1011 JSR    OPCODE_INVALID              ;INVALID
00002062  4E75                    1265               RTS
00002064  4EB9 000021F6           1266  LOTScode1100 JSR    OPCODE_INVALID              ;INVALID
0000206A  4E75                    1267               RTS
0000206C  4EB9 000021F6           1268  LOTScode1101 JSR    OPCODE_INVALID              ;INVALID
00002072  4E75                    1269               RTS
00002074  4EB9 000028C2           1270  LOTScode1110 JSR    ISLEA
0000207A  4E75                    1271               RTS
0000207C  4EB9 000021F6           1272  LOTScode1111 JSR    OPCODE_INVALID              ;INVALID
00002082  4E75                    1273               RTS
00002084                          1274  
00002084                          1275  ADDI_BorADDI_WorADDI_L:
00002084  41F9 000020A2           1276          LEA         tableADDI_BorADDI_WorADDI_L,A0 ; Index into the table
0000208A  4280                    1277          CLR.L       D0              ; Zero it
0000208C  3016                    1278          MOVE.W      (A6),D0     ; We'll play with it here
0000208E  123C 0007               1279          MOVE.B      #7,D1           ; Shift 7 bits left
00002092  E360                    1280          ASL.W       D1,D0
00002094  123C 000D               1281          MOVE.B      #13,D1          ; Shift 13 bits right
00002098  E260                    1282          ASR.W       D1,D0
0000209A  C0FC 0006               1283          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000209E  4EF0 0000               1284          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000020A2                          1285  
000020A2                          1286  tableADDI_BorADDI_WorADDI_L:
000020A2  4EF9 000020BA           1287          JMP         ADDIBcode00
000020A8  4EF9 000020C2           1288          JMP         ADDIWcode01
000020AE  4EF9 000020CA           1289          JMP         ADDILcode10
000020B4  4EF9 000020D2           1290          JMP         ADDILcode11
000020BA                          1291  
000020BA  4EB9 00002A56           1292  ADDIBcode00 JSR     ISADDIB
000020C0  4E75                    1293              RTS
000020C2  4EB9 00002A0E           1294  ADDIWcode01 JSR     ISADDIW
000020C8  4E75                    1295              RTS
000020CA  4EB9 00002A32           1296  ADDILcode10 JSR     ISADDIL
000020D0  4E75                    1297              RTS
000020D2  4EB9 000021F6           1298  ADDILcode11 JSR    OPCODE_INVALID              ;INVALID
000020D8  4E75                    1299              RTS
000020DA                          1300  
000020DA                          1301  MOVEA_LorMOVE_L:
000020DA  41F9 000020F8           1302          LEA         tableMOVEA_LorMOVE_L,A0 ; Index into the table
000020E0  4280                    1303          CLR.L       D0              ; Zero it
000020E2  3016                    1304          MOVE.W      (A6),D0         ; We'll play with it here
000020E4  123C 0007               1305          MOVE.B      #7,D1           ; Shift 7 bits left
000020E8  E360                    1306          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
000020EA  123C 000D               1307          MOVE.B      #13,D1          ; Shift 13 bits right
000020EE  E260                    1308          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
000020F0  C0FC 0006               1309          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000020F4  4EF0 0000               1310          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000020F8                          1311  
000020F8                          1312  tableMOVEA_LorMOVE_L:
000020F8  4EF9 00002128           1313          JMP         MOVEcode000
000020FE  4EF9 00002130           1314          JMP         MOVEAcode001
00002104  4EF9 00002138           1315          JMP         MOVEcode010
0000210A  4EF9 00002140           1316          JMP         MOVEcode011
00002110  4EF9 00002148           1317          JMP         MOVEcode100
00002116  4EF9 00002150           1318          JMP         MOVEcode101
0000211C  4EF9 00002158           1319          JMP         MOVEcode110
00002122  4EF9 00002160           1320          JMP         MOVEcode111
00002128                          1321  
00002128  4EB9 000029AC           1322  MOVEcode000 JSR     ISMOVEL
0000212E  4E75                    1323              RTS
00002130  4EB9 000029D0           1324  MOVEAcode001 JSR    ISMOVEAL
00002136  4E75                    1325               RTS
00002138  4EB9 000029AC           1326  MOVEcode010 JSR     ISMOVEL
0000213E  4E75                    1327              RTS
00002140  4EB9 000029AC           1328  MOVEcode011 JSR     ISMOVEL
00002146  4E75                    1329              RTS
00002148  4EB9 000029AC           1330  MOVEcode100 JSR     ISMOVEL
0000214E  4E75                    1331              RTS
00002150  4EB9 000029AC           1332  MOVEcode101 JSR     ISMOVEL
00002156  4E75                    1333              RTS
00002158  4EB9 000029AC           1334  MOVEcode110 JSR     ISMOVEL
0000215E  4E75                    1335              RTS
00002160  4EB9 000029AC           1336  MOVEcode111 JSR     ISMOVEL
00002166  4E75                    1337              RTS
00002168                          1338  
00002168                          1339  MOVEA_WorMOVE_W:
00002168  41F9 00002186           1340          LEA         tableMOVEA_WorMOVE_W,A0 ; Index into the table
0000216E  4280                    1341          CLR.L       D0              ; Zero it
00002170  3016                    1342          MOVE.W      (A6),D0     ; We'll play with it here
00002172  123C 0007               1343          MOVE.B      #7,D1           ; Shift 7 bits left
00002176  E360                    1344          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
00002178  123C 000D               1345          MOVE.B      #13,D1          ; Shift 13 bits right
0000217C  E260                    1346          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
0000217E  C0FC 0006               1347          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002182  4EF0 0000               1348          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00002186                          1349  
00002186                          1350  tableMOVEA_WorMOVE_W:
00002186  4EF9 000021B6           1351          JMP         MOVEWcode000
0000218C  4EF9 000021BE           1352          JMP         MOVEAWcode001
00002192  4EF9 000021C6           1353          JMP         MOVEWcode010
00002198  4EF9 000021CE           1354          JMP         MOVEWcode011
0000219E  4EF9 000021D6           1355          JMP         MOVEWcode100
000021A4  4EF9 000021DE           1356          JMP         MOVEWcode101
000021AA  4EF9 000021E6           1357          JMP         MOVEWcode110
000021B0  4EF9 000021EE           1358          JMP         MOVEWcode111
000021B6                          1359  
000021B6  4EB9 00002964           1360  MOVEWcode000 JSR    ISMOVEW
000021BC  4E75                    1361               RTS
000021BE  4EB9 00002988           1362  MOVEAWcode001 JSR   ISMOVEAW
000021C4  4E75                    1363                RTS
000021C6  4EB9 00002964           1364  MOVEWcode010 JSR    ISMOVEW
000021CC  4E75                    1365               RTS
000021CE  4EB9 00002964           1366  MOVEWcode011 JSR    ISMOVEW
000021D4  4E75                    1367               RTS
000021D6  4EB9 00002964           1368  MOVEWcode100 JSR    ISMOVEW
000021DC  4E75                    1369               RTS
000021DE  4EB9 00002964           1370  MOVEWcode101 JSR    ISMOVEW
000021E4  4E75                    1371               RTS
000021E6  4EB9 00002964           1372  MOVEWcode110 JSR    ISMOVEW
000021EC  4E75                    1373               RTS
000021EE  4EB9 00002964           1374  MOVEWcode111 JSR    ISMOVEW
000021F4  4E75                    1375               RTS
000021F6                          1376  
000021F6                          1377  ; TODO: adjust workflow to:
000021F6                          1378  ;   1) save message address to buffer pointer
000021F6  48E7 FFFE               1379  OPCODE_INVALID  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000021FA  4EB8 12EE               1380              JSR     INVALID_DATA
000021FE  548E                    1381              ADDA.L      #$00000002, A6          ; Increment past current opcode word
00002200  4CDF 7FFF               1382              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00002204  4E75                    1383              RTS
00002206                          1384  
00002206  48E7 FFFE               1385  ISBCC  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000220A  49F8 165A               1386              LEA    MESSAGEBCC, A4
0000220E  4EB9 00004642           1387              JSR    WRITE2MEM
00002214  49F8 14EC               1388              LEA    MESSAGESPACE, A4
00002218  4EB9 00004642           1389              JSR    WRITE2MEM
0000221E  4EB9 000036BE           1390              JSR     EA_Bcc
00002224  4CDF 7FFF               1391              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00002228  4E75                    1392              RTS
0000222A  48E7 FFFE               1393  ISBGT  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000222E  49F8 165E               1394              LEA MESSAGEBGT, A4
00002232  4EB9 00004642           1395              JSR    WRITE2MEM
00002238  49F8 14EC               1396              LEA    MESSAGESPACE, A4
0000223C  4EB9 00004642           1397              JSR    WRITE2MEM
00002242  4EB9 000036BE           1398              JSR     EA_Bcc
00002248  4CDF 7FFF               1399              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
0000224C  4E75                    1400              RTS
0000224E                          1401  
0000224E  48E7 FFFE               1402  ISBLE  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002252  49F8 1662               1403              LEA MESSAGEBLE, A4
00002256  4EB9 00004642           1404              JSR    WRITE2MEM
0000225C  49F8 14EC               1405              LEA    MESSAGESPACE, A4
00002260  4EB9 00004642           1406              JSR    WRITE2MEM
00002266  4EB9 000036BE           1407              JSR     EA_Bcc
0000226C  4CDF 7FFF               1408              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00002270  4E75                    1409              RTS
00002272                          1410  
00002272  48E7 FFFE               1411  ISDIVUW     MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002276  49F8 1653               1412              LEA MESSAGEDIVUW, A4
0000227A  4EB9 00004642           1413              JSR    WRITE2MEM
00002280  49F8 14EC               1414              LEA    MESSAGESPACE, A4
00002284  4EB9 00004642           1415              JSR    WRITE2MEM
0000228A  4EB9 000038F0           1416              JSR     EA_DIVU_W
00002290  4CDF 7FFF               1417              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00002294  4E75                    1418              RTS
00002296                          1419  
00002296  48E7 FFFE               1420  ISORB   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000229A  49F8 1644               1421          LEA         MESSAGEORB, A4
0000229E  4EB9 00004642           1422          JSR    WRITE2MEM
000022A4  49F8 14EC               1423          LEA    MESSAGESPACE, A4
000022A8  4EB9 00004642           1424          JSR    WRITE2MEM
000022AE  4EB9 00004104           1425          JSR         EA_OR
000022B4  4CDF 7FFF               1426          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022B8  4E75                    1427          RTS
000022BA                          1428  
000022BA  48E7 FFFE               1429  ISORW   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022BE  49F8 1649               1430          LEA         MESSAGEORW, A4
000022C2  4EB9 00004642           1431          JSR    WRITE2MEM
000022C8  49F8 14EC               1432          LEA    MESSAGESPACE, A4
000022CC  4EB9 00004642           1433          JSR    WRITE2MEM
000022D2  4EB9 00004104           1434          JSR         EA_OR
000022D8  4CDF 7FFF               1435          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022DC  4E75                    1436          RTS
000022DE                          1437  
000022DE  48E7 FFFE               1438  ISORL   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022E2  49F8 164E               1439          LEA         MESSAGEORL, A4
000022E6  4EB9 00004642           1440          JSR    WRITE2MEM
000022EC  49F8 14EC               1441          LEA    MESSAGESPACE, A4
000022F0  4EB9 00004642           1442          JSR    WRITE2MEM
000022F6  4EB9 00004104           1443          JSR         EA_OR
000022FC  4CDF 7FFF               1444          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002300  4E75                    1445          RTS
00002302                          1446  
00002302  48E7 FFFE               1447  ISASRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002306  49F8 15D8               1448          LEA         MESSAGEASRB, A4
0000230A  4EB9 00004642           1449          JSR    WRITE2MEM
00002310  49F8 14EC               1450          LEA    MESSAGESPACE, A4
00002314  4EB9 00004642           1451          JSR    WRITE2MEM
0000231A  4EB9 0000358E           1452          JSR         EA_ASd
00002320  4CDF 7FFF               1453          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002324  4E75                    1454          RTS
00002326                          1455  
00002326  48E7 FFFE               1456  ISASRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000232A  49F8 15DE               1457          LEA         MESSAGEASRW, A4
0000232E  4EB9 00004642           1458          JSR    WRITE2MEM
00002334  49F8 14EC               1459          LEA    MESSAGESPACE, A4
00002338  4EB9 00004642           1460          JSR    WRITE2MEM
0000233E  4EB9 0000358E           1461          JSR         EA_ASd
00002344  4CDF 7FFF               1462          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002348  4E75                    1463          RTS
0000234A                          1464  
0000234A  48E7 FFFE               1465  ISASRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000234E  49F8 15E4               1466          LEA         MESSAGEASRL, A4
00002352  4EB9 00004642           1467          JSR    WRITE2MEM
00002358  49F8 14EC               1468          LEA    MESSAGESPACE, A4
0000235C  4EB9 00004642           1469          JSR    WRITE2MEM
00002362  4EB9 0000358E           1470          JSR         EA_ASd
00002368  4CDF 7FFF               1471          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000236C  4E75                    1472          RTS
0000236E                          1473  
0000236E  48E7 FFFE               1474  ISASLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002372  49F8 15EA               1475          LEA         MESSAGEASLB, A4
00002376  4EB9 00004642           1476          JSR    WRITE2MEM
0000237C  49F8 14EC               1477          LEA    MESSAGESPACE, A4
00002380  4EB9 00004642           1478          JSR    WRITE2MEM
00002386  4EB9 0000358E           1479          JSR         EA_ASd
0000238C  4CDF 7FFF               1480          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002390  4E75                    1481          RTS
00002392                          1482  
00002392  48E7 FFFE               1483  ISASLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002396  43F8 15F0               1484          LEA         MESSAGEASLW, A1
0000239A  103C 000E               1485          MOVE.B      #14, D0
0000239E  4E4F                    1486          TRAP        #15
000023A0  4EB9 0000358E           1487          JSR         EA_ASd
000023A6  4CDF 7FFF               1488          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023AA  4E75                    1489          RTS
000023AC                          1490  
000023AC  48E7 FFFE               1491  ISASLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023B0  49F8 15F6               1492          LEA         MESSAGEASLL, A4
000023B4  4EB9 00004642           1493          JSR    WRITE2MEM
000023BA  49F8 14EC               1494          LEA    MESSAGESPACE, A4
000023BE  4EB9 00004642           1495          JSR    WRITE2MEM
000023C4  4EB9 0000358E           1496          JSR         EA_ASd
000023CA  4CDF 7FFF               1497          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023CE  4E75                    1498          RTS
000023D0                          1499  
000023D0  48E7 FFFE               1500  ISLSRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023D4  49F8 1620               1501          LEA         MESSAGELSRB, A4
000023D8  4EB9 00004642           1502          JSR    WRITE2MEM
000023DE  49F8 14EC               1503          LEA    MESSAGESPACE, A4
000023E2  4EB9 00004642           1504          JSR    WRITE2MEM
000023E8  4EB9 00003B84           1505          JSR         EA_LSd
000023EE  4CDF 7FFF               1506          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023F2  4E75                    1507          RTS
000023F4                          1508  
000023F4  48E7 FFFE               1509  ISLSRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023F8  49F8 1626               1510          LEA         MESSAGELSRW, A4
000023FC  4EB9 00004642           1511          JSR    WRITE2MEM
00002402  49F8 14EC               1512          LEA    MESSAGESPACE, A4
00002406  4EB9 00004642           1513          JSR    WRITE2MEM
0000240C  4EB9 00003B84           1514          JSR         EA_LSd
00002412  4CDF 7FFF               1515          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002416  4E75                    1516          RTS
00002418                          1517  
00002418  48E7 FFFE               1518  ISLSRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000241C  49F8 162C               1519          LEA         MESSAGELSRL, A4
00002420  4EB9 00004642           1520          JSR    WRITE2MEM
00002426  49F8 14EC               1521          LEA    MESSAGESPACE, A4
0000242A  4EB9 00004642           1522          JSR    WRITE2MEM
00002430  4EB9 00003B84           1523          JSR         EA_LSd
00002436  4CDF 7FFF               1524          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000243A  4E75                    1525          RTS
0000243C                          1526  
0000243C  48E7 FFFE               1527  ISLSLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002440  43F8 1632               1528          LEA         MESSAGELSLB, A1
00002444  103C 000E               1529          MOVE.B      #14, D0
00002448  4E4F                    1530          TRAP        #15
0000244A  4EB9 00003B84           1531          JSR         EA_LSd
00002450  4CDF 7FFF               1532          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002454  4E75                    1533          RTS
00002456                          1534  
00002456  48E7 FFFE               1535  ISLSLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000245A  49F8 1638               1536          LEA         MESSAGELSLW, A4
0000245E  4EB9 00004642           1537          JSR    WRITE2MEM
00002464  49F8 14EC               1538          LEA    MESSAGESPACE, A4
00002468  4EB9 00004642           1539          JSR    WRITE2MEM
0000246E  4EB9 00003B84           1540          JSR         EA_LSd
00002474  4CDF 7FFF               1541          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002478  4E75                    1542          RTS
0000247A                          1543  
0000247A  48E7 FFFE               1544  ISLSLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000247E  49F8 163E               1545          LEA         MESSAGELSLL, A4
00002482  4EB9 00004642           1546          JSR    WRITE2MEM
00002488  49F8 14EC               1547          LEA    MESSAGESPACE, A4
0000248C  4EB9 00004642           1548          JSR    WRITE2MEM
00002492  4EB9 00003B84           1549          JSR         EA_LSd
00002498  4CDF 7FFF               1550          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000249C  4E75                    1551          RTS
0000249E                          1552  
0000249E  48E7 FFFE               1553  ISRORB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024A2  49F8 15FC               1554          LEA         MESSAGERORB, A4
000024A6  4EB9 00004642           1555          JSR    WRITE2MEM
000024AC  49F8 14EC               1556          LEA    MESSAGESPACE, A4
000024B0  4EB9 00004642           1557          JSR    WRITE2MEM
000024B6  4EB9 000042C8           1558          JSR         EA_ROd
000024BC  4CDF 7FFF               1559          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024C0  4E75                    1560          RTS
000024C2                          1561  
000024C2  48E7 FFFE               1562  ISRORW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024C6  43F8 1602               1563          LEA         MESSAGERORW, A1
000024CA  103C 000E               1564          MOVE.B      #14, D0
000024CE  4E4F                    1565          TRAP        #15
000024D0  4EB9 000042C8           1566          JSR         EA_ROd
000024D6  4CDF 7FFF               1567          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024DA  4E75                    1568          RTS
000024DC                          1569  
000024DC  48E7 FFFE               1570  ISRORL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024E0  49F8 1608               1571          LEA         MESSAGERORL, A4
000024E4  4EB9 00004642           1572          JSR    WRITE2MEM
000024EA  49F8 14EC               1573          LEA    MESSAGESPACE, A4
000024EE  4EB9 00004642           1574          JSR    WRITE2MEM
000024F4  4EB9 000042C8           1575          JSR         EA_ROd
000024FA  4CDF 7FFF               1576          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024FE  4E75                    1577          RTS
00002500                          1578  
00002500  48E7 FFFE               1579  ISROLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002504  49F8 160E               1580          LEA         MESSAGEROLB, A4
00002508  4EB9 00004642           1581          JSR    WRITE2MEM
0000250E  49F8 14EC               1582          LEA    MESSAGESPACE, A4
00002512  4EB9 00004642           1583          JSR    WRITE2MEM
00002518  4EB9 000042C8           1584          JSR         EA_ROd
0000251E  4CDF 7FFF               1585          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002522  4E75                    1586          RTS
00002524                          1587  
00002524  48E7 FFFE               1588  ISROLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002528  49F8 1614               1589          LEA         MESSAGEROLW, A4
0000252C  4EB9 00004642           1590          JSR    WRITE2MEM
00002532  49F8 14EC               1591          LEA    MESSAGESPACE, A4
00002536  4EB9 00004642           1592          JSR    WRITE2MEM
0000253C  4EB9 000042C8           1593          JSR         EA_ROd
00002542  4CDF 7FFF               1594          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002546  4E75                    1595          RTS
00002548                          1596  
00002548  48E7 FFFE               1597  ISROLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000254C  49F8 161A               1598          LEA         MESSAGEROLL, A4
00002550  4EB9 00004642           1599          JSR    WRITE2MEM
00002556  49F8 14EC               1600          LEA    MESSAGESPACE, A4
0000255A  4EB9 00004642           1601          JSR    WRITE2MEM
00002560  4EB9 000042C8           1602          JSR         EA_ROd
00002566  4CDF 7FFF               1603          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000256A  4E75                    1604          RTS
0000256C                          1605  
0000256C  48E7 FFFE               1606  ISMULSW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002570  49F8 15D1               1607          LEA         MESSAGEMULSW, A4
00002574  4EB9 00004642           1608          JSR    WRITE2MEM
0000257A  49F8 14EC               1609          LEA    MESSAGESPACE, A4
0000257E  4EB9 00004642           1610          JSR    WRITE2MEM
00002584  4EB9 00004014           1611          JSR         EA_MULS_W
0000258A  4CDF 7FFF               1612          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000258E  4E75                    1613          RTS
00002590                          1614  
00002590  48E7 FFFE               1615  ISANDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002594  49F8 15BF               1616          LEA         MESSAGEANDB, A4
00002598  4EB9 00004642           1617          JSR    WRITE2MEM
0000259E  49F8 14EC               1618          LEA    MESSAGESPACE, A4
000025A2  4EB9 00004642           1619          JSR    WRITE2MEM
000025A8  4EB9 000033D0           1620          JSR         EA_AND
000025AE  4CDF 7FFF               1621          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025B2  4E75                    1622          RTS
000025B4                          1623  
000025B4  48E7 FFFE               1624  ISANDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025B8  49F8 15C5               1625          LEA         MESSAGEANDW, A4
000025BC  4EB9 00004642           1626          JSR    WRITE2MEM
000025C2  49F8 14EC               1627          LEA    MESSAGESPACE, A4
000025C6  4EB9 00004642           1628          JSR    WRITE2MEM
000025CC  4EB9 000033D0           1629          JSR         EA_AND
000025D2  4CDF 7FFF               1630          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025D6  4E75                    1631          RTS
000025D8                          1632  
000025D8  48E7 FFFE               1633  ISANDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025DC  49F8 15CB               1634          LEA         MESSAGEANDL, A4
000025E0  4EB9 00004642           1635          JSR    WRITE2MEM
000025E6  49F8 14EC               1636          LEA    MESSAGESPACE, A4
000025EA  4EB9 00004642           1637          JSR    WRITE2MEM
000025F0  4EB9 000033D0           1638          JSR         EA_AND
000025F6  4CDF 7FFF               1639          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025FA  4E75                    1640          RTS
000025FC                          1641  
000025FC  48E7 FFFE               1642  ISADDAW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002600  49F8 15A9               1643          LEA         MESSAGEADDAW, A4
00002604  4EB9 00004642           1644          JSR    WRITE2MEM
0000260A  49F8 14EC               1645          LEA    MESSAGESPACE, A4
0000260E  4EB9 00004642           1646          JSR    WRITE2MEM
00002614  4EB9 000030C6           1647          JSR         EA_ADDA
0000261A  4CDF 7FFF               1648          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000261E  4E75                    1649          RTS
00002620                          1650  
00002620  48E7 FFFE               1651  ISADDAL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002624  49F8 15B0               1652          LEA         MESSAGEADDAL, A4
00002628  4EB9 00004642           1653          JSR    WRITE2MEM
0000262E  49F8 14EC               1654          LEA    MESSAGESPACE, A4
00002632  4EB9 00004642           1655          JSR    WRITE2MEM
00002638  4EB9 000030C6           1656          JSR         EA_ADDA
0000263E  4CDF 7FFF               1657          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002642  4E75                    1658          RTS
00002644                          1659  
00002644  48E7 FFFE               1660  ISADDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002648  49F8 1597               1661          LEA         MESSAGEADDB, A4
0000264C  4EB9 00004642           1662          JSR    WRITE2MEM
00002652  49F8 14EC               1663          LEA    MESSAGESPACE, A4
00002656  4EB9 00004642           1664          JSR    WRITE2MEM
0000265C  4EB9 00002EFA           1665          JSR         EA_ADD
00002662  4CDF 7FFF               1666          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002666  4E75                    1667          RTS
00002668                          1668  
00002668  48E7 FFFE               1669  ISADDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000266C  49F8 159D               1670          LEA         MESSAGEADDW, A4
00002670  4EB9 00004642           1671          JSR    WRITE2MEM
00002676  49F8 14EC               1672          LEA    MESSAGESPACE, A4
0000267A  4EB9 00004642           1673          JSR    WRITE2MEM
00002680  4EB9 00002EFA           1674          JSR         EA_ADD
00002686  4CDF 7FFF               1675          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000268A  4E75                    1676          RTS
0000268C                          1677  
0000268C  48E7 FFFE               1678  ISADDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002690  49F8 15A3               1679          LEA         MESSAGEADDL, A4
00002694  4EB9 00004642           1680          JSR    WRITE2MEM
0000269A  49F8 14EC               1681          LEA    MESSAGESPACE, A4
0000269E  4EB9 00004642           1682          JSR    WRITE2MEM
000026A4  4EB9 00002EFA           1683          JSR         EA_ADD
000026AA  4CDF 7FFF               1684          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026AE  4E75                    1685          RTS
000026B0                          1686  
000026B0  48E7 FFFE               1687  ISSUBB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026B4  49F8 1585               1688          LEA         MESSAGESUBB, A4
000026B8  4EB9 00004642           1689          JSR    WRITE2MEM
000026BE  49F8 14EC               1690          LEA    MESSAGESPACE, A4
000026C2  4EB9 00004642           1691          JSR    WRITE2MEM
000026C8  4EB9 000043F8           1692          JSR         EA_SUB
000026CE  4CDF 7FFF               1693          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026D2  4E75                    1694          RTS
000026D4                          1695  
000026D4  48E7 FFFE               1696  ISSUBW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026D8  49F8 158B               1697          LEA         MESSAGESUBW, A4
000026DC  4EB9 00004642           1698          JSR    WRITE2MEM
000026E2  49F8 14EC               1699          LEA    MESSAGESPACE, A4
000026E6  4EB9 00004642           1700          JSR    WRITE2MEM
000026EC  4EB9 000043F8           1701          JSR         EA_SUB
000026F2  4CDF 7FFF               1702          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026F6  4E75                    1703          RTS
000026F8                          1704  
000026F8  48E7 FFFE               1705  ISSUBL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026FC  49F8 1591               1706          LEA         MESSAGESUBL, A4
00002700  4EB9 00004642           1707          JSR    WRITE2MEM
00002706  49F8 14EC               1708          LEA    MESSAGESPACE, A4
0000270A  4EB9 00004642           1709          JSR    WRITE2MEM
00002710  4EB9 000043F8           1710          JSR         EA_SUB
00002716  4CDF 7FFF               1711          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000271A  4E75                    1712          RTS
0000271C                          1713  
0000271C  48E7 FFFE               1714  ISCMPB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002720  49F8 1573               1715          LEA         MESSAGECMPB, A4
00002724  4EB9 00004642           1716          JSR    WRITE2MEM
0000272A  49F8 14EC               1717          LEA    MESSAGESPACE, A4
0000272E  4EB9 00004642           1718          JSR    WRITE2MEM
00002734  4EB9 00003814           1719          JSR         EA_CMP
0000273A  4CDF 7FFF               1720          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000273E  4E75                    1721          RTS
00002740                          1722  
00002740  48E7 FFFE               1723  ISCMPW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002744  49F8 1579               1724          LEA         MESSAGECMPW, A4
00002748  4EB9 00004642           1725          JSR    WRITE2MEM
0000274E  49F8 14EC               1726          LEA    MESSAGESPACE, A4
00002752  4EB9 00004642           1727          JSR    WRITE2MEM
00002758  4EB9 00003814           1728          JSR         EA_CMP
0000275E  4CDF 7FFF               1729          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002762  4E75                    1730          RTS
00002764                          1731  
00002764  48E7 FFFE               1732  ISCMPL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002768  49F8 157F               1733          LEA         MESSAGECMPL, A4
0000276C  4EB9 00004642           1734          JSR    WRITE2MEM
00002772  49F8 14EC               1735          LEA    MESSAGESPACE, A4
00002776  4EB9 00004642           1736          JSR    WRITE2MEM
0000277C  4EB9 00003814           1737          JSR         EA_CMP
00002782  4CDF 7FFF               1738          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002786  4E75                    1739          RTS
00002788                          1740  
00002788  48E7 FFFE               1741  ISADDQB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000278C  49F8 155E               1742          LEA         MESSAGEADDQB, A4
00002790  4EB9 00004642           1743          JSR    WRITE2MEM
00002796  49F8 14EC               1744          LEA    MESSAGESPACE, A4
0000279A  4EB9 00004642           1745          JSR    WRITE2MEM
000027A0  4EB9 000032D2           1746          JSR         EA_ADDQ
000027A6  4CDF 7FFF               1747          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027AA  4E75                    1748          RTS
000027AC                          1749  
000027AC  48E7 FFFE               1750  ISADDQW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027B0  49F8 1565               1751          LEA         MESSAGEADDQW, A4
000027B4  4EB9 00004642           1752          JSR    WRITE2MEM
000027BA  49F8 14EC               1753          LEA    MESSAGESPACE, A4
000027BE  4EB9 00004642           1754          JSR    WRITE2MEM
000027C4  4EB9 000032D2           1755          JSR         EA_ADDQ
000027CA  4CDF 7FFF               1756          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027CE  4E75                    1757          RTS
000027D0                          1758  
000027D0  48E7 FFFE               1759  ISADDQL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027D4  43F8 156C               1760          LEA         MESSAGEADDQL, A1 *OPCODE is ADDQ.L
000027D8  103C 000E               1761          MOVE.B      #14, D0
000027DC  4E4F                    1762          TRAP        #15
000027DE  4EB9 000032D2           1763          JSR         EA_ADDQ
000027E4  4CDF 7FFF               1764          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027E8  4E75                    1765          RTS
000027EA                          1766  
000027EA  48E7 FFFE               1767  ISMOVEQL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000027EE  49F8 15B7               1768          LEA         MESSAGEMOVEQL, A4
000027F2  4EB9 00004642           1769          JSR    WRITE2MEM
000027F8  49F8 14EC               1770          LEA    MESSAGESPACE, A4
000027FC  4EB9 00004642           1771          JSR    WRITE2MEM
00002802  4EB9 00003FB4           1772          JSR         EA_MOVEQ
00002808  4CDF 7FFF               1773          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000280C  4E75                    1774          RTS
0000280E                          1775  
0000280E  48E7 FFFE               1776  ISCLRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002812  49F8 154C               1777          LEA         MESSAGECLRB, A4
00002816  4EB9 00004642           1778          JSR    WRITE2MEM
0000281C  49F8 14EC               1779          LEA    MESSAGESPACE, A4
00002820  4EB9 00004642           1780          JSR    WRITE2MEM
00002826  4EB9 00003FB4           1781          JSR         EA_MOVEQ
0000282C  4CDF 7FFF               1782          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002830  4E75                    1783          RTS
00002832                          1784  
00002832  48E7 FFFE               1785  ISCLRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002836  49F8 1552               1786          LEA         MESSAGECLRW, A4
0000283A  4EB9 00004642           1787          JSR    WRITE2MEM
00002840  49F8 14EC               1788          LEA    MESSAGESPACE, A4
00002844  4EB9 00004642           1789          JSR    WRITE2MEM
0000284A  4EB9 0000374C           1790          JSR         EA_CLR
00002850  4CDF 7FFF               1791          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002854  4E75                    1792          RTS
00002856                          1793  
00002856  48E7 FFFE               1794  ISCLRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000285A  49F8 1558               1795          LEA         MESSAGECLRL, A4
0000285E  4EB9 00004642           1796          JSR    WRITE2MEM
00002864  49F8 14EC               1797          LEA    MESSAGESPACE, A4
00002868  4EB9 00004642           1798          JSR    WRITE2MEM
0000286E  4EB9 0000374C           1799          JSR         EA_CLR
00002874  4CDF 7FFF               1800          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002878  4E75                    1801          RTS
0000287A                          1802  
0000287A  48E7 FFFE               1803  ISMOVEML MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
0000287E  49F8 152C               1804          LEA         MESSAGEMOVEML, A4
00002882  4EB9 00004642           1805          JSR    WRITE2MEM
00002888  49F8 14EC               1806          LEA    MESSAGESPACE, A4
0000288C  4EB9 00004642           1807          JSR    WRITE2MEM
00002892  4EB9 00003FAE           1808          JSR         EA_MOVEM
00002898  4CDF 7FFF               1809          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000289C  4E75                    1810          RTS
0000289E                          1811  
0000289E  48E7 FFFE               1812  ISMOVEMW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000028A2  49F8 1534               1813          LEA         MESSAGEMOVEMW, A4
000028A6  4EB9 00004642           1814          JSR    WRITE2MEM
000028AC  49F8 14EC               1815          LEA    MESSAGESPACE, A4
000028B0  4EB9 00004642           1816          JSR    WRITE2MEM
000028B6  4EB9 00003FAE           1817          JSR         EA_MOVEM
000028BC  4CDF 7FFF               1818          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000028C0  4E75                    1819          RTS
000028C2                          1820  
000028C2  48E7 FFFE               1821  ISLEA   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000028C6  49F8 1548               1822          LEA         MESSAGELEA, A4
000028CA  4EB9 00004642           1823          JSR    WRITE2MEM
000028D0  49F8 14EC               1824          LEA    MESSAGESPACE, A4
000028D4  4EB9 00004642           1825          JSR    WRITE2MEM
000028DA  4EB9 00003AA8           1826          JSR         EA_LEA
000028E0  4CDF 7FFF               1827          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000028E4  4E75                    1828          RTS                         ; Exit subroutine
000028E6                          1829  
000028E6  48E7 FFFE               1830  ISJSR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000028EA  49F8 153C               1831          LEA         MESSAGEJSR, A4
000028EE  4EB9 00004642           1832          JSR    WRITE2MEM
000028F4  49F8 14EC               1833          LEA    MESSAGESPACE, A4
000028F8  4EB9 00004642           1834          JSR    WRITE2MEM
000028FE  4EB9 000039E0           1835          JSR         EA_JSR
00002904  4CDF 7FFF               1836          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002908  4E75                    1837          RTS                         ; Exit subroutine
0000290A                          1838  
0000290A  48E7 FFFE               1839  ISRTS   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000290E  49F8 1544               1840          LEA         MESSAGERTS, A4
00002912  4EB9 00004642           1841          JSR    WRITE2MEM
00002918  49F8 14EC               1842          LEA    MESSAGESPACE, A4
0000291C  4EB9 00004642           1843          JSR    WRITE2MEM
00002922  548E                    1844          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
00002924  4CDF 7FFF               1845          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002928  4E75                    1846          RTS
0000292A                          1847  
0000292A  48E7 FFFE               1848  ISCLR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000292E  43F8 1540               1849          LEA         MESSAGECLR, A1  *OPCODE is CLR
00002932  103C 000E               1850          MOVE.B      #14, D0
00002936  4E4F                    1851          TRAP        #15
00002938  4EB9 0000374C           1852          JSR         EA_CLR
0000293E  4CDF 7FFF               1853          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002942  4E75                    1854          RTS
00002944                          1855  
00002944  48E7 FFFE               1856  ISNOP   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002948  49F8 14EE               1857          LEA         MESSAGENOP, A4
0000294C  4EB9 00004642           1858          JSR    WRITE2MEM
00002952  49F8 14EC               1859          LEA    MESSAGESPACE, A4
00002956  4EB9 00004642           1860          JSR    WRITE2MEM
0000295C  548E                    1861          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
0000295E  4CDF 7FFF               1862          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002962  4E75                    1863          RTS                         ; Exit subroutine
00002964                          1864  
00002964  48E7 FFFE               1865  ISMOVEW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002968  49F8 14F2               1866          LEA         MESSAGEMOVEW, A4
0000296C  4EB9 00004642           1867          JSR    WRITE2MEM
00002972  49F8 14EC               1868          LEA    MESSAGESPACE, A4
00002976  4EB9 00004642           1869          JSR    WRITE2MEM
0000297C  4EB9 00003CB4           1870          JSR         EA_MOVE
00002982  4CDF 7FFF               1871          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002986  4E75                    1872          RTS                         ; Exit subroutine
00002988                          1873  
00002988  48E7 FFFE               1874  ISMOVEAW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
0000298C  49F8 1524               1875          LEA         MESSAGEMOVEAW, A4
00002990  4EB9 00004642           1876          JSR    WRITE2MEM
00002996  49F8 14EC               1877          LEA    MESSAGESPACE, A4
0000299A  4EB9 00004642           1878          JSR    WRITE2MEM
000029A0  4EB9 00003E88           1879          JSR         EA_MOVEA
000029A6  4CDF 7FFF               1880          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000029AA  4E75                    1881          RTS                         ; Exit subroutine
000029AC                          1882  
000029AC  48E7 FFFE               1883  ISMOVEL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000029B0  49F8 14F9               1884          LEA         MESSAGEMOVEL, A4
000029B4  4EB9 00004642           1885          JSR    WRITE2MEM
000029BA  49F8 14EC               1886          LEA    MESSAGESPACE, A4
000029BE  4EB9 00004642           1887          JSR    WRITE2MEM
000029C4  4EB9 00003CB4           1888          JSR         EA_MOVE
000029CA  4CDF 7FFF               1889          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000029CE  4E75                    1890          RTS                         ; Exit subroutine
000029D0                          1891  
000029D0  48E7 FFFE               1892  ISMOVEAL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000029D4  49F8 151C               1893          LEA         MESSAGEMOVEAL, A4
000029D8  4EB9 00004642           1894          JSR    WRITE2MEM
000029DE  49F8 14EC               1895          LEA    MESSAGESPACE, A4
000029E2  4EB9 00004642           1896          JSR    WRITE2MEM
000029E8  4EB9 00003E88           1897          JSR         EA_MOVEA
000029EE  4CDF 7FFF               1898          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000029F2  4E75                    1899          RTS                         ; Exit subroutine
000029F4                          1900  
000029F4  48E7 FFFE               1901  ISMOVEB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000029F8  43F8 1500               1902          LEA         MESSAGEMOVEB, A1 *OPCODE is MOVE.B so display MOVEB message
000029FC  103C 000E               1903          MOVE.B      #14, D0
00002A00  4E4F                    1904          TRAP        #15
00002A02  4EB9 00003CB4           1905          JSR         EA_MOVE
00002A08  4CDF 7FFF               1906          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002A0C  4E75                    1907          RTS                         ; Exit subroutine
00002A0E                          1908  
00002A0E  48E7 FFFE               1909  ISADDIW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002A12  49F8 1507               1910          LEA         MESSAGEADDIW, A4
00002A16  4EB9 00004642           1911          JSR    WRITE2MEM
00002A1C  49F8 14EC               1912          LEA    MESSAGESPACE, A4
00002A20  4EB9 00004642           1913          JSR    WRITE2MEM
00002A26  4EB9 000031B6           1914          JSR         EA_ADDI
00002A2C  4CDF 7FFF               1915          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002A30  4E75                    1916          RTS                         ; Exit subroutine
00002A32                          1917  
00002A32  48E7 FFFE               1918  ISADDIL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002A36  49F8 150E               1919          LEA         MESSAGEADDIL, A4
00002A3A  4EB9 00004642           1920          JSR    WRITE2MEM
00002A40  49F8 14EC               1921          LEA    MESSAGESPACE, A4
00002A44  4EB9 00004642           1922          JSR    WRITE2MEM
00002A4A  4EB9 000031B6           1923          JSR         EA_ADDI
00002A50  4CDF 7FFF               1924          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002A54  4E75                    1925          RTS                         ; Exit subroutine
00002A56                          1926  
00002A56  48E7 FFFE               1927  ISADDIB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002A5A  49F8 1515               1928          LEA         MESSAGEADDIB, A4
00002A5E  4EB9 00004642           1929          JSR    WRITE2MEM
00002A64  49F8 14EC               1930          LEA    MESSAGESPACE, A4
00002A68  4EB9 00004642           1931          JSR    WRITE2MEM
00002A6E  4EB9 000031B6           1932          JSR         EA_ADDI
00002A74  4CDF 7FFF               1933          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002A78  4E75                    1934          RTS                         ; Exit subroutine
00002A7A                          1935  
00002A7A                          1936  
00002A7A                          1937  
00002A7A                          1938  
00002A7A                          1939  
00002A7A                          1940  
00002A7A                          1941  
00002A7A                          1942  
00002A7A                          1943  -------------------- end include --------------------
00002A7A                          1944      INCLUDE 'EA.X68'
00002A7A                          1945  
00002A7A                          1946      INCLUDE 'EAMessages.X68'
00002A7A                          1947  
00002A7A= 00                      1948  EA_MSG_NULL         DC.B    0
00002A7B= 20 00                   1949  EA_MSG_SPACE        DC.B    ' ',0
00002A7D= 2C 20 00                1950  EA_MSG_COMMA        DC.B    ', ',0
00002A80= 28 00                   1951  EA_MSG_OPENPAREN    DC.B    '(',0
00002A82= 29 00                   1952  EA_MSG_CLOSEPAREN   DC.B    ')',0
00002A84= 2D 00                   1953  EA_MSG_MIN          DC.B    '-',0
00002A86= 2B 00                   1954  EA_MSG_PLUS         DC.B    '+',0
00002A88= 23 00                   1955  EA_MSG_HASH         DC.B    '#',0
00002A8A= 24 00                   1956  EA_MSG_HEX          DC.B    '$',0
00002A8C                          1957  
00002A8C= 44 30 00                1958  EA_MSG_D0           DC.B    'D0',0
00002A8F= 44 31 00                1959  EA_MSG_D1           DC.B    'D1',0
00002A92= 44 32 00                1960  EA_MSG_D2           DC.B    'D2',0
00002A95= 44 33 00                1961  EA_MSG_D3           DC.B    'D3',0
00002A98= 44 34 00                1962  EA_MSG_D4           DC.B    'D4',0
00002A9B= 44 35 00                1963  EA_MSG_D5           DC.B    'D5',0
00002A9E= 44 36 00                1964  EA_MSG_D6           DC.B    'D6',0
00002AA1= 44 37 00                1965  EA_MSG_D7           DC.B    'D7',0
00002AA4                          1966  
00002AA4= 41 30 00                1967  EA_MSG_A0           DC.B    'A0',0
00002AA7= 41 31 00                1968  EA_MSG_A1           DC.B    'A1',0
00002AAA= 41 32 00                1969  EA_MSG_A2           DC.B    'A2',0
00002AAD= 41 33 00                1970  EA_MSG_A3           DC.B    'A3',0
00002AB0= 41 34 00                1971  EA_MSG_A4           DC.B    'A4',0
00002AB3= 41 35 00                1972  EA_MSG_A5           DC.B    'A5',0
00002AB6= 41 36 00                1973  EA_MSG_A6           DC.B    'A6',0
00002AB9= 41 37 00                1974  EA_MSG_A7           DC.B    'A7',0
00002ABC                          1975  
00002ABC= 5B 45 41 20 43 4F ...   1976  EA_MSG_UNIMP        DC.B    '[EA CODE NOT IMPLEMENTED]',0
00002AD6= 5B 50 52 49 4E 54 ...   1977  EA_MSG_PRINT_DATA   DC.B    '[PRINTING DATA NOT IMPLEMENTED]',0
00002AF6                          1978  
00002AF6                          1979  -------------------- end include --------------------
00002AF6                          1980      INCLUDE 'EA_UTIL.X68'
00002AF6                          1981  
00002AF6                          1982  
00002AF6                          1983  EA_UNIMPLEMENTED:
00002AF6  548E                    1984      ADDA.L      #$00000002, A6      ; Increment past current opcode word
00002AF8  49F8 2ABC               1985      LEA         EA_MSG_UNIMP, A4
00002AFC  4EB9 00004642           1986      JSR         WRITE2MEM
00002B02  4E75                    1987      RTS
00002B04                          1988  
00002B04                          1989  EA_INVALID:
00002B04  2A4E                    1990      MOVEA.L     A6, A5              ; Copy global pointer
00002B06  548D                    1991      ADDA.L      #$00000002, A5      ; Increment past current opcode word
00002B08  4EB8 12EE               1992      JSR         INVALID_DATA        ; Print data error message
00002B0C  4E75                    1993      RTS
00002B0E                          1994  
00002B0E                          1995  EA_PRINT_DATA:
00002B0E  49F8 2AD6               1996      LEA         EA_MSG_PRINT_DATA, A4
00002B12  4EB9 00004642           1997      JSR         WRITE2MEM
00002B18  4E75                    1998      RTS
00002B1A                          1999  
00002B1A                          2000  
00002B1A                          2001  EA_UPDATE_POINTER:
00002B1A  BDCD                    2002      CMP.L       A5, A6              ; Check if A5==A6
00002B1C  6600 0004               2003      BNE         UPDATE_PTR          ; If NOT equal (a.k.a if any extra operands
00002B20                          2004                                      ; were read, and is already up to date),
00002B20                          2005                                      ; update global with current
00002B20  548D                    2006      ADDA.L      #$00000002, A5      ; Else, increment past current opcode word, then update
00002B22                          2007  UPDATE_PTR:
00002B22  2C4D                    2008      MOVEA.L     A5, A6              ; Update global pointer
00002B24  4E75                    2009      RTS
00002B26                          2010  
00002B26                          2011  EA_COPY_PTR:
00002B26  2A4E                    2012      MOVEA.L     A6, A5              ; Save global pointer
00002B28  4E75                    2013      RTS
00002B2A                          2014  
00002B2A                          2015  EA_DEFAULT_COMBO:
00002B2A  4286                    2016      CLR.L       D6                  ; Clear space for mode bits
00002B2C  4287                    2017      CLR.L       D7                  ; Clear space for register bits
00002B2E  2216                    2018      MOVE.L      (A6), D1            ; Load opcode to data register 1
00002B30  143C 000A               2019      MOVE.B      #10, D2             ; Clear upper 10 bits of opcode word
00002B34  E569                    2020      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002B36  143C 000D               2021      MOVE.B      #13, D2             ; 'Right-align' bits 3-5 to determine mode bits
00002B3A  E469                    2022      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002B3C  1C01                    2023      MOVE.B      D1, D6              ; Save mode bits to D6
00002B3E  2216                    2024      MOVE.L      (A6), D1            ; Reload opcode to data register 1
00002B40  143C 000D               2025      MOVE.B      #13, D2             ; Clear upper 13 bits of opcode word
00002B44  E569                    2026      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002B46  143C 000D               2027      MOVE.B      #13, D2             ; 'Right-align' bits 0-2 to determine register bits
00002B4A  E469                    2028      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002B4C  1E01                    2029      MOVE.B      D1, D7              ; Save register bits to D7
00002B4E  4E75                    2030      RTS                             ; Return from subroutine
00002B50                          2031  
00002B50                          2032  EA_OPMODE_COMBO:
00002B50  4286                    2033      CLR.L       D6                  ; Clear space for mode bits
00002B52  4287                    2034      CLR.L       D7                  ; Clear space for register bits
00002B54  2216                    2035      MOVE.L      (A6), D1            ; Load opcode to data register 1
00002B56  143C 0007               2036      MOVE.B      #7, D2              ; Clear upper 7 bits of opcode word
00002B5A  E569                    2037      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002B5C  143C 000D               2038      MOVE.B      #13, D2             ; 'Right-align' bits 6-8 to determine opmode bits
00002B60  E469                    2039      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002B62  1C01                    2040      MOVE.B      D1, D6              ; Save opmode bits to D6
00002B64  2216                    2041      MOVE.L      (A6), D1            ; Reload opcode to data register 1
00002B66  143C 0004               2042      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00002B6A  E569                    2043      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002B6C  143C 000D               2044      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register bits
00002B70  E469                    2045      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002B72  1E01                    2046      MOVE.B      D1, D7              ; Save register bits to D7
00002B74  4E75                    2047      RTS                             ; Return from subroutine
00002B76                          2048  
00002B76                          2049  EA_SIZE_BITS:
00002B76  4287                    2050      CLR.L       D7
00002B78  2E16                    2051      MOVE.L      (A6), D7            ; Load opcode to data register 1
00002B7A  143C 0008               2052      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00002B7E  E56F                    2053      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00002B80  143C 000E               2054      MOVE.B      #14, D2             ; 'Right-align' bits 6-7 to determine size bits
00002B84  E46F                    2055      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00002B86  4E75                    2056      RTS
00002B88                          2057  
00002B88                          2058  
00002B88                          2059  EA_PRINT_DN:
00002B88  41F9 00002B96           2060      LEA         EA_PRINT_DN_JMP, A0 ; Set index '0' for jump table
00002B8E  CEFC 0006               2061      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002B92  4EF0 7000               2062      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002B96                          2063  EA_PRINT_DN_JMP:
00002B96  4EF9 00002BC6           2064      JMP         DN_000 ; D0
00002B9C  4EF9 00002BD0           2065      JMP         DN_001 ; D1
00002BA2  4EF9 00002BDA           2066      JMP         DN_010 ; D2
00002BA8  4EF9 00002BE4           2067      JMP         DN_011 ; D3
00002BAE  4EF9 00002BEE           2068      JMP         DN_100 ; D4
00002BB4  4EF9 00002BF8           2069      JMP         DN_101 ; D5
00002BBA  4EF9 00002C02           2070      JMP         DN_110 ; D6
00002BC0  4EF9 00002C0C           2071      JMP         DN_111 ; D7
00002BC6                          2072  DN_000: ; D0
00002BC6  49F8 2A8C               2073      LEA         EA_MSG_D0, A4
00002BCA  4EB9 00004642           2074      JSR         WRITE2MEM
00002BD0                          2075  DN_001: ; D1
00002BD0  49F8 2A8F               2076      LEA         EA_MSG_D1, A4
00002BD4  4EB9 00004642           2077      JSR         WRITE2MEM
00002BDA                          2078  DN_010: ; D2
00002BDA  49F8 2A92               2079      LEA         EA_MSG_D2, A4
00002BDE  4EB9 00004642           2080      JSR         WRITE2MEM
00002BE4                          2081  DN_011: ; D3
00002BE4  49F8 2A95               2082      LEA         EA_MSG_D3, A4
00002BE8  4EB9 00004642           2083      JSR         WRITE2MEM
00002BEE                          2084  DN_100: ; D4
00002BEE  49F8 2A98               2085      LEA         EA_MSG_D4, A4
00002BF2  4EB9 00004642           2086      JSR         WRITE2MEM
00002BF8                          2087  DN_101: ; D5
00002BF8  49F8 2A9B               2088      LEA         EA_MSG_D5, A4
00002BFC  4EB9 00004642           2089      JSR         WRITE2MEM
00002C02                          2090  DN_110: ; D6
00002C02  49F8 2A9E               2091      LEA         EA_MSG_D6, A4
00002C06  4EB9 00004642           2092      JSR         WRITE2MEM
00002C0C                          2093  DN_111: ; D7
00002C0C  49F8 2AA1               2094      LEA         EA_MSG_D7, A4
00002C10  4EB9 00004642           2095      JSR         WRITE2MEM
00002C16                          2096  
00002C16                          2097  EA_PRINT_DN_END:
00002C16  4E75                    2098      RTS
00002C18                          2099  
00002C18                          2100  EA_PRINT_AN:
00002C18  41F9 00002C26           2101      LEA         AN_JMP, A0          ; Set index '0' for jump table
00002C1E  CEFC 0006               2102      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002C22  4EF0 7000               2103      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002C26                          2104  AN_JMP:
00002C26  4EF9 00002C56           2105      JMP         AN_000 ; A0
00002C2C  4EF9 00002C60           2106      JMP         AN_001 ; A1
00002C32  4EF9 00002C6A           2107      JMP         AN_010 ; A2
00002C38  4EF9 00002C74           2108      JMP         AN_011 ; A3
00002C3E  4EF9 00002C7E           2109      JMP         AN_100 ; A4
00002C44  4EF9 00002C88           2110      JMP         AN_101 ; A5
00002C4A  4EF9 00002C92           2111      JMP         AN_110 ; A6
00002C50  4EF9 00002C9C           2112      JMP         AN_111 ; A7
00002C56                          2113  AN_000: ; A0
00002C56  49F8 2AA4               2114      LEA         EA_MSG_A0, A4
00002C5A  4EB9 00004642           2115      JSR         WRITE2MEM
00002C60                          2116  AN_001: ; A1
00002C60  49F8 2AA7               2117      LEA         EA_MSG_A1, A4
00002C64  4EB9 00004642           2118      JSR         WRITE2MEM
00002C6A                          2119  AN_010: ; A2
00002C6A  49F8 2AAA               2120      LEA         EA_MSG_A2, A4
00002C6E  4EB9 00004642           2121      JSR         WRITE2MEM
00002C74                          2122  AN_011: ; A3
00002C74  49F8 2AAD               2123      LEA         EA_MSG_A3, A4
00002C78  4EB9 00004642           2124      JSR         WRITE2MEM
00002C7E                          2125  AN_100: ; A4
00002C7E  49F8 2AB0               2126      LEA         EA_MSG_A4, A4
00002C82  4EB9 00004642           2127      JSR         WRITE2MEM
00002C88                          2128  AN_101: ; A5
00002C88  49F8 2AB3               2129      LEA         EA_MSG_A5, A4
00002C8C  4EB9 00004642           2130      JSR         WRITE2MEM
00002C92                          2131  AN_110: ; A6
00002C92  49F8 2AB6               2132      LEA         EA_MSG_A6, A4
00002C96  4EB9 00004642           2133      JSR         WRITE2MEM
00002C9C                          2134  AN_111: ; A7
00002C9C  49F8 2AB9               2135      LEA         EA_MSG_A7, A4
00002CA0  4EB9 00004642           2136      JSR         WRITE2MEM
00002CA6                          2137  
00002CA6                          2138  EA_PRINT_AN_END:
00002CA6  4E75                    2139      RTS
00002CA8                          2140  EA_PRINT_IND:
00002CA8  49F9 0000473A           2141      LEA         OPAREN, A4    ; Print open parentheses
00002CAE  4EB9 00004642           2142      JSR         WRITE2MEM
00002CB4  41F9 00002CC2           2143      LEA         IND_JMP, A0         ; Set index '0' for jump table
00002CBA  CEFC 0006               2144      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002CBE  4EF0 7000               2145      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002CC2                          2146  IND_JMP:
00002CC2  4EF9 00002CF2           2147      JMP         IND_000 ; (A0)
00002CC8  4EF9 00002CFC           2148      JMP         IND_001 ; (A1)
00002CCE  4EF9 00002D06           2149      JMP         IND_010 ; (A2)
00002CD4  4EF9 00002D10           2150      JMP         IND_011 ; (A3)
00002CDA  4EF9 00002D1A           2151      JMP         IND_100 ; (A4)
00002CE0  4EF9 00002D24           2152      JMP         IND_101 ; (A5)
00002CE6  4EF9 00002D2E           2153      JMP         IND_110 ; (A6)
00002CEC  4EF9 00002D38           2154      JMP         IND_111 ; (A7)
00002CF2                          2155  IND_000: ; (A0)
00002CF2  49F8 2AA4               2156      LEA         EA_MSG_A0, A4
00002CF6  4EB9 00004642           2157      JSR         WRITE2MEM
00002CFC                          2158  IND_001: ; (A1)
00002CFC  49F8 2AA7               2159      LEA         EA_MSG_A1, A4
00002D00  4EB9 00004642           2160      JSR         WRITE2MEM
00002D06                          2161  IND_010: ; (A2)
00002D06  49F8 2AAA               2162      LEA         EA_MSG_A2, A4
00002D0A  4EB9 00004642           2163      JSR         WRITE2MEM
00002D10                          2164  IND_011: ; (A3)
00002D10  49F8 2AAD               2165      LEA         EA_MSG_A3, A4
00002D14  4EB9 00004642           2166      JSR         WRITE2MEM
00002D1A                          2167  IND_100: ; (A4)
00002D1A  49F8 2AB0               2168      LEA         EA_MSG_A4, A4
00002D1E  4EB9 00004642           2169      JSR         WRITE2MEM
00002D24                          2170  IND_101: ; (A5)
00002D24  49F8 2AB3               2171      LEA         EA_MSG_A5, A4
00002D28  4EB9 00004642           2172      JSR         WRITE2MEM
00002D2E                          2173  IND_110: ; (A6)
00002D2E  49F8 2AB6               2174      LEA         EA_MSG_A6, A4
00002D32  4EB9 00004642           2175      JSR         WRITE2MEM
00002D38                          2176  IND_111: ; (A7)
00002D38  49F8 2AB9               2177      LEA         EA_MSG_A7, A4
00002D3C  4EB9 00004642           2178      JSR         WRITE2MEM
00002D42                          2179  EA_PRINT_IND_END:
00002D42  49F9 0000473C           2180      LEA         CPAREN, A4   ; Print close parentheses
00002D48  4EB9 00004642           2181      JSR         WRITE2MEM
00002D4E  4E75                    2182      RTS
00002D50                          2183  EA_PRINT_IMM:
00002D50  224D                    2184      MOVEA.L     A5, A1              ; copy pointer to temp
00002D52  5489                    2185      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002D54  BA7C 0003               2186      CMP         #3, D5
00002D58  6700 0010               2187      BEQ         PRINT_IMM_L         ; if L, branch
00002D5C  3011                    2188      MOVE.W      (A1), D0            ; store value in a register (todo, register tbd)
00002D5E  4EB8 2B0E               2189      JSR         EA_PRINT_DATA *print value TODO
00002D62  5489                    2190      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002D64  4EF9 00002D6E           2191      JMP         PRINT_IMM_END
00002D6A                          2192  PRINT_IMM_L:
00002D6A  2011                    2193      MOVE.L      (A1), D0            ; store value in a register (todo, register tbd)
00002D6C                          2194      *print value TODO
00002D6C  5889                    2195      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002D6E                          2196  PRINT_IMM_END:
00002D6E  2A49                    2197      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002D70  4E75                    2198      RTS
00002D72                          2199  EA_PRINT_POSTINC:
00002D72  49F9 0000473A           2200      LEA         OPAREN, A4    ; Print open parentheses
00002D78  4EB9 00004642           2201      JSR         WRITE2MEM
00002D7E  41F9 00002D8C           2202      LEA         POSTINC_JMP, A0     ; Set index '0' for jump table
00002D84  CEFC 0006               2203      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002D88  4EF0 7000               2204      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002D8C                          2205  POSTINC_JMP:
00002D8C  4EF9 00002DBC           2206      JMP         POSTINC_000 ; (A0)+
00002D92  4EF9 00002DC6           2207      JMP         POSTINC_001 ; (A1)+
00002D98  4EF9 00002DD0           2208      JMP         POSTINC_010 ; (A2)+
00002D9E  4EF9 00002DDA           2209      JMP         POSTINC_011 ; (A3)+
00002DA4  4EF9 00002DE4           2210      JMP         POSTINC_100 ; (A4)+
00002DAA  4EF9 00002DEE           2211      JMP         POSTINC_101 ; (A5)+
00002DB0  4EF9 00002DF8           2212      JMP         POSTINC_110 ; (A6)+
00002DB6  4EF9 00002E02           2213      JMP         POSTINC_111 ; (A7)+
00002DBC                          2214  POSTINC_000: ; (A0)+
00002DBC  49F8 2AA4               2215      LEA         EA_MSG_A0, A4
00002DC0  4EB9 00004642           2216      JSR         WRITE2MEM
00002DC6                          2217  POSTINC_001: ; (A1)+
00002DC6  49F8 2AA7               2218      LEA         EA_MSG_A1, A4
00002DCA  4EB9 00004642           2219      JSR         WRITE2MEM
00002DD0                          2220  POSTINC_010: ; (A2)+
00002DD0  49F8 2AAA               2221      LEA         EA_MSG_A2, A4
00002DD4  4EB9 00004642           2222      JSR         WRITE2MEM
00002DDA                          2223  POSTINC_011: ; (A3)+
00002DDA  49F8 2AAD               2224      LEA         EA_MSG_A3, A4
00002DDE  4EB9 00004642           2225      JSR         WRITE2MEM
00002DE4                          2226  POSTINC_100: ; (A4)+
00002DE4  49F8 2AB0               2227      LEA         EA_MSG_A4, A4
00002DE8  4EB9 00004642           2228      JSR         WRITE2MEM
00002DEE                          2229  POSTINC_101: ; (A5)+
00002DEE  49F8 2AB3               2230      LEA         EA_MSG_A5, A4
00002DF2  4EB9 00004642           2231      JSR         WRITE2MEM
00002DF8                          2232  POSTINC_110: ; (A6)+
00002DF8  49F8 2AB6               2233      LEA         EA_MSG_A6, A4
00002DFC  4EB9 00004642           2234      JSR         WRITE2MEM
00002E02                          2235  POSTINC_111: ; (A7)+
00002E02  49F8 2AB9               2236      LEA         EA_MSG_A7, A4
00002E06  4EB9 00004642           2237      JSR         WRITE2MEM
00002E0C                          2238  EA_PRINT_PI_END:
00002E0C  49F9 0000473C           2239      LEA         CPAREN, A4   ; Print close parentheses
00002E12  4EB9 00004642           2240      JSR         WRITE2MEM
00002E18  49F9 0000473E           2241      LEA         PLUS, A4         ; Print plus sign
00002E1E  4EB9 00004642           2242      JSR         WRITE2MEM
00002E24  4E75                    2243      RTS
00002E26                          2244  EA_PRINT_PREDEC:
00002E26  49F9 00004740           2245      LEA         MINUS, A4               ; Print minus sign
00002E2C  4EB9 00004642           2246      JSR         WRITE2MEM
00002E32  49F9 0000473A           2247      LEA         OPAREN, A4              ; Print open parentheses
00002E38  4EB9 00004642           2248      JSR         WRITE2MEM
00002E3E  41F9 00002E4C           2249      LEA         PREDEC_JMP, A0      ; Set index '0' for jump table
00002E44  CEFC 0006               2250      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002E48  4EF0 7000               2251      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002E4C                          2252  PREDEC_JMP:
00002E4C  4EF9 00002E7C           2253      JMP         PREDEC_000 ; -(A0)
00002E52  4EF9 00002E86           2254      JMP         PREDEC_001 ; -(A1)
00002E58  4EF9 00002E90           2255      JMP         PREDEC_010 ; -(A2)
00002E5E  4EF9 00002E9A           2256      JMP         PREDEC_011 ; -(A3)
00002E64  4EF9 00002EA4           2257      JMP         PREDEC_100 ; -(A4)
00002E6A  4EF9 00002EAE           2258      JMP         PREDEC_101 ; -(A5)
00002E70  4EF9 00002EB8           2259      JMP         PREDEC_110 ; -(A6)
00002E76  4EF9 00002EC2           2260      JMP         PREDEC_111 ; -(A7)
00002E7C                          2261  
00002E7C                          2262  PREDEC_000: ; -(A0)
00002E7C  49F8 2AA4               2263      LEA         EA_MSG_A0, A4
00002E80  4EB9 00004642           2264      JSR         WRITE2MEM
00002E86                          2265  PREDEC_001: ; -(A1)
00002E86  49F8 2AA7               2266      LEA         EA_MSG_A1, A4
00002E8A  4EB9 00004642           2267      JSR         WRITE2MEM
00002E90                          2268  PREDEC_010: ; -(A2)
00002E90  49F8 2AAA               2269      LEA         EA_MSG_A2, A4
00002E94  4EB9 00004642           2270      JSR         WRITE2MEM
00002E9A                          2271  PREDEC_011: ; -(A3)
00002E9A  49F8 2AAD               2272      LEA         EA_MSG_A3, A4
00002E9E  4EB9 00004642           2273      JSR         WRITE2MEM
00002EA4                          2274  PREDEC_100: ; -(A4)
00002EA4  49F8 2AB0               2275      LEA         EA_MSG_A4, A4
00002EA8  4EB9 00004642           2276      JSR         WRITE2MEM
00002EAE                          2277  PREDEC_101: ; -(A5)
00002EAE  49F8 2AB3               2278      LEA         EA_MSG_A5, A4
00002EB2  4EB9 00004642           2279      JSR         WRITE2MEM
00002EB8                          2280  PREDEC_110: ; -(A6)
00002EB8  49F8 2AB6               2281      LEA         EA_MSG_A6, A4
00002EBC  4EB9 00004642           2282      JSR         WRITE2MEM
00002EC2                          2283  PREDEC_111: ; -(A7)
00002EC2  49F8 2AB9               2284      LEA         EA_MSG_A7, A4
00002EC6  4EB9 00004642           2285      JSR         WRITE2MEM
00002ECC                          2286  
00002ECC                          2287  EA_PRINT_PD_END:
00002ECC  49F9 0000473C           2288      LEA         CPAREN, A4   ; Print close parentheses
00002ED2  4EB9 00004642           2289      JSR         WRITE2MEM
00002ED8  4E75                    2290      RTS
00002EDA                          2291  EA_PRINT_ABS_L:
00002EDA  224D                    2292      MOVEA.L     A5, A1              ; copy pointer to temp
00002EDC  5489                    2293      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002EDE  2011                    2294      MOVE.L      (A1), D0            ; store longword address to print TODO
00002EE0  4EB8 2B0E               2295      JSR         EA_PRINT_DATA *print value TODO
00002EE4  5889                    2296      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002EE6  2A49                    2297      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002EE8  4E75                    2298      RTS
00002EEA                          2299  EA_PRINT_ABS_W:
00002EEA  224D                    2300      MOVEA.L     A5, A1              ; copy pointer to temp
00002EEC  5489                    2301      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002EEE  2011                    2302      MOVE.L      (A1), D0            ; store word address to print in TODO
00002EF0  4EB8 2B0E               2303      JSR         EA_PRINT_DATA *print value TODO
00002EF4  5489                    2304      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002EF6  2A49                    2305      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002EF8  4E75                    2306      RTS
00002EFA                          2307  
00002EFA                          2308  
00002EFA                          2309  -------------------- end include --------------------
00002EFA                          2310  
00002EFA                          2311  EA_ADD:
00002EFA  48E7 FFFC               2312      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002EFE  4EB8 2B26               2313      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002F02  4EB8 2B50               2314      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00002F06  41F9 00002F14           2315      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
00002F0C  CCFC 0006               2316      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002F10  4EF0 6000               2317      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002F14                          2318  ADD_OPMODE:
00002F14  4EF9 00002F44           2319      JMP         ADD_OPMODE_000      ; mode 1, byte
00002F1A  4EF9 00002F4E           2320      JMP         ADD_OPMODE_001      ; mode 1, word
00002F20  4EF9 00002F58           2321      JMP         ADD_OPMODE_010      ; mode 1, long
00002F26  4EF9 00002F62           2322      JMP         ADD_OPMODE_011      ; Invalid value
00002F2C  4EF9 00002F6C           2323      JMP         ADD_OPMODE_100      ; mode 2, byte
00002F32  4EF9 00002F76           2324      JMP         ADD_OPMODE_101      ; mode 2, word
00002F38  4EF9 00002F80           2325      JMP         ADD_OPMODE_110      ; mode 2, long
00002F3E  4EF9 00002F8A           2326      JMP         ADD_OPMODE_111      ; Invalid value
00002F44                          2327  ADD_OPMODE_000: ; mode 1, byte
00002F44  1A3C 0001               2328      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002F48  4EF9 00002F94           2329      JMP         ADD_MODE_1
00002F4E                          2330  ADD_OPMODE_001: ; mode 1, word
00002F4E  1A3C 0002               2331      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00002F52  4EF9 00002F94           2332      JMP         ADD_MODE_1
00002F58                          2333  ADD_OPMODE_010: ; mode 1, long
00002F58  1A3C 0003               2334      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00002F5C  4EF9 00002F94           2335      JMP         ADD_MODE_1
00002F62                          2336  ADD_OPMODE_011: ; Invalid value
00002F62  4EB8 2B04               2337      JSR         EA_INVALID
00002F66  4EF9 000030BC           2338      JMP         ADD_END
00002F6C                          2339  ADD_OPMODE_100: ; mode 2, byte
00002F6C  1A3C 0001               2340      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002F70  4EF9 00002FBE           2341      JMP         ADD_MODE_2
00002F76                          2342  ADD_OPMODE_101: ; mode 2, word
00002F76  1A3C 0001               2343      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002F7A  4EF9 00002FBE           2344      JMP         ADD_MODE_2
00002F80                          2345  ADD_OPMODE_110: ; mode 2, long
00002F80  1A3C 0001               2346      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002F84  4EF9 00002FBE           2347      JMP         ADD_MODE_2
00002F8A                          2348  ADD_OPMODE_111: ; Invalid value
00002F8A  4EB8 2B04               2349      JSR         EA_INVALID
00002F8E  4EF9 000030BC           2350      JMP         ADD_END
00002F94                          2351  ADD_MODE_1:
00002F94  4280                    2352      CLR.L       D0                  ; Clear data register 0
00002F96  103C 0001               2353      MOVE.B      #1, D0              ; Save mode number to D0
00002F9A  3207                    2354      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00002F9C  4EB8 2B2A               2355      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002FA0  4EB9 00002FE4           2356      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002FA6  49F9 00004737           2357      LEA         COMMA, A4        ; Print comma
00002FAC  4EB9 00004642           2358      JSR         WRITE2MEM
00002FB2  3E01                    2359      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00002FB4  4EB8 2B88               2360      JSR         EA_PRINT_DN         ; Print data register
00002FB8  4EF9 000030BC           2361      JMP         ADD_END
00002FBE                          2362  ADD_MODE_2:
00002FBE  4280                    2363      CLR.L       D0                  ; Clear data register 0
00002FC0  103C 0002               2364      MOVE.B      #2, D0              ; Save mode number to D0
00002FC4  4EB8 2B88               2365      JSR         EA_PRINT_DN         ; Print data register
00002FC8  49F9 00004737           2366      LEA         COMMA, A4        ; Print comma
00002FCE  4EB9 00004642           2367      JSR         WRITE2MEM
00002FD4  4EB8 2B2A               2368      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002FD8  4EB9 00002FE4           2369      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002FDE  4EF9 000030BC           2370      JMP         ADD_END
00002FE4                          2371  ADD_EVAL_EA:
00002FE4  41F9 00002FF2           2372      LEA         ADD_MODE, A0        ; Set index '0' for jump table
00002FEA  CCFC 0006               2373      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002FEE  4EF0 6000               2374      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002FF2                          2375  ADD_MODE:
00002FF2  4EF9 00003022           2376      JMP         ADD_MODE_000        ; Dn (invalid if opmode 2)
00002FF8  4EF9 00003034           2377      JMP         ADD_MODE_001        ; An (invalid if opmode 2)
00002FFE  4EF9 00003046           2378      JMP         ADD_MODE_010        ; (An)
00003004  4EF9 00003050           2379      JMP         ADD_MODE_011        ; (An)+
0000300A  4EF9 0000305A           2380      JMP         ADD_MODE_100        ; -(An)
00003010  4EF9 00003064           2381      JMP         ADD_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003016  4EF9 0000306A           2382      JMP         ADD_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000301C  4EF9 00003070           2383      JMP         ADD_MODE_111        ; The rest (not all valid, validated by register number)
00003022                          2384  ADD_MODE_000: ; Dn (invalid if opmode 2)
00003022  B07C 0002               2385      CMP         #2, D0
00003026  6700 008E               2386      BEQ         ADD_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
0000302A  4EB8 2B88               2387      JSR         EA_PRINT_DN         ; Print data register direct operand
0000302E  4EF9 000030B4           2388      JMP         ADD_MODE_END        ; End evaluation of ea mode
00003034                          2389  ADD_MODE_001: ; An (invalid if opmode 2)
00003034  B07C 0002               2390      CMP         #2, D0
00003038  6700 007C               2391      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
0000303C  4EB8 2C18               2392      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00003040  4EF9 000030B4           2393      JMP         ADD_MODE_END        ; End evaluation of ea mode
00003046                          2394  ADD_MODE_010: ; (An)
00003046  4EB8 2CA8               2395      JSR         EA_PRINT_IND         ; Print address register indirect
0000304A  4EF9 000030B4           2396      JMP         ADD_MODE_END        ; End evaluation of ea mode
00003050                          2397  ADD_MODE_011: ; (An)+
00003050  4EB8 2D72               2398      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003054  4EF9 000030B4           2399      JMP         ADD_MODE_END        ; End evaluation of ea mode
0000305A                          2400  ADD_MODE_100: ; -(An)
0000305A  4EB8 2E26               2401      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000305E  4EF9 000030B4           2402      JMP         ADD_MODE_END        ; End evaluation of ea mode
00003064                          2403  ADD_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003064  4EF9 000030B6           2404      JMP         ADD_MODE_INVALID
0000306A                          2405  ADD_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000306A  4EF9 000030B6           2406      JMP         ADD_MODE_INVALID
00003070                          2407  ADD_MODE_111: ; The rest (not all valid, validated by register number)
00003070  BE3C 0000               2408      CMP.B       #$00, D7            ; Test for absolute word address
00003074  6700 0018               2409      BEQ         ADD_ABS_W
00003078  BE3C 0001               2410      CMP.B       #$01, D7            ; Test for absolute long address
0000307C  6700 001A               2411      BEQ         ADD_ABS_L
00003080  BE3C 0004               2412      CMP.B       #$04, D7            ; Test for immediate data
00003084  6700 001C               2413      BEQ         ADD_IMM
00003088  4EF9 000030B6           2414      JMP         ADD_MODE_INVALID    ; else, invalid
0000308E                          2415  ADD_ABS_W:
0000308E  4EB8 2EEA               2416      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003092  4EF9 000030B4           2417      JMP         ADD_MODE_END
00003098                          2418  ADD_ABS_L:
00003098  4EB8 2EDA               2419      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000309C  4EF9 000030B4           2420      JMP         ADD_MODE_END
000030A2                          2421  ADD_IMM: ; invalid if opmode is 2
000030A2  B07C 0002               2422      CMP         #2, D0
000030A6  6700 000E               2423      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
000030AA  4EB8 2D50               2424      JSR         EA_PRINT_IMM        ; Print immediate data
000030AE  4EF9 000030B4           2425      JMP         ADD_MODE_END
000030B4                          2426  ADD_MODE_END:
000030B4  4E75                    2427      RTS                             ; Finish evaluating EA bits
000030B6                          2428  ADD_MODE_INVALID:
000030B6  4EB8 2B04               2429      JSR         EA_INVALID          ; Opcode word is Invalid
000030BA  4E75                    2430      RTS                             ; Finish evaluating EA bits
000030BC                          2431  ADD_END:
000030BC  4EB8 2B1A               2432      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000030C0  4CDF 3FFF               2433      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000030C4  4E75                    2434      RTS
000030C6                          2435  
000030C6                          2436  EA_ADDA:
000030C6  48E7 FFFC               2437      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000030CA  4EB8 2B26               2438      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000030CE  4EB8 2B2A               2439      JSR         EA_DEFAULT_COMBO    ; Mode: D6, register: D7
000030D2  41F9 000030E0           2440      LEA         ADDA_MODE, A0       ; Set index '0' for jump table
000030D8  CCFC 0006               2441      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000030DC  4EF0 6000               2442      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000030E0                          2443  ADDA_MODE:
000030E0  4EF9 00003110           2444      JMP         ADDA_MODE_000       ; Dn
000030E6  4EF9 0000311A           2445      JMP         ADDA_MODE_001       ; An
000030EC  4EF9 00003124           2446      JMP         ADDA_MODE_010       ; (An)
000030F2  4EF9 0000312E           2447      JMP         ADDA_MODE_011       ; (An)+
000030F8  4EF9 00003138           2448      JMP         ADDA_MODE_100       ; -(An)
000030FE  4EF9 00003142           2449      JMP         ADDA_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00003104  4EF9 00003148           2450      JMP         ADDA_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000310A  4EF9 0000314E           2451      JMP         ADDA_MODE_111       ; The rest (not all valid, validated by register number)
00003110                          2452  ADDA_MODE_000: ; Dn
00003110  4EB8 2B88               2453      JSR         EA_PRINT_DN         ; Print data register direct operand
00003114  4EF9 00003198           2454      JMP         ADDA_MODE_END       ; End evaluation of ea mode
0000311A                          2455  ADDA_MODE_001: ; An
0000311A  4EB8 2C18               2456      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
0000311E  4EF9 00003198           2457      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00003124                          2458  ADDA_MODE_010: ; (An)
00003124  4EB8 2CA8               2459      JSR         EA_PRINT_IND         ; Print address register indirect
00003128  4EF9 00003198           2460      JMP         ADDA_MODE_END       ; End evaluation of ea mode
0000312E                          2461  ADDA_MODE_011: ; (An)+
0000312E  4EB8 2D72               2462      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003132  4EF9 00003198           2463      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00003138                          2464  ADDA_MODE_100: ; -(An)
00003138  4EB8 2E26               2465      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000313C  4EF9 00003198           2466      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00003142                          2467  ADDA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003142  4EF9 0000318E           2468      JMP         ADDA_MODE_INVALID
00003148                          2469  ADDA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003148  4EF9 0000318E           2470      JMP         ADDA_MODE_INVALID
0000314E                          2471  ADDA_MODE_111: ; The rest (not all valid, validated by register number)
0000314E  BE3C 0000               2472      CMP.B       #$00, D7            ; Test for absolute word address
00003152  6700 0018               2473      BEQ         ADDA_ABS_W
00003156  BE3C 0001               2474      CMP.B       #$01, D7            ; Test for absolute long address
0000315A  6700 001A               2475      BEQ         ADDA_ABS_L
0000315E  BE3C 0004               2476      CMP.B       #$04, D7            ; Test for immediate data
00003162  6700 001C               2477      BEQ         ADDA_IMM
00003166  4EF9 0000318E           2478      JMP         ADDA_MODE_INVALID   ; Else, invalid
0000316C                          2479  ADDA_ABS_W:
0000316C  4EB8 2EEA               2480      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003170  4EF9 00003198           2481      JMP         ADDA_MODE_END
00003176                          2482  ADDA_ABS_L:
00003176  4EB8 2EDA               2483      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000317A  4EF9 00003198           2484      JMP         ADDA_MODE_END
00003180                          2485  ADDA_IMM:
00003180  4EB8 2B50               2486      JSR         EA_OPMODE_COMBO     ; Get opmode bits in
00003184  4EB8 2D50               2487      JSR         EA_PRINT_IMM        ; Print immediate data
00003188  4EF9 00003198           2488      JMP         ADDA_MODE_END
0000318E                          2489  ADDA_MODE_INVALID:
0000318E  4EB8 2B04               2490      JSR         EA_INVALID          ; Opcode word is Invalid
00003192  4EF9 000031AC           2491      JMP         ADDA_END
00003198                          2492  ADDA_MODE_END:
00003198  49F9 00004737           2493      LEA         COMMA, A4        ; Print comma
0000319E  4EB9 00004642           2494      JSR         WRITE2MEM
000031A4  4EB8 2B50               2495      JSR         EA_OPMODE_COMBO     ; Opmode: D6, register: D7
000031A8  4EB8 2C18               2496      JSR         EA_PRINT_AN         ; Print address register
000031AC                          2497  ADDA_END:
000031AC  4EB8 2B1A               2498      JSR         EA_UPDATE_POINTER   ; Update global pointer
000031B0  4CDF 3FFF               2499      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000031B4  4E75                    2500      RTS
000031B6                          2501  
000031B6                          2502  EA_ADDI:
000031B6  48E7 FFFC               2503      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000031BA  4EB8 2B26               2504      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000031BE  4EB8 2B76               2505      JSR         EA_SIZE_BITS        ; get size bits in D7
000031C2  BE3C 0000               2506      CMP.B       #$00, D7            ; Test if size: byte
000031C6  6700 001C               2507      BEQ         ADDI_B
000031CA  BE3C 0001               2508      CMP.B       #$01, D7            ; Test if size: word
000031CE  6700 002E               2509      BEQ         ADDI_W
000031D2  BE3C 0002               2510      CMP.B       #$02, D7            ; Test if size: long
000031D6  6700 0034               2511      BEQ         ADDI_L
000031DA  4EB8 2B04               2512      JSR         EA_INVALID          ; Else, invalid
000031DE  4EF9 000032C8           2513      JMP         ADDI_END
000031E4                          2514  ADDI_B:
000031E4  548D                    2515      ADDA.L      #$00000002, A5      ; Increment A5 past current word
000031E6  4280                    2516      CLR.L       D0
000031E8  3015                    2517      MOVE.W      (A5), D0            ; read next word in memory and save
000031EA  143C 0008               2518      MOVE.B      #8, D2              ; Clear upper 8 bits of operand word
000031EE  E568                    2519      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
000031F0  143C 0008               2520      MOVE.B      #8, D2             ; 'Right-align' bits 0-7 to get value
000031F4  E468                    2521      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
000031F6                          2522      *print data
000031F6  548D                    2523      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
000031F8  4EF9 00003212           2524      JMP         ADDI_GET_DEST
000031FE                          2525  ADDI_W:
000031FE  548D                    2526      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00003200  4280                    2527      CLR.L       D0
00003202  3015                    2528      MOVE.W      (A5), D0            ; read next word in memory and save
00003204                          2529      *print data
00003204  548D                    2530      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
00003206  4EF9 00003212           2531      JMP         ADDI_GET_DEST
0000320C                          2532  ADDI_L:
0000320C  548D                    2533      ADDA.L      #$00000002, A5      ; Increment A5 past current word
0000320E  2015                    2534      MOVE.L      (A5), D0            ; read next two words in memory and save
00003210  588D                    2535      ADDA.L      #$00000004, A5      ; Increment A5 past operand longword
00003212                          2536  ADDI_GET_DEST:
00003212                          2537      *PRINT COMMA
00003212  4EB8 2B2A               2538      JSR         EA_DEFAULT_COMBO    ; get mode bits in D6, register bits in D7
00003216  41F9 00003224           2539      LEA         ADDI_MODE, A0       ; Set index '0' for jump table
0000321C  CCFC 0006               2540      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003220  4EF0 6000               2541      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003224                          2542  ADDI_MODE:
00003224  4EF9 00003254           2543      JMP         ADDI_MODE_000       ; Dn
0000322A  4EF9 0000325E           2544      JMP         ADDI_MODE_001       ; Invalid: An
00003230  4EF9 00003268           2545      JMP         ADDI_MODE_010       ; (An)
00003236  4EF9 00003272           2546      JMP         ADDI_MODE_011       ; (An)+
0000323C  4EF9 0000327C           2547      JMP         ADDI_MODE_100       ; -(An)
00003242  4EF9 00003286           2548      JMP         ADDI_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00003248  4EF9 00003290           2549      JMP         ADDI_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000324E  4EF9 0000329A           2550      JMP         ADDI_MODE_111       ; The rest (not all valid, validated by register number)
00003254                          2551  ADDI_MODE_000: ; Dn
00003254  4EB8 2B88               2552      JSR         EA_PRINT_DN         ; Print data register direct operand
00003258  4EF9 000032C8           2553      JMP         ADDI_END
0000325E                          2554  ADDI_MODE_001: ; Invalid: An
0000325E  4EB8 2B04               2555      JSR         EA_INVALID          ; Opcode word is Invalid
00003262  4EF9 000032C8           2556      JMP         ADDI_END
00003268                          2557  ADDI_MODE_010: ; (An)
00003268  4EB8 2CA8               2558      JSR         EA_PRINT_IND         ; Print address register indirect
0000326C  4EF9 000032C8           2559      JMP         ADDI_END            ; End evaluation of ea mode
00003272                          2560  ADDI_MODE_011: ; (An)+
00003272  4EB8 2D72               2561      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003276  4EF9 000032C8           2562      JMP         ADDI_END            ; End evaluation of ea mode
0000327C                          2563  ADDI_MODE_100: ; -(An)
0000327C  4EB8 2E26               2564      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003280  4EF9 000032C8           2565      JMP         ADDI_END            ; End evaluation of ea mode
00003286                          2566  ADDI_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003286  4EB8 2B04               2567      JSR         EA_INVALID          ; Opcode word is Invalid
0000328A  4EF9 000032C8           2568      JMP         ADDI_END
00003290                          2569  ADDI_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003290  4EB8 2B04               2570      JSR         EA_INVALID          ; Opcode word is Invalid
00003294  4EF9 000032C8           2571      JMP         ADDI_END
0000329A                          2572  ADDI_MODE_111: ; The rest (not all valid, validated by register number)
0000329A  BE3C 0000               2573      CMP.B       #$00, D7            ; Test for absolute word address
0000329E  6700 0014               2574      BEQ         ADDI_ABS_W
000032A2  BE3C 0001               2575      CMP.B       #$01, D7            ; Test for absolute long address
000032A6  6700 0016               2576      BEQ         ADDI_ABS_L
000032AA  4EB8 2B04               2577      JSR         EA_INVALID          ; else, invalid
000032AE  4EF9 000032C8           2578      JMP         ADDI_END
000032B4                          2579  ADDI_ABS_W:
000032B4  4EB8 2EEA               2580      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000032B8  4EF9 000032C8           2581      JMP         ADDI_END
000032BE                          2582  ADDI_ABS_L:
000032BE  4EB8 2EDA               2583      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000032C2  4EF9 000032C8           2584      JMP         ADDI_END
000032C8                          2585  ADDI_END:
000032C8  4EB8 2B1A               2586      JSR         EA_UPDATE_POINTER   ; Update global pointer
000032CC  4CDF 3FFF               2587      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000032D0  4E75                    2588      RTS
000032D2                          2589  EA_ADDQ:
000032D2  48E7 FFFC               2590      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000032D6  4EB8 2B26               2591      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000032DA  2216                    2592      MOVE.L      (A6), D1            ; Load opcode to data register 1
000032DC  143C 0004               2593      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
000032E0  E569                    2594      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000032E2  143C 000D               2595      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine mode bits
000032E6  E469                    2596      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000032E8  B23C 0000               2597      CMP.B       #$00, D1            ; Check for special case (if imm. data is 0, value is actually 8)
000032EC  6600 0006               2598      BNE         ADDQ_PRINT_IMM      ; If any value other than 0, print the data
000032F0  123C 0008               2599      MOVE.B      #$08, D1            ; Else, the value is 0 and therefore symbolic of the value 8, so replace with the value 8
000032F4                          2600  ADDQ_PRINT_IMM:
000032F4  49F9 00004731           2601      LEA         POUND, A4         ; Print '#'
000032FA  4EB9 00004642           2602      JSR         WRITE2MEM
00003300  4EB8 2B0E               2603      JSR         EA_PRINT_DATA
00003304  49F9 00004737           2604      LEA         COMMA, A4        ; Print comma
0000330A  4EB9 00004642           2605      JSR         WRITE2MEM
00003310  4EB8 2B2A               2606      JSR         EA_DEFAULT_COMBO
00003314  41F9 00003322           2607      LEA         ADDQ_MODE, A0       ; Set index '0' for jump table
0000331A  CCFC 0006               2608      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000331E  4EF0 6000               2609      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003322                          2610  ADDQ_MODE:
00003322  4EF9 00003352           2611      JMP         ADDQ_MODE_000       ; Dn
00003328  4EF9 0000335C           2612      JMP         ADDQ_MODE_001       ; An
0000332E  4EF9 00003366           2613      JMP         ADDQ_MODE_010       ; (An)
00003334  4EF9 00003370           2614      JMP         ADDQ_MODE_011       ; (An)+
0000333A  4EF9 0000337A           2615      JMP         ADDQ_MODE_100       ; -(An)
00003340  4EF9 00003384           2616      JMP         ADDQ_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00003346  4EF9 0000338E           2617      JMP         ADDQ_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000334C  4EF9 00003398           2618      JMP         ADDQ_MODE_111       ; The rest (not all valid, validated by register number)
00003352                          2619  ADDQ_MODE_000: ; Dn
00003352  4EB8 2B88               2620      JSR         EA_PRINT_DN         ; Print data register direct operand
00003356  4EF9 000033C6           2621      JMP         ADDQ_END            ; End evaluation of ea mode
0000335C                          2622  ADDQ_MODE_001: ; An
0000335C  4EB8 2C18               2623      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00003360  4EF9 000033C6           2624      JMP         ADDQ_END            ; End evaluation of ea mode
00003366                          2625  ADDQ_MODE_010: ; (An)
00003366  4EB8 2CA8               2626      JSR         EA_PRINT_IND         ; Print address register indirect
0000336A  4EF9 000033C6           2627      JMP         ADDQ_END            ; End evaluation of ea mode
00003370                          2628  ADDQ_MODE_011: ; (An)+
00003370  4EB8 2D72               2629      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003374  4EF9 000033C6           2630      JMP         ADDQ_END            ; End evaluation of ea mode
0000337A                          2631  ADDQ_MODE_100: ; -(An)
0000337A  4EB8 2E26               2632      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000337E  4EF9 000033C6           2633      JMP         ADDQ_END            ; End evaluation of ea mode
00003384                          2634  ADDQ_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003384  4EB8 2B04               2635      JSR         EA_INVALID          ; Opcode word is Invalid
00003388  4EF9 000033C6           2636      JMP         ADDQ_END
0000338E                          2637  ADDQ_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000338E  4EB8 2B04               2638      JSR         EA_INVALID          ; Opcode word is Invalid
00003392  4EF9 000033C6           2639      JMP         ADDQ_END
00003398                          2640  ADDQ_MODE_111: ; The rest (not all valid, validated by register number)
00003398  BE3C 0000               2641      CMP.B       #$00, D7            ; Test for absolute word address
0000339C  6700 0014               2642      BEQ         ADDQ_ABS_W
000033A0  BE3C 0001               2643      CMP.B       #$01, D7            ; Test for absolute long address
000033A4  6700 0016               2644      BEQ         ADDQ_ABS_L
000033A8  4EB8 2B04               2645      JSR         EA_INVALID          ; Opcode word is Invalid
000033AC  4EF9 000033C6           2646      JMP         ADDQ_END
000033B2                          2647  ADDQ_ABS_W:
000033B2  4EB8 2EEA               2648      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000033B6  4EF9 000033C6           2649      JMP         ADDQ_END
000033BC                          2650  ADDQ_ABS_L:
000033BC  4EB8 2EDA               2651      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000033C0  4EF9 000033C6           2652      JMP         ADDQ_END
000033C6                          2653  
000033C6                          2654  ADDQ_END:
000033C6  4EB8 2B1A               2655      JSR         EA_UPDATE_POINTER   ; Update global pointer
000033CA  4CDF 3FFF               2656      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000033CE  4E75                    2657      RTS
000033D0                          2658  EA_AND:
000033D0  48E7 FFFC               2659      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000033D4  4EB8 2B26               2660      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000033D8  4EB8 2B50               2661      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
000033DC  41F8 2F14               2662      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
000033E0  CCFC 0006               2663      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000033E4  4EF0 6000               2664      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000033E8                          2665  AND_OPMODE:
000033E8  4EF9 00003418           2666      JMP         AND_OPMODE_000      ; mode 1, byte
000033EE  4EF9 00003422           2667      JMP         AND_OPMODE_001      ; mode 1, word
000033F4  4EF9 0000342C           2668      JMP         AND_OPMODE_010      ; mode 1, long
000033FA  4EF9 00003436           2669      JMP         AND_OPMODE_011      ; Invalid value
00003400  4EF9 00003440           2670      JMP         AND_OPMODE_100      ; mode 2, byte
00003406  4EF9 0000344A           2671      JMP         AND_OPMODE_101      ; mode 2, word
0000340C  4EF9 00003454           2672      JMP         AND_OPMODE_110      ; mode 2, long
00003412  4EF9 0000345E           2673      JMP         AND_OPMODE_111      ; Invalid value
00003418                          2674  AND_OPMODE_000: ; mode 1, byte
00003418  1A3C 0001               2675      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000341C  4EF9 00003468           2676      JMP         AND_MODE_1
00003422                          2677  AND_OPMODE_001: ; mode 1, word
00003422  1A3C 0002               2678      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00003426  4EF9 00003468           2679      JMP         AND_MODE_1
0000342C                          2680  AND_OPMODE_010: ; mode 1, long
0000342C  1A3C 0003               2681      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00003430  4EF9 00003468           2682      JMP         AND_MODE_1
00003436                          2683  AND_OPMODE_011: ; Invalid value
00003436  4EB8 2B04               2684      JSR         EA_INVALID
0000343A  4EF9 00003584           2685      JMP         AND_END
00003440                          2686  AND_OPMODE_100: ; mode 2, byte
00003440  1A3C 0001               2687      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003444  4EF9 00003492           2688      JMP         AND_MODE_2
0000344A                          2689  AND_OPMODE_101: ; mode 2, word
0000344A  1A3C 0001               2690      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000344E  4EF9 00003492           2691      JMP         AND_MODE_2
00003454                          2692  AND_OPMODE_110: ; mode 2, long
00003454  1A3C 0001               2693      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003458  4EF9 00003492           2694      JMP         AND_MODE_2
0000345E                          2695  AND_OPMODE_111: ; Invalid value
0000345E  4EB8 2B04               2696      JSR         EA_INVALID
00003462  4EF9 00003584           2697      JMP         AND_END
00003468                          2698  AND_MODE_1:
00003468  4280                    2699      CLR.L       D0                  ; Clear data register 0
0000346A  103C 0001               2700      MOVE.B      #1, D0              ; Save mode number to D0
0000346E  3207                    2701      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003470  4EB8 2B2A               2702      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003474  4EB9 000034B8           2703      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
0000347A  49F9 00004737           2704      LEA         COMMA, A4        ; Print comma
00003480  4EB9 00004642           2705      JSR         WRITE2MEM
00003486  3E01                    2706      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003488  4EB8 2B88               2707      JSR         EA_PRINT_DN         ; Print data register
0000348C  4EF9 00003584           2708      JMP         AND_END
00003492                          2709  AND_MODE_2:
00003492  4280                    2710      CLR.L       D0                  ; Clear data register 0
00003494  103C 0002               2711      MOVE.B      #2, D0              ; Save mode number to D0
00003498  4EB8 2B88               2712      JSR         EA_PRINT_DN         ; Print data register
0000349C  49F9 00004737           2713      LEA         COMMA, A4        ; Print comma
000034A2  4EB9 00004642           2714      JSR         WRITE2MEM
000034A8  4EB8 2B2A               2715      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
000034AC  4EB9 000034B8           2716      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
000034B2  4EF9 00003584           2717      JMP         AND_END
000034B8                          2718  AND_EVAL_EA:
000034B8  41F9 000034C6           2719      LEA         AND_MODE, A0        ; Set index '0' for jump table
000034BE  CCFC 0006               2720      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000034C2  4EF0 6000               2721      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000034C6                          2722  AND_MODE:
000034C6  4EF9 000034F6           2723      JMP         AND_MODE_000        ; Dn (invalid if opmode 2)
000034CC  4EF9 00003508           2724      JMP         AND_MODE_001        ; Invalid: An
000034D2  4EF9 0000350E           2725      JMP         AND_MODE_010        ; (An)
000034D8  4EF9 00003518           2726      JMP         AND_MODE_011        ; (An)+
000034DE  4EF9 00003522           2727      JMP         AND_MODE_100        ; -(An)
000034E4  4EF9 0000352C           2728      JMP         AND_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000034EA  4EF9 00003532           2729      JMP         AND_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000034F0  4EF9 00003538           2730      JMP         AND_MODE_111        ; The rest (not all valid, validated by register number)
000034F6                          2731  AND_MODE_000: ; Dn (invalid if opmode 2)
000034F6  B07C 0002               2732      CMP         #2, D0
000034FA  6700 0082               2733      BEQ         AND_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
000034FE  4EB8 2B88               2734      JSR         EA_PRINT_DN         ; Print data register direct operand
00003502  4EF9 0000357C           2735      JMP         AND_MODE_END        ; End evaluation of ea mode
00003508                          2736  AND_MODE_001: ; Invalid: An
00003508  4EF9 0000357E           2737      JMP         AND_MODE_INVALID
0000350E                          2738  AND_MODE_010: ; (An)
0000350E  4EB8 2CA8               2739      JSR         EA_PRINT_IND         ; Print address register indirect
00003512  4EF9 0000357C           2740      JMP         AND_MODE_END        ; End evaluation of ea mode
00003518                          2741  AND_MODE_011: ; (An)+
00003518  4EB8 2D72               2742      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000351C  4EF9 0000357C           2743      JMP         AND_MODE_END        ; End evaluation of ea mode
00003522                          2744  AND_MODE_100: ; -(An)
00003522  4EB8 2E26               2745      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003526  4EF9 0000357C           2746      JMP         AND_MODE_END        ; End evaluation of ea mode
0000352C                          2747  AND_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000352C  4EF9 0000357E           2748      JMP         AND_MODE_INVALID
00003532                          2749  AND_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003532  4EF9 0000357E           2750      JMP         AND_MODE_INVALID
00003538                          2751  AND_MODE_111: ; The rest (not all valid, validated by register number)
00003538  BE3C 0000               2752      CMP.B       #$00, D7            ; Test for absolute word address
0000353C  6700 0018               2753      BEQ         AND_ABS_W
00003540  BE3C 0001               2754      CMP.B       #$01, D7            ; Test for absolute long address
00003544  6700 001A               2755      BEQ         AND_ABS_L
00003548  BE3C 0004               2756      CMP.B       #$04, D7            ; Test for immediate data
0000354C  6700 001C               2757      BEQ         AND_IMM
00003550  4EF9 0000357E           2758      JMP         AND_MODE_INVALID    ; else, invalid
00003556                          2759  AND_ABS_W:
00003556  4EB8 2EEA               2760      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000355A  4EF9 0000357C           2761      JMP         AND_MODE_END
00003560                          2762  AND_ABS_L:
00003560  4EB8 2EDA               2763      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003564  4EF9 0000357C           2764      JMP         AND_MODE_END
0000356A                          2765  AND_IMM: ; invalid if opmode is 2
0000356A  B07C 0002               2766      CMP         #2, D0
0000356E  6700 000E               2767      BEQ         AND_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00003572  4EB8 2D50               2768      JSR         EA_PRINT_IMM        ; Print immediate data
00003576  4EF9 0000357C           2769      JMP         AND_MODE_END
0000357C                          2770  AND_MODE_END:
0000357C  4E75                    2771      RTS                             ; Finish evaluating EA bits
0000357E                          2772  AND_MODE_INVALID:
0000357E  4EB8 2B04               2773      JSR         EA_INVALID          ; Opcode word is Invalid
00003582  4E75                    2774      RTS                             ; Finish evaluating EA bits
00003584                          2775  AND_END:
00003584  4EB8 2B1A               2776      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003588  4CDF 3FFF               2777      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000358C  4E75                    2778      RTS
0000358E                          2779  EA_ASd:
0000358E  48E7 FFFC               2780      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003592  4EB8 2B26               2781      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003596  4EB8 2B76               2782      JSR         EA_SIZE_BITS        ; get size bits in D7
0000359A  BE3C 0003               2783      CMP.B       #$03, D7            ; test if memory shift
0000359E  6700 005E               2784      BEQ         ASd_MEM
000035A2  6000 0002               2785      BRA         ASd_REG             ; else, register shfit
000035A6                          2786  ASd_REG:
000035A6  3E16                    2787      MOVE.W      (A6), D7            ; read opcode word in memory and save,
000035A8                          2788                                      ; (using D7 because EA_PRINT_DN uses D7)
000035A8  143C 0004               2789      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
000035AC  E56F                    2790      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000035AE  143C 000D               2791      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
000035B2  E46F                    2792      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000035B4  3016                    2793      MOVE.W      (A6), D0            ; read opcode word in memory and save
000035B6  143C 000A               2794      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
000035BA  E568                    2795      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
000035BC  143C 000F               2796      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
000035C0  E468                    2797      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
000035C2  B03C 0000               2798      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
000035C6  6700 000C               2799      BEQ         ASd_REG_COUNT
000035CA                          2800  ASd_REG_REG:                        ; Else, count/register field contains register number
000035CA  4EB8 2B88               2801      JSR         EA_PRINT_DN         ; Print register value, stored in D7
000035CE  4EF9 000035E4           2802      JMP         ASd_REG_END         ; Jump to end of ASd_REG
000035D4                          2803  ASd_REG_COUNT:
000035D4  49F9 00004731           2804      LEA         POUND, A4        ; Print '#'
000035DA  4EB9 00004642           2805      JSR         WRITE2MEM
000035E0  4EB8 2B0E               2806      JSR         EA_PRINT_DATA *print hex value in D7 as byte todo, continue on to ASd_REG_END
000035E4                          2807  ASd_REG_END:
000035E4  49F9 00004737           2808      LEA         COMMA, A4        ; Print comma
000035EA  4EB9 00004642           2809      JSR         WRITE2MEM
000035F0  4EB8 2B2A               2810      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
000035F4  4EB8 2B88               2811      JSR         EA_PRINT_DN         ; Print register value in D7
000035F8  4EF9 000036B4           2812      JMP         ASd_END
000035FE                          2813  ASd_MEM:
000035FE  4EB8 2B2A               2814      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003602  41F9 00003610           2815      LEA         ASd_MEM_MODE, A0    ; Set index '0' for jump table
00003608  CCFC 0006               2816      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000360C  4EF0 6000               2817      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003610                          2818  ASd_MEM_MODE:
00003610  4EF9 00003640           2819      JMP         ASd_MEM_MODE_000     ; Invalid: Dn
00003616  4EF9 0000364A           2820      JMP         ASd_MEM_MODE_001     ; Invalid: An
0000361C  4EF9 00003654           2821      JMP         ASd_MEM_MODE_010     ; (An)
00003622  4EF9 0000365E           2822      JMP         ASd_MEM_MODE_011     ; (An)+
00003628  4EF9 00003668           2823      JMP         ASd_MEM_MODE_100     ; -(An)
0000362E  4EF9 00003672           2824      JMP         ASd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003634  4EF9 0000367C           2825      JMP         ASd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000363A  4EF9 00003686           2826      JMP         ASd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00003640                          2827  ASd_MEM_MODE_000: ; Invalid: Dn
00003640  4EB8 2B04               2828      JSR         EA_INVALID          ; Data register direct is invalid mode
00003644  4EF9 000036B4           2829      JMP         ASd_END
0000364A                          2830  ASd_MEM_MODE_001: ; Invalid: An
0000364A  4EB8 2B04               2831      JSR         EA_INVALID          ; Address register direct is invalid mode
0000364E  4EF9 000036B4           2832      JMP         ASd_END
00003654                          2833  ASd_MEM_MODE_010: ; (An)
00003654  4EB8 2CA8               2834      JSR         EA_PRINT_IND         ; Print address register indirect
00003658  4EF9 000036B4           2835      JMP         ASd_END
0000365E                          2836  ASd_MEM_MODE_011: ; (An)+
0000365E  4EB8 2D72               2837      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003662  4EF9 000036B4           2838      JMP         ASd_END
00003668                          2839  ASd_MEM_MODE_100: ; -(An)
00003668  4EB8 2E26               2840      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000366C  4EF9 000036B4           2841      JMP         ASd_END         ; Continue with parsing destination operand
00003672                          2842  ASd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003672  4EB8 2B04               2843      JSR         EA_INVALID          ; Opcode word is Invalid
00003676  4EF9 000036B4           2844      JMP         ASd_END
0000367C                          2845  ASd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000367C  4EB8 2B04               2846      JSR         EA_INVALID          ; Opcode word is Invalid
00003680  4EF9 000036B4           2847      JMP         ASd_END
00003686                          2848  ASd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
00003686  BE3C 0000               2849      CMP.B       #$00, D7            ; Test for absolute word address
0000368A  6700 0014               2850      BEQ         ASd_MEM_ABS_W
0000368E  BE3C 0001               2851      CMP.B       #$01, D7            ; Test for absolute long address
00003692  6700 0016               2852      BEQ         ASd_MEM_ABS_L
00003696  4EB8 2B04               2853      JSR         EA_INVALID          ; Else: invalid
0000369A  4EF9 000036B4           2854      JMP         ASd_END
000036A0                          2855  ASd_MEM_ABS_W:
000036A0  4EB8 2EEA               2856      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000036A4  4EF9 000036B4           2857      JMP         ASd_END
000036AA                          2858  ASd_MEM_ABS_L:
000036AA  4EB8 2EDA               2859      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000036AE  4EF9 000036B4           2860      JMP         ASd_END
000036B4                          2861  ASd_END:
000036B4  4EB8 2B1A               2862      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000036B8  4CDF 3FFF               2863      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000036BC  4E75                    2864      RTS
000036BE                          2865  EA_Bcc:
000036BE  48E7 FFFC               2866      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000036C2  4EB8 2B26               2867      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000036C6  2216                    2868      MOVE.L      (A6), D1            ; Load opcode to data register 1
000036C8  143C 0008               2869      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
000036CC  E569                    2870      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000036CE  143C 0008               2871      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine condition
000036D2  E469                    2872      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000036D4                          2873      *save ultimate address to be printed
000036D4  284E                    2874      MOVEA.L     A6, A4              ; Copy global pointer for dislay
000036D6  B23C 0000               2875      CMP.B       #$00, D1            ; If value is zero, real value is next word in memory
000036DA  6700 0034               2876      BEQ         BCC_W
000036DE  B23C 00FF               2877      CMP.B       #$FF, D1            ; If value is FF, real value is next longword
000036E2  6700 004E               2878      BEQ         BCC_L
000036E6  4EF9 000036EC           2879      JMP         BCC_B               ; Else, parse lower-order byte of opcode word
000036EC                          2880  BCC_B:
000036EC  548C                    2881      ADDA.L      #$00000002, A4      ; Increment display pointer past opcode word
000036EE  3616                    2882      MOVE.W      (A6), D3            ; Save opcode word
000036F0  143C 0008               2883      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
000036F4  E56B                    2884      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
000036F6  143C 000F               2885      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
000036FA  E46B                    2886      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
000036FC  B63C 0000               2887      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003700  6700 003E               2888      BEQ         BCC_DISPLAY
00003704  0681 FFFFFF00           2889      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
0000370A  4EF9 00003740           2890      JMP         BCC_DISPLAY
00003710                          2891  BCC_W:
00003710  588C                    2892      ADDA.L      #$00000004, A4      ; Increment display pointer past opcode word
00003712                          2893                                      ; and displacement word in memory
00003712  548D                    2894      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
00003714  3615                    2895      MOVE.W      (A5), D3            ; Read word displacement from memory
00003716  548D                    2896      ADDA.L      #$00000002, A5      ; Increment A5 past word read
00003718  143C 000F               2897      MOVE.B      #15, D2             ; 'Right-align' bit 15 to determine MSB
0000371C  E46B                    2898      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
0000371E  B63C 0000               2899      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003722  6700 001C               2900      BEQ         BCC_DISPLAY
00003726  0681 FFFF0000           2901      ADD.L       #$FFFF0000, D1      ; Else, sign extend data with F
0000372C  4EF9 00003740           2902      JMP         BCC_DISPLAY
00003732                          2903  BCC_L:
00003732  5C8C                    2904      ADDA.L      #$00000006, A4      ; Increment display pointer past opcode word
00003734                          2905                                      ; and displacement longword in memory
00003734  548D                    2906      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
00003736  2215                    2907      MOVE.L      (A5), D1            ; Read longword displacement from memory
00003738  588D                    2908      ADDA.L      #$00000004, A5      ; Increment A5 past longword read
0000373A  4EF9 00003740           2909      JMP         BCC_DISPLAY
00003740                          2910  BCC_DISPLAY:
00003740  D9C1                    2911      ADDA.L      D1, A4              ; add displacement to current addressing
00003742                          2912      *print address in A4
00003742  4EB8 2B1A               2913      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003746  4CDF 3FFF               2914      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000374A  4E75                    2915      RTS
0000374C                          2916  EA_CLR:
0000374C  48E7 FFFC               2917      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003750  4EB8 2B26               2918      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003754  4EB8 2B2A               2919      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003758  41F9 00003766           2920      LEA         CLR_MODE, A0        ; Set index '0' for jump table
0000375E  CCFC 0006               2921      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003762  4EF0 6000               2922      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003766                          2923  CLR_MODE:
00003766  4EF9 00003796           2924      JMP         CLR_MODE_000        ; Dn
0000376C  4EF9 000037A0           2925      JMP         CLR_MODE_001        ; Invalid: An
00003772  4EF9 000037AA           2926      JMP         CLR_MODE_010        ; (An)
00003778  4EF9 000037B4           2927      JMP         CLR_MODE_011        ; (An)+
0000377E  4EF9 000037BE           2928      JMP         CLR_MODE_100        ; -(An)
00003784  4EF9 000037C8           2929      JMP         CLR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
0000378A  4EF9 000037D2           2930      JMP         CLR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003790  4EF9 000037DC           2931      JMP         CLR_MODE_111        ; The rest (not all valid, validated by register number)
00003796                          2932  CLR_MODE_000: ; Dn
00003796  4EB8 2B88               2933      JSR         EA_PRINT_DN
0000379A  4EF9 0000380A           2934      JMP         CLR_END
000037A0                          2935  CLR_MODE_001: ; Invalid: An
000037A0  4EB8 2B04               2936      JSR         EA_INVALID          ; Address register direct is invalid mode
000037A4  4EF9 0000380A           2937      JMP         CLR_END
000037AA                          2938  CLR_MODE_010: ; (An)
000037AA  4EB8 2CA8               2939      JSR         EA_PRINT_IND         ; Print address register indirect
000037AE  4EF9 0000380A           2940      JMP         CLR_END
000037B4                          2941  CLR_MODE_011: ; (An)+
000037B4  4EB8 2D72               2942      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000037B8  4EF9 0000380A           2943      JMP         CLR_END
000037BE                          2944  CLR_MODE_100: ; -(An)
000037BE  4EB8 2E26               2945      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000037C2  4EF9 0000380A           2946      JMP         CLR_END             ; Continue with parsing destination operand
000037C8                          2947  CLR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000037C8  4EB8 2B04               2948      JSR         EA_INVALID          ; Opcode word is Invalid
000037CC  4EF9 0000380A           2949      JMP         CLR_END
000037D2                          2950  CLR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000037D2  4EB8 2B04               2951      JSR         EA_INVALID          ; Opcode word is Invalid
000037D6  4EF9 0000380A           2952      JMP         CLR_END
000037DC                          2953  CLR_MODE_111: ; The rest (not all valid, validated by register number)
000037DC  BE3C 0000               2954      CMP.B       #$00, D7            ; Test for absolute word address
000037E0  6700 0014               2955      BEQ         CLR_ABS_W
000037E4  BE3C 0001               2956      CMP.B       #$01, D7            ; Test for absolute long address
000037E8  6700 0016               2957      BEQ         CLR_ABS_L
000037EC  4EB8 2B04               2958      JSR         EA_INVALID          ; Else: invalid
000037F0  4EF9 0000380A           2959      JMP         CLR_END
000037F6                          2960  CLR_ABS_W:
000037F6  4EB8 2EEA               2961      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000037FA  4EF9 0000380A           2962      JMP         CLR_END
00003800                          2963  CLR_ABS_L:
00003800  4EB8 2EDA               2964      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003804  4EF9 0000380A           2965      JMP         CLR_END
0000380A                          2966  CLR_END:
0000380A  4EB8 2B1A               2967      JSR         EA_UPDATE_POINTER   ; Updates global pointer
0000380E  4CDF 3FFF               2968      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003812  4E75                    2969      RTS
00003814                          2970  EA_CMP:
00003814  48E7 FFFC               2971      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003818  4EB8 2B26               2972      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000381C  4EB8 2B2A               2973      JSR         EA_DEFAULT_COMBO
00003820  41F9 0000382E           2974      LEA         CMP_MODE, A0       ; Set index '0' for jump table
00003826  CCFC 0006               2975      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000382A  4EF0 6000               2976      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000382E                          2977  CMP_MODE:
0000382E  4EF9 0000385E           2978      JMP         CMP_MODE_000       ; Dn
00003834  4EF9 00003868           2979      JMP         CMP_MODE_001       ; An
0000383A  4EF9 00003872           2980      JMP         CMP_MODE_010       ; (An)
00003840  4EF9 0000387C           2981      JMP         CMP_MODE_011       ; (An)+
00003846  4EF9 00003886           2982      JMP         CMP_MODE_100       ; -(An)
0000384C  4EF9 00003890           2983      JMP         CMP_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00003852  4EF9 0000389A           2984      JMP         CMP_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003858  4EF9 000038A4           2985      JMP         CMP_MODE_111       ; The rest (not all valid, validated by register number)
0000385E                          2986  CMP_MODE_000: ; Dn
0000385E  4EB8 2B88               2987      JSR         EA_PRINT_DN         ; Print data register direct operand
00003862  4EF9 000038D2           2988      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003868                          2989  CMP_MODE_001: ; An
00003868  4EB8 2C18               2990      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
0000386C  4EF9 000038D2           2991      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003872                          2992  CMP_MODE_010: ; (An)
00003872  4EB8 2CA8               2993      JSR         EA_PRINT_IND        ; Print address register indirect
00003876  4EF9 000038D2           2994      JMP         CMP_MODE_END        ; End evaluation of ea mode
0000387C                          2995  CMP_MODE_011: ; (An)+
0000387C  4EB8 2D72               2996      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003880  4EF9 000038D2           2997      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003886                          2998  CMP_MODE_100: ; -(An)
00003886  4EB8 2E26               2999      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000388A  4EF9 000038D2           3000      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003890                          3001  CMP_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003890  4EB8 2B04               3002      JSR         EA_INVALID          ; Opcode word is Invalid
00003894  4EF9 000038E6           3003      JMP         CMP_END
0000389A                          3004  CMP_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000389A  4EB8 2B04               3005      JSR         EA_INVALID          ; Opcode word is Invalid
0000389E  4EF9 000038E6           3006      JMP         CMP_END
000038A4                          3007  CMP_MODE_111: ; The rest (not all valid, validated by register number)
000038A4  BE3C 0000               3008      CMP.B       #$00, D7            ; Test for absolute word address
000038A8  6700 0014               3009      BEQ         CMP_ABS_W
000038AC  BE3C 0001               3010      CMP.B       #$01, D7            ; Test for absolute long address
000038B0  6700 0016               3011      BEQ         CMP_ABS_L
000038B4  4EB8 2B04               3012      JSR         EA_INVALID          ; Opcode word is Invalid
000038B8  4EF9 000038E6           3013      JMP         CMP_END
000038BE                          3014  CMP_ABS_W:
000038BE  4EB8 2EEA               3015      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000038C2  4EF9 000038D2           3016      JMP         CMP_MODE_END
000038C8                          3017  CMP_ABS_L:
000038C8  4EB8 2EDA               3018      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000038CC  4EF9 000038D2           3019      JMP         CMP_MODE_END
000038D2                          3020  CMP_MODE_END:
000038D2  49F9 00004737           3021      LEA         COMMA, A4        ; Print comma
000038D8  4EB9 00004642           3022      JSR         WRITE2MEM
000038DE  4EB8 2B50               3023      JSR         EA_OPMODE_COMBO     ; get register bits in D7, opmode bits not used
000038E2  4EB8 2B88               3024      JSR         EA_PRINT_DN         ; print register
000038E6                          3025  CMP_END:
000038E6  4EB8 2B1A               3026      JSR         EA_UPDATE_POINTER   ; Update global pointer
000038EA  4CDF 3FFF               3027      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000038EE  4E75                    3028      RTS
000038F0                          3029  EA_DIVU_W:
000038F0  48E7 FFFC               3030      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000038F4  4EB8 2B26               3031      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000038F8  4EB8 2B2A               3032      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000038FC  41F9 0000390A           3033      LEA         DIVU_W_MODE, A0       ; Set index '0' for jump table
00003902  CCFC 0006               3034      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003906  4EF0 6000               3035      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000390A                          3036  DIVU_W_MODE:
0000390A  4EF9 0000393A           3037      JMP         DIVU_W_MODE_000     ; Dn
00003910  4EF9 00003944           3038      JMP         DIVU_W_MODE_001     ; Invalid: An
00003916  4EF9 0000394E           3039      JMP         DIVU_W_MODE_010     ; (An)
0000391C  4EF9 00003958           3040      JMP         DIVU_W_MODE_011     ; (An)+
00003922  4EF9 00003962           3041      JMP         DIVU_W_MODE_100     ; -(An)
00003928  4EF9 0000396C           3042      JMP         DIVU_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
0000392E  4EF9 00003976           3043      JMP         DIVU_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003934  4EF9 00003980           3044      JMP         DIVU_W_MODE_111     ; The rest (not all valid, validated by register number)
0000393A                          3045  DIVU_W_MODE_000: ; Dn
0000393A  4EB8 2B88               3046      JSR         EA_PRINT_DN         ; Print data register direct operand
0000393E  4EF9 000039C4           3047      JMP         DIVU_W_DEST         ; Go to: print destination operand
00003944                          3048  DIVU_W_MODE_001: ; Invalid: An
00003944  4EB8 2B04               3049      JSR         EA_INVALID          ; Address register direct is invalid mode
00003948  4EF9 000039D6           3050      JMP         DIVU_W_END
0000394E                          3051  DIVU_W_MODE_010: ; (An)
0000394E  4EB8 2CA8               3052      JSR         EA_PRINT_IND         ; Print address register indirect
00003952  4EF9 000039C4           3053      JMP         DIVU_W_DEST
00003958                          3054  DIVU_W_MODE_011: ; (An)+
00003958  4EB8 2D72               3055      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000395C  4EF9 000039C4           3056      JMP         DIVU_W_DEST
00003962                          3057  DIVU_W_MODE_100: ; -(An)
00003962  4EB8 2E26               3058      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003966  4EF9 000039C4           3059      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
0000396C                          3060  DIVU_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000396C  4EB8 2B04               3061      JSR         EA_INVALID          ; Opcode word is Invalid
00003970  4EF9 000039D6           3062      JMP         DIVU_W_END
00003976                          3063  DIVU_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003976  4EB8 2B04               3064      JSR         EA_INVALID          ; Opcode word is Invalid
0000397A  4EF9 000039D6           3065      JMP         DIVU_W_END
00003980                          3066  DIVU_W_MODE_111: ; The rest (not all valid, validated by register number)
00003980  BE3C 0000               3067      CMP.B       #$00, D7            ; Test for absolute word address
00003984  6700 001C               3068      BEQ         DIVU_W_ABS_W
00003988  BE3C 0001               3069      CMP.B       #$01, D7            ; Test for absolute long address
0000398C  6700 001E               3070      BEQ         DIVU_W_ABS_L
00003990  BE3C 0004               3071      CMP.B       #$04, D7            ; Test for immediate data
00003994  6700 0020               3072      BEQ         DIVU_W_IMM
00003998  4EB8 2B04               3073      JSR         EA_INVALID          ; Else: invalid
0000399C  4EF9 000039D6           3074      JMP         DIVU_W_END
000039A2                          3075  DIVU_W_ABS_W:
000039A2  4EB8 2EEA               3076      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000039A6  4EF9 000039C4           3077      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000039AC                          3078  DIVU_W_ABS_L:
000039AC  4EB8 2EDA               3079      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000039B0  4EF9 000039C4           3080      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000039B6                          3081  DIVU_W_IMM:
000039B6  1A3C 0002               3082      MOVE.B      #2, D5              ; Size is word
000039BA  4EB8 2D50               3083      JSR         EA_PRINT_IMM        ; Print immediate data
000039BE  4EF9 000039C4           3084      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000039C4                          3085  DIVU_W_DEST:
000039C4                          3086      *print COMMA
000039C4                          3087      *Get destination register
000039C4  3E16                    3088      MOVE.W      (A6), D7            ; Load word at current pointer to D1
000039C6  143C 0004               3089      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
000039CA  E56F                    3090      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000039CC  143C 000D               3091      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
000039D0  E46F                    3092      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000039D2  4EB8 2B88               3093      JSR         EA_PRINT_DN         ; Print data register direct operand
000039D6                          3094  DIVU_W_END:
000039D6  4EB8 2B1A               3095      JSR         EA_UPDATE_POINTER   ; Update global pointer
000039DA  4CDF 3FFF               3096      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000039DE  4E75                    3097      RTS
000039E0                          3098  EA_JSR:
000039E0  48E7 FFFC               3099      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000039E4  4EB8 2B26               3100      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000039E8  4EB8 2B2A               3101      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000039EC  41F9 000039FA           3102      LEA         JSR_MODE, A0        ; Set index '0' for jump table
000039F2  CCFC 0006               3103      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000039F6  4EF0 6000               3104      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000039FA                          3105  JSR_MODE:
000039FA  4EF9 00003A2A           3106      JMP         JSR_MODE_000        ; Invalid: Dn
00003A00  4EF9 00003A34           3107      JMP         JSR_MODE_001        ; Invalid: An
00003A06  4EF9 00003A3E           3108      JMP         JSR_MODE_010        ; (An)
00003A0C  4EF9 00003A48           3109      JMP         JSR_MODE_011        ; Invalid: (An)+
00003A12  4EF9 00003A52           3110      JMP         JSR_MODE_100        ; Invalid: -(An)
00003A18  4EF9 00003A5C           3111      JMP         JSR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003A1E  4EF9 00003A66           3112      JMP         JSR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A24  4EF9 00003A70           3113      JMP         JSR_MODE_111        ; The rest (not all valid, validated by register number)
00003A2A                          3114  JSR_MODE_000: ; Invalid: Dn
00003A2A  4EB8 2B04               3115      JSR         EA_INVALID          ; Data register direct is invalid mode
00003A2E  4EF9 00003A9E           3116      JMP         JSR_END
00003A34                          3117  JSR_MODE_001: ; Invalid: An
00003A34  4EB8 2B04               3118      JSR         EA_INVALID          ; Address register direct is invalid mode
00003A38  4EF9 00003A9E           3119      JMP         JSR_END
00003A3E                          3120  JSR_MODE_010: ; (An)
00003A3E  4EB8 2CA8               3121      JSR         EA_PRINT_IND         ; Print address register indirect
00003A42  4EF9 00003A9E           3122      JMP         JSR_END
00003A48                          3123  JSR_MODE_011: ; (An)+
00003A48  4EB8 2B04               3124      JSR         EA_INVALID          ; Address register indirect w/ post increment is invalid mode
00003A4C  4EF9 00003A9E           3125      JMP         JSR_END
00003A52                          3126  JSR_MODE_100: ; -(An)
00003A52  4EB8 2B04               3127      JSR         EA_INVALID          ; Address register indirect w/ pre decrement is invalid mode
00003A56  4EF9 00003A9E           3128      JMP         JSR_END
00003A5C                          3129  JSR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003A5C  4EB8 2B04               3130      JSR         EA_INVALID          ; Opcode word is Invalid
00003A60  4EF9 00003A9E           3131      JMP         JSR_END
00003A66                          3132  JSR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A66  4EB8 2B04               3133      JSR         EA_INVALID          ; Opcode word is Invalid
00003A6A  4EF9 00003A9E           3134      JMP         JSR_END
00003A70                          3135  JSR_MODE_111: ; The rest (not all valid, validated by register number)
00003A70  BE3C 0000               3136      CMP.B       #$00, D7            ; Test for absolute word address
00003A74  6700 0014               3137      BEQ         JSR_ABS_W
00003A78  BE3C 0001               3138      CMP.B       #$01, D7            ; Test for absolute long address
00003A7C  6700 0016               3139      BEQ         JSR_ABS_L
00003A80  4EB8 2B04               3140      JSR         EA_INVALID          ; Else: invalid
00003A84  4EF9 00003A9E           3141      JMP         JSR_END
00003A8A                          3142  JSR_ABS_W:
00003A8A  4EB8 2EEA               3143      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003A8E  4EF9 00003A9E           3144      JMP         JSR_END
00003A94                          3145  JSR_ABS_L:
00003A94  4EB8 2EDA               3146      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003A98  4EF9 00003A9E           3147      JMP         JSR_END
00003A9E                          3148  JSR_END:
00003A9E  4EB8 2B1A               3149      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003AA2  4CDF 3FFF               3150      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003AA6  4E75                    3151      RTS
00003AA8                          3152  EA_LEA:
00003AA8  48E7 FFFC               3153      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003AAC  4EB8 2B26               3154      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003AB0  4EB8 2B2A               3155      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003AB4  41F9 00003AC2           3156      LEA         LEA_MODE, A0        ; Set index '0' for jump table
00003ABA  CCFC 0006               3157      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003ABE  4EF0 6000               3158      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003AC2                          3159  LEA_MODE:
00003AC2  4EF9 00003AF2           3160      JMP         LEA_MODE_000        ; Dn
00003AC8  4EF9 00003AFC           3161      JMP         LEA_MODE_001        ; Invalid: An
00003ACE  4EF9 00003B06           3162      JMP         LEA_MODE_010        ; (An)
00003AD4  4EF9 00003B10           3163      JMP         LEA_MODE_011        ; (An)+
00003ADA  4EF9 00003B1A           3164      JMP         LEA_MODE_100        ; -(An)
00003AE0  4EF9 00003B24           3165      JMP         LEA_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003AE6  4EF9 00003B2E           3166      JMP         LEA_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003AEC  4EF9 00003B38           3167      JMP         LEA_MODE_111        ; The rest (not all valid, validated by register number)
00003AF2                          3168  LEA_MODE_000: ; Invalid: Dn
00003AF2  4EB8 2B04               3169      JSR         EA_INVALID          ; Data register direct is invalid mode
00003AF6  4EF9 00003B7A           3170      JMP         LEA_END
00003AFC                          3171  LEA_MODE_001: ; Invalid: An
00003AFC  4EB8 2B04               3172      JSR         EA_INVALID          ; Address register direct is invalid mode
00003B00  4EF9 00003B7A           3173      JMP         LEA_END
00003B06                          3174  LEA_MODE_010: ; (An)
00003B06  4EB8 2CA8               3175      JSR         EA_PRINT_IND         ; Print address register indirect
00003B0A  4EF9 00003B66           3176      JMP         LEA_DEST
00003B10                          3177  LEA_MODE_011: ; (An)+
00003B10  4EB8 2B04               3178      JSR         EA_INVALID          ; Address register indirect with post increment is invalid
00003B14  4EF9 00003B7A           3179      JMP         LEA_END
00003B1A                          3180  LEA_MODE_100: ; -(An)
00003B1A  4EB8 2B04               3181      JSR         EA_INVALID          ; Adress register indirect with pre decrement is invalid
00003B1E  4EF9 00003B7A           3182      JMP         LEA_END             ; Continue with parsing destination operand
00003B24                          3183  LEA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003B24  4EB8 2B04               3184      JSR         EA_INVALID          ; Opcode word is Invalid
00003B28  4EF9 00003B7A           3185      JMP         LEA_END
00003B2E                          3186  LEA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003B2E  4EB8 2B04               3187      JSR         EA_INVALID          ; Opcode word is Invalid
00003B32  4EF9 00003B7A           3188      JMP         LEA_END
00003B38                          3189  LEA_MODE_111: ; The rest (not all valid, validated by register number)
00003B38  BE3C 0000               3190      CMP.B       #$00, D7            ; Test for absolute word address
00003B3C  6700 0014               3191      BEQ         LEA_ABS_W
00003B40  BE3C 0001               3192      CMP.B       #$01, D7            ; Test for absolute long address
00003B44  6700 0016               3193      BEQ         LEA_ABS_L
00003B48  4EB8 2B04               3194      JSR         EA_INVALID          ; Else: invalid
00003B4C  4EF9 00003B66           3195      JMP         LEA_DEST
00003B52                          3196  LEA_ABS_W:
00003B52  4EB8 2EEA               3197      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003B56  4EF9 00003B66           3198      JMP         LEA_DEST
00003B5C                          3199  LEA_ABS_L:
00003B5C  4EB8 2EDA               3200      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003B60  4EF9 00003B66           3201      JMP         LEA_DEST
00003B66                          3202  LEA_DEST:
00003B66  49F9 00004737           3203      LEA         COMMA, A4        ; Print comma
00003B6C  4EB9 00004642           3204      JSR         WRITE2MEM
00003B72  4EB8 2B50               3205      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, opmode bits unused
00003B76  4EB8 2C18               3206      JSR         EA_PRINT_AN         ; Print address register
00003B7A                          3207  LEA_END:
00003B7A  4EB8 2B1A               3208      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003B7E  4CDF 3FFF               3209      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003B82  4E75                    3210      RTS
00003B84                          3211  EA_LSd:
00003B84  48E7 FFFC               3212      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003B88  4EB8 2B26               3213      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003B8C  4EB8 2B76               3214      JSR         EA_SIZE_BITS        ; get size bits in D7
00003B90  BE3C 0003               3215      CMP.B       #$03, D7            ; test if memory shift
00003B94  6700 005E               3216      BEQ         LSd_MEM
00003B98  6000 0002               3217      BRA         LSd_REG             ; else, register shfit
00003B9C                          3218  LSd_REG:
00003B9C  3E16                    3219      MOVE.W      (A6), D7            ; read opcode word in memory and save,
00003B9E                          3220                                      ; (using D7 because EA_PRINT_DN uses D7)
00003B9E  143C 0004               3221      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
00003BA2  E56F                    3222      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003BA4  143C 000D               3223      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
00003BA8  E46F                    3224      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003BAA  3016                    3225      MOVE.W      (A6), D0            ; read opcode word in memory and save
00003BAC  143C 000A               3226      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
00003BB0  E568                    3227      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00003BB2  143C 000F               3228      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
00003BB6  E468                    3229      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00003BB8  B03C 0000               3230      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
00003BBC  6700 000C               3231      BEQ         LSd_REG_COUNT
00003BC0                          3232  LSd_REG_REG:                        ; Else, count/register field contains register number
00003BC0  4EB8 2B88               3233      JSR         EA_PRINT_DN         ; Print register value, stored in D7
00003BC4  4EF9 00003BDA           3234      JMP         LSd_REG_END         ; Jump to end of LSd_REG
00003BCA                          3235  LSd_REG_COUNT:
00003BCA  49F9 00004731           3236      LEA         POUND, A4         ; Print '#'
00003BD0  4EB9 00004642           3237      JSR         WRITE2MEM
00003BD6  4EB8 2B0E               3238      JSR         EA_PRINT_DATA  *print hex value in D7 as byte todo, continue on to LSd_REG_END
00003BDA                          3239  LSd_REG_END:
00003BDA  49F9 00004737           3240      LEA         COMMA, A4        ; Print comma
00003BE0  4EB9 00004642           3241      JSR         WRITE2MEM
00003BE6  4EB8 2B2A               3242      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
00003BEA  4EB8 2B88               3243      JSR         EA_PRINT_DN         ; Print register value in D7
00003BEE  4EF9 00003CAA           3244      JMP         LSd_END
00003BF4                          3245  LSd_MEM:
00003BF4  4EB8 2B2A               3246      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003BF8  41F9 00003C06           3247      LEA         LSd_MEM_MODE, A0    ; Set index '0' for jump table
00003BFE  CCFC 0006               3248      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003C02  4EF0 6000               3249      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003C06                          3250  LSd_MEM_MODE:
00003C06  4EF9 00003C36           3251      JMP         LSd_MEM_MODE_000     ; Invalid: Dn
00003C0C  4EF9 00003C40           3252      JMP         LSd_MEM_MODE_001     ; Invalid: An
00003C12  4EF9 00003C4A           3253      JMP         LSd_MEM_MODE_010     ; (An)
00003C18  4EF9 00003C54           3254      JMP         LSd_MEM_MODE_011     ; (An)+
00003C1E  4EF9 00003C5E           3255      JMP         LSd_MEM_MODE_100     ; -(An)
00003C24  4EF9 00003C68           3256      JMP         LSd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003C2A  4EF9 00003C72           3257      JMP         LSd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003C30  4EF9 00003C7C           3258      JMP         LSd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00003C36                          3259  LSd_MEM_MODE_000: ; Invalid: Dn
00003C36  4EB8 2B04               3260      JSR         EA_INVALID          ; Data register direct is invalid mode
00003C3A  4EF9 00003CAA           3261      JMP         LSd_END
00003C40                          3262  LSd_MEM_MODE_001: ; Invalid: An
00003C40  4EB8 2B04               3263      JSR         EA_INVALID          ; Address register direct is invalid mode
00003C44  4EF9 00003CAA           3264      JMP         LSd_END
00003C4A                          3265  LSd_MEM_MODE_010: ; (An)
00003C4A  4EB8 2CA8               3266      JSR         EA_PRINT_IND         ; Print address register indirect
00003C4E  4EF9 00003CAA           3267      JMP         LSd_END
00003C54                          3268  LSd_MEM_MODE_011: ; (An)+
00003C54  4EB8 2D72               3269      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003C58  4EF9 00003CAA           3270      JMP         LSd_END
00003C5E                          3271  LSd_MEM_MODE_100: ; -(An)
00003C5E  4EB8 2E26               3272      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003C62  4EF9 00003CAA           3273      JMP         LSd_END         ; Continue with parsing destination operand
00003C68                          3274  LSd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003C68  4EB8 2B04               3275      JSR         EA_INVALID          ; Opcode word is Invalid
00003C6C  4EF9 00003CAA           3276      JMP         LSd_END
00003C72                          3277  LSd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003C72  4EB8 2B04               3278      JSR         EA_INVALID          ; Opcode word is Invalid
00003C76  4EF9 00003CAA           3279      JMP         LSd_END
00003C7C                          3280  LSd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
00003C7C  BE3C 0000               3281      CMP.B       #$00, D7            ; Test for absolute word address
00003C80  6700 0014               3282      BEQ         LSd_MEM_ABS_W
00003C84  BE3C 0001               3283      CMP.B       #$01, D7            ; Test for absolute long address
00003C88  6700 0016               3284      BEQ         LSd_MEM_ABS_L
00003C8C  4EB8 2B04               3285      JSR         EA_INVALID          ; Else: invalid
00003C90  4EF9 00003CAA           3286      JMP         LSd_END
00003C96                          3287  LSd_MEM_ABS_W:
00003C96  4EB8 2EEA               3288      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003C9A  4EF9 00003CAA           3289      JMP         LSd_END
00003CA0                          3290  LSd_MEM_ABS_L:
00003CA0  4EB8 2EDA               3291      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003CA4  4EF9 00003CAA           3292      JMP         LSd_END
00003CAA                          3293  LSd_END:
00003CAA  4EB8 2B1A               3294      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003CAE  4CDF 3FFF               3295      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003CB2  4E75                    3296      RTS
00003CB4                          3297  EA_MOVE:
00003CB4  48E7 FFFC               3298      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003CB8  4EB8 2B26               3299      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003CBC  2A16                    3300      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
00003CBE  143C 0002               3301      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
00003CC2  E56D                    3302      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
00003CC4  143C 000E               3303      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
00003CC8  E46D                    3304      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
00003CCA  BA3C 0003               3305      CMP.B       #$03, D5            ; if size bits are 11, correct D5
00003CCE                          3306                                      ; to 10 for use with immediate data subroutine
00003CCE  6700 0010               3307      BEQ         MOVE_ADJUST_W
00003CD2  BA3C 0002               3308      CMP.B       #$02, D5            ; if size bits are 10, correct D5
00003CD6                          3309                                      ; to 11 for use with immediate data subroutine
00003CD6  6700 0012               3310      BEQ         MOVE_ADJUST_L
00003CDA  4EF9 00003CF4           3311      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003CE0                          3312  MOVE_ADJUST_W:
00003CE0  1A3C 0002               3313      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
00003CE4  4EF9 00003CF4           3314      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003CEA                          3315  MOVE_ADJUST_L:
00003CEA  1A3C 0003               3316      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
00003CEE  4EF9 00003CF4           3317      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003CF4                          3318  MOVE_SOURCE:
00003CF4  4EB8 2B2A               3319      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003CF8  41F9 00003D06           3320      LEA         MOVE_SRC_MODE, A0   ; Set index '0' for jump table
00003CFE  CCFC 0006               3321      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003D02  4EF0 6000               3322      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003D06                          3323  MOVE_SRC_MODE:
00003D06  4EF9 00003D36           3324      JMP         MOVE_SRC_MODE_000   ; Dn
00003D0C  4EF9 00003D40           3325      JMP         MOVE_SRC_MODE_001   ; An
00003D12  4EF9 00003D4A           3326      JMP         MOVE_SRC_MODE_010   ; (An)
00003D18  4EF9 00003D54           3327      JMP         MOVE_SRC_MODE_011   ; (An)+
00003D1E  4EF9 00003D5E           3328      JMP         MOVE_SRC_MODE_100   ; -(An)
00003D24  4EF9 00003D68           3329      JMP         MOVE_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003D2A  4EF9 00003D72           3330      JMP         MOVE_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003D30  4EF9 00003D7C           3331      JMP         MOVE_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003D36                          3332  MOVE_SRC_MODE_000: ; Dn
00003D36  4EB8 2B88               3333      JSR         EA_PRINT_DN         ; Print data register in D7
00003D3A  4EF9 00003DBC           3334      JMP         MOVE_DESTINATION
00003D40                          3335  MOVE_SRC_MODE_001: ; Invalid: An
00003D40  4EB8 2C18               3336      JSR         EA_PRINT_AN         ; Print address register in D7
00003D44  4EF9 00003DBC           3337      JMP         MOVE_DESTINATION
00003D4A                          3338  MOVE_SRC_MODE_010: ; (An)
00003D4A  4EB8 2CA8               3339      JSR         EA_PRINT_IND         ; Print address register indirect
00003D4E  4EF9 00003DBC           3340      JMP         MOVE_DESTINATION
00003D54                          3341  MOVE_SRC_MODE_011: ; (An)+
00003D54  4EB8 2D72               3342      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003D58  4EF9 00003DBC           3343      JMP         MOVE_DESTINATION
00003D5E                          3344  MOVE_SRC_MODE_100: ; -(An)
00003D5E  4EB8 2E26               3345      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003D62  4EF9 00003DBC           3346      JMP         MOVE_DESTINATION    ; Continue with parsing destination operand
00003D68                          3347  MOVE_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003D68  4EB8 2B04               3348      JSR         EA_INVALID          ; Opcode word is Invalid
00003D6C  4EF9 00003E7E           3349      JMP         MOVE_END
00003D72                          3350  MOVE_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003D72  4EB8 2B04               3351      JSR         EA_INVALID          ; Opcode word is Invalid
00003D76  4EF9 00003E7E           3352      JMP         MOVE_END
00003D7C                          3353  MOVE_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003D7C  BE3C 0000               3354      CMP.B       #$00, D7            ; Test for absolute word address
00003D80  6700 001C               3355      BEQ         MOVE_SRC_ABS_W
00003D84  BE3C 0001               3356      CMP.B       #$01, D7            ; Test for absolute long address
00003D88  6700 001E               3357      BEQ         MOVE_SRC_ABS_L
00003D8C  BE3C 0004               3358      CMP.B       #$04, D7            ; Test for immediate data
00003D90  6700 0020               3359      BEQ         MOVE_SRC_IMM
00003D94  4EB8 2B04               3360      JSR         EA_INVALID          ; Else: invalid
00003D98  4EF9 00003E7E           3361      JMP         MOVE_END
00003D9E                          3362  MOVE_SRC_ABS_W:
00003D9E  4EB8 2EEA               3363      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003DA2  4EF9 00003DBC           3364      JMP         MOVE_DESTINATION
00003DA8                          3365  MOVE_SRC_ABS_L:
00003DA8  4EB8 2EDA               3366      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003DAC  4EF9 00003DBC           3367      JMP         MOVE_DESTINATION
00003DB2                          3368  MOVE_SRC_IMM:
00003DB2  4EB8 2D50               3369      JSR         EA_PRINT_IMM        ; Print immediate data
00003DB6  4EF9 00003DBC           3370      JMP         MOVE_DESTINATION
00003DBC                          3371  MOVE_DESTINATION:
00003DBC  49F9 00004737           3372      LEA         COMMA, A4        ; Print comma
00003DC2  4EB9 00004642           3373      JSR         WRITE2MEM
00003DC8  4EB8 2B50               3374      JSR         EA_OPMODE_COMBO     ; mode: D6, register: D7 (destination bits)
00003DCC  41F9 00003DDA           3375      LEA         MOVE_DST_MODE, A0   ; Set index '0' for jump table
00003DD2  CCFC 0006               3376      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003DD6  4EF0 6000               3377      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003DDA                          3378  MOVE_DST_MODE:
00003DDA  4EF9 00003E0A           3379      JMP         MOVE_DST_MODE_000   ; Dn
00003DE0  4EF9 00003E14           3380      JMP         MOVE_DST_MODE_001   ; Invalid: An
00003DE6  4EF9 00003E1E           3381      JMP         MOVE_DST_MODE_010   ; (An)
00003DEC  4EF9 00003E28           3382      JMP         MOVE_DST_MODE_011   ; (An)+
00003DF2  4EF9 00003E32           3383      JMP         MOVE_DST_MODE_100   ; -(An)
00003DF8  4EF9 00003E3C           3384      JMP         MOVE_DST_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003DFE  4EF9 00003E46           3385      JMP         MOVE_DST_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E04  4EF9 00003E50           3386      JMP         MOVE_DST_MODE_111   ; The rest (not all valid, validated by register number)
00003E0A                          3387  MOVE_DST_MODE_000: ; Dn
00003E0A  4EB8 2B88               3388      JSR         EA_PRINT_DN         ; Print data register in D7
00003E0E  4EF9 00003E7E           3389      JMP         MOVE_END
00003E14                          3390  MOVE_DST_MODE_001: ; Invalid: An
00003E14  4EB8 2B04               3391      JSR         EA_INVALID          ; Print address register in D7
00003E18  4EF9 00003E7E           3392      JMP         MOVE_END
00003E1E                          3393  MOVE_DST_MODE_010: ; (An)
00003E1E  4EB8 2CA8               3394      JSR         EA_PRINT_IND         ; Print address register indirect
00003E22  4EF9 00003E7E           3395      JMP         MOVE_END
00003E28                          3396  MOVE_DST_MODE_011: ; (An)+
00003E28  4EB8 2D72               3397      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003E2C  4EF9 00003E7E           3398      JMP         MOVE_END
00003E32                          3399  MOVE_DST_MODE_100: ; -(An)
00003E32  4EB8 2E26               3400      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003E36  4EF9 00003E7E           3401      JMP         MOVE_END    ; Continue with parsing destination operand
00003E3C                          3402  MOVE_DST_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003E3C  4EB8 2B04               3403      JSR         EA_INVALID          ; Opcode word is Invalid
00003E40  4EF9 00003E7E           3404      JMP         MOVE_END
00003E46                          3405  MOVE_DST_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E46  4EB8 2B04               3406      JSR         EA_INVALID          ; Opcode word is Invalid
00003E4A  4EF9 00003E7E           3407      JMP         MOVE_END
00003E50                          3408  MOVE_DST_MODE_111: ; The rest (not all valid, validated by register number)
00003E50  BE3C 0000               3409      CMP.B       #$00, D7            ; Test for absolute word address
00003E54  6700 0014               3410      BEQ         MOVE_DST_ABS_W
00003E58  BE3C 0001               3411      CMP.B       #$01, D7            ; Test for absolute long address
00003E5C  6700 0016               3412      BEQ         MOVE_DST_ABS_L
00003E60  4EB8 2B04               3413      JSR         EA_INVALID          ; Else: invalid
00003E64  4EF9 00003E7E           3414      JMP         MOVE_END
00003E6A                          3415  MOVE_DST_ABS_W:
00003E6A  4EB8 2EEA               3416      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003E6E  4EF9 00003E7E           3417      JMP         MOVE_END
00003E74                          3418  MOVE_DST_ABS_L:
00003E74  4EB8 2EDA               3419      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003E78  4EF9 00003E7E           3420      JMP         MOVE_END
00003E7E                          3421  MOVE_END:
00003E7E  4EB8 2B1A               3422      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003E82  4CDF 3FFF               3423      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003E86  4E75                    3424      RTS
00003E88                          3425  EA_MOVEA:
00003E88  48E7 FFFC               3426      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003E8C  4EB8 2B26               3427      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003E90  2A16                    3428      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
00003E92  143C 0002               3429      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
00003E96  E56D                    3430      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
00003E98  143C 000E               3431      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
00003E9C  E46D                    3432      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
00003E9E  BA3C 0003               3433      CMP.B       #$03, D5            ; if size bits are 11, correct D5
00003EA2                          3434                                      ; to 10 for use with immediate data subroutine
00003EA2  6700 0010               3435      BEQ         MOVEA_ADJUST_W
00003EA6  BA3C 0002               3436      CMP.B       #$02, D5            ; if size bits are 10, correct D5
00003EAA                          3437                                      ; to 11 for use with immediate data subroutine
00003EAA  6700 0012               3438      BEQ         MOVEA_ADJUST_L
00003EAE  4EF9 00003EC8           3439      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003EB4                          3440  MOVEA_ADJUST_W:
00003EB4  1A3C 0002               3441      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
00003EB8  4EF9 00003EC8           3442      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003EBE                          3443  MOVEA_ADJUST_L:
00003EBE  1A3C 0003               3444      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
00003EC2  4EF9 00003EC8           3445      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003EC8                          3446  MOVEA_SOURCE:
00003EC8  4EB8 2B2A               3447      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003ECC  41F9 00003EDA           3448      LEA         MOVEA_SRC_MODE, A0   ; Set index '0' for jump table
00003ED2  CCFC 0006               3449      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003ED6  4EF0 6000               3450      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003EDA                          3451  MOVEA_SRC_MODE:
00003EDA  4EF9 00003F0A           3452      JMP         MOVEA_SRC_MODE_000   ; Dn
00003EE0  4EF9 00003F14           3453      JMP         MOVEA_SRC_MODE_001   ; An
00003EE6  4EF9 00003F1E           3454      JMP         MOVEA_SRC_MODE_010   ; (An)
00003EEC  4EF9 00003F28           3455      JMP         MOVEA_SRC_MODE_011   ; (An)+
00003EF2  4EF9 00003F32           3456      JMP         MOVEA_SRC_MODE_100   ; -(An)
00003EF8  4EF9 00003F3C           3457      JMP         MOVEA_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003EFE  4EF9 00003F46           3458      JMP         MOVEA_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003F04  4EF9 00003F50           3459      JMP         MOVEA_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003F0A                          3460  MOVEA_SRC_MODE_000: ; Dn
00003F0A  4EB8 2B88               3461      JSR         EA_PRINT_DN         ; Print data register in D7
00003F0E  4EF9 00003F90           3462      JMP         MOVEA_DESTINATION
00003F14                          3463  MOVEA_SRC_MODE_001: ; Invalid: An
00003F14  4EB8 2C18               3464      JSR         EA_PRINT_AN         ; Print address register in D7
00003F18  4EF9 00003F90           3465      JMP         MOVEA_DESTINATION
00003F1E                          3466  MOVEA_SRC_MODE_010: ; (An)
00003F1E  4EB8 2CA8               3467      JSR         EA_PRINT_IND         ; Print address register indirect
00003F22  4EF9 00003F90           3468      JMP         MOVEA_DESTINATION
00003F28                          3469  MOVEA_SRC_MODE_011: ; (An)+
00003F28  4EB8 2D72               3470      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003F2C  4EF9 00003F90           3471      JMP         MOVEA_DESTINATION
00003F32                          3472  MOVEA_SRC_MODE_100: ; -(An)
00003F32  4EB8 2E26               3473      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003F36  4EF9 00003F90           3474      JMP         MOVEA_DESTINATION    ; Continue with parsing destination operand
00003F3C                          3475  MOVEA_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003F3C  4EB8 2B04               3476      JSR         EA_INVALID          ; Opcode word is Invalid
00003F40  4EF9 00003FA4           3477      JMP         MOVEA_END
00003F46                          3478  MOVEA_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003F46  4EB8 2B04               3479      JSR         EA_INVALID          ; Opcode word is Invalid
00003F4A  4EF9 00003FA4           3480      JMP         MOVEA_END
00003F50                          3481  MOVEA_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003F50  BE3C 0000               3482      CMP.B       #$00, D7            ; Test for absolute word address
00003F54  6700 001C               3483      BEQ         MOVEA_SRC_ABS_W
00003F58  BE3C 0001               3484      CMP.B       #$01, D7            ; Test for absolute long address
00003F5C  6700 001E               3485      BEQ         MOVEA_SRC_ABS_L
00003F60  BE3C 0004               3486      CMP.B       #$04, D7            ; Test for immediate data
00003F64  6700 0020               3487      BEQ         MOVEA_SRC_IMM
00003F68  4EB8 2B04               3488      JSR         EA_INVALID          ; Else: invalid
00003F6C  4EF9 00003FA4           3489      JMP         MOVEA_END
00003F72                          3490  MOVEA_SRC_ABS_W:
00003F72  4EB8 2EEA               3491      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003F76  4EF9 00003F90           3492      JMP         MOVEA_DESTINATION
00003F7C                          3493  MOVEA_SRC_ABS_L:
00003F7C  4EB8 2EDA               3494      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003F80  4EF9 00003F90           3495      JMP         MOVEA_DESTINATION
00003F86                          3496  MOVEA_SRC_IMM:
00003F86  4EB8 2D50               3497      JSR         EA_PRINT_IMM        ; Print immediate data
00003F8A  4EF9 00003F90           3498      JMP         MOVEA_DESTINATION
00003F90                          3499  MOVEA_DESTINATION:
00003F90  49F9 00004737           3500      LEA         COMMA, A4        ; Print comma
00003F96  4EB9 00004642           3501      JSR         WRITE2MEM
00003F9C  4EB8 2B50               3502      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003FA0  4EB8 2C18               3503      JSR         EA_PRINT_AN         ; Print address register, continue to end
00003FA4                          3504  MOVEA_END:
00003FA4  4EB8 2B1A               3505      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003FA8  4CDF 3FFF               3506      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003FAC  4E75                    3507      RTS
00003FAE                          3508  EA_MOVEM:
00003FAE                          3509      *seems complicated, todo
00003FAE  4EB8 2AF6               3510      JSR         EA_UNIMPLEMENTED
00003FB2  4E75                    3511      RTS
00003FB4                          3512  EA_MOVEQ:
00003FB4  48E7 FFFC               3513      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003FB8  4EB8 2B26               3514      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003FBC  2216                    3515      MOVE.L      (A6), D1            ; Load opcode to data register 1
00003FBE  143C 0008               3516      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003FC2  E569                    3517      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00003FC4  143C 0008               3518      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine data bits
00003FC8  E469                    3519      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00003FCA  2616                    3520      MOVE.L      (A6), D3            ; Save mode bits to D6
00003FCC  143C 0008               3521      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003FD0  E56B                    3522      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
00003FD2  143C 000F               3523      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
00003FD6  E46B                    3524      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003FD8  B63C 0000               3525      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003FDC  6700 0008               3526      BEQ         MOVEQ_PRINT_DATA
00003FE0  0681 FFFFFF00           3527      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
00003FE6                          3528  MOVEQ_PRINT_DATA:
00003FE6  49F9 00004731           3529      LEA         POUND, A4         ; Print '#'
00003FEC  4EB9 00004642           3530      JSR         WRITE2MEM
00003FF2  4EB8 2B0E               3531      JSR         EA_PRINT_DATA *print data todo
00003FF6  49F9 00004737           3532      LEA         COMMA, A4        ; Print comma
00003FFC  4EB9 00004642           3533      JSR         WRITE2MEM
00004002  4EB8 2B50               3534      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00004006  4EB8 2B88               3535      JSR         EA_PRINT_DN         ; Print data register
0000400A  4EB8 2B1A               3536      JSR         EA_UPDATE_POINTER   ; Updates global pointer
0000400E  4CDF 3FFF               3537      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00004012  4E75                    3538      RTS
00004014                          3539  EA_MULS_W:
00004014  48E7 FFFC               3540      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00004018  4EB8 2B26               3541      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000401C  4EB8 2B2A               3542      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00004020  41F9 0000402E           3543      LEA         MULS_W_MODE, A0     ; Set index '0' for jump table
00004026  CCFC 0006               3544      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000402A  4EF0 6000               3545      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000402E                          3546  MULS_W_MODE:
0000402E  4EF9 0000405E           3547      JMP         MULS_W_MODE_000     ; Dn
00004034  4EF9 00004068           3548      JMP         MULS_W_MODE_001     ; Invalid: An
0000403A  4EF9 00004072           3549      JMP         MULS_W_MODE_010     ; (An)
00004040  4EF9 0000407C           3550      JMP         MULS_W_MODE_011     ; (An)+
00004046  4EF9 00004086           3551      JMP         MULS_W_MODE_100     ; -(An)
0000404C  4EF9 00004090           3552      JMP         MULS_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00004052  4EF9 0000409A           3553      JMP         MULS_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004058  4EF9 000040A4           3554      JMP         MULS_W_MODE_111     ; The rest (not all valid, validated by register number)
0000405E                          3555  MULS_W_MODE_000: ; Dn
0000405E  4EB8 2B88               3556      JSR         EA_PRINT_DN         ; Print data register direct operand
00004062  4EF9 000040E8           3557      JMP         MULS_W_DEST         ; Go to: print destination operand
00004068                          3558  MULS_W_MODE_001: ; Invalid: An
00004068  4EB8 2B04               3559      JSR         EA_INVALID          ; Address register direct is invalid mode
0000406C  4EF9 000040FA           3560      JMP         MULS_W_END
00004072                          3561  MULS_W_MODE_010: ; (An)
00004072  4EB8 2CA8               3562      JSR         EA_PRINT_IND         ; Print address register indirect
00004076  4EF9 000040E8           3563      JMP         MULS_W_DEST
0000407C                          3564  MULS_W_MODE_011: ; (An)+
0000407C  4EB8 2D72               3565      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00004080  4EF9 000040E8           3566      JMP         MULS_W_DEST
00004086                          3567  MULS_W_MODE_100: ; -(An)
00004086  4EB8 2E26               3568      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000408A  4EF9 000040E8           3569      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00004090                          3570  MULS_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00004090  4EB8 2B04               3571      JSR         EA_INVALID          ; Opcode word is Invalid
00004094  4EF9 000040FA           3572      JMP         MULS_W_END
0000409A                          3573  MULS_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000409A  4EB8 2B04               3574      JSR         EA_INVALID          ; Opcode word is Invalid
0000409E  4EF9 000040FA           3575      JMP         MULS_W_END
000040A4                          3576  MULS_W_MODE_111: ; The rest (not all valid, validated by register number)
000040A4  BE3C 0000               3577      CMP.B       #$00, D7            ; Test for absolute word address
000040A8  6700 001C               3578      BEQ         MULS_W_ABS_W
000040AC  BE3C 0001               3579      CMP.B       #$01, D7            ; Test for absolute long address
000040B0  6700 001E               3580      BEQ         MULS_W_ABS_L
000040B4  BE3C 0004               3581      CMP.B       #$04, D7            ; Test for immediate data
000040B8  6700 0020               3582      BEQ         MULS_W_IMM
000040BC  4EB8 2B04               3583      JSR         EA_INVALID          ; Else: invalid
000040C0  4EF9 000040FA           3584      JMP         MULS_W_END
000040C6                          3585  MULS_W_ABS_W:
000040C6  4EB8 2EEA               3586      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000040CA  4EF9 000040E8           3587      JMP         MULS_W_DEST         ; Continue with parsing destination operand
000040D0                          3588  MULS_W_ABS_L:
000040D0  4EB8 2EDA               3589      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000040D4  4EF9 000040E8           3590      JMP         MULS_W_DEST         ; Continue with parsing destination operand
000040DA                          3591  MULS_W_IMM:
000040DA  1A3C 0002               3592      MOVE.B      #2, D5              ; Size is word
000040DE  4EB8 2D50               3593      JSR         EA_PRINT_IMM        ; Print immediate data
000040E2  4EF9 000040E8           3594      JMP         MULS_W_DEST         ; Continue with parsing destination operand
000040E8                          3595  MULS_W_DEST:
000040E8                          3596      *print COMMA
000040E8                          3597      *Get destination register
000040E8  3E16                    3598      MOVE.W      (A6), D7            ; Load word at current pointer to D1
000040EA  143C 0004               3599      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
000040EE  E56F                    3600      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000040F0  143C 000D               3601      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
000040F4  E46F                    3602      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000040F6  4EB8 2B88               3603      JSR         EA_PRINT_DN         ; Print data register direct operand
000040FA                          3604  MULS_W_END:
000040FA  4EB8 2B1A               3605      JSR         EA_UPDATE_POINTER   ; Update global pointer
000040FE  4CDF 3FFF               3606      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00004102  4E75                    3607      RTS
00004104                          3608  
00004104                          3609  EA_OR:
00004104  48E7 FFFC               3610      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00004108  4EB8 2B26               3611      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000410C  4EB8 2B50               3612      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00004110  41F9 0000411E           3613      LEA         OR_OPMODE, A0       ; Set index '0' for jump table
00004116  CCFC 0006               3614      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000411A  4EF0 6000               3615      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000411E                          3616  OR_OPMODE:
0000411E  4EF9 0000414E           3617      JMP         OR_OPMODE_000       ; mode 1, byte
00004124  4EF9 00004158           3618      JMP         OR_OPMODE_001       ; mode 1, word
0000412A  4EF9 00004162           3619      JMP         OR_OPMODE_010       ; mode 1, long
00004130  4EF9 0000416C           3620      JMP         OR_OPMODE_011       ; Invalid value
00004136  4EF9 00004176           3621      JMP         OR_OPMODE_100       ; mode 2, byte
0000413C  4EF9 00004180           3622      JMP         OR_OPMODE_101       ; mode 2, word
00004142  4EF9 0000418A           3623      JMP         OR_OPMODE_110       ; mode 2, long
00004148  4EF9 00004194           3624      JMP         OR_OPMODE_111       ; Invalid value
0000414E                          3625  OR_OPMODE_000: ; mode 1, byte
0000414E  1A3C 0001               3626      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004152  4EF9 0000419E           3627      JMP         OR_MODE_1
00004158                          3628  OR_OPMODE_001: ; mode 1, word
00004158  1A3C 0002               3629      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
0000415C  4EF9 0000419E           3630      JMP         OR_MODE_1
00004162                          3631  OR_OPMODE_010: ; mode 1, long
00004162  1A3C 0003               3632      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00004166  4EF9 0000419E           3633      JMP         OR_MODE_1
0000416C                          3634  OR_OPMODE_011: ; Invalid value
0000416C  4EB8 2B04               3635      JSR         EA_INVALID
00004170  4EF9 000042BE           3636      JMP         OR_END
00004176                          3637  OR_OPMODE_100: ; mode 2, byte
00004176  1A3C 0001               3638      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000417A  4EF9 000041C8           3639      JMP         OR_MODE_2
00004180                          3640  OR_OPMODE_101: ; mode 2, word
00004180  1A3C 0001               3641      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004184  4EF9 000041C8           3642      JMP         OR_MODE_2
0000418A                          3643  OR_OPMODE_110: ; mode 2, long
0000418A  1A3C 0001               3644      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000418E  4EF9 000041C8           3645      JMP         OR_MODE_2
00004194                          3646  OR_OPMODE_111: ; Invalid value
00004194  4EB8 2B04               3647      JSR         EA_INVALID
00004198  4EF9 000042BE           3648      JMP         OR_END
0000419E                          3649  OR_MODE_1:
0000419E  4280                    3650      CLR.L       D0                  ; Clear data register 0
000041A0  103C 0001               3651      MOVE.B      #1, D0              ; Save mode number to D0
000041A4  3207                    3652      MOVE.W      D7, D1              ; Save register value for printing dest. operand
000041A6  4EB8 2B2A               3653      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
000041AA  4EB9 000041EE           3654      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
000041B0  49F9 00004737           3655      LEA         COMMA, A4        ; Print comma
000041B6  4EB9 00004642           3656      JSR         WRITE2MEM
000041BC  3E01                    3657      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
000041BE  4EB8 2B88               3658      JSR         EA_PRINT_DN         ; Print data register
000041C2  4EF9 000042BE           3659      JMP         OR_END
000041C8                          3660  OR_MODE_2:
000041C8  4280                    3661      CLR.L       D0                  ; Clear data register 0
000041CA  103C 0002               3662      MOVE.B      #2, D0              ; Save mode number to D0
000041CE  4EB8 2B88               3663      JSR         EA_PRINT_DN         ; Print data register
000041D2  49F9 00004737           3664      LEA         COMMA, A4        ; Print comma
000041D8  4EB9 00004642           3665      JSR         WRITE2MEM
000041DE  4EB8 2B2A               3666      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
000041E2  4EB9 000041EE           3667      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
000041E8  4EF9 000042BE           3668      JMP         OR_END
000041EE                          3669  OR_EVAL_EA:
000041EE  41F9 000041FC           3670      LEA         OR_MODE, A0         ; Set index '0' for jump table
000041F4  CCFC 0006               3671      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000041F8  4EF0 6000               3672      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000041FC                          3673  OR_MODE:
000041FC  4EF9 0000422C           3674      JMP         OR_MODE_000         ; Invalid: Dn
00004202  4EF9 00004236           3675      JMP         OR_MODE_001         ; An (invalid if opmode 2)
00004208  4EF9 00004248           3676      JMP         OR_MODE_010         ; (An)
0000420E  4EF9 00004252           3677      JMP         OR_MODE_011         ; (An)+
00004214  4EF9 0000425C           3678      JMP         OR_MODE_100         ; -(An)
0000421A  4EF9 00004266           3679      JMP         OR_MODE_101         ; Invalid: Address Register Indirect with Displacement Mode
00004220  4EF9 0000426C           3680      JMP         OR_MODE_110         ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004226  4EF9 00004272           3681      JMP         OR_MODE_111         ; The rest (not all valid, validated by register number)
0000422C                          3682  OR_MODE_000: ; Invalid: Dn
0000422C  4EB8 2B04               3683      JSR         EA_INVALID          ; Invalid for both opmodes
00004230  4EF9 000042B6           3684      JMP         OR_MODE_END         ; End evaluation of ea mode
00004236                          3685  OR_MODE_001: ; An (invalid if opmode 2)
00004236  B07C 0002               3686      CMP         #2, D0
0000423A  6700 007C               3687      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
0000423E  4EB8 2C18               3688      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00004242  4EF9 000042B6           3689      JMP         OR_MODE_END         ; End evaluation of ea mode
00004248                          3690  OR_MODE_010: ; (An)
00004248  4EB8 2CA8               3691      JSR         EA_PRINT_IND         ; Print address register indirect
0000424C  4EF9 000042B6           3692      JMP         OR_MODE_END         ; End evaluation of ea mode
00004252                          3693  OR_MODE_011: ; (An)+
00004252  4EB8 2D72               3694      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00004256  4EF9 000042B6           3695      JMP         OR_MODE_END         ; End evaluation of ea mode
0000425C                          3696  OR_MODE_100: ; -(An)
0000425C  4EB8 2E26               3697      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00004260  4EF9 000042B6           3698      JMP         OR_MODE_END         ; End evaluation of ea mode
00004266                          3699  OR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00004266  4EF9 000042B8           3700      JMP         OR_MODE_INVALID
0000426C                          3701  OR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000426C  4EF9 000042B8           3702      JMP         OR_MODE_INVALID
00004272                          3703  OR_MODE_111: ; The rest (not all valid, validated by register number)
00004272  BE3C 0000               3704      CMP.B       #$00, D7            ; Test for absolute word address
00004276  6700 0018               3705      BEQ         OR_ABS_W
0000427A  BE3C 0001               3706      CMP.B       #$01, D7            ; Test for absolute long address
0000427E  6700 001A               3707      BEQ         OR_ABS_L
00004282  BE3C 0004               3708      CMP.B       #$04, D7            ; Test for immediate data
00004286  6700 001C               3709      BEQ         OR_IMM
0000428A  4EF9 000042B8           3710      JMP         OR_MODE_INVALID     ; else, invalid
00004290                          3711  OR_ABS_W:
00004290  4EB8 2EEA               3712      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00004294  4EF9 000042B6           3713      JMP         OR_MODE_END
0000429A                          3714  OR_ABS_L:
0000429A  4EB8 2EDA               3715      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000429E  4EF9 000042B6           3716      JMP         OR_MODE_END
000042A4                          3717  OR_IMM: ; invalid if opmode is 2
000042A4  B07C 0002               3718      CMP         #2, D0
000042A8  6700 000E               3719      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
000042AC  4EB8 2D50               3720      JSR         EA_PRINT_IMM        ; Print immediate data
000042B0  4EF9 000042B6           3721      JMP         OR_MODE_END
000042B6                          3722  OR_MODE_END:
000042B6  4E75                    3723      RTS                             ; Finish evaluating EA bits
000042B8                          3724  OR_MODE_INVALID:
000042B8  4EB8 2B04               3725      JSR         EA_INVALID          ; Opcode word is Invalid
000042BC  4E75                    3726      RTS
000042BE                          3727  OR_END:
000042BE  4EB8 2B1A               3728      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000042C2  4CDF 3FFF               3729      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000042C6  4E75                    3730      RTS
000042C8                          3731  EA_ROd:
000042C8  48E7 FFFC               3732      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000042CC  4EB8 2B26               3733      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000042D0  4EB8 2B76               3734      JSR         EA_SIZE_BITS        ; get size bits in D7
000042D4  BE3C 0003               3735      CMP.B       #$03, D7            ; test if memory shift
000042D8  6700 005E               3736      BEQ         ROd_MEM
000042DC  6000 0002               3737      BRA         ROd_REG             ; else, register shfit
000042E0                          3738  ROd_REG:
000042E0  3E16                    3739      MOVE.W      (A6), D7            ; read opcode word in memory and save,
000042E2                          3740                                      ; (using D7 because EA_PRINT_DN uses D7)
000042E2  143C 0004               3741      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
000042E6  E56F                    3742      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000042E8  143C 000D               3743      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
000042EC  E46F                    3744      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000042EE  3016                    3745      MOVE.W      (A6), D0            ; read opcode word in memory and save
000042F0  143C 000A               3746      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
000042F4  E568                    3747      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
000042F6  143C 000F               3748      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
000042FA  E468                    3749      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
000042FC  B03C 0000               3750      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
00004300  6700 000C               3751      BEQ         ROd_REG_COUNT
00004304                          3752  ROd_REG_REG:                        ; Else, count/register field contains register number
00004304  4EB8 2B88               3753      JSR         EA_PRINT_DN         ; Print register value, stored in D7
00004308  4EF9 0000431E           3754      JMP         ROd_REG_END         ; Jump to end of ROd_REG
0000430E                          3755  ROd_REG_COUNT:
0000430E  49F9 00004731           3756      LEA         POUND, A4         ; Print '#'''
00004314  4EB9 00004642           3757      JSR         WRITE2MEM
0000431A  4EB8 2B0E               3758      JSR         EA_PRINT_DATA       *print hex value in D7 as byte todo, continue on to ROd_REG_END
0000431E                          3759  ROd_REG_END:
0000431E  49F9 00004737           3760      LEA         COMMA, A4        ; Print comma
00004324  4EB9 00004642           3761      JSR         WRITE2MEM
0000432A  4EB8 2B2A               3762      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
0000432E  4EB8 2B88               3763      JSR         EA_PRINT_DN         ; Print register value in D7
00004332  4EF9 000043EE           3764      JMP         ROd_END
00004338                          3765  ROd_MEM:
00004338  4EB8 2B2A               3766      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
0000433C  41F9 0000434A           3767      LEA         ROd_MEM_MODE, A0    ; Set index '0' for jump table
00004342  CCFC 0006               3768      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00004346  4EF0 6000               3769      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000434A                          3770  ROd_MEM_MODE:
0000434A  4EF9 0000437A           3771      JMP         ROd_MEM_MODE_000     ; Invalid: Dn
00004350  4EF9 00004384           3772      JMP         ROd_MEM_MODE_001     ; Invalid: An
00004356  4EF9 0000438E           3773      JMP         ROd_MEM_MODE_010     ; (An)
0000435C  4EF9 00004398           3774      JMP         ROd_MEM_MODE_011     ; (An)+
00004362  4EF9 000043A2           3775      JMP         ROd_MEM_MODE_100     ; -(An)
00004368  4EF9 000043AC           3776      JMP         ROd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
0000436E  4EF9 000043B6           3777      JMP         ROd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004374  4EF9 000043C0           3778      JMP         ROd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
0000437A                          3779  ROd_MEM_MODE_000: ; Invalid: Dn
0000437A  4EB8 2B04               3780      JSR         EA_INVALID          ; Data register direct is invalid mode
0000437E  4EF9 000043EE           3781      JMP         ROd_END
00004384                          3782  ROd_MEM_MODE_001: ; Invalid: An
00004384  4EB8 2B04               3783      JSR         EA_INVALID          ; Address register direct is invalid mode
00004388  4EF9 000043EE           3784      JMP         ROd_END
0000438E                          3785  ROd_MEM_MODE_010: ; (An)
0000438E  4EB8 2CA8               3786      JSR         EA_PRINT_IND         ; Print address register indirect
00004392  4EF9 000043EE           3787      JMP         ROd_END
00004398                          3788  ROd_MEM_MODE_011: ; (An)+
00004398  4EB8 2D72               3789      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000439C  4EF9 000043EE           3790      JMP         ROd_END
000043A2                          3791  ROd_MEM_MODE_100: ; -(An)
000043A2  4EB8 2E26               3792      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000043A6  4EF9 000043EE           3793      JMP         ROd_END         ; Continue with parsing destination operand
000043AC                          3794  ROd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000043AC  4EB8 2B04               3795      JSR         EA_INVALID          ; Opcode word is Invalid
000043B0  4EF9 000043EE           3796      JMP         ROd_END
000043B6                          3797  ROd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000043B6  4EB8 2B04               3798      JSR         EA_INVALID          ; Opcode word is Invalid
000043BA  4EF9 000043EE           3799      JMP         ROd_END
000043C0                          3800  ROd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
000043C0  BE3C 0000               3801      CMP.B       #$00, D7            ; Test for absolute word address
000043C4  6700 0014               3802      BEQ         ROd_MEM_ABS_W
000043C8  BE3C 0001               3803      CMP.B       #$01, D7            ; Test for absolute long address
000043CC  6700 0016               3804      BEQ         ROd_MEM_ABS_L
000043D0  4EB8 2B04               3805      JSR         EA_INVALID          ; Else: invalid
000043D4  4EF9 000043EE           3806      JMP         ROd_END
000043DA                          3807  ROd_MEM_ABS_W:
000043DA  4EB8 2EEA               3808      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000043DE  4EF9 000043EE           3809      JMP         ROd_END
000043E4                          3810  ROd_MEM_ABS_L:
000043E4  4EB8 2EDA               3811      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000043E8  4EF9 000043EE           3812      JMP         ROd_END
000043EE                          3813  ROd_END:
000043EE  4EB8 2B1A               3814      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000043F2  4CDF 3FFF               3815      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000043F6  4E75                    3816      RTS
000043F8                          3817  EA_SUB:
000043F8  4EB8 2B50               3818      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
000043FC  41F9 0000440A           3819      LEA         SUB_OPMODE, A0      ; Set index '0' for jump table
00004402  CCFC 0006               3820      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00004406  4EF0 6000               3821      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000440A                          3822  SUB_OPMODE:
0000440A  4EF9 0000443A           3823      JMP         SUB_OPMODE_000      ; mode 1, byte
00004410  4EF9 00004444           3824      JMP         SUB_OPMODE_001      ; mode 1, word
00004416  4EF9 0000444E           3825      JMP         SUB_OPMODE_010      ; mode 1, long
0000441C  4EF9 00004458           3826      JMP         SUB_OPMODE_011      ; Invalid value
00004422  4EF9 00004462           3827      JMP         SUB_OPMODE_100      ; mode 2, byte
00004428  4EF9 0000446C           3828      JMP         SUB_OPMODE_101      ; mode 2, word
0000442E  4EF9 00004476           3829      JMP         SUB_OPMODE_110      ; mode 2, long
00004434  4EF9 00004480           3830      JMP         SUB_OPMODE_111      ; Invalid value
0000443A                          3831  SUB_OPMODE_000: ; mode 1, byte
0000443A  1A3C 0001               3832      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000443E  4EF9 0000448A           3833      JMP         SUB_MODE_1
00004444                          3834  SUB_OPMODE_001: ; mode 1, word
00004444  1A3C 0002               3835      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00004448  4EF9 0000448A           3836      JMP         SUB_MODE_1
0000444E                          3837  SUB_OPMODE_010: ; mode 1, long
0000444E  1A3C 0003               3838      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00004452  4EF9 0000448A           3839      JMP         SUB_MODE_1
00004458                          3840  SUB_OPMODE_011: ; Invalid value
00004458  4EB8 2B04               3841      JSR         EA_INVALID
0000445C  4EF9 000045B2           3842      JMP         SUB_END
00004462                          3843  SUB_OPMODE_100: ; mode 2, byte
00004462  1A3C 0001               3844      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004466  4EF9 000044B4           3845      JMP         SUB_MODE_2
0000446C                          3846  SUB_OPMODE_101: ; mode 2, word
0000446C  1A3C 0001               3847      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004470  4EF9 000044B4           3848      JMP         SUB_MODE_2
00004476                          3849  SUB_OPMODE_110: ; mode 2, long
00004476  1A3C 0001               3850      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000447A  4EF9 000044B4           3851      JMP         SUB_MODE_2
00004480                          3852  SUB_OPMODE_111: ; Invalid value
00004480  4EB8 2B04               3853      JSR         EA_INVALID
00004484  4EF9 000045B2           3854      JMP         SUB_END
0000448A                          3855  SUB_MODE_1:
0000448A  4280                    3856      CLR.L       D0                  ; Clear data register 0
0000448C  103C 0001               3857      MOVE.B      #1, D0              ; Save mode number to D0
00004490  3207                    3858      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00004492  4EB8 2B2A               3859      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00004496  4EB9 000044DA           3860      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
0000449C  49F9 00004737           3861      LEA         COMMA, A4        ; Print comma
000044A2  4EB9 00004642           3862      JSR         WRITE2MEM
000044A8  3E01                    3863      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
000044AA  4EB8 2B88               3864      JSR         EA_PRINT_DN         ; Print data register
000044AE  4EF9 000045B2           3865      JMP         SUB_END
000044B4                          3866  SUB_MODE_2:
000044B4  4280                    3867      CLR.L       D0                  ; Clear data register 0
000044B6  103C 0002               3868      MOVE.B      #2, D0              ; Save mode number to D0
000044BA  4EB8 2B88               3869      JSR         EA_PRINT_DN         ; Print data register
000044BE  49F9 00004737           3870      LEA         COMMA, A4        ; Print comma
000044C4  4EB9 00004642           3871      JSR         WRITE2MEM
000044CA  4EB8 2B2A               3872      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
000044CE  4EB9 000044DA           3873      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
000044D4  4EF9 000045B2           3874      JMP         SUB_END
000044DA                          3875  SUB_EVAL_EA:
000044DA  41F9 000044E8           3876      LEA         SUB_MODE, A0        ; Set index '0' for jump table
000044E0  CCFC 0006               3877      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000044E4  4EF0 6000               3878      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000044E8                          3879  SUB_MODE:
000044E8  4EF9 00004518           3880      JMP         SUB_MODE_000        ; Dn (invalid if opmode 2)
000044EE  4EF9 0000452A           3881      JMP         SUB_MODE_001        ; An (invalid if opmode 2)
000044F4  4EF9 0000453C           3882      JMP         SUB_MODE_010        ; (An)
000044FA  4EF9 00004546           3883      JMP         SUB_MODE_011        ; (An)+
00004500  4EF9 00004550           3884      JMP         SUB_MODE_100        ; -(An)
00004506  4EF9 0000455A           3885      JMP         SUB_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
0000450C  4EF9 00004560           3886      JMP         SUB_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004512  4EF9 00004566           3887      JMP         SUB_MODE_111        ; The rest (not all valid, validated by register number)
00004518                          3888  SUB_MODE_000: ; Dn (invalid if opmode 2)
00004518  B07C 0002               3889      CMP         #2, D0
0000451C  6700 008E               3890      BEQ         SUB_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00004520  4EB8 2B88               3891      JSR         EA_PRINT_DN         ; Print data register direct operand
00004524  4EF9 000045AA           3892      JMP         SUB_MODE_END        ; End evaluation of ea mode
0000452A                          3893  SUB_MODE_001: ; An (invalid if opmode 2)
0000452A  B07C 0002               3894      CMP         #2, D0
0000452E  6700 007C               3895      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00004532  4EB8 2C18               3896      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00004536  4EF9 000045AA           3897      JMP         SUB_MODE_END        ; End evaluation of ea mode
0000453C                          3898  SUB_MODE_010: ; (An)
0000453C  4EB8 2CA8               3899      JSR         EA_PRINT_IND         ; Print address register indirect
00004540  4EF9 000045AA           3900      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004546                          3901  SUB_MODE_011: ; (An)+
00004546  4EB8 2D72               3902      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000454A  4EF9 000045AA           3903      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004550                          3904  SUB_MODE_100: ; -(An)
00004550  4EB8 2E26               3905      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00004554  4EF9 000045AA           3906      JMP         SUB_MODE_END        ; End evaluation of ea mode
0000455A                          3907  SUB_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000455A  4EF9 000045AC           3908      JMP         SUB_MODE_INVALID
00004560                          3909  SUB_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004560  4EF9 000045AC           3910      JMP         SUB_MODE_INVALID
00004566                          3911  SUB_MODE_111: ; The rest (not all valid, validated by register number)
00004566  BE3C 0000               3912      CMP.B       #$00, D7            ; Test for absolute word address
0000456A  6700 0018               3913      BEQ         SUB_ABS_W
0000456E  BE3C 0001               3914      CMP.B       #$01, D7            ; Test for absolute long address
00004572  6700 001A               3915      BEQ         SUB_ABS_L
00004576  BE3C 0004               3916      CMP.B       #$04, D7            ; Test for immediate data
0000457A  6700 001C               3917      BEQ         SUB_IMM
0000457E  4EF9 000045AC           3918      JMP         SUB_MODE_INVALID    ; else, invalid
00004584                          3919  SUB_ABS_W:
00004584  4EB8 2EEA               3920      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00004588  4EF9 000045AA           3921      JMP         SUB_MODE_END
0000458E                          3922  SUB_ABS_L:
0000458E  4EB8 2EDA               3923      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00004592  4EF9 000045AA           3924      JMP         SUB_MODE_END
00004598                          3925  SUB_IMM: ; invalid if opmode is 2
00004598  B07C 0002               3926      CMP         #2, D0
0000459C  6700 000E               3927      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
000045A0  4EB8 2D50               3928      JSR         EA_PRINT_IMM        ; Print immediate data
000045A4  4EF9 000045AA           3929      JMP         SUB_MODE_END
000045AA                          3930  SUB_MODE_END:
000045AA  4E75                    3931      RTS                             ; Finish evaluating EA bits
000045AC                          3932  SUB_MODE_INVALID:
000045AC  4EB8 2B04               3933      JSR         EA_INVALID          ; Opcode word is Invalid
000045B0  4E75                    3934      RTS
000045B2                          3935  SUB_END:
000045B2  4EB8 2B1A               3936      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000045B6  4CDF 3FFF               3937      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000045BA  4E75                    3938      RTS
000045BC                          3939  
000045BC                          3940  
000045BC                          3941  
000045BC                          3942  -------------------- end include --------------------
000045BC                          3943      INCLUDE 'EndProgram.X68'
000045BC                          3944  
000045BC                          3945  
000045BC                          3946  
000045BC  =00000059               3947  UPYES     EQU   'Y'
000045BC  =00000079               3948  LOWYES    EQU   'y'
000045BC                          3949  
000045BC                          3950  
000045BC                          3951  
000045BC                          3952  KEEP_RUNNING
000045BC  6100 0004               3953      BSR.W       RERUN               * Run welcome subroutine
000045C0  4E75                    3954      RTS                             * Return to Disassembler
000045C2                          3955      
000045C2                          3956  
000045C2                          3957  
000045C2                          3958             
000045C2                          3959  
000045C2                          3960  RERUN 
000045C2  43F9 000045F6           3961      LEA         ENDQUESTION,A1      * Loads message into A1
000045C8  103C 000E               3962      MOVE.B      #14,D0              * Moves the Task 14 into D0
000045CC  4E4F                    3963      TRAP        #15                 * Displays Intro Message
000045CE                          3964      
000045CE  103C 0005               3965      MOVE.B      #5,D0               * Move task 5 to read one char
000045D2  4E4F                    3966      TRAP        #15                 * Trap 15 for IO
000045D4                          3967      
000045D4  0C01 0059               3968      CMPI.B      #UPYES,D1           * Is char = Y
000045D8  6700 0012               3969      BEQ         NOTDONE             * If yes, notdone
000045DC  0C01 0079               3970      CMPI.B      #LOWYES,D1          * Is char = y   
000045E0  6700 000A               3971      BEQ         NOTDONE             * If yes, notdone
000045E4  11FC 0000 6000          3972      MOVE.B      #0,(RUNAGAIN)       * 0 for false to end program
000045EA  4E75                    3973      RTS 
000045EC                          3974      
000045EC                          3975  NOTDONE
000045EC  11FC 0001 6000          3976      MOVE.B      #1,(RUNAGAIN)       * 1 for true to rerun program
000045F2  6000 CCDC               3977      BRA.W       CLEARSCRN           * Clear screen and return from subroutine         
000045F6                          3978          
000045F6                          3979  
000045F6                          3980  
000045F6                          3981  
000045F6= 57 4F 55 4C 44 20 ...   3982  ENDQUESTION     DC.B 'WOULD YOU LIKE TO RUN THE PROGRAM AGAIN (Y/N)? ',0
00004626                          3983  
00004626                          3984  
00004626                          3985  
00004626                          3986  -------------------- end include --------------------
00004626                          3987      INCLUDE 'WriteBuffer.X68'
00004626                          3988  
00004626  =0000000D               3989  CR      EQU     $0D                 * Carriage return
00004626  =0000000A               3990  LF      EQU     $0A                 * Line feed
00004626                          3991  
00004626  =00002000               3992  BUFFER  EQU     $2000               * Buffer address for string
00004626  =0000001E               3993  RCOUNT  EQU     30                  * Counters
00004626                          3994  
00004626                          3995  WRITE_LINE
00004626  163C 001E               3996      MOVE.B      #RCOUNT,D3          * Move row counter to D3
0000462A  45F8 2000               3997      LEA         BUFFER,A2           * Load BUFFER address to A2 for use
0000462E                          3998  
0000462E  6112                    3999      BSR.S       WRITE2MEM
00004630  4E75                    4000      RTS
00004632                          4001  
00004632                          4002  
00004632                          4003  
00004632                          4004      *BSR.S       PRINTLN             * Subroutine to print buffer
00004632                          4005  
00004632                          4006      *LEA         BUFFER,A2           * Reset A2 for buffer cleaning
00004632                          4007      *BSR.S       CLEAN_BUFF          * Subroutine to reset buffer to all F's
00004632                          4008  
00004632  5303                    4009      SUBI.B      #1,D3               * Decrement RCOUNT by 1
00004634  0C03 0000               4010      CMPI.B      #0,D3               * Is RCOUNT = 0
00004638  6700 004C               4011      BEQ         NEW_PAGE            * If yes, prompt user and make new page
0000463C  61E8                    4012      BSR.S       WRITE_LINE          * If no, keep writing lines
0000463E                          4013  
0000463E  6000 005E               4014      BRA         PAUSE               * Pause program (SIMHALT)
00004642                          4015  
00004642                          4016  WRITE2MEM
00004642  0C14 0000               4017      CMP.B       #$00,(A4)           * Check if byte is string terminator
00004646  6700 0006               4018      BEQ         SKIP_WRITE          * If yes, skip write and return
0000464A  14DC                    4019      MOVE.B      (A4)+,(A2)+         * If no, write byte to memory
0000464C  60F4                    4020      BRA         WRITE2MEM           * Keep writing, not end of string
0000464E                          4021  SKIP_WRITE
0000464E  287C 00000000           4022      MOVEA.L     #$00000000,A4       * Clean up A4
00004654  4E75                    4023      RTS                             * Return to main
00004656                          4024  
00004656                          4025  WRITE_ENDL
00004656  14FC 000D               4026      MOVE.B      #CR,(A2)+           * Move carriage return into memory
0000465A  14FC 000A               4027      MOVE.B      #LF,(A2)+           * Move line feed into memory
0000465E  14FC 0000               4028      MOVE.B      #$00,(A2)+          * Move string terminator into memory
00004662  4E75                    4029      RTS
00004664                          4030  
00004664                          4031  PRINTLN
00004664  45F8 2000               4032      LEA         BUFFER,A2           * Reset A2 to BUFFER address beginning
00004668  43D2                    4033      LEA         (A2),A1             * Load BUFFER address into A1
0000466A  103C 000E               4034      MOVE.B      #14,D0              * Task 14, no CR or LF
0000466E  4E4F                    4035      TRAP        #15                 * Display string held in BUFFER
00004670  4E75                    4036      RTS                             * Return to main
00004672                          4037  
00004672                          4038  CLEAN_BUFF
00004672  0C92 FFFFFFFF           4039      CMPI.L      #$FFFFFFFF,(A2)     *
00004678  6700 000A               4040      BEQ         BUFFDONE            * Buffer has been cleaned
0000467C  24FC FFFFFFFF           4041      MOVE.L      #$FFFFFFFF,(A2)+    * Fill with F's
00004682  60EE                    4042      BRA         CLEAN_BUFF          * Continue cleaning buffer
00004684                          4043  BUFFDONE
00004684  4E75                    4044      RTS                             * Return to main
00004686                          4045  
00004686                          4046  NEW_PAGE
00004686  4283                    4047      CLR.L       D3                  * Clear counter
00004688  43F9 000046A6           4048      LEA         ENTER,A1            * Load enter message into A1
0000468E  103C 000E               4049      MOVE.B      #14,D0              * Moves the Task 14 into D0
00004692  4E4F                    4050      TRAP        #15                 * Displays contents of A1
00004694  103C 0005               4051      MOVE.B      #5,D0               * Read single character from
00004698  4E4F                    4052      TRAP        #15                 * The keyboard into D1.B
0000469A  6000 CC34               4053      BRA.W       CLEARSCRN           * Clear the screen.
0000469E                          4054  
0000469E                          4055  PAUSE
0000469E  FFFF FFFF               4056          SIMHALT                     * Halt simulator
000046A2  6000 00A3               4057          BRA     QUIT                * End program
000046A6                          4058  
000046A6                          4059  
000046A6= 2D 2D 2D 2D 2D 2D ...   4060  ENTER           DC.B '------------------------- Press Enter ------------------------',0
000046E5                          4061  
000046E5                          4062  
000046E5= 4D 4F 56 45 00          4063  MV              DC.B 'MOVE',0
000046EA= 41 44 44 20 00          4064  AD              DC.B 'ADD ',0
000046EF                          4065  
000046EF= 2E 42 20 20 00          4066  BYTE            DC.B '.B  ',0
000046F4= 2E 57 20 20 00          4067  WORD            DC.B '.W  ',0
000046F9= 2E 4C 20 20 00          4068  LONG            DC.B '.L  ',0
000046FE= 0D 0A 00                4069  ENDL            DC.B CR,LF,0
00004701                          4070  
00004701= 44 30 00                4071  DREG0           DC.B 'D0',0
00004704= 44 31 00                4072  DREG1           DC.B 'D1',0
00004707= 44 32 00                4073  DREG2           DC.B 'D2',0
0000470A= 44 33 00                4074  DREG3           DC.B 'D3',0
0000470D= 44 34 00                4075  DREG4           DC.B 'D4',0
00004710= 44 35 00                4076  DREG5           DC.B 'D5',0
00004713= 44 36 00                4077  DREG6           DC.B 'D6',0
00004716= 44 37 00                4078  DREG7           DC.B 'D7',0
00004719= 41 30 00                4079  AREG0           DC.B 'A0',0
0000471C= 41 31 00                4080  AREG1           DC.B 'A1',0
0000471F= 41 32 00                4081  AREG2           DC.B 'A2',0
00004722= 41 33 00                4082  AREG3           DC.B 'A3',0
00004725= 41 34 00                4083  AREG4           DC.B 'A4',0
00004728= 41 35 00                4084  AREG5           DC.B 'A5',0
0000472B= 41 36 00                4085  AREG6           DC.B 'A6',0
0000472E= 41 37 00                4086  AREG7           DC.B 'A7',0
00004731                          4087  
00004731= 23 00                   4088  POUND           DC.B '#',0
00004733= 24 00                   4089  DOLLAR          DC.B '$',0
00004735= 25 00                   4090  PERCENT         DC.B '%',0
00004737= 2C 20 00                4091  COMMA           DC.B ', ',0
0000473A= 28 00                   4092  OPAREN          DC.B '(',0
0000473C= 29 00                   4093  CPAREN          DC.B ')',0
0000473E= 2B 00                   4094  PLUS            DC.B '+',0
00004740= 2D 00                   4095  MINUS           DC.B '-',0
00004742                          4096  
00004742= 20 20 20 20 00          4097  TAB             DC.B '    ',0
00004747                          4098  
00004747                          4099  QUIT
00004747                          4100          *END     START        ; last line of source
00004747                          4101  
00004747                          4102  
00004747                          4103  -------------------- end include --------------------
00004747                          4104  
00004747                          4105  *********** END INCLUDES *****************************************************
00004747                          4106  
00004747                          4107  
00004747                          4108  ******************************************************************************
00004747                          4109  *           BEGIN CODE                                                       *
00004747                          4110  ******************************************************************************
00004747                          4111  
00004747                          4112  *---------- START ------------------------------------------------------------
00004747                          4113  * Begins program's logical flow. Similar to main in C/C++
00004747                          4114  *-----------------------------------------------------------------------------
00004747                          4115  START
00004748  4FF8 7000               4116      LEA         STACK,SP            * SP is stored in A7
0000474C  4EB8 1000               4117      JSR         GET_ADDRESSES       * Runs GET_ADDRESSES and IO_WELCOME
00004750  2C78 5000               4118      MOVEA.L     BEGINADDR,A6        * Assign beginning address to A6 for use
00004754                          4119  
00004754                          4120  LOOP
00004754                          4121      * OC_PARSE Command doesn't work due to issues in the Opcode include
00004754                          4122      * many errors need to be fixed. Same with EA include
00004754                          4123  
00004754  45F8 2000               4124      LEA         BUFFER, A2
00004758  4EB8 167D               4125      JSR         OC_PARSE            * Determine if there is an initial opcode match
0000475C  4EB8 4656               4126      JSR         WRITE_ENDL
00004760  4EB8 4664               4127      JSR         PRINTLN
00004764  45F8 2000               4128      LEA         BUFFER, A2
00004768  4EB8 4672               4129      JSR         CLEAN_BUFF
0000476C                          4130  
0000476C                          4131      * decrement row count
0000476C                          4132      * if at 0, prompt for next page
0000476C                          4133      * else, continue
0000476C                          4134  
0000476C                          4135      *JSR         INVALID_DATA
0000476C                          4136      *ADDA.L      #$00000002,A6            * Advance address to test LOOP (test only)
0000476C                          4137  
0000476C                          4138  LOOP_CHECK
0000476C                          4139      * Changed the following code from:
0000476C                          4140      * CMPA        A6, ENDADDR
0000476C                          4141      * to:
0000476C                          4142      * CMPA      (ENDADDR),A6
0000476C                          4143      * When using the CMPA, destination must be an address so A6
0000476C  BDF8 5010               4144      CMPA.L      ENDADDR,A6          * Is pointer at end of address range?
00004770                          4145  
00004770  6E00 0004               4146      BGT         END_LOOP            * If yes, END_LOOP
00004774                          4147      ; in case this resets status register, do another compare TODO
00004774                          4148  
00004774  66DE                    4149      BNE         LOOP                * If not, continue processing addresses
00004776                          4150      ; If at end of address range, check if user wants to continue
00004776                          4151      ; if user wants to continue, restart
00004776                          4152      ; else, end
00004776                          4153  
00004776                          4154  END_LOOP
00004776  4EB8 45BC               4155      JSR         KEEP_RUNNING        * Does the user want to run program again
0000477A  0C38 0001 6000          4156      CMPI.B      #1,(RUNAGAIN)       * Does RUNAGAIN = TRUE?
00004780  67C5                    4157      BEQ         START               * If yes, rerun program
00004782  4E72 3000               4158      STOP        #$3000              * Else, end program
00004786                          4159  
00004786                          4160  *---------- END - START ------------------------------------------------------
00004786                          4161  
00004786                          4162  *********** END BEGIN CODE ***************************************************
00004786                          4163  
00004786                          4164  
00004786                          4165  ******************************************************************************
00004786                          4166  *           VARIABLES AND CONSTANTS                                          *
00004786                          4167  ******************************************************************************
00004786                          4168  
00004786                          4169  
00004786                          4170  
00004786                          4171  *---------- Reserved Registers -----------------------------
00004786                          4172  *   A7: stack pointer
00004786                          4173  *   A6: current address (updated by subroutines)
00004786                          4174  *   D0: instruction validity flag (reset by main control
00004786                          4175  *       code, can be set to false by subroutines)
00004786                          4176  *-----------------------------------------------------------
00004786                          4177  
00004786                          4178  *---------- End --------------------------------------------
Line 4179 WARNING: Origin value is odd (Location counter set to next highest address)
00004786                          4179                 END  START          * Last line of source

No errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AD                  46EA
ADDA_ABS_L          3176
ADDA_ABS_W          316C
ADDA_END            31AC
ADDA_IMM            3180
ADDA_MODE           30E0
ADDA_MODE_000       3110
ADDA_MODE_001       311A
ADDA_MODE_010       3124
ADDA_MODE_011       312E
ADDA_MODE_100       3138
ADDA_MODE_101       3142
ADDA_MODE_110       3148
ADDA_MODE_111       314E
ADDA_MODE_END       3198
ADDA_MODE_INVALID   318E
ADDCODE000          1C5C
ADDCODE001          1C64
ADDCODE010          1C6C
ADDCODE011          1C74
ADDCODE100          1C7C
ADDCODE101          1C84
ADDCODE110          1C8C
ADDCODE111          1C94
ADDIBCODE00         20BA
ADDILCODE10         20CA
ADDILCODE11         20D2
ADDIWCODE01         20C2
ADDI_ABS_L          32BE
ADDI_ABS_W          32B4
ADDI_B              31E4
ADDI_BORADDI_WORADDI_L  2084
ADDI_END            32C8
ADDI_GET_DEST       3212
ADDI_L              320C
ADDI_MODE           3224
ADDI_MODE_000       3254
ADDI_MODE_001       325E
ADDI_MODE_010       3268
ADDI_MODE_011       3272
ADDI_MODE_100       327C
ADDI_MODE_101       3286
ADDI_MODE_110       3290
ADDI_MODE_111       329A
ADDI_W              31FE
ADDQCODE00          1DB6
ADDQCODE01          1DBE
ADDQCODE10          1DC6
ADDQCODE11          1DCE
ADDQ_ABS_L          33BC
ADDQ_ABS_W          33B2
ADDQ_BORADDQ_WORADDQ_L  1D80
ADDQ_END            33C6
ADDQ_MODE           3322
ADDQ_MODE_000       3352
ADDQ_MODE_001       335C
ADDQ_MODE_010       3366
ADDQ_MODE_011       3370
ADDQ_MODE_100       337A
ADDQ_MODE_101       3384
ADDQ_MODE_110       338E
ADDQ_MODE_111       3398
ADDQ_PRINT_IMM      32F4
ADDRESS_ERR         12DC
ADD_ABS_L           3098
ADD_ABS_W           308E
ADD_BORADD_WORADD_L  1C0E
ADD_END             30BC
ADD_EVAL_EA         2FE4
ADD_IMM             30A2
ADD_MODE            2FF2
ADD_MODE_000        3022
ADD_MODE_001        3034
ADD_MODE_010        3046
ADD_MODE_011        3050
ADD_MODE_1          2F94
ADD_MODE_100        305A
ADD_MODE_101        3064
ADD_MODE_110        306A
ADD_MODE_111        3070
ADD_MODE_2          2FBE
ADD_MODE_END        30B4
ADD_MODE_INVALID    30B6
ADD_OPMODE          2F14
ADD_OPMODE_000      2F44
ADD_OPMODE_001      2F4E
ADD_OPMODE_010      2F58
ADD_OPMODE_011      2F62
ADD_OPMODE_100      2F6C
ADD_OPMODE_101      2F76
ADD_OPMODE_110      2F80
ADD_OPMODE_111      2F8A
ADR_ERR_NOTLT       143C
ANDCODE000          1BCE
ANDCODE001          1BD6
ANDCODE010          1BDE
ANDCODE011          1BE6
ANDCODE100          1BEE
ANDCODE101          1BF6
ANDCODE110          1BFE
ANDCODE111          1C06
AND_ABS_L           3560
AND_ABS_W           3556
AND_BORAND_WORAND_LORMULS_W  1B80
AND_END             3584
AND_EVAL_EA         34B8
AND_IMM             356A
AND_MODE            34C6
AND_MODE_000        34F6
AND_MODE_001        3508
AND_MODE_010        350E
AND_MODE_011        3518
AND_MODE_1          3468
AND_MODE_100        3522
AND_MODE_101        352C
AND_MODE_110        3532
AND_MODE_111        3538
AND_MODE_2          3492
AND_MODE_END        357C
AND_MODE_INVALID    357E
AND_OPMODE          33E8
AND_OPMODE_000      3418
AND_OPMODE_001      3422
AND_OPMODE_010      342C
AND_OPMODE_011      3436
AND_OPMODE_100      3440
AND_OPMODE_101      344A
AND_OPMODE_110      3454
AND_OPMODE_111      345E
AN_000              2C56
AN_001              2C60
AN_010              2C6A
AN_011              2C74
AN_100              2C7E
AN_101              2C88
AN_110              2C92
AN_111              2C9C
AN_JMP              2C26
AREG0               4719
AREG1               471C
AREG2               471F
AREG3               4722
AREG4               4725
AREG5               4728
AREG6               472B
AREG7               472E
ASCII_TO_HEX        1124
ASD_END             36B4
ASD_MEM             35FE
ASD_MEM_ABS_L       36AA
ASD_MEM_ABS_W       36A0
ASD_MEM_MODE        3610
ASD_MEM_MODE_000    3640
ASD_MEM_MODE_001    364A
ASD_MEM_MODE_010    3654
ASD_MEM_MODE_011    365E
ASD_MEM_MODE_100    3668
ASD_MEM_MODE_101    3672
ASD_MEM_MODE_110    367C
ASD_MEM_MODE_111    3686
ASD_REG             35A6
ASD_REG_COUNT       35D4
ASD_REG_END         35E4
ASD_REG_REG         35CA
ASLCODE00           1916
ASLCODE01           191E
ASLCODE10           1926
ASLCODE11           192E
ASL_ASR             1AFA
ASL_ASRCODE0        1B24
ASL_ASRCODE1        1B2A
ASRCODE00           18C0
ASRCODE01           18C8
ASRCODE10           18D0
ASRCODE11           18D8
BCCORBGTORBLE       17A6
BCCORBGTORBLECODE00  17DC
BCCORBGTORBLECODE01  17E4
BCCORBGTORBLECODE10  17EC
BCCORBGTORBLECODE11  17F4
BCC_B               36EC
BCC_DISPLAY         3740
BCC_L               3732
BCC_W               3710
BEGINADDR           5000
BMESSAGE            13FE
BUFFDONE            4684
BUFFER              2000
BYTE                46EF
CHECK_BADDR_IS_LESS_THAN_EADDR  10A4
CLEAN_BUFF          4672
CLEAR               10D8
CLEARSCRN           12D0
CLRCODE00           1E0C
CLRCODE01           1E14
CLRCODE10           1E1C
CLRCODE11           1E24
CLR_ABS_L           3800
CLR_ABS_W           37F6
CLR_END             380A
CLR_MODE            3766
CLR_MODE_000        3796
CLR_MODE_001        37A0
CLR_MODE_010        37AA
CLR_MODE_011        37B4
CLR_MODE_100        37BE
CLR_MODE_101        37C8
CLR_MODE_110        37D2
CLR_MODE_111        37DC
CMPCODE00           1D60
CMPCODE01           1D68
CMPCODE10           1D70
CMPCODE11           1D78
CMP_ABS_L           38C8
CMP_ABS_W           38BE
CMP_BORCMP_WORCMP_L  1D2A
CMP_END             38E6
CMP_MODE            382E
CMP_MODE_000        385E
CMP_MODE_001        3868
CMP_MODE_010        3872
CMP_MODE_011        387C
CMP_MODE_100        3886
CMP_MODE_101        3890
CMP_MODE_110        389A
CMP_MODE_111        38A4
CMP_MODE_END        38D2
CODE0000            16FA
CODE0001            1700
CODE0010            170C
CODE0011            1712
CODE0100            1718
CODE0101            1724
CODE0110            1730
CODE0111            173C
CODE1000            1748
CODE1001            1754
CODE1010            1760
CODE1011            1768
CODE1100            1774
CODE1101            1780
CODE1110            178C
CODE1111            1798
COMMA               4737
CPAREN              473C
CR                  D
DATA                14E7
DIVU_W_ABS_L        39AC
DIVU_W_ABS_W        39A2
DIVU_W_DEST         39C4
DIVU_W_END          39D6
DIVU_W_IMM          39B6
DIVU_W_MODE         390A
DIVU_W_MODE_000     393A
DIVU_W_MODE_001     3944
DIVU_W_MODE_010     394E
DIVU_W_MODE_011     3958
DIVU_W_MODE_100     3962
DIVU_W_MODE_101     396C
DIVU_W_MODE_110     3976
DIVU_W_MODE_111     3980
DN_000              2BC6
DN_001              2BD0
DN_010              2BDA
DN_011              2BE4
DN_100              2BEE
DN_101              2BF8
DN_110              2C02
DN_111              2C0C
DOLLAR              4733
DONE                17A0
DREG0               4701
DREG1               4704
DREG2               4707
DREG3               470A
DREG4               470D
DREG5               4710
DREG6               4713
DREG7               4716
EA_ADD              2EFA
EA_ADDA             30C6
EA_ADDI             31B6
EA_ADDQ             32D2
EA_AND              33D0
EA_ASD              358E
EA_BCC              36BE
EA_CLR              374C
EA_CMP              3814
EA_COPY_PTR         2B26
EA_DEFAULT_COMBO    2B2A
EA_DIVU_W           38F0
EA_INVALID          2B04
EA_JSR              39E0
EA_LEA              3AA8
EA_LSD              3B84
EA_MOVE             3CB4
EA_MOVEA            3E88
EA_MOVEM            3FAE
EA_MOVEQ            3FB4
EA_MSG_A0           2AA4
EA_MSG_A1           2AA7
EA_MSG_A2           2AAA
EA_MSG_A3           2AAD
EA_MSG_A4           2AB0
EA_MSG_A5           2AB3
EA_MSG_A6           2AB6
EA_MSG_A7           2AB9
EA_MSG_CLOSEPAREN   2A82
EA_MSG_COMMA        2A7D
EA_MSG_D0           2A8C
EA_MSG_D1           2A8F
EA_MSG_D2           2A92
EA_MSG_D3           2A95
EA_MSG_D4           2A98
EA_MSG_D5           2A9B
EA_MSG_D6           2A9E
EA_MSG_D7           2AA1
EA_MSG_HASH         2A88
EA_MSG_HEX          2A8A
EA_MSG_MIN          2A84
EA_MSG_NULL         2A7A
EA_MSG_OPENPAREN    2A80
EA_MSG_PLUS         2A86
EA_MSG_PRINT_DATA   2AD6
EA_MSG_SPACE        2A7B
EA_MSG_UNIMP        2ABC
EA_MULS_W           4014
EA_OPMODE_COMBO     2B50
EA_OR               4104
EA_PRINT_ABS_L      2EDA
EA_PRINT_ABS_W      2EEA
EA_PRINT_AN         2C18
EA_PRINT_AN_END     2CA6
EA_PRINT_DATA       2B0E
EA_PRINT_DN         2B88
EA_PRINT_DN_END     2C16
EA_PRINT_DN_JMP     2B96
EA_PRINT_IMM        2D50
EA_PRINT_IND        2CA8
EA_PRINT_IND_END    2D42
EA_PRINT_PD_END     2ECC
EA_PRINT_PI_END     2E0C
EA_PRINT_POSTINC    2D72
EA_PRINT_PREDEC     2E26
EA_ROD              42C8
EA_SIZE_BITS        2B76
EA_SUB              43F8
EA_UNIMPLEMENTED    2AF6
EA_UPDATE_POINTER   2B1A
EMESSAGE            141D
ENDADDR             5010
ENDL                46FE
ENDQUESTION         45F6
END_LOOP            4776
ENTER               46A6
FINISHED            10C2
FOUND               11E0
GET_ADDRESSES       1000
GET_FIRST_ADDRESS   100C
GET_HEXSTRING       10F2
GET_SECOND_ADDRESS  1058
HEXA                1230
HEXB                1238
HEXC                1240
HEXD                1248
HEXE                1250
HEXEIGHT            1224
HEXF                1258
HEXFIVE             1218
HEXFLAG             5021
HEXFOUR             1214
HEXNINE             1228
HEXONE              1208
HEXSEVEN            1220
HEXSIX              121C
HEXSTRING           1497
HEXTHREE            1210
HEXTWO              120C
HEXVALUE            5030
HEXZERO             1200
IND_000             2CF2
IND_001             2CFC
IND_010             2D06
IND_011             2D10
IND_100             2D1A
IND_101             2D24
IND_110             2D2E
IND_111             2D38
IND_JMP             2CC2
INITIAL_TABLE       169A
INTRO               1344
INVALID_DATA        12EE
IO_WELCOME          10C4
ISADDAL             2620
ISADDAW             25FC
ISADDB              2644
ISADDIB             2A56
ISADDIL             2A32
ISADDIW             2A0E
ISADDL              268C
ISADDQB             2788
ISADDQL             27D0
ISADDQW             27AC
ISADDW              2668
ISANDB              2590
ISANDL              25D8
ISANDW              25B4
ISASLB              236E
ISASLL              23AC
ISASLW              2392
ISASRB              2302
ISASRL              234A
ISASRW              2326
ISBCC               2206
ISBGT               222A
ISBLE               224E
ISCLR               292A
ISCLRB              280E
ISCLRL              2856
ISCLRW              2832
ISCMPB              271C
ISCMPL              2764
ISCMPW              2740
ISDIVUW             2272
ISJSR               28E6
ISLEA               28C2
ISLSLB              243C
ISLSLL              247A
ISLSLW              2456
ISLSRB              23D0
ISLSRL              2418
ISLSRW              23F4
ISMOVEAL            29D0
ISMOVEAW            2988
ISMOVEB             29F4
ISMOVEL             29AC
ISMOVEML            287A
ISMOVEMW            289E
ISMOVEQL            27EA
ISMOVEW             2964
ISMULSW             256C
ISNOP               2944
ISORB               2296
ISORL               22DE
ISORW               22BA
ISROLB              2500
ISROLL              2548
ISROLW              2524
ISRORB              249E
ISRORL              24DC
ISRORW              24C2
ISRTS               290A
ISSUBB              26B0
ISSUBL              26F8
ISSUBW              26D4
IS_HEX_EVEN         1280
IS_LESSTHAN         1260
JSRORCLRCODE0000    1ECE
JSRORCLRCODE0001    1ED6
JSRORCLRCODE0010    1EDE
JSRORCLRCODE0011    1EE4
JSRORCLRCODE0100    1EEC
JSRORCLRCODE0101    1EF4
JSRORCLRCODE0110    1EFC
JSRORCLRCODE0111    1F04
JSRORCLRCODE1000    1F0C
JSRORCLRCODE1001    1F14
JSRORCLRCODE1010    1F1C
JSRORCLRCODE1011    1F24
JSRORCLRCODE1100    1F2C
JSRORCLRCODE1101    1F34
JSRORCLRCODE1110    1F3C
JSRORCLRCODE1111    1F44
JSR_ABS_L           3A94
JSR_ABS_W           3A8A
JSR_END             3A9E
JSR_MODE            39FA
JSR_MODE_000        3A2A
JSR_MODE_001        3A34
JSR_MODE_010        3A3E
JSR_MODE_011        3A48
JSR_MODE_100        3A52
JSR_MODE_101        3A5C
JSR_MODE_110        3A66
JSR_MODE_111        3A70
KEEP_RUNNING        45BC
LEA_ABS_L           3B5C
LEA_ABS_W           3B52
LEA_DEST            3B66
LEA_END             3B7A
LEA_MODE            3AC2
LEA_MODE_000        3AF2
LEA_MODE_001        3AFC
LEA_MODE_010        3B06
LEA_MODE_011        3B10
LEA_MODE_100        3B1A
LEA_MODE_101        3B24
LEA_MODE_110        3B2E
LEA_MODE_111        3B38
LF                  A
LONG                46F9
LOOP                4754
LOOP_CHECK          476C
LOTSCODE0000        200A
LOTSCODE0001        2012
LOTSCODE0010        201A
LOTSCODE0011        2020
LOTSCODE0100        2028
LOTSCODE0101        2030
LOTSCODE0110        2038
LOTSCODE0111        2040
LOTSCODE1000        2048
LOTSCODE1001        204E
LOTSCODE1010        2056
LOTSCODE1011        205C
LOTSCODE1100        2064
LOTSCODE1101        206C
LOTSCODE1110        2074
LOTSCODE1111        207C
LOWYES              79
LSD_END             3CAA
LSD_MEM             3BF4
LSD_MEM_ABS_L       3CA0
LSD_MEM_ABS_W       3C96
LSD_MEM_MODE        3C06
LSD_MEM_MODE_000    3C36
LSD_MEM_MODE_001    3C40
LSD_MEM_MODE_010    3C4A
LSD_MEM_MODE_011    3C54
LSD_MEM_MODE_100    3C5E
LSD_MEM_MODE_101    3C68
LSD_MEM_MODE_110    3C72
LSD_MEM_MODE_111    3C7C
LSD_REG             3B9C
LSD_REG_COUNT       3BCA
LSD_REG_END         3BDA
LSD_REG_REG         3BC0
LSLCODE00           19C2
LSLCODE01           19CA
LSLCODE10           19D2
LSLCODE11           19DA
LSL_LSR             1AC4
LSL_LSRCODE0        1AEE
LSL_LSRCODE1        1AF4
LSRCODE00           196C
LSRCODE01           1974
LSRCODE10           197C
LSRCODE11           1984
LT                  1278
MESSAGEADDAL        15B0
MESSAGEADDAW        15A9
MESSAGEADDB         1597
MESSAGEADDIB        1515
MESSAGEADDIL        150E
MESSAGEADDIW        1507
MESSAGEADDL         15A3
MESSAGEADDQB        155E
MESSAGEADDQL        156C
MESSAGEADDQW        1565
MESSAGEADDW         159D
MESSAGEANDB         15BF
MESSAGEANDL         15CB
MESSAGEANDW         15C5
MESSAGEASLB         15EA
MESSAGEASLL         15F6
MESSAGEASLW         15F0
MESSAGEASRB         15D8
MESSAGEASRL         15E4
MESSAGEASRW         15DE
MESSAGEBCC          165A
MESSAGEBGT          165E
MESSAGEBLE          1662
MESSAGECLR          1540
MESSAGECLRB         154C
MESSAGECLRL         1558
MESSAGECLRW         1552
MESSAGECMPB         1573
MESSAGECMPL         157F
MESSAGECMPW         1579
MESSAGEDIVUW        1653
MESSAGEJSR          153C
MESSAGELEA          1548
MESSAGELSLB         1632
MESSAGELSLL         163E
MESSAGELSLW         1638
MESSAGELSRB         1620
MESSAGELSRL         162C
MESSAGELSRW         1626
MESSAGEMOVEAL       151C
MESSAGEMOVEAW       1524
MESSAGEMOVEB        1500
MESSAGEMOVEL        14F9
MESSAGEMOVEML       152C
MESSAGEMOVEMW       1534
MESSAGEMOVEQL       15B7
MESSAGEMOVEW        14F2
MESSAGEMULSW        15D1
MESSAGENOP          14EE
MESSAGEOPCODE_INVALID  1666
MESSAGEORB          1644
MESSAGEORL          164E
MESSAGEORW          1649
MESSAGEROLB         160E
MESSAGEROLL         161A
MESSAGEROLW         1614
MESSAGERORB         15FC
MESSAGERORL         1608
MESSAGERORW         1602
MESSAGERTS          1544
MESSAGESPACE        14EC
MESSAGESUBB         1585
MESSAGESUBL         1591
MESSAGESUBW         158B
MINUS               4740
MOD                 2
MOVEACODE001        2130
MOVEAWCODE001       21BE
MOVEA_ADJUST_L      3EBE
MOVEA_ADJUST_W      3EB4
MOVEA_DESTINATION   3F90
MOVEA_END           3FA4
MOVEA_LORMOVE_L     20DA
MOVEA_SOURCE        3EC8
MOVEA_SRC_ABS_L     3F7C
MOVEA_SRC_ABS_W     3F72
MOVEA_SRC_IMM       3F86
MOVEA_SRC_MODE      3EDA
MOVEA_SRC_MODE_000  3F0A
MOVEA_SRC_MODE_001  3F14
MOVEA_SRC_MODE_010  3F1E
MOVEA_SRC_MODE_011  3F28
MOVEA_SRC_MODE_100  3F32
MOVEA_SRC_MODE_101  3F3C
MOVEA_SRC_MODE_110  3F46
MOVEA_SRC_MODE_111  3F50
MOVEA_WORMOVE_W     2168
MOVECODE000         2128
MOVECODE010         2138
MOVECODE011         2140
MOVECODE100         2148
MOVECODE101         2150
MOVECODE110         2158
MOVECODE111         2160
MOVEMCODE0          1F76
MOVEMCODE1          1F7E
MOVEQ_PRINT_DATA    3FE6
MOVEWCODE000        21B6
MOVEWCODE010        21C6
MOVEWCODE011        21CE
MOVEWCODE100        21D6
MOVEWCODE101        21DE
MOVEWCODE110        21E6
MOVEWCODE111        21EE
MOVE_ADJUST_L       3CEA
MOVE_ADJUST_W       3CE0
MOVE_DESTINATION    3DBC
MOVE_DST_ABS_L      3E74
MOVE_DST_ABS_W      3E6A
MOVE_DST_MODE       3DDA
MOVE_DST_MODE_000   3E0A
MOVE_DST_MODE_001   3E14
MOVE_DST_MODE_010   3E1E
MOVE_DST_MODE_011   3E28
MOVE_DST_MODE_100   3E32
MOVE_DST_MODE_101   3E3C
MOVE_DST_MODE_110   3E46
MOVE_DST_MODE_111   3E50
MOVE_END            3E7E
MOVE_SOURCE         3CF4
MOVE_SRC_ABS_L      3DA8
MOVE_SRC_ABS_W      3D9E
MOVE_SRC_IMM        3DB2
MOVE_SRC_MODE       3D06
MOVE_SRC_MODE_000   3D36
MOVE_SRC_MODE_001   3D40
MOVE_SRC_MODE_010   3D4A
MOVE_SRC_MODE_011   3D54
MOVE_SRC_MODE_100   3D5E
MOVE_SRC_MODE_101   3D68
MOVE_SRC_MODE_110   3D72
MOVE_SRC_MODE_111   3D7C
MULS_W_ABS_L        40D0
MULS_W_ABS_W        40C6
MULS_W_DEST         40E8
MULS_W_END          40FA
MULS_W_IMM          40DA
MULS_W_MODE         402E
MULS_W_MODE_000     405E
MULS_W_MODE_001     4068
MULS_W_MODE_010     4072
MULS_W_MODE_011     407C
MULS_W_MODE_100     4086
MULS_W_MODE_101     4090
MULS_W_MODE_110     409A
MULS_W_MODE_111     40A4
MV                  46E5
NEW_LINE            12C2
NEW_PAGE            4686
NOPCOMMAND          1EC6
NOPORCLRORRTSORJSR  1E2C
NOP_MOVEM_LEA_JSR_CLR_RTS  1F86
NOTDONE             45EC
NOTEVEN             12AA
OC_PARSE            167D
OPAREN              473A
OPCODE_INVALID      21F6
OR_ABS_L            429A
OR_ABS_W            4290
OR_BOROR_WOROR_LORDIVU  17FC
OR_DIVUCODE000      184A
OR_DIVUCODE001      1852
OR_DIVUCODE010      185A
OR_DIVUCODE011      1862
OR_DIVUCODE100      186A
OR_DIVUCODE101      1872
OR_DIVUCODE110      187A
OR_DIVUCODE111      1882
OR_END              42BE
OR_EVAL_EA          41EE
OR_IMM              42A4
OR_MODE             41FC
OR_MODE_000         422C
OR_MODE_001         4236
OR_MODE_010         4248
OR_MODE_011         4252
OR_MODE_1           419E
OR_MODE_100         425C
OR_MODE_101         4266
OR_MODE_110         426C
OR_MODE_111         4272
OR_MODE_2           41C8
OR_MODE_END         42B6
OR_MODE_INVALID     42B8
OR_OPMODE           411E
OR_OPMODE_000       414E
OR_OPMODE_001       4158
OR_OPMODE_010       4162
OR_OPMODE_011       416C
OR_OPMODE_100       4176
OR_OPMODE_101       4180
OR_OPMODE_110       418A
OR_OPMODE_111       4194
PAUSE               469E
PERCENT             4735
PLUS                473E
POSTINC_000         2DBC
POSTINC_001         2DC6
POSTINC_010         2DD0
POSTINC_011         2DDA
POSTINC_100         2DE4
POSTINC_101         2DEE
POSTINC_110         2DF8
POSTINC_111         2E02
POSTINC_JMP         2D8C
POUND               4731
PREDEC_000          2E7C
PREDEC_001          2E86
PREDEC_010          2E90
PREDEC_011          2E9A
PREDEC_100          2EA4
PREDEC_101          2EAE
PREDEC_110          2EB8
PREDEC_111          2EC2
PREDEC_JMP          2E4C
PRINTLN             4664
PRINT_HEXVALUE      12B4
PRINT_IMM_END       2D6E
PRINT_IMM_L         2D6A
PS1                 136C
PS2                 13B6
QUIT                4747
RCOUNT              1E
REMAINDER           5050
REPEAT              128C
RERUN               45C2
ROD_END             43EE
ROD_LSD_ASD         1B30
ROD_LSD_ASDCODE00   1B66
ROD_LSD_ASDCODE01   1B6C
ROD_LSD_ASDCODE10   1B72
ROD_LSD_ASDCODE11   1B7A
ROD_MEM             4338
ROD_MEM_ABS_L       43E4
ROD_MEM_ABS_W       43DA
ROD_MEM_MODE        434A
ROD_MEM_MODE_000    437A
ROD_MEM_MODE_001    4384
ROD_MEM_MODE_010    438E
ROD_MEM_MODE_011    4398
ROD_MEM_MODE_100    43A2
ROD_MEM_MODE_101    43AC
ROD_MEM_MODE_110    43B6
ROD_MEM_MODE_111    43C0
ROD_REG             42E0
ROD_REG_COUNT       430E
ROD_REG_END         431E
ROD_REG_REG         4304
ROLCODE00           1A18
ROLCODE01           1A20
ROLCODE10           1A28
ROLCODE11           1A30
ROL_ROR             1A8E
ROL_RORCODE0        1AB8
ROL_RORCODE1        1ABE
RORCODE00           1A6E
RORCODE01           1A76
RORCODE10           1A7E
RORCODE11           1A86
RTSCOMMAND          1EBE
RUNAGAIN            6000
SHIFTLEFT           11FA
SKIP_WRITE          464E
SOMEASL             18E0
SOMEASR             188A
SOMECLR             1DD6
SOMELSL             198C
SOMELSR             1936
SOMEMOVEM           1F4C
SOMEROL             19E2
SOMEROR             1A38
STACK               7000
START               4747
STR_LEN             5020
SUBCODE000          1CEA
SUBCODE001          1CF2
SUBCODE010          1CFA
SUBCODE011          1D02
SUBCODE100          1D0A
SUBCODE101          1D12
SUBCODE110          1D1A
SUBCODE111          1D22
SUB_ABS_L           458E
SUB_ABS_W           4584
SUB_BORSUB_WORSUB_L  1C9C
SUB_END             45B2
SUB_EVAL_EA         44DA
SUB_IMM             4598
SUB_MODE            44E8
SUB_MODE_000        4518
SUB_MODE_001        452A
SUB_MODE_010        453C
SUB_MODE_011        4546
SUB_MODE_1          448A
SUB_MODE_100        4550
SUB_MODE_101        455A
SUB_MODE_110        4560
SUB_MODE_111        4566
SUB_MODE_2          44B4
SUB_MODE_END        45AA
SUB_MODE_INVALID    45AC
SUB_OPMODE          440A
SUB_OPMODE_000      443A
SUB_OPMODE_001      4444
SUB_OPMODE_010      444E
SUB_OPMODE_011      4458
SUB_OPMODE_100      4462
SUB_OPMODE_101      446C
SUB_OPMODE_110      4476
SUB_OPMODE_111      4480
TAB                 4742
TABLEADDI_BORADDI_WORADDI_L  20A2
TABLEADDQ_BORADDQ_WORADDQ_L  1D9E
TABLEADD_BORADD_WORADD_L  1C2C
TABLEAND_BORAND_WORAND_LORMULS_W  1B9E
TABLEASL_ASR        1B18
TABLEBCCORBGTORBLE  17C4
TABLECMP_BORCMP_WORCMP_L  1D48
TABLELSL_LSR        1AE2
TABLEMOVEA_LORMOVE_L  20F8
TABLEMOVEA_WORMOVE_W  2186
TABLENOPORCLRORRTSORJSR  1E5E
TABLENOP_MOVEM_LEA_JSR_CLR_RTS  1FAA
TABLEOR_BOROR_WOROR_LORDIVU  181A
TABLEROD_LSD_ASD    1B4E
TABLEROL_ROR        1AAC
TABLESOMEASL        18FE
TABLESOMEASR        18A8
TABLESOMECLR        1DF4
TABLESOMELSL        19AA
TABLESOMELSR        1954
TABLESOMEMOVEM      1F6A
TABLESOMEROL        1A00
TABLESOMEROR        1A56
TABLESUB_BORSUB_WORSUB_L  1CBA
UPDATE_PTR          2B22
UPYES               59
WORD                46F4
WRITE2MEM           4642
WRITE_ENDL          4656
WRITE_LINE          4626
