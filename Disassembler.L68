000014AA Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/29/2016 4:05:57 PM

00000000                             1  ******************************************************************************
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Brandon Authier (Hblkr), Jack S. Eldridge
00000000                             4  *              (JackScottie), Marijn Burger (marijnburger)
00000000                             5  * Date       : 16 May 2016
00000000                             6  * Description: An inverse assembler that will convert a memory
00000000                             7  *              image of instructions and data back to the display.
00000000                             8  *              The following will be decoded:
00000000                             9  *
00000000                            10  *              Addressing Modes
00000000                            11  *
00000000                            12  *                Data Register Direct
00000000                            13  *                Address Register Direct
00000000                            14  *                Address Register Indirect
00000000                            15  *                Immediate Data
00000000                            16  *                Address Register Indirect with Post Increment
00000000                            17  *                Address Register Indirect with Pre Decrement
00000000                            18  *                Absolute Long Address
00000000                            19  *                Absolute Word Address
00000000                            20  *
00000000                            21  *              Instructions
00000000                            22  *
00000000                            23  *                NOP
00000000                            24  *                MOVE
00000000                            25  *                MOVEA
00000000                            26  *                MOVEQ
00000000                            27  *                MOVEM
00000000                            28  *                ADD
00000000                            29  *                ADDA
00000000                            30  *                ADDI
00000000                            31  *                ADDQ
00000000                            32  *                SUB
00000000                            33  *                MULS
00000000                            34  *                DIVU
00000000                            35  *                LEA
00000000                            36  *                CLR
00000000                            37  *                AND
00000000                            38  *                OR
00000000                            39  *                LSL
00000000                            40  *                LSR
00000000                            41  *                ASR
00000000                            42  *                ASL
00000000                            43  *                ROL
00000000                            44  *                ROR
00000000                            45  *                CMP
00000000                            46  *                Bcc (BCC, BGT, BLE)
00000000                            47  *                JSR
00000000                            48  *                RTS
00000000                            49  *
00000000                            50  ******************************************************************************
00000000                            51  
00000000                            52  ******************************************************************************
00000000                            53  *           DEFINITIONS                                                      *
00000000                            54  ******************************************************************************
00000000  =00007000                 55  STACK     EQU   $7000               * Beginning address for stack pointer
00000000                            56  
00000000  =00005000                 57  BEGINADDR EQU   $5000               * Variable to hold beginning address value
00000000  =00005010                 58  ENDADDR   EQU   $5010               * Variable to hold ending address value
00000000                            59  
00000000  =00000001                 60  TRUE      EQU   $01                 * Value equivalent to 'true'
00000000                            61  
00001000                            62            ORG   $1000               * Program begins at address 1000
00001000                            63            
00001000                            64  *********** END DEFINITIONS **************************************************
00001000                            65  
00001000                            66            
00001000                            67  ******************************************************************************
00001000                            68  *           INCLUDES                                                         *
00001000                            69  ******************************************************************************
00001000                            70  
00001000                            71      INCLUDE 'IO.X68'
00001000                            72  
00001000                            73  
00001000                            74  
00001000  =00005020                 75  STR_LEN   EQU   $5020
00001000  =00005021                 76  HEXFLAG   EQU   $5021
00001000  =00005030                 77  HEXVALUE  EQU   $5030
00001000  =00005050                 78  REMAINDER EQU   $5050
00001000  =00000002                 79  MOD       EQU   2
00001000                            80  
00001000  =0000000D                 81  CR        EQU   $0D
00001000  =0000000A                 82  LF        EQU   $0A 
00001000                            83  
00001000                            84            ORG   $1000 
00001000                            85  
00001000                            86  
00001000                            87  GET_ADDRESSES
00001000  4EB9 000012CE             88      JSR         CLEARSCRN
00001006  4EB9 000010C4             89      JSR         IO_WELCOME          * Run welcome subroutine
0000100C                            90              
0000100C                            91  GET_FIRST_ADDRESS
0000100C  43F9 00001314             92      LEA         PS1,A1              * Loads message into A1
00001012  4EB9 000010F2             93      JSR         GET_HEXSTRING       * Get string from user
00001018  0C38 0001 5021            94      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000101E  66EC                      95      BNE         GET_FIRST_ADDRESS   * If no, get hex again
00001020                            96     
00001020  4EB9 00001122             97      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001026  0C38 0001 5021            98      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000102C  66DE                      99      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000102E                           100      
0000102E  4EB9 0000127E            101      JSR         IS_HEX_EVEN         * Check that hex value is even
00001034  0C38 0001 5021           102      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000103A  66D0                     103      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000103C                           104     
0000103C  21F8 5030 5000           105      MOVE.L      HEXVALUE,BEGINADDR  * Copy hex value to begin
00001042  43F9 000013A6            106      LEA         BMESSAGE,A1         * Load message in A1 for display
00001048  2238 5030                107      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display 
0000104C  4EB9 000012C0            108      JSR         NEW_LINE            * Space
00001052                           109      
00001052  4EB9 000010D8            110      JSR         CLEAR               * Clear values for next hex
00001058                           111      
00001058                           112  GET_SECOND_ADDRESS
00001058  43F9 0000135E            113      LEA         PS2,A1              * Loads message into A1
0000105E  4EB9 000010F2            114      JSR         GET_HEXSTRING       * Get string from user
00001064  0C38 0001 5021           115      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000106A  66EC                     116      BNE         GET_SECOND_ADDRESS  * If no, get hex again
0000106C                           117     
0000106C  4EB9 00001122            118      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001072  0C38 0001 5021           119      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001078  66DE                     120      BNE         GET_SECOND_ADDRESS  * If no, get hex again
0000107A                           121      
0000107A  4EB9 0000127E            122      JSR         IS_HEX_EVEN         * Check that hex value is even
00001080  0C38 0001 5021           123      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001086  66D0                     124      BNE         GET_SECOND_ADDRESS  * If no, get hex again
00001088                           125     
00001088  21F8 5030 5010           126      MOVE.L      HEXVALUE,ENDADDR    * Copy hex value to begin
0000108E  43F9 000013C5            127      LEA         EMESSAGE,A1         * Load message in A1 for display
00001094  2238 5030                128      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display
00001098  4EB9 000012C0            129      JSR         NEW_LINE            * Space
0000109E                           130      
0000109E  4EB9 000010D8            131      JSR         CLEAR               * Clear values for next hex
000010A4                           132      
000010A4                           133  CHECK_BADDR_IS_LESS_THAN_EADDR
000010A4  4EB9 0000125E            134      JSR         IS_LESSTHAN         *
000010AA  0C38 0001 5021           135      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000010B0  6700 0010                136      BEQ         FINISHED            * If yes, finished
000010B4  43F9 000013E7            137      LEA         ADR_ERR_NOTLT,A1    * Else, load error message
000010BA  6100 021E                138      BSR.W       ADDRESS_ERR
000010BE  6100 03EA                139      BSR.W       START      
000010C2                           140  
000010C2                           141  
000010C2                           142  FINISHED
000010C2  4E75                     143      RTS                             * Return to Disassembler
000010C4                           144      
000010C4                           145         
000010C4                           146             
000010C4                           147             
000010C4                           148  
000010C4                           149  IO_WELCOME: 
000010C4  43F9 000012EC            150      LEA         INTRO,A1            * Loads message into A1
000010CA  103C 000E                151      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010CE  4E4F                     152      TRAP        #15                 * Displays Intro Message 
000010D0                           153        
000010D0  4EB9 000012C0            154      JSR         NEW_LINE            * Call Subroutine        
000010D6  4E75                     155      RTS                             * Return from subroutine
000010D8                           156          
000010D8                           157  
000010D8                           158  
000010D8                           159  CLEAR
000010D8  4286                     160      CLR.L       D6                   * Clear
000010DA  31FC FFFF 5020           161      MOVE.W      #$FFFF,STR_LEN       * Clear   
000010E0  21FC FFFFFFFF 5030       162      MOVE.L      #$FFFFFFFF,HEXVALUE  * Clear  
000010E8  21FC FFFFFFFF 5050       163      MOVE.L      #$FFFFFFFF,REMAINDER * Clear
000010F0  4E75                     164      RTS                              * Return to main to get hex
000010F2                           165  
000010F2                           166  
000010F2                           167          
000010F2                           168  GET_HEXSTRING
000010F2  103C 000E                169      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010F6  323C 004A                170      MOVE.W      #(PS2-PS1),D1       * The prompt string length
000010FA  4E4F                     171      TRAP        #15                 * Displays contents of A1
000010FC                           172   
000010FC  43F9 00001442            173      LEA         HEXSTRING,A1        * Pointer to store the sentence
00001102  103C 0002                174      MOVE.B      #2,D0               * Set up readstring function
00001106  4E4F                     175      TRAP        #15                 * Get string from keyboard
00001108  11C1 5020                176      MOVE.B      D1,STR_LEN          * Save length of input string
0000110C                           177      
0000110C  0C38 0008 5020           178      CMPI.B      #8,(STR_LEN)        * Is length > 8?
00001112  6EDE                     179      BGT         GET_HEXSTRING       * If yes, get hex again
00001114                           180         
00001114  41F9 00001442            181      LEA         HEXSTRING,A0        * Load address for verification     
0000111A  11FC 0001 5021           182      MOVE.B      #1,(HEXFLAG)   
00001120  4E75                     183      RTS                             * Return from subroutine
00001122                           184          
00001122                           185  
00001122                           186  
00001122                           187  ASCII_TO_HEX      
00001122  1618                     188      MOVE.B      (A0)+,D3            * Move first char into D3    
00001124  0C03 0030                189      CMPI.B      #'0',D3             * Is Char equal to 0?
00001128  6700 00D4                190      BEQ         HEXZERO            
0000112C  0C03 0031                191      CMPI.B      #'1',D3             * Is Char equal to 1?
00001130  6700 00D4                192      BEQ         HEXONE                   
00001134  0C03 0032                193      CMPI.B      #'2',D3             * Is Char equal to 2?
00001138  6700 00D0                194      BEQ         HEXTWO    
0000113C  0C03 0033                195      CMPI.B      #'3',D3             * Is Char equal to 3?
00001140  6700 00CC                196      BEQ         HEXTHREE    
00001144  0C03 0034                197      CMPI.B      #'4',D3             * Is Char equal to 4?
00001148  6700 00C8                198      BEQ         HEXFOUR    
0000114C  0C03 0035                199      CMPI.B      #'5',D3             * Is Char equal to 5?
00001150  6700 00C4                200      BEQ         HEXFIVE    
00001154  0C03 0036                201      CMPI.B      #'6',D3             * Is Char equal to 6?
00001158  6700 00C0                202      BEQ         HEXSIX
0000115C  0C03 0037                203      CMPI.B      #'7',D3             * Is Char equal to 7?
00001160  6700 00BC                204      BEQ         HEXSEVEN
00001164  0C03 0038                205      CMPI.B      #'8',D3             * Is Char equal to 8?
00001168  6700 00B8                206      BEQ         HEXEIGHT
0000116C  0C03 0039                207      CMPI.B      #'9',D3             * Is Char equal to 9?
00001170  6700 00B4                208      BEQ         HEXNINE
00001174  0C03 0041                209      CMPI.B      #'A',D3             * Is Char equal to A?
00001178  6700 00B4                210      BEQ         HEXA                      
0000117C  0C03 0042                211      CMPI.B      #'B',D3             * Is Char equal to B?
00001180  6700 00B4                212      BEQ         HEXB
00001184  0C03 0043                213      CMPI.B      #'C',D3             * Is Char equal to C?
00001188  6700 00B4                214      BEQ         HEXC
0000118C  0C03 0044                215      CMPI.B      #'D',D3             * Is Char equal to D?
00001190  6700 00B4                216      BEQ         HEXD
00001194  0C03 0045                217      CMPI.B      #'E',D3             * Is Char equal to E?
00001198  6700 00B4                218      BEQ         HEXE
0000119C  0C03 0046                219      CMPI.B      #'F',D3             * Is Char equal to F?
000011A0  6700 00B4                220      BEQ         HEXF
000011A4  0C03 0061                221      CMPI.B      #'a',D3             * Is Char equal to a?
000011A8  6700 0084                222      BEQ         HEXA
000011AC  0C03 0062                223      CMPI.B      #'b',D3             * Is Char equal to b?
000011B0  6700 0084                224      BEQ         HEXB
000011B4  0C03 0063                225      CMPI.B      #'c',D3             * Is Char equal to c?
000011B8  6700 0084                226      BEQ         HEXC
000011BC  0C03 0064                227      CMPI.B      #'d',D3             * Is Char equal to d?
000011C0  6700 0084                228      BEQ         HEXD
000011C4  0C03 0065                229      CMPI.B      #'e',D3             * Is Char equal to e?
000011C8  6700 0084                230      BEQ         HEXE
000011CC  0C03 0066                231      CMPI.B      #'f',D3             * Is Char equal to f?
000011D0  6700 0084                232      BEQ         HEXF
000011D4                           233      
000011D4  11FC 0000 5021           234      MOVE.B      #0,HEXFLAG          * Set false    
000011DA  6000 FEFC                235      BRA         CLEAR               * Clear some values
000011DE                           236      
000011DE                           237  FOUND  
000011DE  5338 5020                238      SUBI.B      #1,STR_LEN          * Decrease string by one
000011E2  0C38 0000 5020           239      CMPI.B      #0,STR_LEN          * Is string = 0?
000011E8  6600 000E                240      BNE         SHIFTLEFT           * If no, shift value left 
000011EC  21C6 5030                241      MOVE.L      D6,HEXVALUE         * If yes, save hex value
000011F0  11FC 0001 5021           242      MOVE.B      #1,HEXFLAG          * Set true
000011F6  4E75                     243      RTS                             * Then, return to main
000011F8                           244  
000011F8                           245  SHIFTLEFT
000011F8  E98E                     246      LSL.L       #4,D6               * Shift the value left
000011FA  6000 FF26                247      BRA         ASCII_TO_HEX        * Check next char
000011FE                           248  
000011FE                           249  HEXZERO
000011FE  0686 00000000            250      ADD.L       #$0,D6              * Add value
00001204  60D8                     251      BRA         FOUND               * found, decrease strlen, shift value left    
00001206                           252  HEXONE
00001206  5286                     253      ADD.L       #$1,D6              * Add value
00001208  60D4                     254      BRA         FOUND               * found, decrease strlen, shift value left
0000120A                           255  HEXTWO
0000120A  5486                     256      ADD.L       #$2,D6              * Add value
0000120C  60D0                     257      BRA         FOUND               * found, decrease strlen, shift value left
0000120E                           258  HEXTHREE
0000120E  5686                     259      ADD.L       #$3,D6              * Add value
00001210  60CC                     260      BRA         FOUND               * found, decrease strlen, shift value left
00001212                           261  HEXFOUR
00001212  5886                     262      ADD.L       #$4,D6              * Add value
00001214  60C8                     263      BRA         FOUND               * found, decrease strlen, shift value left
00001216                           264  HEXFIVE
00001216  5A86                     265      ADD.L       #$5,D6              * Add value
00001218  60C4                     266      BRA         FOUND               * found, decrease strlen, shift value left
0000121A                           267  HEXSIX
0000121A  5C86                     268      ADD.L       #$6,D6              * Add value
0000121C  60C0                     269      BRA         FOUND               * found, decrease strlen, shift value left
0000121E                           270  HEXSEVEN
0000121E  5E86                     271      ADD.L       #$7,D6              * Add value
00001220  60BC                     272      BRA         FOUND               * found, decrease strlen, shift value left
00001222                           273  HEXEIGHT
00001222  5086                     274      ADD.L       #$8,D6              * Add value
00001224  60B8                     275      BRA         FOUND               * found, decrease strlen, shift value left
00001226                           276  HEXNINE
00001226  0686 00000009            277      ADD.L       #$9,D6              * Add value
0000122C  60B0                     278      BRA         FOUND               * found, decrease strlen, shift value left
0000122E                           279  HEXA
0000122E  0686 0000000A            280      ADD.L       #$A,D6              * Add value
00001234  60A8                     281      BRA         FOUND               * found, decrease strlen, shift value left    
00001236                           282  HEXB
00001236  0686 0000000B            283      ADD.L       #$B,D6              * Add value
0000123C  60A0                     284      BRA         FOUND               * found, decrease strlen, shift value left
0000123E                           285  HEXC
0000123E  0686 0000000C            286      ADD.L       #$C,D6              * Add value
00001244  6098                     287      BRA         FOUND               * found, decrease strlen, shift value left
00001246                           288  HEXD
00001246  0686 0000000D            289      ADD.L       #$D,D6              * Add value
0000124C  6090                     290      BRA         FOUND               * found, decrease strlen, shift value left
0000124E                           291  HEXE
0000124E  0686 0000000E            292      ADD.L       #$E,D6              * Add value
00001254  6088                     293      BRA         FOUND               * found, decrease strlen, shift value left
00001256                           294  HEXF
00001256  0686 0000000F            295      ADD.L       #$F,D6              * Add value
0000125C  6080                     296      BRA         FOUND               * found, decrease strlen, shift value left 
0000125E                           297     
0000125E                           298  
0000125E                           299  
0000125E                           300  IS_LESSTHAN
0000125E  2838 5000                301      MOVE.L      BEGINADDR,D4        * Store beginning address in D4
00001262  2C38 5010                302      MOVE.L      ENDADDR,D6          * Store ending address in D6
00001266  B886                     303      CMP.L       D6,D4               * Is D4 < D6
00001268  6D00 000C                304      BLT         LT                  * Yes, mark true return to main
0000126C  11FC 0000 5021           305      MOVE.B      #0,HEXFLAG          * No, mark false
00001272  6000 FE64                306      BRA         CLEAR               * Clear values, return to main
00001276                           307  
00001276                           308  LT
00001276  11FC 0001 5021           309      MOVE.B      #1,HEXFLAG          * Mark true
0000127C  4E75                     310      RTS                             * Return to main
0000127E                           311  
0000127E                           312  
0000127E                           313  
0000127E                           314  IS_HEX_EVEN      
0000127E  3606                     315      MOVE.W      D6,D3               * Move value to be modded into D3
00001280  3A3C 0002                316      MOVE.W      #MOD,D5             * Move mod value into D5
00001284  86C5                     317      DIVU        D5,D3               * Divide D3 by D5
00001286  123C 0003                318      MOVE.B      #3,D1               * Set counter to shift value into word 
0000128A                           319                                      * position    
0000128A                           320  REPEAT 
0000128A  E88B                     321      LSR.L       #4,D3               * Shift remainder to lower word
0000128C  57C9 FFFC                322      DBEQ        D1,REPEAT           * UNTIL [D0] = - 1
00001290  4241                     323      CLR         D1                  * Clear
00001292                           324      
00001292  B6BC 00000000            325      CMP.L       #0,D3               * Is hex even?
00001298  6600 000E                326      BNE         NOTEVEN             * No, clear and go back to get_hex
0000129C  31C3 5050                327      MOVE.W      D3,REMAINDER        * Save remainder
000012A0  11FC 0001 5021           328      MOVE.B      #1,HEXFLAG          * Set true
000012A6  4E75                     329      RTS                             * Return to main
000012A8                           330  
000012A8                           331  NOTEVEN
000012A8  11FC 0000 5021           332      MOVE.B      #0,HEXFLAG          * Set false
000012AE  6000 FE28                333      BRA         CLEAR               * Clear values
000012B2                           334  
000012B2                           335  
000012B2                           336  
000012B2                           337  PRINT_HEXVALUE
000012B2  103C 000E                338      MOVE.B      #14,D0              * Moves the Task 14 into D0
000012B6  4E4F                     339      TRAP        #15                 * Displays contents of A1
000012B8                           340      
000012B8                           341      
000012B8  103C 0003                342      MOVE.B      #3,D0               * Moves the Task 3 into D0
000012BC  4E4F                     343      TRAP        #15                 * Displays contents of D1
000012BE                           344      
000012BE  4E75                     345      RTS                             * Return from subroutine                                  
000012C0                           346  
000012C0                           347  
000012C0                           348  NEW_LINE
000012C0  43F9 000013E4            349      LEA         ENDL,A1             * Loads message into A1
000012C6  103C 000E                350      MOVE.B      #14,D0              * Moves the TRACK 14 into D0
000012CA  4E4F                     351      TRAP        #15                 * Displays New line
000012CC  4E75                     352      RTS                             * Return from subroutine
000012CE                           353  
000012CE                           354  
000012CE                           355  CLEARSCRN     
000012CE  103C 000B                356      MOVE.B      #11,D0              * Task 11 for clearing screen
000012D2  323C FF00                357      MOVE.W      #$FF00,D1           * FF00, Clear screen
000012D6  4E4F                     358      TRAP        #15                 * Wait for keystroke
000012D8  4E75                     359      RTS                             * Return from subroutine
000012DA                           360  
000012DA                           361  
000012DA                           362  
000012DA                           363  
000012DA                           364  ADDRESS_ERR
000012DA  6100 FFF2                365      BSR.W       CLEARSCRN           * Clear output before displaying error
000012DE  103C 000D                366      MOVE.B      #13,D0              * Moves the Task 13 into D0
000012E2  4E4F                     367      TRAP        #15                 * Displays contents of A1
000012E4  103C 0005                368      MOVE.B      #5,D0               * Read single character from 
000012E8  4E4F                     369      TRAP        #15                 * The keyboard into D1.B
000012EA  4E75                     370      RTS                             * Return from subroutine
000012EC                           371  
000012EC                           372  
000012EC                           373  
000012EC                           374  
000012EC= 57 45 4C 43 4F 4D ...    375  INTRO           DC.B 'WELCOME!',CR,LF,'THIS IS A 68K DISASSEMBLER.',CR,LF,0
00001314= 50 4C 45 41 53 45 ...    376  PS1             DC.B 'PLEASE ENTER THE STARTING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
0000135E= 50 4C 45 41 53 45 ...    377  PS2             DC.B 'PLEASE ENTER THE ENDING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000013A6= 0D 0A 42 45 47 49 ...    378  BMESSAGE        DC.B CR,LF,'BEGINNING ADDRESS GIVEN IS: ',0
000013C5= 0D 0A 45 4E 44 49 ...    379  EMESSAGE        DC.B CR,LF,'ENDING ADDRESS GIVEN IS   : ',0
000013E4= 0D 0A 00                 380  ENDL            DC.B CR,LF,0
000013E7                           381  
000013E7= 54 48 45 20 42 45 ...    382  ADR_ERR_NOTLT   DC.B 'THE BEGINNING ADDRESS MUST BE LESS THAN THE ENDING ADDRESS.',CR,LF,'PRESS ANY KEY TO TRY AGAIN...',0
00001442                           383  
00001442                           384  HEXSTRING       DS.B 80             * Var for hex string
00001492                           385  
00001492= 31 30 30 30 20 20 ...    386  ILLEGAL         DC.B '1000    DATA    $WXYZ',CR,LF,0
000014AA                           387  
000014AA                           388  
000014AA                           389  
000014AA                           390  
000014AA                           391  
000014AA                           392  
000014AA                           393  
000014AA                           394  -------------------- end include --------------------
000014AA                           395      *INCLUDE 'OpCodes.X68'
000014AA                           396      *INCLUDE 'EA.X68'
000014AA                           397  
000014AA                           398  *********** END INCLUDES *****************************************************    
000014AA                           399        
000014AA                           400        
000014AA                           401  ******************************************************************************
000014AA                           402  *           BEGIN CODE                                                       *
000014AA                           403  ******************************************************************************
000014AA                           404  
000014AA                           405  *---------- START ------------------------------------------------------------
000014AA                           406  * Begins program's logical flow. Similar to main in C/C++
000014AA                           407  *-----------------------------------------------------------------------------
000014AA                           408  START
000014AA  4FF8 7000                409      LEA         STACK,SP            * SP is stored in A7
000014AE  4EB8 1000                410      JSR         GET_ADDRESSES       * Runs GET_ADDRESSES and IO_WELCOME
000014B2  2C78 5000                411      MOVEA.L     BEGINADDR,A6        * Assign beginning address to A6 for use
000014B6                           412  
000014B6                           413  LOOP
000014B6                           414      *JSR         OC_PARSE            * Determine if there is an initial opcode match
000014B6                           415      * decrement row count
000014B6                           416      * if at 0, prompt for next page
000014B6                           417      * else, continue
000014B6  584E                     418      ADDA.W      #$4,A6            * Advance address to test LOOP (test only)
000014B8                           419      
000014B8                           420  LOOP_CHECK
000014B8                           421      * Changed the following code from: 
000014B8                           422      * CMPA        A6, ENDADDR         
000014B8                           423      * to:
000014B8                           424      * CMPA      (ENDADDR),A6 
000014B8                           425      * When using the CMPA, destination must be an address so A6
000014B8  BDF8 5010                426      CMPA.L      ENDADDR,A6          * Is pointer at end of address range?
000014BC                           427      
000014BC  6E00 0004                428      BGT         END_LOOP            * If yes, END_LOOP
000014C0                           429      ; in case this resets status register, do another compare TODO
000014C0                           430      
000014C0  66F4                     431      BNE         LOOP                * If not, continue processing addresses
000014C2                           432      ; If at end of address range, check if user wants to continue
000014C2                           433      ; if user wants to continue, restart
000014C2                           434      ; else, end
000014C2                           435  
000014C2                           436  END_LOOP
000014C2  4E72 3000                437      STOP        #$3000              * End program
000014C6                           438  *    JMP         START               * Restart program (optional workflow)
000014C6                           439  
000014C6                           440  *---------- END - START ------------------------------------------------------
000014C6                           441  
000014C6                           442  *********** END BEGIN CODE ***************************************************
000014C6                           443  
000014C6                           444  
000014C6                           445  ******************************************************************************
000014C6                           446  *           VARIABLES AND CONSTANTS                                          *
000014C6                           447  ******************************************************************************
000014C6                           448  
000014C6                           449  
000014C6                           450  
000014C6                           451  *---------- Reserved Registers -----------------------------
000014C6                           452  *   A7: stack pointer
000014C6                           453  *   A6: current address (updated by subroutines)
000014C6                           454  *   D0: instruction validity flag (reset by main control
000014C6                           455  *       code, can be set to false by subroutines)
000014C6                           456  *-----------------------------------------------------------
000014C6                           457  
000014C6                           458  *---------- End --------------------------------------------
000014C6                           459                 END  START          * Last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDRESS_ERR         12DA
ADR_ERR_NOTLT       13E7
ASCII_TO_HEX        1122
BEGINADDR           5000
BMESSAGE            13A6
CHECK_BADDR_IS_LESS_THAN_EADDR  10A4
CLEAR               10D8
CLEARSCRN           12CE
CR                  D
EMESSAGE            13C5
ENDADDR             5010
ENDL                13E4
END_LOOP            14C2
FINISHED            10C2
FOUND               11DE
GET_ADDRESSES       1000
GET_FIRST_ADDRESS   100C
GET_HEXSTRING       10F2
GET_SECOND_ADDRESS  1058
HEXA                122E
HEXB                1236
HEXC                123E
HEXD                1246
HEXE                124E
HEXEIGHT            1222
HEXF                1256
HEXFIVE             1216
HEXFLAG             5021
HEXFOUR             1212
HEXNINE             1226
HEXONE              1206
HEXSEVEN            121E
HEXSIX              121A
HEXSTRING           1442
HEXTHREE            120E
HEXTWO              120A
HEXVALUE            5030
HEXZERO             11FE
ILLEGAL             1492
INTRO               12EC
IO_WELCOME          10C4
IS_HEX_EVEN         127E
IS_LESSTHAN         125E
LF                  A
LOOP                14B6
LOOP_CHECK          14B8
LT                  1276
MOD                 2
NEW_LINE            12C0
NOTEVEN             12A8
PRINT_HEXVALUE      12B2
PS1                 1314
PS2                 135E
REMAINDER           5050
REPEAT              128A
SHIFTLEFT           11F8
STACK               7000
START               14AA
STR_LEN             5020
TRUE                1
