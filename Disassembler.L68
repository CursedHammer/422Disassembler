0000466C Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/2/2016 2:24:00 PM

00000000                             1  ******************************************************************************
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Brandon Authier (Hblkr), Jack S. Eldridge
00000000                             4  *              (JackScottie), Marijn Burger (marijnburger)
00000000                             5  * Date       : 16 May 2016
00000000                             6  * Description: An inverse assembler that will convert a memory
00000000                             7  *              image of instructions and data back to the display.
00000000                             8  *              The following will be decoded:
00000000                             9  *
00000000                            10  *              Addressing Modes
00000000                            11  *
00000000                            12  *                Data Register Direct
00000000                            13  *                Address Register Direct
00000000                            14  *                Address Register Indirect
00000000                            15  *                Immediate Data
00000000                            16  *                Address Register Indirect with Post Increment
00000000                            17  *                Address Register Indirect with Pre Decrement
00000000                            18  *                Absolute Long Address
00000000                            19  *                Absolute Word Address
00000000                            20  *
00000000                            21  *              Instructions
00000000                            22  *
00000000                            23  *                NOP
00000000                            24  *                MOVE
00000000                            25  *                MOVEA
00000000                            26  *                MOVEQ
00000000                            27  *                MOVEM
00000000                            28  *                ADD
00000000                            29  *                ADDA
00000000                            30  *                ADDI
00000000                            31  *                ADDQ
00000000                            32  *                SUB
00000000                            33  *                MULS
00000000                            34  *                DIVU
00000000                            35  *                LEA
00000000                            36  *                CLR
00000000                            37  *                AND
00000000                            38  *                OR
00000000                            39  *                LSL
00000000                            40  *                LSR
00000000                            41  *                ASR
00000000                            42  *                ASL
00000000                            43  *                ROL
00000000                            44  *                ROR
00000000                            45  *                CMP
00000000                            46  *                Bcc (BCC, BGT, BLE)
00000000                            47  *                JSR
00000000                            48  *                RTS
00000000                            49  *
00000000                            50  ******************************************************************************
00000000                            51  
00000000                            52  ******************************************************************************
00000000                            53  *           DEFINITIONS                                                      *
00000000                            54  ******************************************************************************
00000000  =00007000                 55  STACK     EQU   $7000               * Beginning address for stack pointer
00000000                            56  
00000000  =00005000                 57  BEGINADDR EQU   $5000               * Variable to hold beginning address value
00000000  =00005010                 58  ENDADDR   EQU   $5010               * Variable to hold ending address value
00000000                            59  
00000000  =00006000                 60  RUNAGAIN  EQU   $6000               * Value equivalent to 'true'
00000000                            61  
00001000                            62            ORG   $1000               * Program begins at address 1000
00001000                            63  
00001000                            64  *********** END DEFINITIONS **************************************************
00001000                            65  
00001000                            66  
00001000                            67  ******************************************************************************
00001000                            68  *           INCLUDES                                                         *
00001000                            69  ******************************************************************************
00001000                            70  
00001000                            71      INCLUDE 'IO.X68'
00001000                            72  
00001000                            73  
00001000                            74  
00001000  =00005020                 75  STR_LEN   EQU   $5020
00001000  =00005021                 76  HEXFLAG   EQU   $5021
00001000  =00005030                 77  HEXVALUE  EQU   $5030
00001000  =00005050                 78  REMAINDER EQU   $5050
00001000  =00000002                 79  MOD       EQU   2
00001000                            80  
00001000  =0000000D                 81  CR        EQU   $0D
00001000  =0000000A                 82  LF        EQU   $0A
00001000                            83  
00001000                            84  
00001000                            85  GET_ADDRESSES
00001000  4EB9 000012D0             86      JSR         CLEARSCRN
00001006  4EB9 000010C4             87      JSR         IO_WELCOME          * Run welcome subroutine
0000100C                            88  
0000100C                            89  GET_FIRST_ADDRESS
0000100C  43F9 0000136C             90      LEA         PS1,A1              * Loads message into A1
00001012  4EB9 000010F2             91      JSR         GET_HEXSTRING       * Get string from user
00001018  0C38 0001 5021            92      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000101E  66EC                      93      BNE         GET_FIRST_ADDRESS   * If no, get hex again
00001020                            94  
00001020  4EB9 00001124             95      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001026  0C38 0001 5021            96      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000102C  66DE                      97      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000102E                            98  
0000102E  4EB9 00001280             99      JSR         IS_HEX_EVEN         * Check that hex value is even
00001034  0C38 0001 5021           100      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000103A  66D0                     101      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000103C                           102  
0000103C  21F8 5030 5000           103      MOVE.L      HEXVALUE,BEGINADDR  * Copy hex value to begin
00001042  43F9 000013FE            104      LEA         BMESSAGE,A1         * Load message in A1 for display
00001048  2238 5030                105      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display
0000104C  4EB9 000012C2            106      JSR         NEW_LINE            * Space
00001052                           107  
00001052  4EB9 000010D8            108      JSR         CLEAR               * Clear values for next hex
00001058                           109  
00001058                           110  GET_SECOND_ADDRESS
00001058  43F9 000013B6            111      LEA         PS2,A1              * Loads message into A1
0000105E  4EB9 000010F2            112      JSR         GET_HEXSTRING       * Get string from user
00001064  0C38 0001 5021           113      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000106A  66EC                     114      BNE         GET_SECOND_ADDRESS  * If no, get hex again
0000106C                           115  
0000106C  4EB9 00001124            116      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001072  0C38 0001 5021           117      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001078  66DE                     118      BNE         GET_SECOND_ADDRESS  * If no, get hex again
0000107A                           119  
0000107A  4EB9 00001280            120      JSR         IS_HEX_EVEN         * Check that hex value is even
00001080  0C38 0001 5021           121      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001086  66D0                     122      BNE         GET_SECOND_ADDRESS  * If no, get hex again
00001088                           123  
00001088  21F8 5030 5010           124      MOVE.L      HEXVALUE,ENDADDR    * Copy hex value to begin
0000108E  43F9 0000141D            125      LEA         EMESSAGE,A1         * Load message in A1 for display
00001094  2238 5030                126      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display
00001098  4EB9 000012C2            127      JSR         NEW_LINE            * Space
0000109E                           128  
0000109E  4EB9 000010D8            129      JSR         CLEAR               * Clear values for next hex
000010A4                           130  
000010A4                           131  CHECK_BADDR_IS_LESS_THAN_EADDR
000010A4  4EB9 00001260            132      JSR         IS_LESSTHAN         *
000010AA  0C38 0001 5021           133      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000010B0  6700 0010                134      BEQ         FINISHED            * If yes, finished
000010B4  43F9 0000143C            135      LEA         ADR_ERR_NOTLT,A1    * Else, load error message
000010BA  6100 0220                136      BSR.W       ADDRESS_ERR
000010BE  6100 35AB                137      BSR.W       START
000010C2                           138  
000010C2                           139  
000010C2                           140  FINISHED
000010C2  4E75                     141      RTS                             * Return to Disassembler
000010C4                           142  
000010C4                           143  
000010C4                           144  
000010C4                           145  
000010C4                           146  
000010C4                           147  IO_WELCOME:
000010C4  43F9 00001344            148      LEA         INTRO,A1            * Loads message into A1
000010CA  103C 000E                149      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010CE  4E4F                     150      TRAP        #15                 * Displays Intro Message
000010D0                           151  
000010D0  4EB9 000012C2            152      JSR         NEW_LINE            * Call Subroutine
000010D6  4E75                     153      RTS                             * Return from subroutine
000010D8                           154  
000010D8                           155  
000010D8                           156  
000010D8                           157  CLEAR
000010D8  4286                     158      CLR.L       D6                   * Clear
000010DA  31FC FFFF 5020           159      MOVE.W      #$FFFF,STR_LEN       * Clear
000010E0  21FC FFFFFFFF 5030       160      MOVE.L      #$FFFFFFFF,HEXVALUE  * Clear
000010E8  21FC FFFFFFFF 5050       161      MOVE.L      #$FFFFFFFF,REMAINDER * Clear
000010F0  4E75                     162      RTS                              * Return to main to get hex
000010F2                           163  
000010F2                           164  
000010F2                           165  
000010F2                           166  GET_HEXSTRING
000010F2  103C 000E                167      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010F6  323C 004A                168      MOVE.W      #(PS2-PS1),D1       * The prompt string length
000010FA  4E4F                     169      TRAP        #15                 * Displays contents of A1
000010FC                           170  
000010FC  43F9 00001497            171      LEA         HEXSTRING,A1        * Pointer to store the sentence
00001102  103C 0002                172      MOVE.B      #2,D0               * Set up readstring function
00001106  4E4F                     173      TRAP        #15                 * Get string from keyboard
00001108  11C1 5020                174      MOVE.B      D1,STR_LEN          * Save length of input string
0000110C                           175  
0000110C  0C38 0008 5020           176      CMPI.B      #8,(STR_LEN)        * Is length > 8?
00001112  6E00 FEF8                177      BGT         GET_FIRST_ADDRESS   * If yes, get hex again
00001116                           178  
00001116  41F9 00001497            179      LEA         HEXSTRING,A0        * Load address for verification
0000111C  11FC 0001 5021           180      MOVE.B      #1,(HEXFLAG)
00001122  4E75                     181      RTS                             * Return from subroutine
00001124                           182  
00001124                           183  
00001124                           184  
00001124                           185  ASCII_TO_HEX
00001124  1618                     186      MOVE.B      (A0)+,D3            * Move first char into D3
00001126  0C03 0030                187      CMPI.B      #'0',D3             * Is Char equal to 0?
0000112A  6700 00D4                188      BEQ         HEXZERO
0000112E  0C03 0031                189      CMPI.B      #'1',D3             * Is Char equal to 1?
00001132  6700 00D4                190      BEQ         HEXONE
00001136  0C03 0032                191      CMPI.B      #'2',D3             * Is Char equal to 2?
0000113A  6700 00D0                192      BEQ         HEXTWO
0000113E  0C03 0033                193      CMPI.B      #'3',D3             * Is Char equal to 3?
00001142  6700 00CC                194      BEQ         HEXTHREE
00001146  0C03 0034                195      CMPI.B      #'4',D3             * Is Char equal to 4?
0000114A  6700 00C8                196      BEQ         HEXFOUR
0000114E  0C03 0035                197      CMPI.B      #'5',D3             * Is Char equal to 5?
00001152  6700 00C4                198      BEQ         HEXFIVE
00001156  0C03 0036                199      CMPI.B      #'6',D3             * Is Char equal to 6?
0000115A  6700 00C0                200      BEQ         HEXSIX
0000115E  0C03 0037                201      CMPI.B      #'7',D3             * Is Char equal to 7?
00001162  6700 00BC                202      BEQ         HEXSEVEN
00001166  0C03 0038                203      CMPI.B      #'8',D3             * Is Char equal to 8?
0000116A  6700 00B8                204      BEQ         HEXEIGHT
0000116E  0C03 0039                205      CMPI.B      #'9',D3             * Is Char equal to 9?
00001172  6700 00B4                206      BEQ         HEXNINE
00001176  0C03 0041                207      CMPI.B      #'A',D3             * Is Char equal to A?
0000117A  6700 00B4                208      BEQ         HEXA
0000117E  0C03 0042                209      CMPI.B      #'B',D3             * Is Char equal to B?
00001182  6700 00B4                210      BEQ         HEXB
00001186  0C03 0043                211      CMPI.B      #'C',D3             * Is Char equal to C?
0000118A  6700 00B4                212      BEQ         HEXC
0000118E  0C03 0044                213      CMPI.B      #'D',D3             * Is Char equal to D?
00001192  6700 00B4                214      BEQ         HEXD
00001196  0C03 0045                215      CMPI.B      #'E',D3             * Is Char equal to E?
0000119A  6700 00B4                216      BEQ         HEXE
0000119E  0C03 0046                217      CMPI.B      #'F',D3             * Is Char equal to F?
000011A2  6700 00B4                218      BEQ         HEXF
000011A6  0C03 0061                219      CMPI.B      #'a',D3             * Is Char equal to a?
000011AA  6700 0084                220      BEQ         HEXA
000011AE  0C03 0062                221      CMPI.B      #'b',D3             * Is Char equal to b?
000011B2  6700 0084                222      BEQ         HEXB
000011B6  0C03 0063                223      CMPI.B      #'c',D3             * Is Char equal to c?
000011BA  6700 0084                224      BEQ         HEXC
000011BE  0C03 0064                225      CMPI.B      #'d',D3             * Is Char equal to d?
000011C2  6700 0084                226      BEQ         HEXD
000011C6  0C03 0065                227      CMPI.B      #'e',D3             * Is Char equal to e?
000011CA  6700 0084                228      BEQ         HEXE
000011CE  0C03 0066                229      CMPI.B      #'f',D3             * Is Char equal to f?
000011D2  6700 0084                230      BEQ         HEXF
000011D6                           231  
000011D6  11FC 0000 5021           232      MOVE.B      #0,HEXFLAG          * Set false
000011DC  6000 FEFA                233      BRA         CLEAR               * Clear some values
000011E0                           234  
000011E0                           235  FOUND
000011E0  5338 5020                236      SUBI.B      #1,STR_LEN          * Decrease string by one
000011E4  0C38 0000 5020           237      CMPI.B      #0,STR_LEN          * Is string = 0?
000011EA  6600 000E                238      BNE         SHIFTLEFT           * If no, shift value left
000011EE  21C6 5030                239      MOVE.L      D6,HEXVALUE         * If yes, save hex value
000011F2  11FC 0001 5021           240      MOVE.B      #1,HEXFLAG          * Set true
000011F8  4E75                     241      RTS                             * Then, return to main
000011FA                           242  
000011FA                           243  SHIFTLEFT
000011FA  E98E                     244      LSL.L       #4,D6               * Shift the value left
000011FC  6000 FF26                245      BRA         ASCII_TO_HEX        * Check next char
00001200                           246  
00001200                           247  HEXZERO
00001200  0686 00000000            248      ADD.L       #$0,D6              * Add value
00001206  60D8                     249      BRA         FOUND               * found, decrease strlen, shift value left
00001208                           250  HEXONE
00001208  5286                     251      ADD.L       #$1,D6              * Add value
0000120A  60D4                     252      BRA         FOUND               * found, decrease strlen, shift value left
0000120C                           253  HEXTWO
0000120C  5486                     254      ADD.L       #$2,D6              * Add value
0000120E  60D0                     255      BRA         FOUND               * found, decrease strlen, shift value left
00001210                           256  HEXTHREE
00001210  5686                     257      ADD.L       #$3,D6              * Add value
00001212  60CC                     258      BRA         FOUND               * found, decrease strlen, shift value left
00001214                           259  HEXFOUR
00001214  5886                     260      ADD.L       #$4,D6              * Add value
00001216  60C8                     261      BRA         FOUND               * found, decrease strlen, shift value left
00001218                           262  HEXFIVE
00001218  5A86                     263      ADD.L       #$5,D6              * Add value
0000121A  60C4                     264      BRA         FOUND               * found, decrease strlen, shift value left
0000121C                           265  HEXSIX
0000121C  5C86                     266      ADD.L       #$6,D6              * Add value
0000121E  60C0                     267      BRA         FOUND               * found, decrease strlen, shift value left
00001220                           268  HEXSEVEN
00001220  5E86                     269      ADD.L       #$7,D6              * Add value
00001222  60BC                     270      BRA         FOUND               * found, decrease strlen, shift value left
00001224                           271  HEXEIGHT
00001224  5086                     272      ADD.L       #$8,D6              * Add value
00001226  60B8                     273      BRA         FOUND               * found, decrease strlen, shift value left
00001228                           274  HEXNINE
00001228  0686 00000009            275      ADD.L       #$9,D6              * Add value
0000122E  60B0                     276      BRA         FOUND               * found, decrease strlen, shift value left
00001230                           277  HEXA
00001230  0686 0000000A            278      ADD.L       #$A,D6              * Add value
00001236  60A8                     279      BRA         FOUND               * found, decrease strlen, shift value left
00001238                           280  HEXB
00001238  0686 0000000B            281      ADD.L       #$B,D6              * Add value
0000123E  60A0                     282      BRA         FOUND               * found, decrease strlen, shift value left
00001240                           283  HEXC
00001240  0686 0000000C            284      ADD.L       #$C,D6              * Add value
00001246  6098                     285      BRA         FOUND               * found, decrease strlen, shift value left
00001248                           286  HEXD
00001248  0686 0000000D            287      ADD.L       #$D,D6              * Add value
0000124E  6090                     288      BRA         FOUND               * found, decrease strlen, shift value left
00001250                           289  HEXE
00001250  0686 0000000E            290      ADD.L       #$E,D6              * Add value
00001256  6088                     291      BRA         FOUND               * found, decrease strlen, shift value left
00001258                           292  HEXF
00001258  0686 0000000F            293      ADD.L       #$F,D6              * Add value
0000125E  6080                     294      BRA         FOUND               * found, decrease strlen, shift value left
00001260                           295  
00001260                           296  
00001260                           297  
00001260                           298  IS_LESSTHAN
00001260  2838 5000                299      MOVE.L      BEGINADDR,D4        * Store beginning address in D4
00001264  2C38 5010                300      MOVE.L      ENDADDR,D6          * Store ending address in D6
00001268  B886                     301      CMP.L       D6,D4               * Is D4 < D6
0000126A  6D00 000C                302      BLT         LT                  * Yes, mark true return to main
0000126E  11FC 0000 5021           303      MOVE.B      #0,HEXFLAG          * No, mark false
00001274  6000 FE62                304      BRA         CLEAR               * Clear values, return to main
00001278                           305  
00001278                           306  LT
00001278  11FC 0001 5021           307      MOVE.B      #1,HEXFLAG          * Mark true
0000127E  4E75                     308      RTS                             * Return to main
00001280                           309  
00001280                           310  
00001280                           311  
00001280                           312  IS_HEX_EVEN
00001280  3606                     313      MOVE.W      D6,D3               * Move value to be modded into D3
00001282  3A3C 0002                314      MOVE.W      #MOD,D5             * Move mod value into D5
00001286  86C5                     315      DIVU        D5,D3               * Divide D3 by D5
00001288  123C 0003                316      MOVE.B      #3,D1               * Set counter to shift value into word
0000128C                           317                                      * position
0000128C                           318  REPEAT
0000128C  E88B                     319      LSR.L       #4,D3               * Shift remainder to lower word
0000128E  57C9 FFFC                320      DBEQ        D1,REPEAT           * UNTIL [D0] = - 1
00001292  4241                     321      CLR         D1                  * Clear
00001294                           322  
00001294  B6BC 00000000            323      CMP.L       #0,D3               * Is hex even?
0000129A  6600 000E                324      BNE         NOTEVEN             * No, clear and go back to get_hex
0000129E  31C3 5050                325      MOVE.W      D3,REMAINDER        * Save remainder
000012A2  11FC 0001 5021           326      MOVE.B      #1,HEXFLAG          * Set true
000012A8  4E75                     327      RTS                             * Return to main
000012AA                           328  
000012AA                           329  NOTEVEN
000012AA  11FC 0000 5021           330      MOVE.B      #0,HEXFLAG          * Set false
000012B0  6000 FE26                331      BRA         CLEAR               * Clear values
000012B4                           332  
000012B4                           333  
000012B4                           334  
000012B4                           335  PRINT_HEXVALUE
000012B4  103C 000E                336      MOVE.B      #14,D0              * Moves the Task 14 into D0
000012B8  4E4F                     337      TRAP        #15                 * Displays contents of A1
000012BA                           338  
000012BA  103C 0003                339      MOVE.B      #3,D0               * Moves the Task 3 into D0
000012BE  4E4F                     340      TRAP        #15                 * Displays contents of D1
000012C0                           341  
000012C0  4E75                     342      RTS                             * Return from subroutine
000012C2                           343  
000012C2                           344  
000012C2                           345  NEW_LINE
000012C2  43F9 00004622            346      LEA         ENDL,A1             * Loads message into A1
000012C8  103C 000E                347      MOVE.B      #14,D0              * Moves the TRACK 14 into D0
000012CC  4E4F                     348      TRAP        #15                 * Displays New line
000012CE  4E75                     349      RTS                             * Return from subroutine
000012D0                           350  
000012D0                           351  
000012D0                           352  CLEARSCRN
000012D0  103C 000B                353      MOVE.B      #11,D0              * Task 11 for clearing screen
000012D4  323C FF00                354      MOVE.W      #$FF00,D1           * FF00, Clear screen
000012D8  4E4F                     355      TRAP        #15                 * Wait for keystroke
000012DA  4E75                     356      RTS                             * Return from subroutine
000012DC                           357  
000012DC                           358  
000012DC                           359  
000012DC                           360  
000012DC                           361  ADDRESS_ERR
000012DC  6100 FFF2                362      BSR.W       CLEARSCRN           * Clear output before displaying error
000012E0  103C 000D                363      MOVE.B      #13,D0              * Moves the Task 13 into D0
000012E4  4E4F                     364      TRAP        #15                 * Displays contents of A1
000012E6  103C 0005                365      MOVE.B      #5,D0               * Read single character from
000012EA  4E4F                     366      TRAP        #15                 * The keyboard into D1.B
000012EC  4E75                     367      RTS                             * Return from subroutine
000012EE                           368  
000012EE                           369  
000012EE                           370  
000012EE                           371  INVALID_DATA
000012EE  220E                     372      MOVE.L      A6,D1               * Move the address location to D1
000012F0  143C 0010                373      MOVE.B      #16,D2              * Move base 16 to D2
000012F4  103C 000F                374      MOVE.B      #15,D0              * Moves Task 15 into D0
000012F8  4E4F                     375      TRAP        #15                 * Displays contents of D1
000012FA                           376  
000012FA  43F9 00004666            377      LEA         TAB,A1              * Load TAB to A1
00001300  103C 000E                378      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001304  4E4F                     379      TRAP        #15                 * Displays a tab of A1
00001306                           380  
00001306  43F9 000014E7            381      LEA         DATA,A1             * Load address location to A1
0000130C  103C 000E                382      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001310  4E4F                     383      TRAP        #15                 * Displays location of A1
00001312                           384  
00001312  43F9 00004666            385      LEA         TAB,A1              * Load TAB to A1
00001318  103C 000E                386      MOVE.B      #14,D0              * Moves the Task 14 into D0
0000131C  4E4F                     387      TRAP        #15                 * Displays a tab of A1
0000131E                           388  
0000131E  43F9 00004657            389      LEA         DOLLAR,A1           * Load TAB to A1
00001324  103C 000E                390      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001328  4E4F                     391      TRAP        #15                 * Displays a tab of A1
0000132A                           392  
0000132A  3216                     393      MOVE.W      (A6),D1             * Move the address value to D1
0000132C  143C 0010                394      MOVE.B      #16,D2              * Move base 16 to D2
00001330  103C 000F                395      MOVE.B      #15,D0              * Moves Task 15 into D0
00001334  4E4F                     396      TRAP        #15                 * Displays value of D1
00001336                           397  
00001336  43F9 00004622            398      LEA         ENDL,A1             * Load TAB to A1
0000133C  103C 000E                399      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001340  4E4F                     400      TRAP        #15                 * Displays a tab of A1
00001342                           401  
00001342  4E75                     402      RTS                             * Return from subroutine
00001344                           403  
00001344                           404  
00001344                           405  
00001344                           406  
00001344= 57 45 4C 43 4F 4D ...    407  INTRO           DC.B 'WELCOME!',CR,LF,'THIS IS A 68K DISASSEMBLER.',CR,LF,0
0000136C= 50 4C 45 41 53 45 ...    408  PS1             DC.B 'PLEASE ENTER THE STARTING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000013B6= 50 4C 45 41 53 45 ...    409  PS2             DC.B 'PLEASE ENTER THE ENDING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000013FE= 0D 0A 42 45 47 49 ...    410  BMESSAGE        DC.B CR,LF,'BEGINNING ADDRESS GIVEN IS: ',0
0000141D= 0D 0A 45 4E 44 49 ...    411  EMESSAGE        DC.B CR,LF,'ENDING ADDRESS GIVEN IS   : ',0
0000143C                           412  
0000143C= 54 48 45 20 42 45 ...    413  ADR_ERR_NOTLT   DC.B 'THE BEGINNING ADDRESS MUST BE LESS THAN THE ENDING ADDRESS.',CR,LF,'PRESS ANY KEY TO TRY AGAIN...',0
00001497                           414  
00001497                           415  HEXSTRING       DS.B 80             * Var for hex string
000014E7                           416  
000014E7= 44 41 54 41 00           417  DATA            DC.B 'DATA',0
000014EC                           418  
000014EC                           419  
000014EC                           420  
000014EC                           421  
000014EC                           422  
000014EC                           423  
000014EC                           424  
000014EC                           425  
000014EC                           426  
000014EC                           427  -------------------- end include --------------------
000014EC                           428      INCLUDE 'OpCodes.X68'
000014EC                           429  
000014EC                           430          INCLUDE 'OCMessages.X68'
000014EC                           431  
000014EC                           432  
000014EC  =0000000D                433  CR      EQU     $0D
000014EC  =0000000A                434  LF      EQU     $0A
000014EC= 20 00                    435  MESSAGESPACE DC.B  ' ',0
000014EE= 4E 4F 50 00              436  MESSAGENOP DC.B    'NOP',0
000014F2                           437  
000014F2= 4D 4F 56 45 2E 57 00     438  MESSAGEMOVEW DC.B    'MOVE.W',0
000014F9= 4D 4F 56 45 2E 4C 00     439  MESSAGEMOVEL DC.B    'MOVE.L',0
00001500= 4D 4F 56 45 2E 42 00     440  MESSAGEMOVEB DC.B    'MOVE.B',0
00001507                           441  
00001507= 41 44 44 49 2E 57 00     442  MESSAGEADDIW DC.B    'ADDI.W',0
0000150E= 41 44 44 49 2E 4C 00     443  MESSAGEADDIL DC.B    'ADDI.L',0
00001515= 41 44 44 49 2E 42 00     444  MESSAGEADDIB DC.B    'ADDI.B',0
0000151C                           445  
0000151C= 4D 4F 56 45 41 2E ...    446  MESSAGEMOVEAL DC.B    'MOVEA.L',0
00001524= 4D 4F 56 45 41 2E ...    447  MESSAGEMOVEAW DC.B    'MOVEA.W',0
0000152C                           448  
0000152C= 4D 4F 56 45 4D 2E ...    449  MESSAGEMOVEML DC.B    'MOVEM.L',0
00001534= 4D 4F 56 45 4D 2E ...    450  MESSAGEMOVEMW DC.B    'MOVEM.W',0
0000153C                           451  
0000153C= 4A 53 52 00              452  MESSAGEJSR DC.B    'JSR',0
00001540                           453  
00001540= 43 4C 52 00              454  MESSAGECLR DC.B    'CLR',0
00001544                           455  
00001544= 52 54 53 00              456  MESSAGERTS DC.B    'RTS',0
00001548                           457  
00001548= 4C 45 41 00              458  MESSAGELEA DC.B    'LEA',0
0000154C                           459  
0000154C= 43 4C 52 2E 42 00        460  MESSAGECLRB DC.B    'CLR.B',0
00001552= 43 4C 52 2E 57 00        461  MESSAGECLRW DC.B    'CLR.W',0
00001558= 43 4C 52 2E 4C 00        462  MESSAGECLRL DC.B    'CLR.L',0
0000155E                           463  
0000155E= 41 44 44 51 2E 42 00     464  MESSAGEADDQB DC.B    'ADDQ.B',0
00001565= 41 44 44 51 2E 57 00     465  MESSAGEADDQW DC.B    'ADDQ.W',0
0000156C= 41 44 44 51 2E 4C 00     466  MESSAGEADDQL DC.B    'ADDQ.L',0
00001573                           467  
00001573= 43 4D 50 2E 42 00        468  MESSAGECMPB DC.B    'CMP.B',0
00001579= 43 4D 50 2E 57 00        469  MESSAGECMPW DC.B    'CMP.W',0
0000157F= 43 4D 50 2E 4C 00        470  MESSAGECMPL DC.B    'CMP.L',0
00001585                           471  
00001585= 53 55 42 2E 42 00        472  MESSAGESUBB DC.B    'SUB.B',0
0000158B= 53 55 42 2E 57 00        473  MESSAGESUBW DC.B    'SUB.W',0
00001591= 53 55 42 2E 4C 00        474  MESSAGESUBL DC.B    'SUB.L',0
00001597                           475  
00001597= 41 44 44 2E 42 00        476  MESSAGEADDB DC.B    'ADD.B',0
0000159D= 41 44 44 2E 57 00        477  MESSAGEADDW DC.B    'ADD.W',0
000015A3= 41 44 44 2E 4C 00        478  MESSAGEADDL DC.B    'ADD.L',0
000015A9                           479  
000015A9= 41 44 44 41 2E 57 00     480  MESSAGEADDAW DC.B    'ADDA.W',0
000015B0= 41 44 44 41 2E 4C 00     481  MESSAGEADDAL DC.B    'ADDA.L',0
000015B7                           482  
000015B7= 4D 4F 56 45 51 2E ...    483  MESSAGEMOVEQL DC.B    'MOVEQ.L',0
000015BF                           484  
000015BF= 41 4E 44 2E 42 00        485  MESSAGEANDB DC.B    'AND.B',0
000015C5= 41 4E 44 2E 57 00        486  MESSAGEANDW DC.B    'AND.W',0
000015CB= 41 4E 44 2E 4C 00        487  MESSAGEANDL DC.B    'AND.L',0
000015D1                           488  
000015D1= 4D 55 4C 53 2E 57 00     489  MESSAGEMULSW DC.B    'MULS.W',0
000015D8                           490  
000015D8= 41 53 52 2E 42 00        491  MESSAGEASRB DC.B    'ASR.B',0
000015DE= 41 53 52 2E 57 00        492  MESSAGEASRW DC.B    'ASR.W',0
000015E4= 41 53 52 2E 4C 00        493  MESSAGEASRL DC.B    'ASR.L',0
000015EA                           494  
000015EA= 41 53 4C 2E 42 00        495  MESSAGEASLB DC.B    'ASL.B',0
000015F0= 41 53 4C 2E 57 00        496  MESSAGEASLW DC.B    'ASL.W',0
000015F6= 41 53 4C 2E 4C 00        497  MESSAGEASLL DC.B    'ASL.L',0
000015FC                           498  
000015FC= 52 4F 52 2E 42 00        499  MESSAGERORB DC.B    'ROR.B',0
00001602= 52 4F 52 2E 57 00        500  MESSAGERORW DC.B    'ROR.W',0
00001608= 52 4F 52 2E 4C 00        501  MESSAGERORL DC.B    'ROR.L',0
0000160E                           502  
0000160E= 52 4F 4C 2E 42 00        503  MESSAGEROLB DC.B    'ROL.B',0
00001614= 52 4F 4C 2E 57 00        504  MESSAGEROLW DC.B    'ROL.W',0
0000161A= 52 4F 4C 2E 4C 00        505  MESSAGEROLL DC.B    'ROL.L',0
00001620                           506  
00001620= 4C 53 52 2E 42 00        507  MESSAGELSRB DC.B    'LSR.B',0
00001626= 4C 53 52 2E 57 00        508  MESSAGELSRW DC.B    'LSR.W',0
0000162C= 4C 53 52 2E 4C 00        509  MESSAGELSRL DC.B    'LSR.L',0
00001632                           510  
00001632= 4C 53 4C 2E 42 00        511  MESSAGELSLB DC.B    'LSL.B',0
00001638= 4C 53 4C 2E 57 00        512  MESSAGELSLW DC.B    'LSL.W',0
0000163E= 4C 53 4C 2E 4C 00        513  MESSAGELSLL DC.B    'LSL.L',0
00001644                           514  
00001644= 4F 52 2E 42 00           515  MESSAGEORB DC.B    'OR.B',0
00001649= 4F 52 2E 57 00           516  MESSAGEORW DC.B    'OR.W',0
0000164E= 4F 52 2E 4C 00           517  MESSAGEORL DC.B    'OR.L',0
00001653                           518  
00001653= 44 49 56 55 2E 57 00     519  MESSAGEDIVUW DC.B    'DIVU.W',0
0000165A                           520  
0000165A= 42 43 43 00              521  MESSAGEBCC DC.B    'BCC',0
0000165E= 42 47 54 00              522  MESSAGEBGT DC.B    'BGT',0
00001662= 42 4C 45 00              523  MESSAGEBLE DC.B    'BLE',0
00001666                           524  
00001666= 54 68 61 74 20 69 ...    525  MESSAGEOPCODE_INVALID DC.B    'That is not an opcode!', 0
0000167D                           526  
0000167D                           527  
0000167D                           528  
0000167D                           529  
0000167D                           530  -------------------- end include --------------------
0000167D                           531  
0000167D                           532  
0000167D                           533  OC_PARSE:
0000167E  48E7 FFFE                534          MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001682  41F9 0000169A            535          LEA         initial_table,A0 ; Index into the table
00001688  4280                     536          CLR.L       D0              ; Zero it
0000168A  3012                     537          MOVE.W      (A2),D0         ; We'll play with it here
0000168C  123C 000C                538          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001690  E268                     539          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001692                           540                                      ; and the rest are zeroed out)
00001692  C0FC 0006                541          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001696  4EF0 0000                542          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000169A                           543  
0000169A                           544  initial_table:
0000169A  4EF9 000016FA            545          JMP         code0000        ; ADDI.B, ADDI.W, or ADDI.L
000016A0  4EF9 00001700            546          JMP         code0001        ; MOVE.B
000016A6  4EF9 0000170C            547          JMP         code0010        ; MOVEA.L or MOVE.L
000016AC  4EF9 00001712            548          JMP         code0011        ; MOVEA.W or MOVE.W
000016B2  4EF9 00001718            549          JMP         code0100        ; NOP or MOVEM.W or MOVEM.L or LEA or CLR.B or CLR.W or CLR.L or JSR or RTS or MULS.W
000016B8  4EF9 00001724            550          JMP         code0101        ; ADDQ.B or ADDQ.W or ADDQ.L
000016BE  4EF9 00001730            551          JMP         code0110        ; BCC or BGT or BLE
000016C4  4EF9 0000173C            552          JMP         code0111        ; MOVEQ.L
000016CA  4EF9 00001748            553          JMP         code1000        ; OR.B or OR.W or OR.L or DIVU (DIVU is either word or long depending on ea)
000016D0  4EF9 00001754            554          JMP         code1001        ; SUB.B or SUB.W or SUB.L
000016D6  4EF9 00001760            555          JMP         code1010
000016DC  4EF9 00001768            556          JMP         code1011        ; CMP.B or CMP.W or CMP.L
000016E2  4EF9 00001774            557          JMP         code1100        ; AND_BorAND_WorAND_LorMULS_W
000016E8  4EF9 00001780            558          JMP         code1101        ; ADD.B or ADD.W or ADD.L
000016EE  4EF9 0000178C            559          JMP         code1110        ; ROd_LSd_ASd
000016F4  4EF9 00001798            560          JMP         code1111
000016FA                           561  
000016FA  4EB9 00002084            562  code0000 JSR        ADDI_BorADDI_WorADDI_L
00001700  4EB9 000029F0            563  code0001 JSR        ISMOVEB
00001706  4EB9 000017A0            564           JSR        DONE
0000170C  4EB9 000020DA            565  code0010 JSR        MOVEA_LorMOVE_L
00001712  4EB9 00002168            566  code0011 JSR        MOVEA_WorMOVE_W
00001718  4EB9 00001F86            567  code0100 JSR        NOP_MOVEM_LEA_JSR_CLR_RTS
0000171E  4EB9 000017A0            568           JSR        DONE
00001724  4EB9 00001D80            569  code0101 JSR        ADDQ_BorADDQ_WorADDQ_L
0000172A  4EB9 000017A0            570           JSR        DONE
00001730  4EB9 000017A6            571  code0110 JSR        BCCorBGTorBLE
00001736  4EB9 000017A0            572           JSR        DONE
0000173C  4EB9 000027E6            573  code0111 JSR        ISMOVEQL
00001742  4EB9 000017A0            574           JSR        DONE
00001748  4EB9 000017FC            575  code1000 JSR        OR_BorOR_WorOR_LorDIVU
0000174E  4EB9 000017A0            576           JSR        DONE
00001754  4EB9 00001C9C            577  code1001 JSR        SUB_BorSUB_WorSUB_L
0000175A  4EB9 000017A0            578           JSR        DONE
00001760  4EB9 000021F6            579  code1010 JSR    OPCODE_INVALID              ;INVALID
00001766  4E75                     580           RTS
00001768  4EB9 00001D2A            581  code1011 JSR        CMP_BorCMP_WorCMP_L
0000176E  4EB9 000017A0            582           JSR        DONE
00001774  4EB9 00001B80            583  code1100 JSR        AND_BorAND_WorAND_LorMULS_W
0000177A  4EB9 000017A0            584           JSR        DONE
00001780  4EB9 00001C0E            585  code1101 JSR        ADD_BorADD_WorADD_L
00001786  4EB9 000017A0            586           JSR        DONE
0000178C  4EB9 00001B30            587  code1110 JSR        ROd_LSd_ASd
00001792  4EB9 000017A0            588           JSR        DONE
00001798  4EB9 000021F6            589  code1111 JSR    OPCODE_INVALID              ;INVALID
0000179E  4E75                     590           RTS
000017A0  4CDF 7FFF                591  DONE    MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000017A4  4E75                     592          RTS
000017A6                           593  
000017A6  41F9 000017C4            594  BCCorBGTorBLE       LEA     tableBCCorBGTorBLE, A0            ; Index into the table
000017AC  4280                     595                      CLR.L   D0                  ; Zero it
000017AE  3016                     596                      MOVE.W  (A6),D0         ; We'll play with it here
000017B0  123C 0006                597                      MOVE.B  #6,D1           ; Shift 6 bits left
000017B4  E360                     598                      ASL.W   D1,D0
000017B6  123C 000E                599                      MOVE.B  #14,D1           ; Shift 14 bits to the right
000017BA  E268                     600                      LSR.W   D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
000017BC                           601                                      ; and the rest are zeroed out)
000017BC  C0FC 0006                602                      MULU    #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
000017C0  4EF0 0000                603                      JMP     0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
000017C4                           604  
000017C4  4EF9 000017DC            605  tableBCCorBGTorBLE   JMP    BCCorBGTorBLEcode00   ; BCC
000017CA  4EF9 000017E4            606                       JMP    BCCorBGTorBLEcode01   ;
000017D0  4EF9 000017EC            607                       JMP    BCCorBGTorBLEcode10   ; BGT
000017D6  4EF9 000017F4            608                       JMP    BCCorBGTorBLEcode11   ; BLE
000017DC                           609  
000017DC                           610  
000017DC                           611  
000017DC  4EB9 00002206            612  BCCorBGTorBLEcode00    JSR     ISBCC
000017E2  4E75                     613                         RTS
000017E4  4EB9 000021F6            614  BCCorBGTorBLEcode01    JSR    OPCODE_INVALID              ;INVALID
000017EA  4E75                     615                         RTS
000017EC  4EB9 0000222A            616  BCCorBGTorBLEcode10    JSR     ISBGT
000017F2  4E75                     617                         RTS
000017F4  4EB9 0000224E            618  BCCorBGTorBLEcode11    JSR     ISBLE
000017FA  4E75                     619                         RTS
000017FC                           620  
000017FC                           621  
000017FC                           622  OR_BorOR_WorOR_LorDIVU:
000017FC  41F9 0000181A            623          LEA         tableOR_BorOR_WorOR_LorDIVU, A0 ; Index into the table
00001802  4280                     624          CLR.L       D0              ; Zero it
00001804  3016                     625          MOVE.W      (A6),D0     ; We'll play with it here
00001806  123C 0007                626          MOVE.B      #7,D1           ; Shift 7 bits left
0000180A  E360                     627          ASL.W       D1,D0
0000180C  123C 000D                628          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001810  E268                     629          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001812                           630                                      ; and the rest are zeroed out)
00001812  C0FC 0006                631          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001816  4EF0 0000                632          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000181A                           633  
0000181A                           634  tableOR_BorOR_WorOR_LorDIVU
0000181A  4EF9 0000184A            635          JMP         OR_DIVUcode000  ; OR.B
00001820  4EF9 00001852            636          JMP         OR_DIVUcode001  ; OR.W
00001826  4EF9 0000185A            637          JMP         OR_DIVUcode010  ; OR.L
0000182C  4EF9 00001862            638          JMP         OR_DIVUcode011  ; DIVU.W
00001832  4EF9 0000186A            639          JMP         OR_DIVUcode100  ; OR.B
00001838  4EF9 00001872            640          JMP         OR_DIVUcode101  ; OR.W
0000183E  4EF9 0000187A            641          JMP         OR_DIVUcode110  ; OR.L
00001844  4EF9 00001882            642          JMP         OR_DIVUcode111  ; INVALID
0000184A                           643  
0000184A                           644  
0000184A  4EB9 00002296            645  OR_DIVUcode000 JSR  ISORB
00001850  4E75                     646                 RTS
00001852  4EB9 000022BA            647  OR_DIVUcode001 JSR  ISORW
00001858  4E75                     648                 RTS
0000185A  4EB9 000022DE            649  OR_DIVUcode010 JSR  ISORL
00001860  4E75                     650                 RTS
00001862  4EB9 00002272            651  OR_DIVUcode011 JSR  ISDIVUW
00001868  4E75                     652                 RTS
0000186A  4EB9 00002296            653  OR_DIVUcode100 JSR  ISORB
00001870  4E75                     654                 RTS
00001872  4EB9 000022BA            655  OR_DIVUcode101 JSR  ISORW
00001878  4E75                     656                 RTS
0000187A  4EB9 000022DE            657  OR_DIVUcode110 JSR  ISORL
00001880  4E75                     658                 RTS
00001882  4EB9 000021F6            659  OR_DIVUcode111 JSR    OPCODE_INVALID              ;INVALID
00001888  4E75                     660                 RTS
0000188A                           661  
0000188A                           662  
0000188A                           663  someASR:
0000188A  41F9 000018A8            664          LEA         tableSomeASR, A0 ; Index into the table
00001890  4280                     665          CLR.L       D0              ; Zero it
00001892  3016                     666          MOVE.W      (A6),D0         ; We'll play with it here
00001894  123C 0008                667          MOVE.B      #8,D1           ; Shift 8 bits left
00001898  E360                     668          ASL.W       D1,D0
0000189A  123C 000E                669          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000189E  E268                     670          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000018A0                           671                                      ; and the rest are zeroed out)
000018A0  C0FC 0006                672          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000018A4  4EF0 0000                673          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000018A8                           674  
000018A8                           675  tableSomeASR:
000018A8  4EF9 000018C0            676          JMP         ASRcode00       *ASR.B
000018AE  4EF9 000018C8            677          JMP         ASRcode01       *ASR.W
000018B4  4EF9 000018D0            678          JMP         ASRcode10       *ASR.L
000018BA  4EF9 000018D8            679          JMP         ASRcode11       *ASR.W
000018C0                           680  
000018C0  4EB9 000022FE            681  ASRcode00 JSR       ISASRB
000018C6  4E75                     682            RTS
000018C8  4EB9 00002322            683  ASRcode01 JSR       ISASRW
000018CE  4E75                     684            RTS
000018D0  4EB9 00002346            685  ASRcode10 JSR       ISASRL
000018D6  4E75                     686            RTS
000018D8  4EB9 00002322            687  ASRcode11 JSR       ISASRW
000018DE  4E75                     688            RTS
000018E0                           689  
000018E0                           690  someASL:
000018E0  41F9 000018FE            691          LEA         tableSomeASL, A0 ; Index into the table
000018E6  4280                     692          CLR.L       D0              ; Zero it
000018E8  3016                     693          MOVE.W      (A6),D0     ; We'll play with it here
000018EA  123C 0008                694          MOVE.B      #8,D1           ; Shift 8 bits left
000018EE  E360                     695          ASL.W       D1,D0
000018F0  123C 000E                696          MOVE.B      #14,D1          ; Shift 14 bits to the right
000018F4  E268                     697          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000018F6                           698                                      ; and the rest are zeroed out)
000018F6  C0FC 0006                699          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000018FA  4EF0 0000                700          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000018FE                           701  
000018FE                           702  tableSomeASL:
000018FE  4EF9 00001916            703          JMP         ASLcode00       *ASL.B
00001904  4EF9 0000191E            704          JMP         ASLcode01       *ASL.W
0000190A  4EF9 00001926            705          JMP         ASLcode10       *ASL.L
00001910  4EF9 0000192E            706          JMP         ASLcode11       *ASL.W
00001916                           707  
00001916  4EB9 0000236A            708  ASLcode00 JSR       ISASLB
0000191C  4E75                     709            RTS
0000191E  4EB9 0000238E            710  ASLcode01 JSR       ISASLW
00001924  4E75                     711            RTS
00001926  4EB9 000023A8            712  ASLcode10 JSR       ISASLL
0000192C  4E75                     713            RTS
0000192E  4EB9 0000238E            714  ASLcode11 JSR       ISASLW
00001934  4E75                     715            RTS
00001936                           716  
00001936                           717  someLSR:
00001936  41F9 00001954            718          LEA         tableSomeLSR, A0 ; Index into the table
0000193C  4280                     719          CLR.L       D0              ; Zero it
0000193E  3016                     720          MOVE.W      (A6),D0     ; We'll play with it here
00001940  123C 0008                721          MOVE.B      #8,D1           ; Shift 8 bits left
00001944  E360                     722          ASL.W       D1,D0
00001946  123C 000E                723          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000194A  E268                     724          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000194C                           725                                      ; and the rest are zeroed out)
0000194C  C0FC 0006                726          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001950  4EF0 0000                727          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001954                           728  
00001954                           729  tableSomeLSR:
00001954  4EF9 0000196C            730          JMP         LSRcode00       *LSR.B
0000195A  4EF9 00001974            731          JMP         LSRcode01       *LSR.W
00001960  4EF9 0000197C            732          JMP         LSRcode10       *LSR.L
00001966  4EF9 00001984            733          JMP         LSRcode11       *LSR.W
0000196C  4EB9 000023CC            734  LSRcode00 JSR       ISLSRB
00001972  4E75                     735            RTS
00001974  4EB9 000023F0            736  LSRcode01 JSR       ISLSRW
0000197A  4E75                     737            RTS
0000197C  4EB9 00002414            738  LSRcode10 JSR       ISLSRL
00001982  4E75                     739            RTS
00001984  4EB9 000023F0            740  LSRcode11 JSR       ISLSRW
0000198A  4E75                     741            RTS
0000198C                           742  
0000198C                           743  someLSL:
0000198C  41F9 000019AA            744          LEA         tableSomeLSL, A0 ; Index into the table
00001992  4280                     745          CLR.L       D0              ; Zero it
00001994  3016                     746          MOVE.W      (A6),D0     ; We'll play with it here
00001996  123C 0008                747          MOVE.B      #8,D1           ; Shift 8 bits left
0000199A  E360                     748          ASL.W       D1,D0
0000199C  123C 000E                749          MOVE.B      #14,D1          ; Shift 14 bits to the right
000019A0  E268                     750          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000019A2                           751                                      ; and the rest are zeroed out)
000019A2  C0FC 0006                752          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000019A6  4EF0 0000                753          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000019AA                           754  
000019AA                           755  tableSomeLSL:
000019AA  4EF9 000019C2            756          JMP         LSLcode00       *LSL.B
000019B0  4EF9 000019CA            757          JMP         LSLcode01       *LSL.W
000019B6  4EF9 000019D2            758          JMP         LSLcode10       *LSL.L
000019BC  4EF9 000019DA            759          JMP         LSLcode11       *LSL.W
000019C2                           760  
000019C2  4EB9 00002438            761  LSLcode00 JSR       ISLSLB
000019C8  4E75                     762            RTS
000019CA  4EB9 00002452            763  LSLcode01 JSR       ISLSLW
000019D0  4E75                     764            RTS
000019D2  4EB9 00002476            765  LSLcode10 JSR       ISLSLL
000019D8  4E75                     766            RTS
000019DA  4EB9 00002452            767  LSLcode11 JSR       ISLSLW
000019E0  4E75                     768            RTS
000019E2                           769  
000019E2                           770  someROL:
000019E2  41F9 00001A00            771          LEA         tableSomeROL, A0 ; Index into the table
000019E8  4280                     772          CLR.L       D0              ; Zero it
000019EA  3016                     773          MOVE.W      (A6),D0     ; We'll play with it here
000019EC  123C 0008                774          MOVE.B      #8,D1           ; Shift 8 bits left
000019F0  E360                     775          ASL.W       D1,D0
000019F2  123C 000E                776          MOVE.B      #14,D1          ; Shift 14 bits to the right
000019F6  E268                     777          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000019F8                           778                                      ; and the rest are zeroed out)
000019F8  C0FC 0006                779          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000019FC  4EF0 0000                780          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A00                           781  
00001A00                           782  tableSomeROL:
00001A00  4EF9 00001A18            783          JMP         ROLcode00       *ROL.B
00001A06  4EF9 00001A20            784          JMP         ROLcode01       *ROL.W
00001A0C  4EF9 00001A28            785          JMP         ROLcode10       *ROL.L
00001A12  4EF9 00001A30            786          JMP         ROLcode11       *ROL.W
00001A18                           787  
00001A18  4EB9 000024FC            788  ROLcode00 JSR       ISROLB
00001A1E  4E75                     789            RTS
00001A20  4EB9 00002520            790  ROLcode01 JSR       ISROLW
00001A26  4E75                     791            RTS
00001A28  4EB9 00002544            792  ROLcode10 JSR       ISROLL
00001A2E  4E75                     793            RTS
00001A30  4EB9 00002520            794  ROLcode11 JSR       ISROLW
00001A36  4E75                     795            RTS
00001A38                           796  
00001A38                           797  
00001A38                           798  someROR:
00001A38  41F9 00001A56            799          LEA         tableSomeROR, A0 ; Index into the table
00001A3E  4280                     800          CLR.L       D0              ; Zero it
00001A40  3016                     801          MOVE.W      (A6),D0     ; We'll play with it here
00001A42  123C 0008                802          MOVE.B      #8,D1           ; Shift 8 bits left
00001A46  E360                     803          ASL.W       D1,D0
00001A48  123C 000E                804          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001A4C  E268                     805          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001A4E                           806                                      ; and the rest are zeroed out)
00001A4E  C0FC 0006                807          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001A52  4EF0 0000                808          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A56                           809  
00001A56                           810  tableSomeROR:
00001A56  4EF9 00001A6E            811          JMP         RORcode00       *ROR.B
00001A5C  4EF9 00001A76            812          JMP         RORcode01       *ROR.W
00001A62  4EF9 00001A7E            813          JMP         RORcode10       *ROR.L
00001A68  4EF9 00001A86            814          JMP         RORcode11       *ROR.W
00001A6E                           815  
00001A6E  4EB9 0000249A            816  RORcode00 JSR       ISRORB
00001A74  4E75                     817            RTS
00001A76  4EB9 000024BE            818  RORcode01 JSR       ISRORW
00001A7C  4E75                     819            RTS
00001A7E  4EB9 000024D8            820  RORcode10 JSR       ISRORL
00001A84  4E75                     821            RTS
00001A86  4EB9 000024BE            822  RORcode11 JSR       ISRORW
00001A8C  4E75                     823            RTS
00001A8E                           824  
00001A8E                           825  ROL_ROR:
00001A8E  41F9 00001AAC            826          LEA         tableROL_ROR, A0 ; Index into the table
00001A94  4280                     827          CLR.L       D0              ; Zero it
00001A96  3016                     828          MOVE.W      (A6),D0     ; We'll play with it here
00001A98  123C 0007                829          MOVE.B      #7,D1           ; Shift 7 bits left
00001A9C  E360                     830          ASL.W       D1,D0
00001A9E  123C 000F                831          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001AA2  E268                     832          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001AA4                           833                                      ; and the rest are zeroed out)
00001AA4  C0FC 0006                834          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001AA8  4EF0 0000                835          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001AAC                           836  
00001AAC                           837  tableROL_ROR:
00001AAC  4EF9 00001AB8            838          JMP         ROL_RORcode0    ; ROR
00001AB2  4EF9 00001ABE            839          JMP         ROL_RORcode1    ; ROL
00001AB8                           840  
00001AB8  4EB8 1A38                841  ROL_RORcode0 JSR    someROR
00001ABC  4E75                     842               RTS
00001ABE  4EB8 19E2                843  ROL_RORcode1 JSR    someROL
00001AC2  4E75                     844               RTS
00001AC4                           845  
00001AC4                           846  LSL_LSR:
00001AC4  41F9 00001AE2            847          LEA         tableLSL_LSR, A0 ; Index into the table
00001ACA  4280                     848          CLR.L       D0              ; Zero it
00001ACC  3016                     849          MOVE.W      (A6),D0     ; We'll play with it here
00001ACE  123C 0007                850          MOVE.B      #7,D1           ; Shift 7 bits left
00001AD2  E360                     851          ASL.W       D1,D0
00001AD4  123C 000F                852          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001AD8  E268                     853          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001ADA                           854                                      ; and the rest are zeroed out)
00001ADA  C0FC 0006                855          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001ADE  4EF0 0000                856          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001AE2                           857  
00001AE2                           858  tableLSL_LSR:
00001AE2  4EF9 00001AEE            859          JMP         LSL_LSRcode0    ; LSR
00001AE8  4EF9 00001AF4            860          JMP         LSL_LSRcode1    ; LSL
00001AEE                           861  
00001AEE  4EB8 1936                862  LSL_LSRcode0 JSR    someLSR
00001AF2  4E75                     863               RTS
00001AF4  4EB8 198C                864  LSL_LSRcode1 JSR    someLSL
00001AF8  4E75                     865               RTS
00001AFA                           866  
00001AFA                           867  ASL_ASR:
00001AFA  41F9 00001B18            868          LEA         tableASL_ASR, A0 ; Index into the table
00001B00  4280                     869          CLR.L       D0              ; Zero it
00001B02  3016                     870          MOVE.W      (A6),D0     ; We'll play with it here
00001B04  123C 0007                871          MOVE.B      #7,D1           ; Shift 7 bits left
00001B08  E360                     872          ASL.W       D1,D0
00001B0A  123C 000F                873          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001B0E  E268                     874          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B10                           875                                      ; and the rest are zeroed out)
00001B10  C0FC 0006                876          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B14  4EF0 0000                877          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B18                           878  
00001B18                           879  tableASL_ASR:
00001B18  4EF9 00001B24            880          JMP         ASL_ASRcode0    ; ASR
00001B1E  4EF9 00001B2A            881          JMP         ASL_ASRcode1    ; ASL
00001B24                           882  
00001B24  4EB8 188A                883  ASL_ASRcode0 JSR    someASR
00001B28  4E75                     884               RTS
00001B2A  4EB8 18E0                885  ASL_ASRcode1 JSR    someASL
00001B2E  4E75                     886               RTS
00001B30                           887  
00001B30                           888  ROd_LSd_ASd:
00001B30  41F9 00001B4E            889          LEA         tableROd_LSd_ASd, A0 ; Index into the table
00001B36  4280                     890          CLR.L       D0              ; Zero it
00001B38  3016                     891          MOVE.W      (A6),D0     ; We'll play with it here
00001B3A  123C 000B                892          MOVE.B      #11,D1          ; Shift 11 bits left
00001B3E  E360                     893          ASL.W       D1,D0
00001B40  123C 000F                894          MOVE.B      #15,D1          ; Shift 12 bits to the right
00001B44  E268                     895          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B46                           896                                      ; and the rest are zeroed out)
00001B46  C0FC 0006                897          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B4A  4EF0 0000                898          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B4E                           899  
00001B4E                           900  tableROd_LSd_ASd:
00001B4E  4EF9 00001B66            901          JMP         ROd_LSd_ASdcode00 ; ASL_ASR
00001B54  4EF9 00001B6C            902          JMP         ROd_LSd_ASdcode01 ; LSL_LSR
00001B5A  4EF9 00001B72            903          JMP         ROd_LSd_ASdcode10
00001B60  4EF9 00001B7A            904          JMP         ROd_LSd_ASdcode11 ; ROL_ROR
00001B66                           905  
00001B66  4EB8 1AFA                906  ROd_LSd_ASdcode00 JSR ASL_ASR
00001B6A  4E75                     907                    RTS
00001B6C  4EB8 1AC4                908  ROd_LSd_ASdcode01 JSR LSL_LSR
00001B70  4E75                     909                    RTS
00001B72  4EB9 000021F6            910  ROd_LSd_ASdcode10 JSR    OPCODE_INVALID              ;INVALID
00001B78  4E75                     911                    RTS
00001B7A  4EB8 1A8E                912  ROd_LSd_ASdcode11 JSR ROL_ROR
00001B7E  4E75                     913                    RTS
00001B80                           914  
00001B80                           915  AND_BorAND_WorAND_LorMULS_W:
00001B80  41F9 00001B9E            916          LEA         tableAND_BorAND_WorAND_LorMULS_W, A0            ; Index into the table
00001B86  4280                     917          CLR.L       D0                  ; Zero it
00001B88  3016                     918          MOVE.W      (A6),D0         ; We'll play with it here
00001B8A  123C 0007                919          MOVE.B      #7,D1           ; Shift 7 bits left
00001B8E  E360                     920          ASL.W       D1,D0
00001B90  123C 000D                921          MOVE.B      #13,D1              ; Shift 13 bits to the right
00001B94  E268                     922          LSR.W       D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B96                           923                                  ; and the rest are zeroed out)
00001B96  C0FC 0006                924          MULU        #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B9A  4EF0 0000                925          JMP         0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B9E                           926  
00001B9E                           927  tableAND_BorAND_WorAND_LorMULS_W:
00001B9E  4EF9 00001BCE            928          JMP         ANDcode000   ; AND.B
00001BA4  4EF9 00001BD6            929          JMP         ANDcode001   ; AND.W
00001BAA  4EF9 00001BDE            930          JMP         ANDcode010   ; AND.L
00001BB0  4EF9 00001BE6            931          JMP         ANDcode011
00001BB6  4EF9 00001BEE            932          JMP         ANDcode100   ; AND.B
00001BBC  4EF9 00001BF6            933          JMP         ANDcode101   ; AND.W
00001BC2  4EF9 00001BFE            934          JMP         ANDcode110   ; AND.L
00001BC8  4EF9 00001C06            935          JMP         ANDcode111   ; MULS.W
00001BCE                           936  
00001BCE  4EB9 0000258C            937  ANDcode000 JSR      ISANDB
00001BD4  4E75                     938             RTS
00001BD6  4EB9 000025B0            939  ANDcode001 JSR      ISANDW
00001BDC  4E75                     940             RTS
00001BDE  4EB9 000025D4            941  ANDcode010 JSR      ISANDL
00001BE4  4E75                     942             RTS
00001BE6  4EB9 000021F6            943  ANDcode011 JSR    OPCODE_INVALID              ;INVALID
00001BEC  4E75                     944             RTS
00001BEE  4EB9 0000258C            945  ANDcode100 JSR      ISANDB
00001BF4  4E75                     946             RTS
00001BF6  4EB9 000025B0            947  ANDcode101 JSR      ISANDW
00001BFC  4E75                     948             RTS
00001BFE  4EB9 000025D4            949  ANDcode110 JSR      ISANDL
00001C04  4E75                     950             RTS
00001C06  4EB9 00002568            951  ANDcode111 JSR      ISMULSW
00001C0C  4E75                     952             RTS
00001C0E                           953  
00001C0E                           954  ADD_BorADD_WorADD_L:
00001C0E  41F9 00001C2C            955          LEA         tableADD_BorADD_WorADD_L, A0 ; Index into the table
00001C14  4280                     956          CLR.L       D0              ; Zero it
00001C16  3016                     957          MOVE.W      (A6),D0     ; We'll play with it here
00001C18  123C 0007                958          MOVE.B      #7,D1           ; Shift 7 bits left
00001C1C  E360                     959          ASL.W       D1,D0
00001C1E  123C 000D                960          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001C22  E268                     961          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001C24                           962                                      ; and the rest are zeroed out)
00001C24  C0FC 0006                963          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001C28  4EF0 0000                964          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001C2C                           965  
00001C2C                           966  tableADD_BorADD_WorADD_L:
00001C2C  4EF9 00001C5C            967          JMP         ADDcode000      *ADD.B
00001C32  4EF9 00001C64            968          JMP         ADDcode001      *ADD.W
00001C38  4EF9 00001C6C            969          JMP         ADDcode010      *ADD.L
00001C3E  4EF9 00001C74            970          JMP         ADDcode011      *ADDA.W
00001C44  4EF9 00001C7C            971          JMP         ADDcode100      *ADD.B
00001C4A  4EF9 00001C84            972          JMP         ADDcode101      *ADD.W
00001C50  4EF9 00001C8C            973          JMP         ADDcode110      *ADD.L
00001C56  4EF9 00001C94            974          JMP         ADDcode111      *ADDA.L
00001C5C                           975  
00001C5C  4EB9 00002640            976  ADDcode000 JSR      ISADDB
00001C62  4E75                     977             RTS
00001C64  4EB9 00002664            978  ADDcode001 JSR      ISADDW
00001C6A  4E75                     979             RTS
00001C6C  4EB9 00002688            980  ADDcode010 JSR      ISADDL
00001C72  4E75                     981             RTS
00001C74  4EB9 000025F8            982  ADDcode011 JSR      ISADDAW
00001C7A  4E75                     983             RTS
00001C7C  4EB9 00002640            984  ADDcode100 JSR      ISADDB
00001C82  4E75                     985             RTS
00001C84  4EB9 00002664            986  ADDcode101 JSR      ISADDW
00001C8A  4E75                     987             RTS
00001C8C  4EB9 00002688            988  ADDcode110 JSR      ISADDL
00001C92  4E75                     989             RTS
00001C94  4EB9 0000261C            990  ADDcode111 JSR      ISADDAL
00001C9A  4E75                     991             RTS
00001C9C                           992  
00001C9C                           993  SUB_BorSUB_WorSUB_L:
00001C9C  41F9 00001CBA            994          LEA         tableSUB_BorSUB_WorSUB_L, A0 ; Index into the table
00001CA2  4280                     995          CLR.L       D0              ; Zero it
00001CA4  3016                     996          MOVE.W      (A6),D0     ; We'll play with it here
00001CA6  123C 0007                997          MOVE.B      #7,D1           ; Shift 7 bits left
00001CAA  E360                     998          ASL.W       D1,D0
00001CAC  123C 000D                999          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001CB0  E268                    1000          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001CB2                          1001                                      ; and the rest are zeroed out)
00001CB2  C0FC 0006               1002          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001CB6  4EF0 0000               1003          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001CBA                          1004  
00001CBA                          1005  tableSUB_BorSUB_WorSUB_L:
00001CBA  4EF9 00001CEA           1006          JMP         SUBcode000      *SUB.B
00001CC0  4EF9 00001CF2           1007          JMP         SUBcode001      *SUB.W
00001CC6  4EF9 00001CFA           1008          JMP         SUBcode010      *SUB.L
00001CCC  4EF9 00001D02           1009          JMP         SUBcode011
00001CD2  4EF9 00001D0A           1010          JMP         SUBcode100      *SUB.B
00001CD8  4EF9 00001D12           1011          JMP         SUBcode101      *SUB.W
00001CDE  4EF9 00001D1A           1012          JMP         SUBcode110      *SUB.L
00001CE4  4EF9 00001D22           1013          JMP         SUBcode111      ; INVALID
00001CEA                          1014  
00001CEA  4EB9 000026AC           1015  SUBcode000 JSR      ISSUBB
00001CF0  4E75                    1016             RTS
00001CF2  4EB9 000026D0           1017  SUBcode001 JSR      ISSUBW
00001CF8  4E75                    1018             RTS
00001CFA  4EB9 000026F4           1019  SUBcode010 JSR      ISSUBL
00001D00  4E75                    1020             RTS
00001D02  4EB9 000021F6           1021  SUBcode011 JSR      OPCODE_INVALID              ;INVALID
00001D08  4E75                    1022             RTS
00001D0A  4EB9 000026AC           1023  SUBcode100 JSR      ISSUBB
00001D10  4E75                    1024             RTS
00001D12  4EB9 000026D0           1025  SUBcode101 JSR      ISSUBW
00001D18  4E75                    1026             RTS
00001D1A  4EB9 000026F4           1027  SUBcode110 JSR      ISSUBL
00001D20  4E75                    1028             RTS
00001D22  4EB9 000021F6           1029  SUBcode111 JSR      OPCODE_INVALID              ;INVALID
00001D28  4E75                    1030             RTS
00001D2A                          1031  
00001D2A                          1032  CMP_BorCMP_WorCMP_L:
00001D2A  41F9 00001D48           1033          LEA         tableCMP_BorCMP_WorCMP_L, A0 ; Index into the table
00001D30  4280                    1034          CLR.L       D0              ; Zero it
00001D32  3016                    1035          MOVE.W      (A6),D0     ; We'll play with it here
00001D34  123C 0008               1036          MOVE.B      #8,D1           ; Shift 8 bits left
00001D38  E360                    1037          ASL.W       D1,D0
00001D3A  123C 000E               1038          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001D3E  E268                    1039          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001D40                          1040                                      ; and the rest are zeroed out)
00001D40  C0FC 0006               1041          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001D44  4EF0 0000               1042          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001D48                          1043  
00001D48                          1044  tableCMP_BorCMP_WorCMP_L:
00001D48  4EF9 00001D60           1045          JMP         CMPcode00       *CMP.B
00001D4E  4EF9 00001D68           1046          JMP         CMPcode01       *CMP.W
00001D54  4EF9 00001D70           1047          JMP         CMPcode10       *CMP.L
00001D5A  4EF9 00001D78           1048          JMP         CMPcode11       ; INVALID
00001D60                          1049  
00001D60  4EB9 00002718           1050  CMPcode00   JSR      ISCMPB
00001D66  4E75                    1051              RTS
00001D68  4EB9 0000273C           1052  CMPcode01   JSR      ISCMPW
00001D6E  4E75                    1053              RTS
00001D70  4EB9 00002760           1054  CMPcode10   JSR      ISCMPL
00001D76  4E75                    1055              RTS
00001D78  4EB9 000021F6           1056  CMPcode11   JSR    OPCODE_INVALID              ;INVALID
00001D7E  4E75                    1057              RTS
00001D80                          1058  
00001D80                          1059  ADDQ_BorADDQ_WorADDQ_L:
00001D80  41F9 00001D9E           1060          LEA         tableADDQ_BorADDQ_WorADDQ_L, A0 ; Index into the table
00001D86  4280                    1061          CLR.L       D0              ; Zero it
00001D88  3016                    1062          MOVE.W      (A6),D0     ; We'll play with it here
00001D8A  123C 0008               1063          MOVE.B      #8,D1           ; Shift 8 bits left
00001D8E  E360                    1064          ASL.W       D1,D0
00001D90  123C 000E               1065          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001D94  E268                    1066          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001D96                          1067                                      ; and the rest are zeroed out)
00001D96  C0FC 0006               1068          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001D9A  4EF0 0000               1069          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001D9E                          1070  
00001D9E                          1071  tableADDQ_BorADDQ_WorADDQ_L:
00001D9E  4EF9 00001DB6           1072          JMP         ADDQcode00      *ADDQ.B
00001DA4  4EF9 00001DBE           1073          JMP         ADDQcode01      *ADDQ.W
00001DAA  4EF9 00001DC6           1074          JMP         ADDQcode10      *ADDQ.L
00001DB0  4EF9 00001DCE           1075          JMP         ADDQcode11      ; INVALID
00001DB6                          1076  
00001DB6  4EB9 00002784           1077  ADDQcode00 JSR      ISADDQB
00001DBC  4E75                    1078             RTS
00001DBE  4EB9 000027A8           1079  ADDQcode01 JSR      ISADDQW
00001DC4  4E75                    1080             RTS
00001DC6  4EB9 000027CC           1081  ADDQcode10 JSR      ISADDQL
00001DCC  4E75                    1082             RTS
00001DCE  4EB9 000021F6           1083  ADDQcode11   JSR    OPCODE_INVALID              ;INVALID
00001DD4  4E75                    1084              RTS
00001DD6                          1085  
00001DD6                          1086  someCLR:
00001DD6  41F9 00001DF4           1087          LEA         tableSomeCLR, A0 ; Index into the table
00001DDC  4280                    1088          CLR.L       D0              ; Zero it
00001DDE  3016                    1089          MOVE.W      (A6),D0     ; We'll play with it here
00001DE0  123C 0008               1090          MOVE.B      #8,D1           ; Shift 8 bits left
00001DE4  E360                    1091          ASL.W       D1,D0
00001DE6  123C 000E               1092          MOVE.B      #14,D1       ; Shift 12 bits to the right
00001DEA  E268                    1093          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001DEC                          1094                                      ; and the rest are zeroed out)
00001DEC  C0FC 0006               1095          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001DF0  4EF0 0000               1096          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001DF4                          1097  
00001DF4                          1098  tableSomeCLR:
00001DF4  4EF9 00001E0C           1099          JMP         CLRcode00       *CLR.B
00001DFA  4EF9 00001E14           1100          JMP         CLRcode01       *CLR.W
00001E00  4EF9 00001E1C           1101          JMP         CLRcode10       *CLR.L
00001E06  4EF9 00001E24           1102          JMP         CLRcode11       ; INVALID
00001E0C                          1103  
00001E0C  4EB9 0000280A           1104  CLRcode00 JSR       ISCLRB
00001E12  4E75                    1105            RTS
00001E14  4EB9 0000282E           1106  CLRcode01 JSR       ISCLRW
00001E1A  4E75                    1107            RTS
00001E1C  4EB9 00002852           1108  CLRcode10 JSR       ISCLRL
00001E22  4E75                    1109            RTS
00001E24  4EB9 000021F6           1110  CLRcode11 JSR    OPCODE_INVALID              ;INVALID
00001E2A  4E75                    1111            RTS
00001E2C                          1112  
00001E2C                          1113  NOPorCLRorRTSorJSR:
00001E2C  41F9 00001E5E           1114          LEA         tableNOPorCLRorRTSorJSR, A0 ; Index into the table
00001E32  4280                    1115          CLR.L       D0              ; Zero it
00001E34  3016                    1116          MOVE.W      (A6),D0     ; We'll play with it here
00001E36                          1117  
00001E36  323C 4E71               1118          MOVE.W      #%0100111001110001, D1 ; 0100111001110001 = NOP
00001E3A  B240                    1119          CMP.W       D0, D1
00001E3C  6700 0088               1120          BEQ         NOPcommand
00001E40                          1121  
00001E40  323C 4E75               1122          MOVE.W      #%0100111001110101, D1 ; 0100111001110101 = RTS
00001E44  B240                    1123          CMP.W       D0, D1
00001E46  6700 0076               1124          BEQ         RTScommand
00001E4A                          1125  
00001E4A  123C 0004               1126          MOVE.B      #4,D1           ; Shift 4 bits left
00001E4E  E360                    1127          ASL.W       D1,D0
00001E50  123C 000C               1128          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001E54  E268                    1129          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001E56                          1130                                      ; and the rest are zeroed out)
00001E56  C0FC 0006               1131          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001E5A  4EF0 0000               1132          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001E5E                          1133  
00001E5E                          1134  tableNOPorCLRorRTSorJSR:
00001E5E  4EF9 00001ECE           1135          JMP         JSRorCLRcode0000
00001E64  4EF9 00001ED6           1136          JMP         JSRorCLRcode0001
00001E6A  4EF9 00001EDE           1137          JMP         JSRorCLRcode0010
00001E70  4EF9 00001EE4           1138          JMP         JSRorCLRcode0011
00001E76  4EF9 00001EEC           1139          JMP         JSRorCLRcode0100
00001E7C  4EF9 00001EF4           1140          JMP         JSRorCLRcode0101
00001E82  4EF9 00001EFC           1141          JMP         JSRorCLRcode0110
00001E88  4EF9 00001F04           1142          JMP         JSRorCLRcode0111
00001E8E  4EF9 00001F0C           1143          JMP         JSRorCLRcode1000
00001E94  4EF9 00001F14           1144          JMP         JSRorCLRcode1001
00001E9A  4EF9 00001F1C           1145          JMP         JSRorCLRcode1010
00001EA0  4EF9 00001F24           1146          JMP         JSRorCLRcode1011
00001EA6  4EF9 00001F2C           1147          JMP         JSRorCLRcode1100
00001EAC  4EF9 00001F34           1148          JMP         JSRorCLRcode1101
00001EB2  4EF9 00001F3C           1149          JMP         JSRorCLRcode1110
00001EB8  4EF9 00001F44           1150          JMP         JSRorCLRcode1111
00001EBE                          1151  
00001EBE  4EB9 00002906           1152  RTScommand JSR      ISRTS
00001EC4  4E75                    1153             RTS
00001EC6  4EB9 00002940           1154  NOPcommand JSR      ISNOP
00001ECC  4E75                    1155             RTS
00001ECE  4EB9 000021F6           1156  JSRorCLRcode0000 JSR    OPCODE_INVALID              ;INVALID
00001ED4  4E75                    1157                   RTS
00001ED6  4EB9 000021F6           1158  JSRorCLRcode0001 JSR    OPCODE_INVALID              ;INVALID
00001EDC  4E75                    1159                   RTS
00001EDE  4EB8 1DD6               1160  JSRorCLRcode0010 JSR someCLR
00001EE2  4E75                    1161                   RTS
00001EE4  4EB9 000021F6           1162  JSRorCLRcode0011 JSR    OPCODE_INVALID              ;INVALID
00001EEA  4E75                    1163                   RTS
00001EEC  4EB9 000021F6           1164  JSRorCLRcode0100 JSR    OPCODE_INVALID              ;INVALID
00001EF2  4E75                    1165                   RTS
00001EF4  4EB9 000021F6           1166  JSRorCLRcode0101 JSR    OPCODE_INVALID              ;INVALID
00001EFA  4E75                    1167                   RTS
00001EFC  4EB9 000021F6           1168  JSRorCLRcode0110 JSR    OPCODE_INVALID              ;INVALID
00001F02  4E75                    1169                   RTS
00001F04  4EB9 000021F6           1170  JSRorCLRcode0111 JSR    OPCODE_INVALID              ;INVALID
00001F0A  4E75                    1171                   RTS
00001F0C  4EB9 000021F6           1172  JSRorCLRcode1000 JSR    OPCODE_INVALID              ;INVALID
00001F12  4E75                    1173                   RTS
00001F14  4EB9 000021F6           1174  JSRorCLRcode1001 JSR    OPCODE_INVALID              ;INVALID
00001F1A  4E75                    1175                   RTS
00001F1C  4EB9 000021F6           1176  JSRorCLRcode1010 JSR    OPCODE_INVALID              ;INVALID
00001F22  4E75                    1177                   RTS
00001F24  4EB9 000021F6           1178  JSRorCLRcode1011 JSR    OPCODE_INVALID              ;INVALID
00001F2A  4E75                    1179                   RTS
00001F2C  4EB9 000021F6           1180  JSRorCLRcode1100 JSR    OPCODE_INVALID              ;INVALID
00001F32  4E75                    1181                   RTS
00001F34  4EB9 000021F6           1182  JSRorCLRcode1101 JSR    OPCODE_INVALID              ;INVALID
00001F3A  4E75                    1183                   RTS
00001F3C  4EB9 000028E2           1184  JSRorCLRcode1110 JSR ISJSR
00001F42  4E75                    1185                   RTS
00001F44  4EB9 000021F6           1186  JSRorCLRcode1111 JSR    OPCODE_INVALID              ;INVALID
00001F4A  4E75                    1187                   RTS
00001F4C                          1188  
00001F4C                          1189  someMOVEM:
00001F4C  41F9 00001F6A           1190          LEA         tableSomeMOVEM, A0 ; Index into the table
00001F52  4280                    1191          CLR.L       D0              ; Zero it
00001F54  3016                    1192          MOVE.W      (A6),D0     ; We'll play with it here
00001F56  123C 0009               1193          MOVE.B      #9,D1           ; Shift 9 bits left
00001F5A  E360                    1194          ASL.W       D1,D0
00001F5C  123C 000F               1195          MOVE.B      #15,D1       ; Shift 12 bits to the right
00001F60  E268                    1196          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001F62                          1197                                      ; and the rest are zeroed out)
00001F62  C0FC 0006               1198          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001F66  4EF0 0000               1199          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001F6A                          1200  
00001F6A                          1201  tableSomeMOVEM:
00001F6A  4EF9 00001F76           1202          JMP         MOVEMcode0      ; MOVEM.W
00001F70  4EF9 00001F7E           1203          JMP         MOVEMcode1      ; MOVEM.L
00001F76                          1204  
00001F76  4EB9 0000289A           1205  MOVEMcode0 JSR      ISMOVEMW
00001F7C  4E75                    1206             RTS
00001F7E  4EB9 00002876           1207  MOVEMcode1 JSR      ISMOVEML
00001F84  4E75                    1208             RTS
00001F86                          1209  
00001F86                          1210  NOP_MOVEM_LEA_JSR_CLR_RTS:
00001F86  41F9 00001FAA           1211          LEA         tableNOP_MOVEM_LEA_JSR_CLR_RTS, A0 ; Index into the table
00001F8C  4280                    1212          CLR.L       D0              ; Zero it
00001F8E  3016                    1213          MOVE.W      (A6),D0     ; We'll play with it here
00001F90  123C 0007               1214          MOVE.B      #7,D1           ; Shift 7 bits right
00001F94  E260                    1215          ASR.W       D1,D0
00001F96  123C 000D               1216          MOVE.B      #13,D1          ; Shift 13 bits left
00001F9A  E360                    1217          ASL.W       D1,D0
00001F9C  123C 000C               1218          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001FA0  E268                    1219          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001FA2                          1220                                      ; and the rest are zeroed out)
00001FA2  C0FC 0006               1221          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001FA6  4EF0 0000               1222          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001FAA                          1223  
00001FAA                          1224  tableNOP_MOVEM_LEA_JSR_CLR_RTS:
00001FAA  4EF9 0000200A           1225          JMP         LOTScode0000
00001FB0  4EF9 00002012           1226          JMP         LOTScode0001
00001FB6  4EF9 0000201A           1227          JMP         LOTScode0010
00001FBC  4EF9 00002020           1228          JMP         LOTScode0011
00001FC2  4EF9 00002028           1229          JMP         LOTScode0100
00001FC8  4EF9 00002030           1230          JMP         LOTScode0101
00001FCE  4EF9 00002038           1231          JMP         LOTScode0110
00001FD4  4EF9 00002040           1232          JMP         LOTScode0111
00001FDA  4EF9 00002048           1233          JMP         LOTScode1000
00001FE0  4EF9 0000204E           1234          JMP         LOTScode1001
00001FE6  4EF9 00002056           1235          JMP         LOTScode1010
00001FEC  4EF9 0000205C           1236          JMP         LOTScode1011
00001FF2  4EF9 00002064           1237          JMP         LOTScode1100
00001FF8  4EF9 0000206C           1238          JMP         LOTScode1101
00001FFE  4EF9 00002074           1239          JMP         LOTScode1110
00002004  4EF9 0000207C           1240          JMP         LOTScode1111
0000200A                          1241  
0000200A  4EB9 000021F6           1242  LOTScode0000 JSR    OPCODE_INVALID              ; MULS.L and DIVU.L are not supported for 68000 Disassember
00002010  4E75                    1243               RTS
00002012  4EB9 000021F6           1244  LOTScode0001 JSR    OPCODE_INVALID              ;INVALID
00002018  4E75                    1245               RTS
0000201A  4EB8 1F4C               1246  LOTScode0010 JSR    someMOVEM
0000201E  4E75                    1247               RTS
00002020  4EB9 000021F6           1248  LOTScode0011 JSR    OPCODE_INVALID              ;INVALID
00002026  4E75                    1249               RTS
00002028  4EB9 000021F6           1250  LOTScode0100 JSR    OPCODE_INVALID              ;INVALID
0000202E  4E75                    1251               RTS
00002030  4EB9 000021F6           1252  LOTScode0101 JSR    OPCODE_INVALID              ;INVALID
00002036  4E75                    1253               RTS
00002038  4EB9 000028BE           1254  LOTScode0110 JSR    ISLEA
0000203E  4E75                    1255               RTS
00002040  4EB9 000021F6           1256  LOTScode0111 JSR    OPCODE_INVALID              ;INVALID
00002046  4E75                    1257               RTS
00002048  4EB8 1E2C               1258  LOTScode1000 JSR    NOPorCLRorRTSorJSR
0000204C  4E75                    1259               RTS
0000204E  4EB9 000021F6           1260  LOTScode1001 JSR    OPCODE_INVALID              ;INVALID
00002054  4E75                    1261               RTS
00002056  4EB8 1E2C               1262  LOTScode1010 JSR    NOPorCLRorRTSorJSR
0000205A  4E75                    1263               RTS
0000205C  4EB9 000021F6           1264  LOTScode1011 JSR    OPCODE_INVALID              ;INVALID
00002062  4E75                    1265               RTS
00002064  4EB9 000021F6           1266  LOTScode1100 JSR    OPCODE_INVALID              ;INVALID
0000206A  4E75                    1267               RTS
0000206C  4EB9 000021F6           1268  LOTScode1101 JSR    OPCODE_INVALID              ;INVALID
00002072  4E75                    1269               RTS
00002074  4EB9 000028BE           1270  LOTScode1110 JSR    ISLEA
0000207A  4E75                    1271               RTS
0000207C  4EB9 000021F6           1272  LOTScode1111 JSR    OPCODE_INVALID              ;INVALID
00002082  4E75                    1273               RTS
00002084                          1274  
00002084                          1275  ADDI_BorADDI_WorADDI_L:
00002084  41F9 000020A2           1276          LEA         tableADDI_BorADDI_WorADDI_L,A0 ; Index into the table
0000208A  4280                    1277          CLR.L       D0              ; Zero it
0000208C  3016                    1278          MOVE.W      (A6),D0     ; We'll play with it here
0000208E  123C 0007               1279          MOVE.B      #7,D1           ; Shift 7 bits left
00002092  E360                    1280          ASL.W       D1,D0
00002094  123C 000D               1281          MOVE.B      #13,D1          ; Shift 13 bits right
00002098  E260                    1282          ASR.W       D1,D0
0000209A  C0FC 0006               1283          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000209E  4EF0 0000               1284          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000020A2                          1285  
000020A2                          1286  tableADDI_BorADDI_WorADDI_L:
000020A2  4EF9 000020BA           1287          JMP         ADDIBcode00
000020A8  4EF9 000020C2           1288          JMP         ADDIWcode01
000020AE  4EF9 000020CA           1289          JMP         ADDILcode10
000020B4  4EF9 000020D2           1290          JMP         ADDILcode11
000020BA                          1291  
000020BA  4EB9 00002A52           1292  ADDIBcode00 JSR     ISADDIB
000020C0  4E75                    1293              RTS
000020C2  4EB9 00002A0A           1294  ADDIWcode01 JSR     ISADDIW
000020C8  4E75                    1295              RTS
000020CA  4EB9 00002A2E           1296  ADDILcode10 JSR     ISADDIL
000020D0  4E75                    1297              RTS
000020D2  4EB9 000021F6           1298  ADDILcode11 JSR    OPCODE_INVALID              ;INVALID
000020D8  4E75                    1299              RTS
000020DA                          1300  
000020DA                          1301  MOVEA_LorMOVE_L:
000020DA  41F9 000020F8           1302          LEA         tableMOVEA_LorMOVE_L,A0 ; Index into the table
000020E0  4280                    1303          CLR.L       D0              ; Zero it
000020E2  3016                    1304          MOVE.W      (A6),D0         ; We'll play with it here
000020E4  123C 0007               1305          MOVE.B      #7,D1           ; Shift 7 bits left
000020E8  E360                    1306          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
000020EA  123C 000D               1307          MOVE.B      #13,D1          ; Shift 13 bits right
000020EE  E260                    1308          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
000020F0  C0FC 0006               1309          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000020F4  4EF0 0000               1310          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000020F8                          1311  
000020F8                          1312  tableMOVEA_LorMOVE_L:
000020F8  4EF9 00002128           1313          JMP         MOVEcode000
000020FE  4EF9 00002130           1314          JMP         MOVEAcode001
00002104  4EF9 00002138           1315          JMP         MOVEcode010
0000210A  4EF9 00002140           1316          JMP         MOVEcode011
00002110  4EF9 00002148           1317          JMP         MOVEcode100
00002116  4EF9 00002150           1318          JMP         MOVEcode101
0000211C  4EF9 00002158           1319          JMP         MOVEcode110
00002122  4EF9 00002160           1320          JMP         MOVEcode111
00002128                          1321  
00002128  4EB9 000029A8           1322  MOVEcode000 JSR     ISMOVEL
0000212E  4E75                    1323              RTS
00002130  4EB9 000029CC           1324  MOVEAcode001 JSR    ISMOVEAL
00002136  4E75                    1325               RTS
00002138  4EB9 000029A8           1326  MOVEcode010 JSR     ISMOVEL
0000213E  4E75                    1327              RTS
00002140  4EB9 000029A8           1328  MOVEcode011 JSR     ISMOVEL
00002146  4E75                    1329              RTS
00002148  4EB9 000029A8           1330  MOVEcode100 JSR     ISMOVEL
0000214E  4E75                    1331              RTS
00002150  4EB9 000029A8           1332  MOVEcode101 JSR     ISMOVEL
00002156  4E75                    1333              RTS
00002158  4EB9 000029A8           1334  MOVEcode110 JSR     ISMOVEL
0000215E  4E75                    1335              RTS
00002160  4EB9 000029A8           1336  MOVEcode111 JSR     ISMOVEL
00002166  4E75                    1337              RTS
00002168                          1338  
00002168                          1339  MOVEA_WorMOVE_W:
00002168  41F9 00002186           1340          LEA         tableMOVEA_WorMOVE_W,A0 ; Index into the table
0000216E  4280                    1341          CLR.L       D0              ; Zero it
00002170  3016                    1342          MOVE.W      (A6),D0     ; We'll play with it here
00002172  123C 0007               1343          MOVE.B      #7,D1           ; Shift 7 bits left
00002176  E360                    1344          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
00002178  123C 000D               1345          MOVE.B      #13,D1          ; Shift 13 bits right
0000217C  E260                    1346          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
0000217E  C0FC 0006               1347          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002182  4EF0 0000               1348          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00002186                          1349  
00002186                          1350  tableMOVEA_WorMOVE_W:
00002186  4EF9 000021B6           1351          JMP         MOVEWcode000
0000218C  4EF9 000021BE           1352          JMP         MOVEAWcode001
00002192  4EF9 000021C6           1353          JMP         MOVEWcode010
00002198  4EF9 000021CE           1354          JMP         MOVEWcode011
0000219E  4EF9 000021D6           1355          JMP         MOVEWcode100
000021A4  4EF9 000021DE           1356          JMP         MOVEWcode101
000021AA  4EF9 000021E6           1357          JMP         MOVEWcode110
000021B0  4EF9 000021EE           1358          JMP         MOVEWcode111
000021B6                          1359  
000021B6  4EB9 00002960           1360  MOVEWcode000 JSR    ISMOVEW
000021BC  4E75                    1361               RTS
000021BE  4EB9 00002984           1362  MOVEAWcode001 JSR   ISMOVEAW
000021C4  4E75                    1363                RTS
000021C6  4EB9 00002960           1364  MOVEWcode010 JSR    ISMOVEW
000021CC  4E75                    1365               RTS
000021CE  4EB9 00002960           1366  MOVEWcode011 JSR    ISMOVEW
000021D4  4E75                    1367               RTS
000021D6  4EB9 00002960           1368  MOVEWcode100 JSR    ISMOVEW
000021DC  4E75                    1369               RTS
000021DE  4EB9 00002960           1370  MOVEWcode101 JSR    ISMOVEW
000021E4  4E75                    1371               RTS
000021E6  4EB9 00002960           1372  MOVEWcode110 JSR    ISMOVEW
000021EC  4E75                    1373               RTS
000021EE  4EB9 00002960           1374  MOVEWcode111 JSR    ISMOVEW
000021F4  4E75                    1375               RTS
000021F6                          1376  
000021F6                          1377  ; TODO: adjust workflow to:
000021F6                          1378  ;   1) save message address to buffer pointer
000021F6  48E7 FFFE               1379  OPCODE_INVALID  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000021FA  4EB8 12EE               1380              JSR     INVALID_DATA
000021FE  548E                    1381              ADDA.L      #$00000002, A6          ; Increment past current opcode word
00002200  4CDF 7FFF               1382              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00002204  4E75                    1383              RTS
00002206                          1384  
00002206  48E7 FFFE               1385  ISBCC  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000220A  49F8 165A               1386              LEA    MESSAGEBCC, A4
0000220E  4EB9 00004566           1387              JSR    WRITE2MEM
00002214  49F8 14EC               1388              LEA    MESSAGESPACE, A4
00002218  4EB9 00004566           1389              JSR    WRITE2MEM
0000221E  4EB9 000035E2           1390              JSR     EA_Bcc
00002224  4CDF 7FFF               1391              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00002228  4E75                    1392              RTS
0000222A  48E7 FFFE               1393  ISBGT  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000222E  49F8 165E               1394              LEA MESSAGEBGT, A4
00002232  4EB9 00004566           1395              JSR    WRITE2MEM
00002238  49F8 14EC               1396              LEA    MESSAGESPACE, A4
0000223C  4EB9 00004566           1397              JSR    WRITE2MEM
00002242  4EB9 000035E2           1398              JSR     EA_Bcc
00002248  4CDF 7FFF               1399              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
0000224C  4E75                    1400              RTS
0000224E                          1401  
0000224E  48E7 FFFE               1402  ISBLE  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002252  49F8 1662               1403              LEA MESSAGEBLE, A4
00002256  4EB9 00004566           1404              JSR    WRITE2MEM
0000225C  49F8 14EC               1405              LEA    MESSAGESPACE, A4
00002260  4EB9 00004566           1406              JSR    WRITE2MEM
00002266  4EB9 000035E2           1407              JSR     EA_Bcc
0000226C  4CDF 7FFF               1408              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00002270  4E75                    1409              RTS
00002272                          1410  
00002272  48E7 FFFE               1411  ISDIVUW     MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002276  49F8 1653               1412              LEA MESSAGEDIVUW, A4
0000227A  4EB9 00004566           1413              JSR    WRITE2MEM
00002280  49F8 14EC               1414              LEA    MESSAGESPACE, A4
00002284  4EB9 00004566           1415              JSR    WRITE2MEM
0000228A  4EB9 00003814           1416              JSR     EA_DIVU_W
00002290  4CDF 7FFF               1417              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00002294  4E75                    1418              RTS
00002296                          1419  
00002296  48E7 FFFE               1420  ISORB   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000229A  49F8 1644               1421          LEA         MESSAGEORB, A4
0000229E  4EB9 00004566           1422          JSR    WRITE2MEM
000022A4  49F8 14EC               1423          LEA    MESSAGESPACE, A4
000022A8  4EB9 00004566           1424          JSR    WRITE2MEM
000022AE  4EB9 00004028           1425          JSR         EA_OR
000022B4  4CDF 7FFF               1426          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022B8  4E75                    1427          RTS
000022BA                          1428  
000022BA  48E7 FFFE               1429  ISORW   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022BE  49F8 1649               1430          LEA         MESSAGEORW, A4
000022C2  4EB9 00004566           1431          JSR    WRITE2MEM
000022C8  49F8 14EC               1432          LEA    MESSAGESPACE, A4
000022CC  4EB9 00004566           1433          JSR    WRITE2MEM
000022D2  4EB9 00004028           1434          JSR         EA_OR
000022D8  4CDF 7FFF               1435          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022DC  4E75                    1436          RTS
000022DE                          1437  
000022DE  48E7 FFFE               1438  ISORL   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
Line 1439 ERROR: Invalid addressing mode
000022E2                          1439          LEA         MESSAGEORL, 4
000022E2  4EB9 00004566           1440          JSR    WRITE2MEM
000022E8  49F8 14EC               1441          LEA    MESSAGESPACE, A4
000022EC  4EB9 00004566           1442          JSR    WRITE2MEM
000022F2  4EB9 00004028           1443          JSR         EA_OR
000022F8  4CDF 7FFF               1444          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022FC  4E75                    1445          RTS
000022FE                          1446  
000022FE  48E7 FFFE               1447  ISASRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002302  49F8 15D8               1448          LEA         MESSAGEASRB, A4
00002306  4EB9 00004566           1449          JSR    WRITE2MEM
0000230C  49F8 14EC               1450          LEA    MESSAGESPACE, A4
00002310  4EB9 00004566           1451          JSR    WRITE2MEM
00002316  4EB9 000034B2           1452          JSR         EA_ASd
0000231C  4CDF 7FFF               1453          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002320  4E75                    1454          RTS
00002322                          1455  
00002322  48E7 FFFE               1456  ISASRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002326  49F8 15DE               1457          LEA         MESSAGEASRW, A4
0000232A  4EB9 00004566           1458          JSR    WRITE2MEM
00002330  49F8 14EC               1459          LEA    MESSAGESPACE, A4
00002334  4EB9 00004566           1460          JSR    WRITE2MEM
0000233A  4EB9 000034B2           1461          JSR         EA_ASd
00002340  4CDF 7FFF               1462          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002344  4E75                    1463          RTS
00002346                          1464  
00002346  48E7 FFFE               1465  ISASRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000234A  49F8 15E4               1466          LEA         MESSAGEASRL, A4
0000234E  4EB9 00004566           1467          JSR    WRITE2MEM
00002354  49F8 14EC               1468          LEA    MESSAGESPACE, A4
00002358  4EB9 00004566           1469          JSR    WRITE2MEM
0000235E  4EB9 000034B2           1470          JSR         EA_ASd
00002364  4CDF 7FFF               1471          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002368  4E75                    1472          RTS
0000236A                          1473  
0000236A  48E7 FFFE               1474  ISASLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000236E  49F8 15EA               1475          LEA         MESSAGEASLB, A4
00002372  4EB9 00004566           1476          JSR    WRITE2MEM
00002378  49F8 14EC               1477          LEA    MESSAGESPACE, A4
0000237C  4EB9 00004566           1478          JSR    WRITE2MEM
00002382  4EB9 000034B2           1479          JSR         EA_ASd
00002388  4CDF 7FFF               1480          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000238C  4E75                    1481          RTS
0000238E                          1482  
0000238E  48E7 FFFE               1483  ISASLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002392  43F8 15F0               1484          LEA         MESSAGEASLW, A1
00002396  103C 000E               1485          MOVE.B      #14, D0
0000239A  4E4F                    1486          TRAP        #15
0000239C  4EB9 000034B2           1487          JSR         EA_ASd
000023A2  4CDF 7FFF               1488          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023A6  4E75                    1489          RTS
000023A8                          1490  
000023A8  48E7 FFFE               1491  ISASLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023AC  49F8 15F6               1492          LEA         MESSAGEASLL, A4
000023B0  4EB9 00004566           1493          JSR    WRITE2MEM
000023B6  49F8 14EC               1494          LEA    MESSAGESPACE, A4
000023BA  4EB9 00004566           1495          JSR    WRITE2MEM
000023C0  4EB9 000034B2           1496          JSR         EA_ASd
000023C6  4CDF 7FFF               1497          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023CA  4E75                    1498          RTS
000023CC                          1499  
000023CC  48E7 FFFE               1500  ISLSRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023D0  49F8 1620               1501          LEA         MESSAGELSRB, A4
000023D4  4EB9 00004566           1502          JSR    WRITE2MEM
000023DA  49F8 14EC               1503          LEA    MESSAGESPACE, A4
000023DE  4EB9 00004566           1504          JSR    WRITE2MEM
000023E4  4EB9 00003AA8           1505          JSR         EA_LSd
000023EA  4CDF 7FFF               1506          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023EE  4E75                    1507          RTS
000023F0                          1508  
000023F0  48E7 FFFE               1509  ISLSRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023F4  49F8 1626               1510          LEA         MESSAGELSRW, A4
000023F8  4EB9 00004566           1511          JSR    WRITE2MEM
000023FE  49F8 14EC               1512          LEA    MESSAGESPACE, A4
00002402  4EB9 00004566           1513          JSR    WRITE2MEM
00002408  4EB9 00003AA8           1514          JSR         EA_LSd
0000240E  4CDF 7FFF               1515          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002412  4E75                    1516          RTS
00002414                          1517  
00002414  48E7 FFFE               1518  ISLSRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002418  49F8 162C               1519          LEA         MESSAGELSRL, A4
0000241C  4EB9 00004566           1520          JSR    WRITE2MEM
00002422  49F8 14EC               1521          LEA    MESSAGESPACE, A4
00002426  4EB9 00004566           1522          JSR    WRITE2MEM
0000242C  4EB9 00003AA8           1523          JSR         EA_LSd
00002432  4CDF 7FFF               1524          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002436  4E75                    1525          RTS
00002438                          1526  
00002438  48E7 FFFE               1527  ISLSLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000243C  43F8 1632               1528          LEA         MESSAGELSLB, A1
00002440  103C 000E               1529          MOVE.B      #14, D0
00002444  4E4F                    1530          TRAP        #15
00002446  4EB9 00003AA8           1531          JSR         EA_LSd
0000244C  4CDF 7FFF               1532          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002450  4E75                    1533          RTS
00002452                          1534  
00002452  48E7 FFFE               1535  ISLSLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002456  49F8 1638               1536          LEA         MESSAGELSLW, A4
0000245A  4EB9 00004566           1537          JSR    WRITE2MEM
00002460  49F8 14EC               1538          LEA    MESSAGESPACE, A4
00002464  4EB9 00004566           1539          JSR    WRITE2MEM
0000246A  4EB9 00003AA8           1540          JSR         EA_LSd
00002470  4CDF 7FFF               1541          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002474  4E75                    1542          RTS
00002476                          1543  
00002476  48E7 FFFE               1544  ISLSLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000247A  49F8 163E               1545          LEA         MESSAGELSLL, A4
0000247E  4EB9 00004566           1546          JSR    WRITE2MEM
00002484  49F8 14EC               1547          LEA    MESSAGESPACE, A4
00002488  4EB9 00004566           1548          JSR    WRITE2MEM
0000248E  4EB9 00003AA8           1549          JSR         EA_LSd
00002494  4CDF 7FFF               1550          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002498  4E75                    1551          RTS
0000249A                          1552  
0000249A  48E7 FFFE               1553  ISRORB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000249E  49F8 15FC               1554          LEA         MESSAGERORB, A4
000024A2  4EB9 00004566           1555          JSR    WRITE2MEM
000024A8  49F8 14EC               1556          LEA    MESSAGESPACE, A4
000024AC  4EB9 00004566           1557          JSR    WRITE2MEM
000024B2  4EB9 000041EC           1558          JSR         EA_ROd
000024B8  4CDF 7FFF               1559          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024BC  4E75                    1560          RTS
000024BE                          1561  
000024BE  48E7 FFFE               1562  ISRORW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024C2  43F8 1602               1563          LEA         MESSAGERORW, A1
000024C6  103C 000E               1564          MOVE.B      #14, D0
000024CA  4E4F                    1565          TRAP        #15
000024CC  4EB9 000041EC           1566          JSR         EA_ROd
000024D2  4CDF 7FFF               1567          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024D6  4E75                    1568          RTS
000024D8                          1569  
000024D8  48E7 FFFE               1570  ISRORL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024DC  49F8 1608               1571          LEA         MESSAGERORL, A4
000024E0  4EB9 00004566           1572          JSR    WRITE2MEM
000024E6  49F8 14EC               1573          LEA    MESSAGESPACE, A4
000024EA  4EB9 00004566           1574          JSR    WRITE2MEM
000024F0  4EB9 000041EC           1575          JSR         EA_ROd
000024F6  4CDF 7FFF               1576          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024FA  4E75                    1577          RTS
000024FC                          1578  
000024FC  48E7 FFFE               1579  ISROLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002500  49F8 160E               1580          LEA         MESSAGEROLB, A4
00002504  4EB9 00004566           1581          JSR    WRITE2MEM
0000250A  49F8 14EC               1582          LEA    MESSAGESPACE, A4
0000250E  4EB9 00004566           1583          JSR    WRITE2MEM
00002514  4EB9 000041EC           1584          JSR         EA_ROd
0000251A  4CDF 7FFF               1585          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000251E  4E75                    1586          RTS
00002520                          1587  
00002520  48E7 FFFE               1588  ISROLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002524  49F8 1614               1589          LEA         MESSAGEROLW, A4
00002528  4EB9 00004566           1590          JSR    WRITE2MEM
0000252E  49F8 14EC               1591          LEA    MESSAGESPACE, A4
00002532  4EB9 00004566           1592          JSR    WRITE2MEM
00002538  4EB9 000041EC           1593          JSR         EA_ROd
0000253E  4CDF 7FFF               1594          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002542  4E75                    1595          RTS
00002544                          1596  
00002544  48E7 FFFE               1597  ISROLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002548  49F8 161A               1598          LEA         MESSAGEROLL, A4
0000254C  4EB9 00004566           1599          JSR    WRITE2MEM
00002552  49F8 14EC               1600          LEA    MESSAGESPACE, A4
00002556  4EB9 00004566           1601          JSR    WRITE2MEM
0000255C  4EB9 000041EC           1602          JSR         EA_ROd
00002562  4CDF 7FFF               1603          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002566  4E75                    1604          RTS
00002568                          1605  
00002568  48E7 FFFE               1606  ISMULSW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000256C  49F8 15D1               1607          LEA         MESSAGEMULSW, A4
00002570  4EB9 00004566           1608          JSR    WRITE2MEM
00002576  49F8 14EC               1609          LEA    MESSAGESPACE, A4
0000257A  4EB9 00004566           1610          JSR    WRITE2MEM
00002580  4EB9 00003F38           1611          JSR         EA_MULS_W
00002586  4CDF 7FFF               1612          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000258A  4E75                    1613          RTS
0000258C                          1614  
0000258C  48E7 FFFE               1615  ISANDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002590  49F8 15BF               1616          LEA         MESSAGEANDB, A4
00002594  4EB9 00004566           1617          JSR    WRITE2MEM
0000259A  49F8 14EC               1618          LEA    MESSAGESPACE, A4
0000259E  4EB9 00004566           1619          JSR    WRITE2MEM
000025A4  4EB9 000032F4           1620          JSR         EA_AND
000025AA  4CDF 7FFF               1621          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025AE  4E75                    1622          RTS
000025B0                          1623  
000025B0  48E7 FFFE               1624  ISANDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025B4  49F8 15C5               1625          LEA         MESSAGEANDW, A4
000025B8  4EB9 00004566           1626          JSR    WRITE2MEM
000025BE  49F8 14EC               1627          LEA    MESSAGESPACE, A4
000025C2  4EB9 00004566           1628          JSR    WRITE2MEM
000025C8  4EB9 000032F4           1629          JSR         EA_AND
000025CE  4CDF 7FFF               1630          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025D2  4E75                    1631          RTS
000025D4                          1632  
000025D4  48E7 FFFE               1633  ISANDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025D8  49F8 15CB               1634          LEA         MESSAGEANDL, A4
000025DC  4EB9 00004566           1635          JSR    WRITE2MEM
000025E2  49F8 14EC               1636          LEA    MESSAGESPACE, A4
000025E6  4EB9 00004566           1637          JSR    WRITE2MEM
000025EC  4EB9 000032F4           1638          JSR         EA_AND
000025F2  4CDF 7FFF               1639          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025F6  4E75                    1640          RTS
000025F8                          1641  
000025F8  48E7 FFFE               1642  ISADDAW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025FC  49F8 15A9               1643          LEA         MESSAGEADDAW, A4
00002600  4EB9 00004566           1644          JSR    WRITE2MEM
00002606  49F8 14EC               1645          LEA    MESSAGESPACE, A4
0000260A  4EB9 00004566           1646          JSR    WRITE2MEM
00002610  4EB9 00002FEA           1647          JSR         EA_ADDA
00002616  4CDF 7FFF               1648          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000261A  4E75                    1649          RTS
0000261C                          1650  
0000261C  48E7 FFFE               1651  ISADDAL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002620  49F8 15B0               1652          LEA         MESSAGEADDAL, A4
00002624  4EB9 00004566           1653          JSR    WRITE2MEM
0000262A  49F8 14EC               1654          LEA    MESSAGESPACE, A4
0000262E  4EB9 00004566           1655          JSR    WRITE2MEM
00002634  4EB9 00002FEA           1656          JSR         EA_ADDA
0000263A  4CDF 7FFF               1657          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000263E  4E75                    1658          RTS
00002640                          1659  
00002640  48E7 FFFE               1660  ISADDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002644  49F8 1597               1661          LEA         MESSAGEADDB, A4
00002648  4EB9 00004566           1662          JSR    WRITE2MEM
0000264E  49F8 14EC               1663          LEA    MESSAGESPACE, A4
00002652  4EB9 00004566           1664          JSR    WRITE2MEM
00002658  4EB9 00002E1E           1665          JSR         EA_ADD
0000265E  4CDF 7FFF               1666          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002662  4E75                    1667          RTS
00002664                          1668  
00002664  48E7 FFFE               1669  ISADDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002668  49F8 159D               1670          LEA         MESSAGEADDW, A4
0000266C  4EB9 00004566           1671          JSR    WRITE2MEM
00002672  49F8 14EC               1672          LEA    MESSAGESPACE, A4
00002676  4EB9 00004566           1673          JSR    WRITE2MEM
0000267C  4EB9 00002E1E           1674          JSR         EA_ADD
00002682  4CDF 7FFF               1675          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002686  4E75                    1676          RTS
00002688                          1677  
00002688  48E7 FFFE               1678  ISADDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000268C  49F8 15A3               1679          LEA         MESSAGEADDL, A4
00002690  4EB9 00004566           1680          JSR    WRITE2MEM
00002696  49F8 14EC               1681          LEA    MESSAGESPACE, A4
0000269A  4EB9 00004566           1682          JSR    WRITE2MEM
000026A0  4EB9 00002E1E           1683          JSR         EA_ADD
000026A6  4CDF 7FFF               1684          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026AA  4E75                    1685          RTS
000026AC                          1686  
000026AC  48E7 FFFE               1687  ISSUBB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026B0  49F8 1585               1688          LEA         MESSAGESUBB, A4
000026B4  4EB9 00004566           1689          JSR    WRITE2MEM
000026BA  49F8 14EC               1690          LEA    MESSAGESPACE, A4
000026BE  4EB9 00004566           1691          JSR    WRITE2MEM
000026C4  4EB9 0000431C           1692          JSR         EA_SUB
000026CA  4CDF 7FFF               1693          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026CE  4E75                    1694          RTS
000026D0                          1695  
000026D0  48E7 FFFE               1696  ISSUBW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026D4  49F8 158B               1697          LEA         MESSAGESUBW, A4
000026D8  4EB9 00004566           1698          JSR    WRITE2MEM
000026DE  49F8 14EC               1699          LEA    MESSAGESPACE, A4
000026E2  4EB9 00004566           1700          JSR    WRITE2MEM
000026E8  4EB9 0000431C           1701          JSR         EA_SUB
000026EE  4CDF 7FFF               1702          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026F2  4E75                    1703          RTS
000026F4                          1704  
000026F4  48E7 FFFE               1705  ISSUBL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026F8  49F8 1591               1706          LEA         MESSAGESUBL, A4
000026FC  4EB9 00004566           1707          JSR    WRITE2MEM
00002702  49F8 14EC               1708          LEA    MESSAGESPACE, A4
00002706  4EB9 00004566           1709          JSR    WRITE2MEM
0000270C  4EB9 0000431C           1710          JSR         EA_SUB
00002712  4CDF 7FFF               1711          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002716  4E75                    1712          RTS
00002718                          1713  
00002718  48E7 FFFE               1714  ISCMPB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000271C  49F8 1573               1715          LEA         MESSAGECMPB, A4
00002720  4EB9 00004566           1716          JSR    WRITE2MEM
00002726  49F8 14EC               1717          LEA    MESSAGESPACE, A4
0000272A  4EB9 00004566           1718          JSR    WRITE2MEM
00002730  4EB9 00003738           1719          JSR         EA_CMP
00002736  4CDF 7FFF               1720          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000273A  4E75                    1721          RTS
0000273C                          1722  
0000273C  48E7 FFFE               1723  ISCMPW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002740  49F8 1579               1724          LEA         MESSAGECMPW, A4
00002744  4EB9 00004566           1725          JSR    WRITE2MEM
0000274A  49F8 14EC               1726          LEA    MESSAGESPACE, A4
0000274E  4EB9 00004566           1727          JSR    WRITE2MEM
00002754  4EB9 00003738           1728          JSR         EA_CMP
0000275A  4CDF 7FFF               1729          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000275E  4E75                    1730          RTS
00002760                          1731  
00002760  48E7 FFFE               1732  ISCMPL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002764  49F8 157F               1733          LEA         MESSAGECMPL, A4
00002768  4EB9 00004566           1734          JSR    WRITE2MEM
0000276E  49F8 14EC               1735          LEA    MESSAGESPACE, A4
00002772  4EB9 00004566           1736          JSR    WRITE2MEM
00002778  4EB9 00003738           1737          JSR         EA_CMP
0000277E  4CDF 7FFF               1738          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002782  4E75                    1739          RTS
00002784                          1740  
00002784  48E7 FFFE               1741  ISADDQB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002788  49F8 155E               1742          LEA         MESSAGEADDQB, A4
0000278C  4EB9 00004566           1743          JSR    WRITE2MEM
00002792  49F8 14EC               1744          LEA    MESSAGESPACE, A4
00002796  4EB9 00004566           1745          JSR    WRITE2MEM
0000279C  4EB9 000031F6           1746          JSR         EA_ADDQ
000027A2  4CDF 7FFF               1747          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027A6  4E75                    1748          RTS
000027A8                          1749  
000027A8  48E7 FFFE               1750  ISADDQW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027AC  49F8 1565               1751          LEA         MESSAGEADDQW, A4
000027B0  4EB9 00004566           1752          JSR    WRITE2MEM
000027B6  49F8 14EC               1753          LEA    MESSAGESPACE, A4
000027BA  4EB9 00004566           1754          JSR    WRITE2MEM
000027C0  4EB9 000031F6           1755          JSR         EA_ADDQ
000027C6  4CDF 7FFF               1756          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027CA  4E75                    1757          RTS
000027CC                          1758  
000027CC  48E7 FFFE               1759  ISADDQL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027D0  43F8 156C               1760          LEA         MESSAGEADDQL, A1 *OPCODE is ADDQ.L
000027D4  103C 000E               1761          MOVE.B      #14, D0
000027D8  4E4F                    1762          TRAP        #15
000027DA  4EB9 000031F6           1763          JSR         EA_ADDQ
000027E0  4CDF 7FFF               1764          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027E4  4E75                    1765          RTS
000027E6                          1766  
000027E6  48E7 FFFE               1767  ISMOVEQL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000027EA  49F8 15B7               1768          LEA         MESSAGEMOVEQL, A4
000027EE  4EB9 00004566           1769          JSR    WRITE2MEM
000027F4  49F8 14EC               1770          LEA    MESSAGESPACE, A4
000027F8  4EB9 00004566           1771          JSR    WRITE2MEM
000027FE  4EB9 00003ED8           1772          JSR         EA_MOVEQ
00002804  4CDF 7FFF               1773          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002808  4E75                    1774          RTS
0000280A                          1775  
0000280A  48E7 FFFE               1776  ISCLRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000280E  49F8 154C               1777          LEA         MESSAGECLRB, A4
00002812  4EB9 00004566           1778          JSR    WRITE2MEM
00002818  49F8 14EC               1779          LEA    MESSAGESPACE, A4
0000281C  4EB9 00004566           1780          JSR    WRITE2MEM
00002822  4EB9 00003ED8           1781          JSR         EA_MOVEQ
00002828  4CDF 7FFF               1782          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000282C  4E75                    1783          RTS
0000282E                          1784  
0000282E  48E7 FFFE               1785  ISCLRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002832  49F8 1552               1786          LEA         MESSAGECLRW, A4
00002836  4EB9 00004566           1787          JSR    WRITE2MEM
0000283C  49F8 14EC               1788          LEA    MESSAGESPACE, A4
00002840  4EB9 00004566           1789          JSR    WRITE2MEM
00002846  4EB9 00003670           1790          JSR         EA_CLR
0000284C  4CDF 7FFF               1791          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002850  4E75                    1792          RTS
00002852                          1793  
00002852  48E7 FFFE               1794  ISCLRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002856  49F8 1558               1795          LEA         MESSAGECLRL, A4
0000285A  4EB9 00004566           1796          JSR    WRITE2MEM
00002860  49F8 14EC               1797          LEA    MESSAGESPACE, A4
00002864  4EB9 00004566           1798          JSR    WRITE2MEM
0000286A  4EB9 00003670           1799          JSR         EA_CLR
00002870  4CDF 7FFF               1800          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002874  4E75                    1801          RTS
00002876                          1802  
00002876  48E7 FFFE               1803  ISMOVEML MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
0000287A  49F8 152C               1804          LEA         MESSAGEMOVEML, A4
0000287E  4EB9 00004566           1805          JSR    WRITE2MEM
00002884  49F8 14EC               1806          LEA    MESSAGESPACE, A4
00002888  4EB9 00004566           1807          JSR    WRITE2MEM
0000288E  4EB9 00003ED2           1808          JSR         EA_MOVEM
00002894  4CDF 7FFF               1809          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002898  4E75                    1810          RTS
0000289A                          1811  
0000289A  48E7 FFFE               1812  ISMOVEMW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
0000289E  49F8 1534               1813          LEA         MESSAGEMOVEMW, A4
000028A2  4EB9 00004566           1814          JSR    WRITE2MEM
000028A8  49F8 14EC               1815          LEA    MESSAGESPACE, A4
000028AC  4EB9 00004566           1816          JSR    WRITE2MEM
000028B2  4EB9 00003ED2           1817          JSR         EA_MOVEM
000028B8  4CDF 7FFF               1818          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000028BC  4E75                    1819          RTS
000028BE                          1820  
000028BE  48E7 FFFE               1821  ISLEA   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000028C2  49F8 1548               1822          LEA         MESSAGELEA, A4
000028C6  4EB9 00004566           1823          JSR    WRITE2MEM
000028CC  49F8 14EC               1824          LEA    MESSAGESPACE, A4
000028D0  4EB9 00004566           1825          JSR    WRITE2MEM
000028D6  4EB9 000039CC           1826          JSR         EA_LEA
000028DC  4CDF 7FFF               1827          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000028E0  4E75                    1828          RTS                         ; Exit subroutine
000028E2                          1829  
000028E2  48E7 FFFE               1830  ISJSR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000028E6  49F8 153C               1831          LEA         MESSAGEJSR, A4
000028EA  4EB9 00004566           1832          JSR    WRITE2MEM
000028F0  49F8 14EC               1833          LEA    MESSAGESPACE, A4
000028F4  4EB9 00004566           1834          JSR    WRITE2MEM
000028FA  4EB9 00003904           1835          JSR         EA_JSR
00002900  4CDF 7FFF               1836          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002904  4E75                    1837          RTS                         ; Exit subroutine
00002906                          1838  
00002906  48E7 FFFE               1839  ISRTS   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000290A  49F8 1544               1840          LEA         MESSAGERTS, A4
0000290E  4EB9 00004566           1841          JSR    WRITE2MEM
00002914  49F8 14EC               1842          LEA    MESSAGESPACE, A4
00002918  4EB9 00004566           1843          JSR    WRITE2MEM
0000291E  548E                    1844          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
00002920  4CDF 7FFF               1845          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002924  4E75                    1846          RTS
00002926                          1847  
00002926  48E7 FFFE               1848  ISCLR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000292A  43F8 1540               1849          LEA         MESSAGECLR, A1  *OPCODE is CLR
0000292E  103C 000E               1850          MOVE.B      #14, D0
00002932  4E4F                    1851          TRAP        #15
00002934  4EB9 00003670           1852          JSR         EA_CLR
0000293A  4CDF 7FFF               1853          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000293E  4E75                    1854          RTS
00002940                          1855  
00002940  48E7 FFFE               1856  ISNOP   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002944  49F8 14EE               1857          LEA         MESSAGENOP, A4
00002948  4EB9 00004566           1858          JSR    WRITE2MEM
0000294E  49F8 14EC               1859          LEA    MESSAGESPACE, A4
00002952  4EB9 00004566           1860          JSR    WRITE2MEM
00002958  548E                    1861          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
0000295A  4CDF 7FFF               1862          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000295E  4E75                    1863          RTS                         ; Exit subroutine
00002960                          1864  
00002960  48E7 FFFE               1865  ISMOVEW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002964  49F8 14F2               1866          LEA         MESSAGEMOVEW, A4
00002968  4EB9 00004566           1867          JSR    WRITE2MEM
0000296E  49F8 14EC               1868          LEA    MESSAGESPACE, A4
00002972  4EB9 00004566           1869          JSR    WRITE2MEM
00002978  4EB9 00003BD8           1870          JSR         EA_MOVE
0000297E  4CDF 7FFF               1871          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002982  4E75                    1872          RTS                         ; Exit subroutine
00002984                          1873  
00002984  48E7 FFFE               1874  ISMOVEAW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
00002988  49F8 1524               1875          LEA         MESSAGEMOVEAW, A4
0000298C  4EB9 00004566           1876          JSR    WRITE2MEM
00002992  49F8 14EC               1877          LEA    MESSAGESPACE, A4
00002996  4EB9 00004566           1878          JSR    WRITE2MEM
0000299C  4EB9 00003DAC           1879          JSR         EA_MOVEA
000029A2  4CDF 7FFF               1880          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000029A6  4E75                    1881          RTS                         ; Exit subroutine
000029A8                          1882  
000029A8  48E7 FFFE               1883  ISMOVEL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000029AC  49F8 14F9               1884          LEA         MESSAGEMOVEL, A4
000029B0  4EB9 00004566           1885          JSR    WRITE2MEM
000029B6  49F8 14EC               1886          LEA    MESSAGESPACE, A4
000029BA  4EB9 00004566           1887          JSR    WRITE2MEM
000029C0  4EB9 00003BD8           1888          JSR         EA_MOVE
000029C6  4CDF 7FFF               1889          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000029CA  4E75                    1890          RTS                         ; Exit subroutine
000029CC                          1891  
000029CC  48E7 FFFE               1892  ISMOVEAL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000029D0  49F8 151C               1893          LEA         MESSAGEMOVEAL, A4
000029D4  4EB9 00004566           1894          JSR    WRITE2MEM
000029DA  49F8 14EC               1895          LEA    MESSAGESPACE, A4
000029DE  4EB9 00004566           1896          JSR    WRITE2MEM
000029E4  4EB9 00003DAC           1897          JSR         EA_MOVEA
000029EA  4CDF 7FFF               1898          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000029EE  4E75                    1899          RTS                         ; Exit subroutine
000029F0                          1900  
000029F0  48E7 FFFE               1901  ISMOVEB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000029F4  43F8 1500               1902          LEA         MESSAGEMOVEB, A1 *OPCODE is MOVE.B so display MOVEB message
000029F8  103C 000E               1903          MOVE.B      #14, D0
000029FC  4E4F                    1904          TRAP        #15
000029FE  4EB9 00003BD8           1905          JSR         EA_MOVE
00002A04  4CDF 7FFF               1906          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002A08  4E75                    1907          RTS                         ; Exit subroutine
00002A0A                          1908  
00002A0A  48E7 FFFE               1909  ISADDIW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002A0E  49F8 1507               1910          LEA         MESSAGEADDIW, A4
00002A12  4EB9 00004566           1911          JSR    WRITE2MEM
00002A18  49F8 14EC               1912          LEA    MESSAGESPACE, A4
00002A1C  4EB9 00004566           1913          JSR    WRITE2MEM
00002A22  4EB9 000030DA           1914          JSR         EA_ADDI
00002A28  4CDF 7FFF               1915          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002A2C  4E75                    1916          RTS                         ; Exit subroutine
00002A2E                          1917  
00002A2E  48E7 FFFE               1918  ISADDIL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002A32  49F8 150E               1919          LEA         MESSAGEADDIL, A4
00002A36  4EB9 00004566           1920          JSR    WRITE2MEM
00002A3C  49F8 14EC               1921          LEA    MESSAGESPACE, A4
00002A40  4EB9 00004566           1922          JSR    WRITE2MEM
00002A46  4EB9 000030DA           1923          JSR         EA_ADDI
00002A4C  4CDF 7FFF               1924          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002A50  4E75                    1925          RTS                         ; Exit subroutine
00002A52                          1926  
00002A52  48E7 FFFE               1927  ISADDIB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002A56  49F8 1515               1928          LEA         MESSAGEADDIB, A4
00002A5A  4EB9 00004566           1929          JSR    WRITE2MEM
00002A60  49F8 14EC               1930          LEA    MESSAGESPACE, A4
00002A64  4EB9 00004566           1931          JSR    WRITE2MEM
00002A6A  4EB9 000030DA           1932          JSR         EA_ADDI
00002A70  4CDF 7FFF               1933          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002A74  4E75                    1934          RTS                         ; Exit subroutine
00002A76                          1935  
00002A76                          1936  
00002A76                          1937  
00002A76                          1938  
00002A76                          1939  
00002A76                          1940  
00002A76                          1941  
00002A76                          1942  -------------------- end include --------------------
00002A76                          1943      INCLUDE 'EA.X68'
00002A76                          1944  
00002A76                          1945      INCLUDE 'EAMessages.X68'
00002A76                          1946  
00002A76= 00                      1947  EA_MSG_NULL         DC.B    0
00002A77= 20 00                   1948  EA_MSG_SPACE        DC.B    ' ',0
00002A79= 2C 20 00                1949  EA_MSG_COMMA        DC.B    ', ',0
00002A7C= 28 00                   1950  EA_MSG_OPENPAREN    DC.B    '(',0
00002A7E= 29 00                   1951  EA_MSG_CLOSEPAREN   DC.B    ')',0
00002A80= 2D 00                   1952  EA_MSG_MIN          DC.B    '-',0
00002A82= 2B 00                   1953  EA_MSG_PLUS         DC.B    '+',0
00002A84= 23 00                   1954  EA_MSG_HASH         DC.B    '#',0
00002A86= 24 00                   1955  EA_MSG_HEX          DC.B    '$',0
00002A88                          1956  
00002A88= 44 30 00                1957  EA_MSG_D0           DC.B    'D0',0
00002A8B= 44 31 00                1958  EA_MSG_D1           DC.B    'D1',0
00002A8E= 44 32 00                1959  EA_MSG_D2           DC.B    'D2',0
00002A91= 44 33 00                1960  EA_MSG_D3           DC.B    'D3',0
00002A94= 44 34 00                1961  EA_MSG_D4           DC.B    'D4',0
00002A97= 44 35 00                1962  EA_MSG_D5           DC.B    'D5',0
00002A9A= 44 36 00                1963  EA_MSG_D6           DC.B    'D6',0
00002A9D= 44 37 00                1964  EA_MSG_D7           DC.B    'D7',0
00002AA0                          1965  
00002AA0= 41 30 00                1966  EA_MSG_A0           DC.B    'A0',0
00002AA3= 41 31 00                1967  EA_MSG_A1           DC.B    'A1',0
00002AA6= 41 32 00                1968  EA_MSG_A2           DC.B    'A2',0
00002AA9= 41 33 00                1969  EA_MSG_A3           DC.B    'A3',0
00002AAC= 41 34 00                1970  EA_MSG_A4           DC.B    'A4',0
00002AAF= 41 35 00                1971  EA_MSG_A5           DC.B    'A5',0
00002AB2= 41 36 00                1972  EA_MSG_A6           DC.B    'A6',0
00002AB5= 41 37 00                1973  EA_MSG_A7           DC.B    'A7',0
00002AB8                          1974  
00002AB8= 5B 45 41 20 43 4F ...   1975  EA_MSG_UNIMP        DC.B    '[EA CODE NOT IMPLEMENTED]',0
00002AD2= 5B 50 52 49 4E 54 ...   1976  EA_MSG_PRINT_DATA   DC.B    '[PRINTING DATA NOT IMPLEMENTED]',0
00002AF2                          1977  
00002AF2                          1978  -------------------- end include --------------------
00002AF2                          1979      INCLUDE 'EA_UTIL.X68'
00002AF2                          1980  
00002AF2                          1981  
00002AF2                          1982  EA_UNIMPLEMENTED:
00002AF2  548E                    1983      ADDA.L      #$00000002, A6      ; Increment past current opcode word
Line 1984 ERROR: Comma expected
00002AF4                          1984      LEA         EA_MSG_UNIMP
00002AF4  4EB9 00004566           1985      JSR         WRITE2MEM
00002AFA  4E75                    1986      RTS
00002AFC                          1987  
00002AFC                          1988  EA_INVALID:
00002AFC  2A4E                    1989      MOVEA.L     A6, A5              ; Copy global pointer
00002AFE  548D                    1990      ADDA.L      #$00000002, A5      ; Increment past current opcode word
00002B00  4EB8 12EE               1991      JSR         INVALID_DATA        ; Print data error message
00002B04  4E75                    1992      RTS
00002B06                          1993  
00002B06                          1994  EA_PRINT_DATA:
Line 1995 ERROR: Comma expected
00002B06                          1995      LEA         EA_MSG_PRINT_DATA
00002B06  4EB9 00004566           1996      JSR         WRITE2MEM
00002B0C  4E75                    1997      RTS
00002B0E                          1998  
00002B0E                          1999  
00002B0E                          2000  EA_UPDATE_POINTER:
00002B0E  BDCD                    2001      CMP.L       A5, A6              ; Check if A5==A6
00002B10  6600 0004               2002      BNE         UPDATE_PTR          ; If NOT equal (a.k.a if any extra operands
00002B14                          2003                                      ; were read, and is already up to date),
00002B14                          2004                                      ; update global with current
00002B14  548D                    2005      ADDA.L      #$00000002, A5      ; Else, increment past current opcode word, then update
00002B16                          2006  UPDATE_PTR:
00002B16  2C4D                    2007      MOVEA.L     A5, A6              ; Update global pointer
00002B18  4E75                    2008      RTS
00002B1A                          2009  
00002B1A                          2010  EA_COPY_PTR:
00002B1A  2A4E                    2011      MOVEA.L     A6, A5              ; Save global pointer
00002B1C  4E75                    2012      RTS
00002B1E                          2013  
00002B1E                          2014  EA_DEFAULT_COMBO:
00002B1E  4286                    2015      CLR.L       D6                  ; Clear space for mode bits
00002B20  4287                    2016      CLR.L       D7                  ; Clear space for register bits
00002B22  2216                    2017      MOVE.L      (A6), D1            ; Load opcode to data register 1
00002B24  143C 000A               2018      MOVE.B      #10, D2             ; Clear upper 10 bits of opcode word
00002B28  E569                    2019      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002B2A  143C 000D               2020      MOVE.B      #13, D2             ; 'Right-align' bits 3-5 to determine mode bits
00002B2E  E469                    2021      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002B30  1C01                    2022      MOVE.B      D1, D6              ; Save mode bits to D6
00002B32  2216                    2023      MOVE.L      (A6), D1            ; Reload opcode to data register 1
00002B34  143C 000D               2024      MOVE.B      #13, D2             ; Clear upper 13 bits of opcode word
00002B38  E569                    2025      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002B3A  143C 000D               2026      MOVE.B      #13, D2             ; 'Right-align' bits 0-2 to determine register bits
00002B3E  E469                    2027      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002B40  1E01                    2028      MOVE.B      D1, D7              ; Save register bits to D7
00002B42  4E75                    2029      RTS                             ; Return from subroutine
00002B44                          2030  
00002B44                          2031  EA_OPMODE_COMBO:
00002B44  4286                    2032      CLR.L       D6                  ; Clear space for mode bits
00002B46  4287                    2033      CLR.L       D7                  ; Clear space for register bits
00002B48  2216                    2034      MOVE.L      (A6), D1            ; Load opcode to data register 1
00002B4A  143C 0007               2035      MOVE.B      #7, D2              ; Clear upper 7 bits of opcode word
00002B4E  E569                    2036      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002B50  143C 000D               2037      MOVE.B      #13, D2             ; 'Right-align' bits 6-8 to determine opmode bits
00002B54  E469                    2038      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002B56  1C01                    2039      MOVE.B      D1, D6              ; Save opmode bits to D6
00002B58  2216                    2040      MOVE.L      (A6), D1            ; Reload opcode to data register 1
00002B5A  143C 0004               2041      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00002B5E  E569                    2042      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002B60  143C 000D               2043      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register bits
00002B64  E469                    2044      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002B66  1E01                    2045      MOVE.B      D1, D7              ; Save register bits to D7
00002B68  4E75                    2046      RTS                             ; Return from subroutine
00002B6A                          2047  
00002B6A                          2048  EA_SIZE_BITS:
00002B6A  4287                    2049      CLR.L       D7
00002B6C  2E16                    2050      MOVE.L      (A6), D7            ; Load opcode to data register 1
00002B6E  143C 0008               2051      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00002B72  E56F                    2052      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00002B74  143C 000E               2053      MOVE.B      #14, D2             ; 'Right-align' bits 6-7 to determine size bits
00002B78  E46F                    2054      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00002B7A  4E75                    2055      RTS
00002B7C                          2056  
00002B7C                          2057  
00002B7C                          2058  EA_PRINT_DN:
00002B7C  41F9 00002B8A           2059      LEA         EA_PRINT_DN_JMP, A0 ; Set index '0' for jump table
00002B82  CEFC 0006               2060      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002B86  4EF0 7000               2061      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002B8A                          2062  EA_PRINT_DN_JMP:
00002B8A  4EF9 00002BBA           2063      JMP         DN_000 ; D0
00002B90  4EF9 00002BC0           2064      JMP         DN_001 ; D1
00002B96  4EF9 00002BC6           2065      JMP         DN_010 ; D2
00002B9C  4EF9 00002BCC           2066      JMP         DN_011 ; D3
00002BA2  4EF9 00002BD2           2067      JMP         DN_100 ; D4
00002BA8  4EF9 00002BD8           2068      JMP         DN_101 ; D5
00002BAE  4EF9 00002BDE           2069      JMP         DN_110 ; D6
00002BB4  4EF9 00002BE4           2070      JMP         DN_111 ; D7
00002BBA                          2071  DN_000: ; D0
Line 2072 ERROR: Comma expected
00002BBA                          2072      LEA         EA_MSG_D0
00002BBA  4EB9 00004566           2073      JSR         WRITE2MEM
00002BC0                          2074  DN_001: ; D1
Line 2075 ERROR: Comma expected
00002BC0                          2075      LEA         EA_MSG_D1
00002BC0  4EB9 00004566           2076      JSR         WRITE2MEM
00002BC6                          2077  DN_010: ; D2
Line 2078 ERROR: Comma expected
00002BC6                          2078      LEA         EA_MSG_D2
00002BC6  4EB9 00004566           2079      JSR         WRITE2MEM
00002BCC                          2080  DN_011: ; D3
Line 2081 ERROR: Comma expected
00002BCC                          2081      LEA         EA_MSG_D3
00002BCC  4EB9 00004566           2082      JSR         WRITE2MEM
00002BD2                          2083  DN_100: ; D4
Line 2084 ERROR: Comma expected
00002BD2                          2084      LEA         EA_MSG_D4
00002BD2  4EB9 00004566           2085      JSR         WRITE2MEM
00002BD8                          2086  DN_101: ; D5
Line 2087 ERROR: Comma expected
00002BD8                          2087      LEA         EA_MSG_D5
00002BD8  4EB9 00004566           2088      JSR         WRITE2MEM
00002BDE                          2089  DN_110: ; D6
Line 2090 ERROR: Comma expected
00002BDE                          2090      LEA         EA_MSG_D6
00002BDE  4EB9 00004566           2091      JSR         WRITE2MEM
00002BE4                          2092  DN_111: ; D7
Line 2093 ERROR: Comma expected
00002BE4                          2093      LEA         EA_MSG_D7
00002BE4  4EB9 00004566           2094      JSR         WRITE2MEM
00002BEA                          2095  
00002BEA                          2096  EA_PRINT_DN_END:
00002BEA  4E75                    2097      RTS
00002BEC                          2098  
00002BEC                          2099  EA_PRINT_AN:
00002BEC  41F9 00002BFA           2100      LEA         AN_JMP, A0          ; Set index '0' for jump table
00002BF2  CEFC 0006               2101      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002BF6  4EF0 7000               2102      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002BFA                          2103  AN_JMP:
00002BFA  4EF9 00002C2A           2104      JMP         AN_000 ; A0
00002C00  4EF9 00002C30           2105      JMP         AN_001 ; A1
00002C06  4EF9 00002C36           2106      JMP         AN_010 ; A2
00002C0C  4EF9 00002C3C           2107      JMP         AN_011 ; A3
00002C12  4EF9 00002C42           2108      JMP         AN_100 ; A4
00002C18  4EF9 00002C48           2109      JMP         AN_101 ; A5
00002C1E  4EF9 00002C4E           2110      JMP         AN_110 ; A6
00002C24  4EF9 00002C54           2111      JMP         AN_111 ; A7
00002C2A                          2112  AN_000: ; A0
Line 2113 ERROR: Comma expected
00002C2A                          2113      LEA         EA_MSG_A0
00002C2A  4EB9 00004566           2114      JSR         WRITE2MEM
00002C30                          2115  AN_001: ; A1
Line 2116 ERROR: Comma expected
00002C30                          2116      LEA         EA_MSG_A1
00002C30  4EB9 00004566           2117      JSR         WRITE2MEM
00002C36                          2118  AN_010: ; A2
Line 2119 ERROR: Comma expected
00002C36                          2119      LEA         EA_MSG_A2
00002C36  4EB9 00004566           2120      JSR         WRITE2MEM
00002C3C                          2121  AN_011: ; A3
Line 2122 ERROR: Comma expected
00002C3C                          2122      LEA         EA_MSG_A3
00002C3C  4EB9 00004566           2123      JSR         WRITE2MEM
00002C42                          2124  AN_100: ; A4
Line 2125 ERROR: Comma expected
00002C42                          2125      LEA         EA_MSG_A4
00002C42  4EB9 00004566           2126      JSR         WRITE2MEM
00002C48                          2127  AN_101: ; A5
Line 2128 ERROR: Comma expected
00002C48                          2128      LEA         EA_MSG_A5
00002C48  4EB9 00004566           2129      JSR         WRITE2MEM
00002C4E                          2130  AN_110: ; A6
Line 2131 ERROR: Comma expected
00002C4E                          2131      LEA         EA_MSG_A6
00002C4E  4EB9 00004566           2132      JSR         WRITE2MEM
00002C54                          2133  AN_111: ; A7
Line 2134 ERROR: Comma expected
00002C54                          2134      LEA         EA_MSG_A7
00002C54  4EB9 00004566           2135      JSR         WRITE2MEM
00002C5A                          2136  
00002C5A                          2137  EA_PRINT_AN_END:
00002C5A  4E75                    2138      RTS
00002C5C                          2139  EA_PRINT_IND:
Line 2140 ERROR: Comma expected
00002C5C                          2140      LEA         OPAREN    ; Print open parentheses
00002C5C  4EB9 00004566           2141      JSR         WRITE2MEM
00002C62  41F9 00002C70           2142      LEA         IND_JMP, A0         ; Set index '0' for jump table
00002C68  CEFC 0006               2143      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002C6C  4EF0 7000               2144      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002C70                          2145  IND_JMP:
00002C70  4EF9 00002CA0           2146      JMP         IND_000 ; (A0)
00002C76  4EF9 00002CA6           2147      JMP         IND_001 ; (A1)
00002C7C  4EF9 00002CAC           2148      JMP         IND_010 ; (A2)
00002C82  4EF9 00002CB2           2149      JMP         IND_011 ; (A3)
00002C88  4EF9 00002CB8           2150      JMP         IND_100 ; (A4)
00002C8E  4EF9 00002CBE           2151      JMP         IND_101 ; (A5)
00002C94  4EF9 00002CC4           2152      JMP         IND_110 ; (A6)
00002C9A  4EF9 00002CCA           2153      JMP         IND_111 ; (A7)
00002CA0                          2154  IND_000: ; (A0)
Line 2155 ERROR: Comma expected
00002CA0                          2155      LEA         EA_MSG_A0
00002CA0  4EB9 00004566           2156      JSR         WRITE2MEM
00002CA6                          2157  IND_001: ; (A1)
Line 2158 ERROR: Comma expected
00002CA6                          2158      LEA         EA_MSG_A1
00002CA6  4EB9 00004566           2159      JSR         WRITE2MEM
00002CAC                          2160  IND_010: ; (A2)
Line 2161 ERROR: Comma expected
00002CAC                          2161      LEA         EA_MSG_A2
00002CAC  4EB9 00004566           2162      JSR         WRITE2MEM
00002CB2                          2163  IND_011: ; (A3)
Line 2164 ERROR: Comma expected
00002CB2                          2164      LEA         EA_MSG_A3
00002CB2  4EB9 00004566           2165      JSR         WRITE2MEM
00002CB8                          2166  IND_100: ; (A4)
Line 2167 ERROR: Comma expected
00002CB8                          2167      LEA         EA_MSG_A4
00002CB8  4EB9 00004566           2168      JSR         WRITE2MEM
00002CBE                          2169  IND_101: ; (A5)
Line 2170 ERROR: Comma expected
00002CBE                          2170      LEA         EA_MSG_A5
00002CBE  4EB9 00004566           2171      JSR         WRITE2MEM
00002CC4                          2172  IND_110: ; (A6)
Line 2173 ERROR: Comma expected
00002CC4                          2173      LEA         EA_MSG_A6
00002CC4  4EB9 00004566           2174      JSR         WRITE2MEM
00002CCA                          2175  IND_111: ; (A7)
Line 2176 ERROR: Comma expected
00002CCA                          2176      LEA         EA_MSG_A7
00002CCA  4EB9 00004566           2177      JSR         WRITE2MEM
00002CD0                          2178  EA_PRINT_IND_END:
Line 2179 ERROR: Comma expected
00002CD0                          2179      LEA         CPAREN   ; Print close parentheses
00002CD0  4EB9 00004566           2180      JSR         WRITE2MEM
00002CD6  4E75                    2181      RTS
00002CD8                          2182  EA_PRINT_IMM:
00002CD8  224D                    2183      MOVEA.L     A5, A1              ; copy pointer to temp
00002CDA  5489                    2184      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002CDC  BA7C 0003               2185      CMP         #3, D5
00002CE0  6700 0010               2186      BEQ         PRINT_IMM_L         ; if L, branch
00002CE4  3011                    2187      MOVE.W      (A1), D0            ; store value in a register (todo, register tbd)
00002CE6  4EB8 2B06               2188      JSR         EA_PRINT_DATA *print value TODO
00002CEA  5489                    2189      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002CEC  4EF9 00002CF6           2190      JMP         PRINT_IMM_END
00002CF2                          2191  PRINT_IMM_L:
00002CF2  2011                    2192      MOVE.L      (A1), D0            ; store value in a register (todo, register tbd)
00002CF4                          2193      *print value TODO
00002CF4  5889                    2194      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002CF6                          2195  PRINT_IMM_END:
00002CF6  2A49                    2196      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002CF8  4E75                    2197      RTS
00002CFA                          2198  EA_PRINT_POSTINC:
Line 2199 ERROR: Comma expected
00002CFA                          2199      LEA         OPAREN    ; Print open parentheses
00002CFA  4EB9 00004566           2200      JSR         WRITE2MEM
00002D00  41F9 00002D0E           2201      LEA         POSTINC_JMP, A0     ; Set index '0' for jump table
00002D06  CEFC 0006               2202      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002D0A  4EF0 7000               2203      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002D0E                          2204  POSTINC_JMP:
00002D0E  4EF9 00002D3E           2205      JMP         POSTINC_000 ; (A0)+
00002D14  4EF9 00002D44           2206      JMP         POSTINC_001 ; (A1)+
00002D1A  4EF9 00002D4A           2207      JMP         POSTINC_010 ; (A2)+
00002D20  4EF9 00002D50           2208      JMP         POSTINC_011 ; (A3)+
00002D26  4EF9 00002D56           2209      JMP         POSTINC_100 ; (A4)+
00002D2C  4EF9 00002D5C           2210      JMP         POSTINC_101 ; (A5)+
00002D32  4EF9 00002D62           2211      JMP         POSTINC_110 ; (A6)+
00002D38  4EF9 00002D68           2212      JMP         POSTINC_111 ; (A7)+
00002D3E                          2213  POSTINC_000: ; (A0)+
Line 2214 ERROR: Comma expected
00002D3E                          2214      LEA         EA_MSG_A0
00002D3E  4EB9 00004566           2215      JSR         WRITE2MEM
00002D44                          2216  POSTINC_001: ; (A1)+
Line 2217 ERROR: Comma expected
00002D44                          2217      LEA         EA_MSG_A1
00002D44  4EB9 00004566           2218      JSR         WRITE2MEM
00002D4A                          2219  POSTINC_010: ; (A2)+
Line 2220 ERROR: Comma expected
00002D4A                          2220      LEA         EA_MSG_A2
00002D4A  4EB9 00004566           2221      JSR         WRITE2MEM
00002D50                          2222  POSTINC_011: ; (A3)+
Line 2223 ERROR: Comma expected
00002D50                          2223      LEA         EA_MSG_A3
00002D50  4EB9 00004566           2224      JSR         WRITE2MEM
00002D56                          2225  POSTINC_100: ; (A4)+
Line 2226 ERROR: Comma expected
00002D56                          2226      LEA         EA_MSG_A4
00002D56  4EB9 00004566           2227      JSR         WRITE2MEM
00002D5C                          2228  POSTINC_101: ; (A5)+
Line 2229 ERROR: Comma expected
00002D5C                          2229      LEA         EA_MSG_A5
00002D5C  4EB9 00004566           2230      JSR         WRITE2MEM
00002D62                          2231  POSTINC_110: ; (A6)+
Line 2232 ERROR: Comma expected
00002D62                          2232      LEA         EA_MSG_A6
00002D62  4EB9 00004566           2233      JSR         WRITE2MEM
00002D68                          2234  POSTINC_111: ; (A7)+
Line 2235 ERROR: Comma expected
00002D68                          2235      LEA         EA_MSG_A7
00002D68  4EB9 00004566           2236      JSR         WRITE2MEM
00002D6E                          2237  EA_PRINT_PI_END:
Line 2238 ERROR: Comma expected
00002D6E                          2238      LEA         CPAREN   ; Print close parentheses
00002D6E  4EB9 00004566           2239      JSR         WRITE2MEM
Line 2240 ERROR: Comma expected
00002D74                          2240      LEA         PLUS         ; Print plus sign
00002D74  4EB9 00004566           2241      JSR         WRITE2MEM
00002D7A  4E75                    2242      RTS
00002D7C                          2243  EA_PRINT_PREDEC:
Line 2244 ERROR: Comma expected
00002D7C                          2244      LEA         MINUS               ; Print minus sign
00002D7C  4EB9 00004566           2245      JSR         WRITE2MEM
Line 2246 ERROR: Comma expected
00002D82                          2246      LEA         OPAREN              ; Print open parentheses
00002D82  4EB9 00004566           2247      JSR         WRITE2MEM
00002D88  41F9 00002D96           2248      LEA         PREDEC_JMP, A0      ; Set index '0' for jump table
00002D8E  CEFC 0006               2249      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002D92  4EF0 7000               2250      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002D96                          2251  PREDEC_JMP:
00002D96  4EF9 00002DC6           2252      JMP         PREDEC_000 ; -(A0)
00002D9C  4EF9 00002DCC           2253      JMP         PREDEC_001 ; -(A1)
00002DA2  4EF9 00002DD2           2254      JMP         PREDEC_010 ; -(A2)
00002DA8  4EF9 00002DD8           2255      JMP         PREDEC_011 ; -(A3)
00002DAE  4EF9 00002DDE           2256      JMP         PREDEC_100 ; -(A4)
00002DB4  4EF9 00002DE4           2257      JMP         PREDEC_101 ; -(A5)
00002DBA  4EF9 00002DEA           2258      JMP         PREDEC_110 ; -(A6)
00002DC0  4EF9 00002DF0           2259      JMP         PREDEC_111 ; -(A7)
00002DC6                          2260  
00002DC6                          2261  PREDEC_000: ; -(A0)
Line 2262 ERROR: Comma expected
00002DC6                          2262      LEA         EA_MSG_A0
00002DC6  4EB9 00004566           2263      JSR         WRITE2MEM
00002DCC                          2264  PREDEC_001: ; -(A1)
Line 2265 ERROR: Comma expected
00002DCC                          2265      LEA         EA_MSG_A1
00002DCC  4EB9 00004566           2266      JSR         WRITE2MEM
00002DD2                          2267  PREDEC_010: ; -(A2)
Line 2268 ERROR: Comma expected
00002DD2                          2268      LEA         EA_MSG_A2
00002DD2  4EB9 00004566           2269      JSR         WRITE2MEM
00002DD8                          2270  PREDEC_011: ; -(A3)
Line 2271 ERROR: Comma expected
00002DD8                          2271      LEA         EA_MSG_A3
00002DD8  4EB9 00004566           2272      JSR         WRITE2MEM
00002DDE                          2273  PREDEC_100: ; -(A4)
Line 2274 ERROR: Comma expected
00002DDE                          2274      LEA         EA_MSG_A4
00002DDE  4EB9 00004566           2275      JSR         WRITE2MEM
00002DE4                          2276  PREDEC_101: ; -(A5)
Line 2277 ERROR: Comma expected
00002DE4                          2277      LEA         EA_MSG_A5
00002DE4  4EB9 00004566           2278      JSR         WRITE2MEM
00002DEA                          2279  PREDEC_110: ; -(A6)
Line 2280 ERROR: Comma expected
00002DEA                          2280      LEA         EA_MSG_A6
00002DEA  4EB9 00004566           2281      JSR         WRITE2MEM
00002DF0                          2282  PREDEC_111: ; -(A7)
Line 2283 ERROR: Comma expected
00002DF0                          2283      LEA         EA_MSG_A7
00002DF0  4EB9 00004566           2284      JSR         WRITE2MEM
00002DF6                          2285  
00002DF6                          2286  EA_PRINT_PD_END:
Line 2287 ERROR: Comma expected
00002DF6                          2287      LEA         CPAREN   ; Print close parentheses
00002DF6  4EB9 00004566           2288      JSR         WRITE2MEM
00002DFC  4E75                    2289      RTS
00002DFE                          2290  EA_PRINT_ABS_L:
00002DFE  224D                    2291      MOVEA.L     A5, A1              ; copy pointer to temp
00002E00  5489                    2292      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002E02  2011                    2293      MOVE.L      (A1), D0            ; store longword address to print TODO
00002E04  4EB8 2B06               2294      JSR         EA_PRINT_DATA *print value TODO
00002E08  5889                    2295      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002E0A  2A49                    2296      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002E0C  4E75                    2297      RTS
00002E0E                          2298  EA_PRINT_ABS_W:
00002E0E  224D                    2299      MOVEA.L     A5, A1              ; copy pointer to temp
00002E10  5489                    2300      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002E12  2011                    2301      MOVE.L      (A1), D0            ; store word address to print in TODO
00002E14  4EB8 2B06               2302      JSR         EA_PRINT_DATA *print value TODO
00002E18  5489                    2303      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002E1A  2A49                    2304      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002E1C  4E75                    2305      RTS
00002E1E                          2306  
00002E1E                          2307  
00002E1E                          2308  -------------------- end include --------------------
00002E1E                          2309  
00002E1E                          2310  EA_ADD:
00002E1E  48E7 FFFC               2311      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002E22  4EB8 2B1A               2312      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002E26  4EB8 2B44               2313      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00002E2A  41F9 00002E38           2314      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
00002E30  CCFC 0006               2315      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002E34  4EF0 6000               2316      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002E38                          2317  ADD_OPMODE:
00002E38  4EF9 00002E68           2318      JMP         ADD_OPMODE_000      ; mode 1, byte
00002E3E  4EF9 00002E72           2319      JMP         ADD_OPMODE_001      ; mode 1, word
00002E44  4EF9 00002E7C           2320      JMP         ADD_OPMODE_010      ; mode 1, long
00002E4A  4EF9 00002E86           2321      JMP         ADD_OPMODE_011      ; Invalid value
00002E50  4EF9 00002E90           2322      JMP         ADD_OPMODE_100      ; mode 2, byte
00002E56  4EF9 00002E9A           2323      JMP         ADD_OPMODE_101      ; mode 2, word
00002E5C  4EF9 00002EA4           2324      JMP         ADD_OPMODE_110      ; mode 2, long
00002E62  4EF9 00002EAE           2325      JMP         ADD_OPMODE_111      ; Invalid value
00002E68                          2326  ADD_OPMODE_000: ; mode 1, byte
00002E68  1A3C 0001               2327      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002E6C  4EF9 00002EB8           2328      JMP         ADD_MODE_1
00002E72                          2329  ADD_OPMODE_001: ; mode 1, word
00002E72  1A3C 0002               2330      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00002E76  4EF9 00002EB8           2331      JMP         ADD_MODE_1
00002E7C                          2332  ADD_OPMODE_010: ; mode 1, long
00002E7C  1A3C 0003               2333      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00002E80  4EF9 00002EB8           2334      JMP         ADD_MODE_1
00002E86                          2335  ADD_OPMODE_011: ; Invalid value
00002E86  4EB8 2AFC               2336      JSR         EA_INVALID
00002E8A  4EF9 00002FE0           2337      JMP         ADD_END
00002E90                          2338  ADD_OPMODE_100: ; mode 2, byte
00002E90  1A3C 0001               2339      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002E94  4EF9 00002EE2           2340      JMP         ADD_MODE_2
00002E9A                          2341  ADD_OPMODE_101: ; mode 2, word
00002E9A  1A3C 0001               2342      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002E9E  4EF9 00002EE2           2343      JMP         ADD_MODE_2
00002EA4                          2344  ADD_OPMODE_110: ; mode 2, long
00002EA4  1A3C 0001               2345      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002EA8  4EF9 00002EE2           2346      JMP         ADD_MODE_2
00002EAE                          2347  ADD_OPMODE_111: ; Invalid value
00002EAE  4EB8 2AFC               2348      JSR         EA_INVALID
00002EB2  4EF9 00002FE0           2349      JMP         ADD_END
00002EB8                          2350  ADD_MODE_1:
00002EB8  4280                    2351      CLR.L       D0                  ; Clear data register 0
00002EBA  103C 0001               2352      MOVE.B      #1, D0              ; Save mode number to D0
00002EBE  3207                    2353      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00002EC0  4EB8 2B1E               2354      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002EC4  4EB9 00002F08           2355      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002ECA  49F9 0000465B           2356      LEA         COMMA, A4        ; Print comma
00002ED0  4EB9 00004566           2357      JSR         WRITE2MEM
00002ED6  3E01                    2358      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00002ED8  4EB8 2B7C               2359      JSR         EA_PRINT_DN         ; Print data register
00002EDC  4EF9 00002FE0           2360      JMP         ADD_END
00002EE2                          2361  ADD_MODE_2:
00002EE2  4280                    2362      CLR.L       D0                  ; Clear data register 0
00002EE4  103C 0002               2363      MOVE.B      #2, D0              ; Save mode number to D0
00002EE8  4EB8 2B7C               2364      JSR         EA_PRINT_DN         ; Print data register
00002EEC  49F9 0000465B           2365      LEA         COMMA, A4        ; Print comma
00002EF2  4EB9 00004566           2366      JSR         WRITE2MEM
00002EF8  4EB8 2B1E               2367      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002EFC  4EB9 00002F08           2368      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002F02  4EF9 00002FE0           2369      JMP         ADD_END
00002F08                          2370  ADD_EVAL_EA:
00002F08  41F9 00002F16           2371      LEA         ADD_MODE, A0        ; Set index '0' for jump table
00002F0E  CCFC 0006               2372      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002F12  4EF0 6000               2373      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002F16                          2374  ADD_MODE:
00002F16  4EF9 00002F46           2375      JMP         ADD_MODE_000        ; Dn (invalid if opmode 2)
00002F1C  4EF9 00002F58           2376      JMP         ADD_MODE_001        ; An (invalid if opmode 2)
00002F22  4EF9 00002F6A           2377      JMP         ADD_MODE_010        ; (An)
00002F28  4EF9 00002F74           2378      JMP         ADD_MODE_011        ; (An)+
00002F2E  4EF9 00002F7E           2379      JMP         ADD_MODE_100        ; -(An)
00002F34  4EF9 00002F88           2380      JMP         ADD_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00002F3A  4EF9 00002F8E           2381      JMP         ADD_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002F40  4EF9 00002F94           2382      JMP         ADD_MODE_111        ; The rest (not all valid, validated by register number)
00002F46                          2383  ADD_MODE_000: ; Dn (invalid if opmode 2)
00002F46  B07C 0002               2384      CMP         #2, D0
00002F4A  6700 008E               2385      BEQ         ADD_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00002F4E  4EB8 2B7C               2386      JSR         EA_PRINT_DN         ; Print data register direct operand
00002F52  4EF9 00002FD8           2387      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002F58                          2388  ADD_MODE_001: ; An (invalid if opmode 2)
00002F58  B07C 0002               2389      CMP         #2, D0
00002F5C  6700 007C               2390      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002F60  4EB8 2BEC               2391      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002F64  4EF9 00002FD8           2392      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002F6A                          2393  ADD_MODE_010: ; (An)
00002F6A  4EB8 2C5C               2394      JSR         EA_PRINT_IND         ; Print address register indirect
00002F6E  4EF9 00002FD8           2395      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002F74                          2396  ADD_MODE_011: ; (An)+
00002F74  4EB8 2CFA               2397      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002F78  4EF9 00002FD8           2398      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002F7E                          2399  ADD_MODE_100: ; -(An)
00002F7E  4EB8 2D7C               2400      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002F82  4EF9 00002FD8           2401      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002F88                          2402  ADD_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002F88  4EF9 00002FDA           2403      JMP         ADD_MODE_INVALID
00002F8E                          2404  ADD_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002F8E  4EF9 00002FDA           2405      JMP         ADD_MODE_INVALID
00002F94                          2406  ADD_MODE_111: ; The rest (not all valid, validated by register number)
00002F94  BE3C 0000               2407      CMP.B       #$00, D7            ; Test for absolute word address
00002F98  6700 0018               2408      BEQ         ADD_ABS_W
00002F9C  BE3C 0001               2409      CMP.B       #$01, D7            ; Test for absolute long address
00002FA0  6700 001A               2410      BEQ         ADD_ABS_L
00002FA4  BE3C 0004               2411      CMP.B       #$04, D7            ; Test for immediate data
00002FA8  6700 001C               2412      BEQ         ADD_IMM
00002FAC  4EF9 00002FDA           2413      JMP         ADD_MODE_INVALID    ; else, invalid
00002FB2                          2414  ADD_ABS_W:
00002FB2  4EB8 2E0E               2415      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002FB6  4EF9 00002FD8           2416      JMP         ADD_MODE_END
00002FBC                          2417  ADD_ABS_L:
00002FBC  4EB8 2DFE               2418      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002FC0  4EF9 00002FD8           2419      JMP         ADD_MODE_END
00002FC6                          2420  ADD_IMM: ; invalid if opmode is 2
00002FC6  B07C 0002               2421      CMP         #2, D0
00002FCA  6700 000E               2422      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002FCE  4EB8 2CD8               2423      JSR         EA_PRINT_IMM        ; Print immediate data
00002FD2  4EF9 00002FD8           2424      JMP         ADD_MODE_END
00002FD8                          2425  ADD_MODE_END:
00002FD8  4E75                    2426      RTS                             ; Finish evaluating EA bits
00002FDA                          2427  ADD_MODE_INVALID:
00002FDA  4EB8 2AFC               2428      JSR         EA_INVALID          ; Opcode word is Invalid
00002FDE  4E75                    2429      RTS                             ; Finish evaluating EA bits
00002FE0                          2430  ADD_END:
00002FE0  4EB8 2B0E               2431      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00002FE4  4CDF 3FFF               2432      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002FE8  4E75                    2433      RTS
00002FEA                          2434  
00002FEA                          2435  EA_ADDA:
00002FEA  48E7 FFFC               2436      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002FEE  4EB8 2B1A               2437      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002FF2  4EB8 2B1E               2438      JSR         EA_DEFAULT_COMBO    ; Mode: D6, register: D7
00002FF6  41F9 00003004           2439      LEA         ADDA_MODE, A0       ; Set index '0' for jump table
00002FFC  CCFC 0006               2440      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003000  4EF0 6000               2441      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003004                          2442  ADDA_MODE:
00003004  4EF9 00003034           2443      JMP         ADDA_MODE_000       ; Dn
0000300A  4EF9 0000303E           2444      JMP         ADDA_MODE_001       ; An
00003010  4EF9 00003048           2445      JMP         ADDA_MODE_010       ; (An)
00003016  4EF9 00003052           2446      JMP         ADDA_MODE_011       ; (An)+
0000301C  4EF9 0000305C           2447      JMP         ADDA_MODE_100       ; -(An)
00003022  4EF9 00003066           2448      JMP         ADDA_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00003028  4EF9 0000306C           2449      JMP         ADDA_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000302E  4EF9 00003072           2450      JMP         ADDA_MODE_111       ; The rest (not all valid, validated by register number)
00003034                          2451  ADDA_MODE_000: ; Dn
00003034  4EB8 2B7C               2452      JSR         EA_PRINT_DN         ; Print data register direct operand
00003038  4EF9 000030BC           2453      JMP         ADDA_MODE_END       ; End evaluation of ea mode
0000303E                          2454  ADDA_MODE_001: ; An
0000303E  4EB8 2BEC               2455      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00003042  4EF9 000030BC           2456      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00003048                          2457  ADDA_MODE_010: ; (An)
00003048  4EB8 2C5C               2458      JSR         EA_PRINT_IND         ; Print address register indirect
0000304C  4EF9 000030BC           2459      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00003052                          2460  ADDA_MODE_011: ; (An)+
00003052  4EB8 2CFA               2461      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003056  4EF9 000030BC           2462      JMP         ADDA_MODE_END       ; End evaluation of ea mode
0000305C                          2463  ADDA_MODE_100: ; -(An)
0000305C  4EB8 2D7C               2464      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003060  4EF9 000030BC           2465      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00003066                          2466  ADDA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003066  4EF9 000030B2           2467      JMP         ADDA_MODE_INVALID
0000306C                          2468  ADDA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000306C  4EF9 000030B2           2469      JMP         ADDA_MODE_INVALID
00003072                          2470  ADDA_MODE_111: ; The rest (not all valid, validated by register number)
00003072  BE3C 0000               2471      CMP.B       #$00, D7            ; Test for absolute word address
00003076  6700 0018               2472      BEQ         ADDA_ABS_W
0000307A  BE3C 0001               2473      CMP.B       #$01, D7            ; Test for absolute long address
0000307E  6700 001A               2474      BEQ         ADDA_ABS_L
00003082  BE3C 0004               2475      CMP.B       #$04, D7            ; Test for immediate data
00003086  6700 001C               2476      BEQ         ADDA_IMM
0000308A  4EF9 000030B2           2477      JMP         ADDA_MODE_INVALID   ; Else, invalid
00003090                          2478  ADDA_ABS_W:
00003090  4EB8 2E0E               2479      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003094  4EF9 000030BC           2480      JMP         ADDA_MODE_END
0000309A                          2481  ADDA_ABS_L:
0000309A  4EB8 2DFE               2482      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000309E  4EF9 000030BC           2483      JMP         ADDA_MODE_END
000030A4                          2484  ADDA_IMM:
000030A4  4EB8 2B44               2485      JSR         EA_OPMODE_COMBO     ; Get opmode bits in
000030A8  4EB8 2CD8               2486      JSR         EA_PRINT_IMM        ; Print immediate data
000030AC  4EF9 000030BC           2487      JMP         ADDA_MODE_END
000030B2                          2488  ADDA_MODE_INVALID:
000030B2  4EB8 2AFC               2489      JSR         EA_INVALID          ; Opcode word is Invalid
000030B6  4EF9 000030D0           2490      JMP         ADDA_END
000030BC                          2491  ADDA_MODE_END:
000030BC  49F9 0000465B           2492      LEA         COMMA, A4        ; Print comma
000030C2  4EB9 00004566           2493      JSR         WRITE2MEM
000030C8  4EB8 2B44               2494      JSR         EA_OPMODE_COMBO     ; Opmode: D6, register: D7
000030CC  4EB8 2BEC               2495      JSR         EA_PRINT_AN         ; Print address register
000030D0                          2496  ADDA_END:
000030D0  4EB8 2B0E               2497      JSR         EA_UPDATE_POINTER   ; Update global pointer
000030D4  4CDF 3FFF               2498      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000030D8  4E75                    2499      RTS
000030DA                          2500  
000030DA                          2501  EA_ADDI:
000030DA  48E7 FFFC               2502      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000030DE  4EB8 2B1A               2503      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000030E2  4EB8 2B6A               2504      JSR         EA_SIZE_BITS        ; get size bits in D7
000030E6  BE3C 0000               2505      CMP.B       #$00, D7            ; Test if size: byte
000030EA  6700 001C               2506      BEQ         ADDI_B
000030EE  BE3C 0001               2507      CMP.B       #$01, D7            ; Test if size: word
000030F2  6700 002E               2508      BEQ         ADDI_W
000030F6  BE3C 0002               2509      CMP.B       #$02, D7            ; Test if size: long
000030FA  6700 0034               2510      BEQ         ADDI_L
000030FE  4EB8 2AFC               2511      JSR         EA_INVALID          ; Else, invalid
00003102  4EF9 000031EC           2512      JMP         ADDI_END
00003108                          2513  ADDI_B:
00003108  548D                    2514      ADDA.L      #$00000002, A5      ; Increment A5 past current word
0000310A  4280                    2515      CLR.L       D0
0000310C  3015                    2516      MOVE.W      (A5), D0            ; read next word in memory and save
0000310E  143C 0008               2517      MOVE.B      #8, D2              ; Clear upper 8 bits of operand word
00003112  E568                    2518      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00003114  143C 0008               2519      MOVE.B      #8, D2             ; 'Right-align' bits 0-7 to get value
00003118  E468                    2520      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
0000311A                          2521      *print data
0000311A  548D                    2522      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
0000311C  4EF9 00003136           2523      JMP         ADDI_GET_DEST
00003122                          2524  ADDI_W:
00003122  548D                    2525      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00003124  4280                    2526      CLR.L       D0
00003126  3015                    2527      MOVE.W      (A5), D0            ; read next word in memory and save
00003128                          2528      *print data
00003128  548D                    2529      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
0000312A  4EF9 00003136           2530      JMP         ADDI_GET_DEST
00003130                          2531  ADDI_L:
00003130  548D                    2532      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00003132  2015                    2533      MOVE.L      (A5), D0            ; read next two words in memory and save
00003134  588D                    2534      ADDA.L      #$00000004, A5      ; Increment A5 past operand longword
00003136                          2535  ADDI_GET_DEST:
00003136                          2536      *PRINT COMMA
00003136  4EB8 2B1E               2537      JSR         EA_DEFAULT_COMBO    ; get mode bits in D6, register bits in D7
0000313A  41F9 00003148           2538      LEA         ADDI_MODE, A0       ; Set index '0' for jump table
00003140  CCFC 0006               2539      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003144  4EF0 6000               2540      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003148                          2541  ADDI_MODE:
00003148  4EF9 00003178           2542      JMP         ADDI_MODE_000       ; Dn
0000314E  4EF9 00003182           2543      JMP         ADDI_MODE_001       ; Invalid: An
00003154  4EF9 0000318C           2544      JMP         ADDI_MODE_010       ; (An)
0000315A  4EF9 00003196           2545      JMP         ADDI_MODE_011       ; (An)+
00003160  4EF9 000031A0           2546      JMP         ADDI_MODE_100       ; -(An)
00003166  4EF9 000031AA           2547      JMP         ADDI_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
0000316C  4EF9 000031B4           2548      JMP         ADDI_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003172  4EF9 000031BE           2549      JMP         ADDI_MODE_111       ; The rest (not all valid, validated by register number)
00003178                          2550  ADDI_MODE_000: ; Dn
00003178  4EB8 2B7C               2551      JSR         EA_PRINT_DN         ; Print data register direct operand
0000317C  4EF9 000031EC           2552      JMP         ADDI_END
00003182                          2553  ADDI_MODE_001: ; Invalid: An
00003182  4EB8 2AFC               2554      JSR         EA_INVALID          ; Opcode word is Invalid
00003186  4EF9 000031EC           2555      JMP         ADDI_END
0000318C                          2556  ADDI_MODE_010: ; (An)
0000318C  4EB8 2C5C               2557      JSR         EA_PRINT_IND         ; Print address register indirect
00003190  4EF9 000031EC           2558      JMP         ADDI_END            ; End evaluation of ea mode
00003196                          2559  ADDI_MODE_011: ; (An)+
00003196  4EB8 2CFA               2560      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000319A  4EF9 000031EC           2561      JMP         ADDI_END            ; End evaluation of ea mode
000031A0                          2562  ADDI_MODE_100: ; -(An)
000031A0  4EB8 2D7C               2563      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000031A4  4EF9 000031EC           2564      JMP         ADDI_END            ; End evaluation of ea mode
000031AA                          2565  ADDI_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000031AA  4EB8 2AFC               2566      JSR         EA_INVALID          ; Opcode word is Invalid
000031AE  4EF9 000031EC           2567      JMP         ADDI_END
000031B4                          2568  ADDI_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000031B4  4EB8 2AFC               2569      JSR         EA_INVALID          ; Opcode word is Invalid
000031B8  4EF9 000031EC           2570      JMP         ADDI_END
000031BE                          2571  ADDI_MODE_111: ; The rest (not all valid, validated by register number)
000031BE  BE3C 0000               2572      CMP.B       #$00, D7            ; Test for absolute word address
000031C2  6700 0014               2573      BEQ         ADDI_ABS_W
000031C6  BE3C 0001               2574      CMP.B       #$01, D7            ; Test for absolute long address
000031CA  6700 0016               2575      BEQ         ADDI_ABS_L
000031CE  4EB8 2AFC               2576      JSR         EA_INVALID          ; else, invalid
000031D2  4EF9 000031EC           2577      JMP         ADDI_END
000031D8                          2578  ADDI_ABS_W:
000031D8  4EB8 2E0E               2579      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000031DC  4EF9 000031EC           2580      JMP         ADDI_END
000031E2                          2581  ADDI_ABS_L:
000031E2  4EB8 2DFE               2582      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000031E6  4EF9 000031EC           2583      JMP         ADDI_END
000031EC                          2584  ADDI_END:
000031EC  4EB8 2B0E               2585      JSR         EA_UPDATE_POINTER   ; Update global pointer
000031F0  4CDF 3FFF               2586      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000031F4  4E75                    2587      RTS
000031F6                          2588  EA_ADDQ:
000031F6  48E7 FFFC               2589      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000031FA  4EB8 2B1A               2590      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000031FE  2216                    2591      MOVE.L      (A6), D1            ; Load opcode to data register 1
00003200  143C 0004               2592      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00003204  E569                    2593      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00003206  143C 000D               2594      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine mode bits
0000320A  E469                    2595      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
0000320C  B23C 0000               2596      CMP.B       #$00, D1            ; Check for special case (if imm. data is 0, value is actually 8)
00003210  6600 0006               2597      BNE         ADDQ_PRINT_IMM      ; If any value other than 0, print the data
00003214  123C 0008               2598      MOVE.B      #$08, D1            ; Else, the value is 0 and therefore symbolic of the value 8, so replace with the value 8
00003218                          2599  ADDQ_PRINT_IMM:
00003218  49F9 00004655           2600      LEA         POUND, A4         ; Print '#'
0000321E  4EB9 00004566           2601      JSR         WRITE2MEM
00003224  4EB8 2B06               2602      JSR         EA_PRINT_DATA
00003228  49F9 0000465B           2603      LEA         COMMA, A4        ; Print comma
0000322E  4EB9 00004566           2604      JSR         WRITE2MEM
00003234  4EB8 2B1E               2605      JSR         EA_DEFAULT_COMBO
00003238  41F9 00003246           2606      LEA         ADDQ_MODE, A0       ; Set index '0' for jump table
0000323E  CCFC 0006               2607      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003242  4EF0 6000               2608      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003246                          2609  ADDQ_MODE:
00003246  4EF9 00003276           2610      JMP         ADDQ_MODE_000       ; Dn
0000324C  4EF9 00003280           2611      JMP         ADDQ_MODE_001       ; An
00003252  4EF9 0000328A           2612      JMP         ADDQ_MODE_010       ; (An)
00003258  4EF9 00003294           2613      JMP         ADDQ_MODE_011       ; (An)+
0000325E  4EF9 0000329E           2614      JMP         ADDQ_MODE_100       ; -(An)
00003264  4EF9 000032A8           2615      JMP         ADDQ_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
0000326A  4EF9 000032B2           2616      JMP         ADDQ_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003270  4EF9 000032BC           2617      JMP         ADDQ_MODE_111       ; The rest (not all valid, validated by register number)
00003276                          2618  ADDQ_MODE_000: ; Dn
00003276  4EB8 2B7C               2619      JSR         EA_PRINT_DN         ; Print data register direct operand
0000327A  4EF9 000032EA           2620      JMP         ADDQ_END            ; End evaluation of ea mode
00003280                          2621  ADDQ_MODE_001: ; An
00003280  4EB8 2BEC               2622      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00003284  4EF9 000032EA           2623      JMP         ADDQ_END            ; End evaluation of ea mode
0000328A                          2624  ADDQ_MODE_010: ; (An)
0000328A  4EB8 2C5C               2625      JSR         EA_PRINT_IND         ; Print address register indirect
0000328E  4EF9 000032EA           2626      JMP         ADDQ_END            ; End evaluation of ea mode
00003294                          2627  ADDQ_MODE_011: ; (An)+
00003294  4EB8 2CFA               2628      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003298  4EF9 000032EA           2629      JMP         ADDQ_END            ; End evaluation of ea mode
0000329E                          2630  ADDQ_MODE_100: ; -(An)
0000329E  4EB8 2D7C               2631      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000032A2  4EF9 000032EA           2632      JMP         ADDQ_END            ; End evaluation of ea mode
000032A8                          2633  ADDQ_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000032A8  4EB8 2AFC               2634      JSR         EA_INVALID          ; Opcode word is Invalid
000032AC  4EF9 000032EA           2635      JMP         ADDQ_END
000032B2                          2636  ADDQ_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000032B2  4EB8 2AFC               2637      JSR         EA_INVALID          ; Opcode word is Invalid
000032B6  4EF9 000032EA           2638      JMP         ADDQ_END
000032BC                          2639  ADDQ_MODE_111: ; The rest (not all valid, validated by register number)
000032BC  BE3C 0000               2640      CMP.B       #$00, D7            ; Test for absolute word address
000032C0  6700 0014               2641      BEQ         ADDQ_ABS_W
000032C4  BE3C 0001               2642      CMP.B       #$01, D7            ; Test for absolute long address
000032C8  6700 0016               2643      BEQ         ADDQ_ABS_L
000032CC  4EB8 2AFC               2644      JSR         EA_INVALID          ; Opcode word is Invalid
000032D0  4EF9 000032EA           2645      JMP         ADDQ_END
000032D6                          2646  ADDQ_ABS_W:
000032D6  4EB8 2E0E               2647      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000032DA  4EF9 000032EA           2648      JMP         ADDQ_END
000032E0                          2649  ADDQ_ABS_L:
000032E0  4EB8 2DFE               2650      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000032E4  4EF9 000032EA           2651      JMP         ADDQ_END
000032EA                          2652  
000032EA                          2653  ADDQ_END:
000032EA  4EB8 2B0E               2654      JSR         EA_UPDATE_POINTER   ; Update global pointer
000032EE  4CDF 3FFF               2655      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000032F2  4E75                    2656      RTS
000032F4                          2657  EA_AND:
000032F4  48E7 FFFC               2658      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000032F8  4EB8 2B1A               2659      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000032FC  4EB8 2B44               2660      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00003300  41F8 2E38               2661      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
00003304  CCFC 0006               2662      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003308  4EF0 6000               2663      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000330C                          2664  AND_OPMODE:
0000330C  4EF9 0000333C           2665      JMP         AND_OPMODE_000      ; mode 1, byte
00003312  4EF9 00003346           2666      JMP         AND_OPMODE_001      ; mode 1, word
00003318  4EF9 00003350           2667      JMP         AND_OPMODE_010      ; mode 1, long
0000331E  4EF9 0000335A           2668      JMP         AND_OPMODE_011      ; Invalid value
00003324  4EF9 00003364           2669      JMP         AND_OPMODE_100      ; mode 2, byte
0000332A  4EF9 0000336E           2670      JMP         AND_OPMODE_101      ; mode 2, word
00003330  4EF9 00003378           2671      JMP         AND_OPMODE_110      ; mode 2, long
00003336  4EF9 00003382           2672      JMP         AND_OPMODE_111      ; Invalid value
0000333C                          2673  AND_OPMODE_000: ; mode 1, byte
0000333C  1A3C 0001               2674      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003340  4EF9 0000338C           2675      JMP         AND_MODE_1
00003346                          2676  AND_OPMODE_001: ; mode 1, word
00003346  1A3C 0002               2677      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
0000334A  4EF9 0000338C           2678      JMP         AND_MODE_1
00003350                          2679  AND_OPMODE_010: ; mode 1, long
00003350  1A3C 0003               2680      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00003354  4EF9 0000338C           2681      JMP         AND_MODE_1
0000335A                          2682  AND_OPMODE_011: ; Invalid value
0000335A  4EB8 2AFC               2683      JSR         EA_INVALID
0000335E  4EF9 000034A8           2684      JMP         AND_END
00003364                          2685  AND_OPMODE_100: ; mode 2, byte
00003364  1A3C 0001               2686      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003368  4EF9 000033B6           2687      JMP         AND_MODE_2
0000336E                          2688  AND_OPMODE_101: ; mode 2, word
0000336E  1A3C 0001               2689      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003372  4EF9 000033B6           2690      JMP         AND_MODE_2
00003378                          2691  AND_OPMODE_110: ; mode 2, long
00003378  1A3C 0001               2692      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000337C  4EF9 000033B6           2693      JMP         AND_MODE_2
00003382                          2694  AND_OPMODE_111: ; Invalid value
00003382  4EB8 2AFC               2695      JSR         EA_INVALID
00003386  4EF9 000034A8           2696      JMP         AND_END
0000338C                          2697  AND_MODE_1:
0000338C  4280                    2698      CLR.L       D0                  ; Clear data register 0
0000338E  103C 0001               2699      MOVE.B      #1, D0              ; Save mode number to D0
00003392  3207                    2700      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003394  4EB8 2B1E               2701      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003398  4EB9 000033DC           2702      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
0000339E  49F9 0000465B           2703      LEA         COMMA, A4        ; Print comma
000033A4  4EB9 00004566           2704      JSR         WRITE2MEM
000033AA  3E01                    2705      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
000033AC  4EB8 2B7C               2706      JSR         EA_PRINT_DN         ; Print data register
000033B0  4EF9 000034A8           2707      JMP         AND_END
000033B6                          2708  AND_MODE_2:
000033B6  4280                    2709      CLR.L       D0                  ; Clear data register 0
000033B8  103C 0002               2710      MOVE.B      #2, D0              ; Save mode number to D0
000033BC  4EB8 2B7C               2711      JSR         EA_PRINT_DN         ; Print data register
000033C0  49F9 0000465B           2712      LEA         COMMA, A4        ; Print comma
000033C6  4EB9 00004566           2713      JSR         WRITE2MEM
000033CC  4EB8 2B1E               2714      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
000033D0  4EB9 000033DC           2715      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
000033D6  4EF9 000034A8           2716      JMP         AND_END
000033DC                          2717  AND_EVAL_EA:
000033DC  41F9 000033EA           2718      LEA         AND_MODE, A0        ; Set index '0' for jump table
000033E2  CCFC 0006               2719      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000033E6  4EF0 6000               2720      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000033EA                          2721  AND_MODE:
000033EA  4EF9 0000341A           2722      JMP         AND_MODE_000        ; Dn (invalid if opmode 2)
000033F0  4EF9 0000342C           2723      JMP         AND_MODE_001        ; Invalid: An
000033F6  4EF9 00003432           2724      JMP         AND_MODE_010        ; (An)
000033FC  4EF9 0000343C           2725      JMP         AND_MODE_011        ; (An)+
00003402  4EF9 00003446           2726      JMP         AND_MODE_100        ; -(An)
00003408  4EF9 00003450           2727      JMP         AND_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
0000340E  4EF9 00003456           2728      JMP         AND_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003414  4EF9 0000345C           2729      JMP         AND_MODE_111        ; The rest (not all valid, validated by register number)
0000341A                          2730  AND_MODE_000: ; Dn (invalid if opmode 2)
0000341A  B07C 0002               2731      CMP         #2, D0
0000341E  6700 0082               2732      BEQ         AND_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00003422  4EB8 2B7C               2733      JSR         EA_PRINT_DN         ; Print data register direct operand
00003426  4EF9 000034A0           2734      JMP         AND_MODE_END        ; End evaluation of ea mode
0000342C                          2735  AND_MODE_001: ; Invalid: An
0000342C  4EF9 000034A2           2736      JMP         AND_MODE_INVALID
00003432                          2737  AND_MODE_010: ; (An)
00003432  4EB8 2C5C               2738      JSR         EA_PRINT_IND         ; Print address register indirect
00003436  4EF9 000034A0           2739      JMP         AND_MODE_END        ; End evaluation of ea mode
0000343C                          2740  AND_MODE_011: ; (An)+
0000343C  4EB8 2CFA               2741      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003440  4EF9 000034A0           2742      JMP         AND_MODE_END        ; End evaluation of ea mode
00003446                          2743  AND_MODE_100: ; -(An)
00003446  4EB8 2D7C               2744      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000344A  4EF9 000034A0           2745      JMP         AND_MODE_END        ; End evaluation of ea mode
00003450                          2746  AND_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003450  4EF9 000034A2           2747      JMP         AND_MODE_INVALID
00003456                          2748  AND_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003456  4EF9 000034A2           2749      JMP         AND_MODE_INVALID
0000345C                          2750  AND_MODE_111: ; The rest (not all valid, validated by register number)
0000345C  BE3C 0000               2751      CMP.B       #$00, D7            ; Test for absolute word address
00003460  6700 0018               2752      BEQ         AND_ABS_W
00003464  BE3C 0001               2753      CMP.B       #$01, D7            ; Test for absolute long address
00003468  6700 001A               2754      BEQ         AND_ABS_L
0000346C  BE3C 0004               2755      CMP.B       #$04, D7            ; Test for immediate data
00003470  6700 001C               2756      BEQ         AND_IMM
00003474  4EF9 000034A2           2757      JMP         AND_MODE_INVALID    ; else, invalid
0000347A                          2758  AND_ABS_W:
0000347A  4EB8 2E0E               2759      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000347E  4EF9 000034A0           2760      JMP         AND_MODE_END
00003484                          2761  AND_ABS_L:
00003484  4EB8 2DFE               2762      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003488  4EF9 000034A0           2763      JMP         AND_MODE_END
0000348E                          2764  AND_IMM: ; invalid if opmode is 2
0000348E  B07C 0002               2765      CMP         #2, D0
00003492  6700 000E               2766      BEQ         AND_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00003496  4EB8 2CD8               2767      JSR         EA_PRINT_IMM        ; Print immediate data
0000349A  4EF9 000034A0           2768      JMP         AND_MODE_END
000034A0                          2769  AND_MODE_END:
000034A0  4E75                    2770      RTS                             ; Finish evaluating EA bits
000034A2                          2771  AND_MODE_INVALID:
000034A2  4EB8 2AFC               2772      JSR         EA_INVALID          ; Opcode word is Invalid
000034A6  4E75                    2773      RTS                             ; Finish evaluating EA bits
000034A8                          2774  AND_END:
000034A8  4EB8 2B0E               2775      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000034AC  4CDF 3FFF               2776      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000034B0  4E75                    2777      RTS
000034B2                          2778  EA_ASd:
000034B2  48E7 FFFC               2779      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000034B6  4EB8 2B1A               2780      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000034BA  4EB8 2B6A               2781      JSR         EA_SIZE_BITS        ; get size bits in D7
000034BE  BE3C 0003               2782      CMP.B       #$03, D7            ; test if memory shift
000034C2  6700 005E               2783      BEQ         ASd_MEM
000034C6  6000 0002               2784      BRA         ASd_REG             ; else, register shfit
000034CA                          2785  ASd_REG:
000034CA  3E16                    2786      MOVE.W      (A6), D7            ; read opcode word in memory and save,
000034CC                          2787                                      ; (using D7 because EA_PRINT_DN uses D7)
000034CC  143C 0004               2788      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
000034D0  E56F                    2789      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000034D2  143C 000D               2790      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
000034D6  E46F                    2791      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000034D8  3016                    2792      MOVE.W      (A6), D0            ; read opcode word in memory and save
000034DA  143C 000A               2793      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
000034DE  E568                    2794      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
000034E0  143C 000F               2795      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
000034E4  E468                    2796      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
000034E6  B03C 0000               2797      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
000034EA  6700 000C               2798      BEQ         ASd_REG_COUNT
000034EE                          2799  ASd_REG_REG:                        ; Else, count/register field contains register number
000034EE  4EB8 2B7C               2800      JSR         EA_PRINT_DN         ; Print register value, stored in D7
000034F2  4EF9 00003508           2801      JMP         ASd_REG_END         ; Jump to end of ASd_REG
000034F8                          2802  ASd_REG_COUNT:
000034F8  49F9 00004655           2803      LEA         POUND, A4        ; Print '#'
000034FE  4EB9 00004566           2804      JSR         WRITE2MEM
00003504  4EB8 2B06               2805      JSR         EA_PRINT_DATA *print hex value in D7 as byte todo, continue on to ASd_REG_END
00003508                          2806  ASd_REG_END:
00003508  49F9 0000465B           2807      LEA         COMMA, A4        ; Print comma
0000350E  4EB9 00004566           2808      JSR         WRITE2MEM
00003514  4EB8 2B1E               2809      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
00003518  4EB8 2B7C               2810      JSR         EA_PRINT_DN         ; Print register value in D7
0000351C  4EF9 000035D8           2811      JMP         ASd_END
00003522                          2812  ASd_MEM:
00003522  4EB8 2B1E               2813      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003526  41F9 00003534           2814      LEA         ASd_MEM_MODE, A0    ; Set index '0' for jump table
0000352C  CCFC 0006               2815      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003530  4EF0 6000               2816      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003534                          2817  ASd_MEM_MODE:
00003534  4EF9 00003564           2818      JMP         ASd_MEM_MODE_000     ; Invalid: Dn
0000353A  4EF9 0000356E           2819      JMP         ASd_MEM_MODE_001     ; Invalid: An
00003540  4EF9 00003578           2820      JMP         ASd_MEM_MODE_010     ; (An)
00003546  4EF9 00003582           2821      JMP         ASd_MEM_MODE_011     ; (An)+
0000354C  4EF9 0000358C           2822      JMP         ASd_MEM_MODE_100     ; -(An)
00003552  4EF9 00003596           2823      JMP         ASd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003558  4EF9 000035A0           2824      JMP         ASd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000355E  4EF9 000035AA           2825      JMP         ASd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00003564                          2826  ASd_MEM_MODE_000: ; Invalid: Dn
00003564  4EB8 2AFC               2827      JSR         EA_INVALID          ; Data register direct is invalid mode
00003568  4EF9 000035D8           2828      JMP         ASd_END
0000356E                          2829  ASd_MEM_MODE_001: ; Invalid: An
0000356E  4EB8 2AFC               2830      JSR         EA_INVALID          ; Address register direct is invalid mode
00003572  4EF9 000035D8           2831      JMP         ASd_END
00003578                          2832  ASd_MEM_MODE_010: ; (An)
00003578  4EB8 2C5C               2833      JSR         EA_PRINT_IND         ; Print address register indirect
0000357C  4EF9 000035D8           2834      JMP         ASd_END
00003582                          2835  ASd_MEM_MODE_011: ; (An)+
00003582  4EB8 2CFA               2836      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003586  4EF9 000035D8           2837      JMP         ASd_END
0000358C                          2838  ASd_MEM_MODE_100: ; -(An)
0000358C  4EB8 2D7C               2839      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003590  4EF9 000035D8           2840      JMP         ASd_END         ; Continue with parsing destination operand
00003596                          2841  ASd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003596  4EB8 2AFC               2842      JSR         EA_INVALID          ; Opcode word is Invalid
0000359A  4EF9 000035D8           2843      JMP         ASd_END
000035A0                          2844  ASd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000035A0  4EB8 2AFC               2845      JSR         EA_INVALID          ; Opcode word is Invalid
000035A4  4EF9 000035D8           2846      JMP         ASd_END
000035AA                          2847  ASd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
000035AA  BE3C 0000               2848      CMP.B       #$00, D7            ; Test for absolute word address
000035AE  6700 0014               2849      BEQ         ASd_MEM_ABS_W
000035B2  BE3C 0001               2850      CMP.B       #$01, D7            ; Test for absolute long address
000035B6  6700 0016               2851      BEQ         ASd_MEM_ABS_L
000035BA  4EB8 2AFC               2852      JSR         EA_INVALID          ; Else: invalid
000035BE  4EF9 000035D8           2853      JMP         ASd_END
000035C4                          2854  ASd_MEM_ABS_W:
000035C4  4EB8 2E0E               2855      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000035C8  4EF9 000035D8           2856      JMP         ASd_END
000035CE                          2857  ASd_MEM_ABS_L:
000035CE  4EB8 2DFE               2858      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000035D2  4EF9 000035D8           2859      JMP         ASd_END
000035D8                          2860  ASd_END:
000035D8  4EB8 2B0E               2861      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000035DC  4CDF 3FFF               2862      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000035E0  4E75                    2863      RTS
000035E2                          2864  EA_Bcc:
000035E2  48E7 FFFC               2865      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000035E6  4EB8 2B1A               2866      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000035EA  2216                    2867      MOVE.L      (A6), D1            ; Load opcode to data register 1
000035EC  143C 0008               2868      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
000035F0  E569                    2869      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000035F2  143C 0008               2870      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine condition
000035F6  E469                    2871      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000035F8                          2872      *save ultimate address to be printed
000035F8  284E                    2873      MOVEA.L     A6, A4              ; Copy global pointer for dislay
000035FA  B23C 0000               2874      CMP.B       #$00, D1            ; If value is zero, real value is next word in memory
000035FE  6700 0034               2875      BEQ         BCC_W
00003602  B23C 00FF               2876      CMP.B       #$FF, D1            ; If value is FF, real value is next longword
00003606  6700 004E               2877      BEQ         BCC_L
0000360A  4EF9 00003610           2878      JMP         BCC_B               ; Else, parse lower-order byte of opcode word
00003610                          2879  BCC_B:
00003610  548C                    2880      ADDA.L      #$00000002, A4      ; Increment display pointer past opcode word
00003612  3616                    2881      MOVE.W      (A6), D3            ; Save opcode word
00003614  143C 0008               2882      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003618  E56B                    2883      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
0000361A  143C 000F               2884      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
0000361E  E46B                    2885      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003620  B63C 0000               2886      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003624  6700 003E               2887      BEQ         BCC_DISPLAY
00003628  0681 FFFFFF00           2888      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
0000362E  4EF9 00003664           2889      JMP         BCC_DISPLAY
00003634                          2890  BCC_W:
00003634  588C                    2891      ADDA.L      #$00000004, A4      ; Increment display pointer past opcode word
00003636                          2892                                      ; and displacement word in memory
00003636  548D                    2893      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
00003638  3615                    2894      MOVE.W      (A5), D3            ; Read word displacement from memory
0000363A  548D                    2895      ADDA.L      #$00000002, A5      ; Increment A5 past word read
0000363C  143C 000F               2896      MOVE.B      #15, D2             ; 'Right-align' bit 15 to determine MSB
00003640  E46B                    2897      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003642  B63C 0000               2898      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003646  6700 001C               2899      BEQ         BCC_DISPLAY
0000364A  0681 FFFF0000           2900      ADD.L       #$FFFF0000, D1      ; Else, sign extend data with F
00003650  4EF9 00003664           2901      JMP         BCC_DISPLAY
00003656                          2902  BCC_L:
00003656  5C8C                    2903      ADDA.L      #$00000006, A4      ; Increment display pointer past opcode word
00003658                          2904                                      ; and displacement longword in memory
00003658  548D                    2905      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
0000365A  2215                    2906      MOVE.L      (A5), D1            ; Read longword displacement from memory
0000365C  588D                    2907      ADDA.L      #$00000004, A5      ; Increment A5 past longword read
0000365E  4EF9 00003664           2908      JMP         BCC_DISPLAY
00003664                          2909  BCC_DISPLAY:
00003664  D9C1                    2910      ADDA.L      D1, A4              ; add displacement to current addressing
00003666                          2911      *print address in A4
00003666  4EB8 2B0E               2912      JSR         EA_UPDATE_POINTER   ; Updates global pointer
0000366A  4CDF 3FFF               2913      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000366E  4E75                    2914      RTS
00003670                          2915  EA_CLR:
00003670  48E7 FFFC               2916      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003674  4EB8 2B1A               2917      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003678  4EB8 2B1E               2918      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
0000367C  41F9 0000368A           2919      LEA         CLR_MODE, A0        ; Set index '0' for jump table
00003682  CCFC 0006               2920      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003686  4EF0 6000               2921      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000368A                          2922  CLR_MODE:
0000368A  4EF9 000036BA           2923      JMP         CLR_MODE_000        ; Dn
00003690  4EF9 000036C4           2924      JMP         CLR_MODE_001        ; Invalid: An
00003696  4EF9 000036CE           2925      JMP         CLR_MODE_010        ; (An)
0000369C  4EF9 000036D8           2926      JMP         CLR_MODE_011        ; (An)+
000036A2  4EF9 000036E2           2927      JMP         CLR_MODE_100        ; -(An)
000036A8  4EF9 000036EC           2928      JMP         CLR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000036AE  4EF9 000036F6           2929      JMP         CLR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000036B4  4EF9 00003700           2930      JMP         CLR_MODE_111        ; The rest (not all valid, validated by register number)
000036BA                          2931  CLR_MODE_000: ; Dn
000036BA  4EB8 2B7C               2932      JSR         EA_PRINT_DN
000036BE  4EF9 0000372E           2933      JMP         CLR_END
000036C4                          2934  CLR_MODE_001: ; Invalid: An
000036C4  4EB8 2AFC               2935      JSR         EA_INVALID          ; Address register direct is invalid mode
000036C8  4EF9 0000372E           2936      JMP         CLR_END
000036CE                          2937  CLR_MODE_010: ; (An)
000036CE  4EB8 2C5C               2938      JSR         EA_PRINT_IND         ; Print address register indirect
000036D2  4EF9 0000372E           2939      JMP         CLR_END
000036D8                          2940  CLR_MODE_011: ; (An)+
000036D8  4EB8 2CFA               2941      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000036DC  4EF9 0000372E           2942      JMP         CLR_END
000036E2                          2943  CLR_MODE_100: ; -(An)
000036E2  4EB8 2D7C               2944      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000036E6  4EF9 0000372E           2945      JMP         CLR_END             ; Continue with parsing destination operand
000036EC                          2946  CLR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000036EC  4EB8 2AFC               2947      JSR         EA_INVALID          ; Opcode word is Invalid
000036F0  4EF9 0000372E           2948      JMP         CLR_END
000036F6                          2949  CLR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000036F6  4EB8 2AFC               2950      JSR         EA_INVALID          ; Opcode word is Invalid
000036FA  4EF9 0000372E           2951      JMP         CLR_END
00003700                          2952  CLR_MODE_111: ; The rest (not all valid, validated by register number)
00003700  BE3C 0000               2953      CMP.B       #$00, D7            ; Test for absolute word address
00003704  6700 0014               2954      BEQ         CLR_ABS_W
00003708  BE3C 0001               2955      CMP.B       #$01, D7            ; Test for absolute long address
0000370C  6700 0016               2956      BEQ         CLR_ABS_L
00003710  4EB8 2AFC               2957      JSR         EA_INVALID          ; Else: invalid
00003714  4EF9 0000372E           2958      JMP         CLR_END
0000371A                          2959  CLR_ABS_W:
0000371A  4EB8 2E0E               2960      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000371E  4EF9 0000372E           2961      JMP         CLR_END
00003724                          2962  CLR_ABS_L:
00003724  4EB8 2DFE               2963      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003728  4EF9 0000372E           2964      JMP         CLR_END
0000372E                          2965  CLR_END:
0000372E  4EB8 2B0E               2966      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003732  4CDF 3FFF               2967      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003736  4E75                    2968      RTS
00003738                          2969  EA_CMP:
00003738  48E7 FFFC               2970      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000373C  4EB8 2B1A               2971      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003740  4EB8 2B1E               2972      JSR         EA_DEFAULT_COMBO
00003744  41F9 00003752           2973      LEA         CMP_MODE, A0       ; Set index '0' for jump table
0000374A  CCFC 0006               2974      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000374E  4EF0 6000               2975      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003752                          2976  CMP_MODE:
00003752  4EF9 00003782           2977      JMP         CMP_MODE_000       ; Dn
00003758  4EF9 0000378C           2978      JMP         CMP_MODE_001       ; An
0000375E  4EF9 00003796           2979      JMP         CMP_MODE_010       ; (An)
00003764  4EF9 000037A0           2980      JMP         CMP_MODE_011       ; (An)+
0000376A  4EF9 000037AA           2981      JMP         CMP_MODE_100       ; -(An)
00003770  4EF9 000037B4           2982      JMP         CMP_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00003776  4EF9 000037BE           2983      JMP         CMP_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000377C  4EF9 000037C8           2984      JMP         CMP_MODE_111       ; The rest (not all valid, validated by register number)
00003782                          2985  CMP_MODE_000: ; Dn
00003782  4EB8 2B7C               2986      JSR         EA_PRINT_DN         ; Print data register direct operand
00003786  4EF9 000037F6           2987      JMP         CMP_MODE_END        ; End evaluation of ea mode
0000378C                          2988  CMP_MODE_001: ; An
0000378C  4EB8 2BEC               2989      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00003790  4EF9 000037F6           2990      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003796                          2991  CMP_MODE_010: ; (An)
00003796  4EB8 2C5C               2992      JSR         EA_PRINT_IND        ; Print address register indirect
0000379A  4EF9 000037F6           2993      JMP         CMP_MODE_END        ; End evaluation of ea mode
000037A0                          2994  CMP_MODE_011: ; (An)+
000037A0  4EB8 2CFA               2995      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000037A4  4EF9 000037F6           2996      JMP         CMP_MODE_END        ; End evaluation of ea mode
000037AA                          2997  CMP_MODE_100: ; -(An)
000037AA  4EB8 2D7C               2998      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000037AE  4EF9 000037F6           2999      JMP         CMP_MODE_END        ; End evaluation of ea mode
000037B4                          3000  CMP_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000037B4  4EB8 2AFC               3001      JSR         EA_INVALID          ; Opcode word is Invalid
000037B8  4EF9 0000380A           3002      JMP         CMP_END
000037BE                          3003  CMP_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000037BE  4EB8 2AFC               3004      JSR         EA_INVALID          ; Opcode word is Invalid
000037C2  4EF9 0000380A           3005      JMP         CMP_END
000037C8                          3006  CMP_MODE_111: ; The rest (not all valid, validated by register number)
000037C8  BE3C 0000               3007      CMP.B       #$00, D7            ; Test for absolute word address
000037CC  6700 0014               3008      BEQ         CMP_ABS_W
000037D0  BE3C 0001               3009      CMP.B       #$01, D7            ; Test for absolute long address
000037D4  6700 0016               3010      BEQ         CMP_ABS_L
000037D8  4EB8 2AFC               3011      JSR         EA_INVALID          ; Opcode word is Invalid
000037DC  4EF9 0000380A           3012      JMP         CMP_END
000037E2                          3013  CMP_ABS_W:
000037E2  4EB8 2E0E               3014      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000037E6  4EF9 000037F6           3015      JMP         CMP_MODE_END
000037EC                          3016  CMP_ABS_L:
000037EC  4EB8 2DFE               3017      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000037F0  4EF9 000037F6           3018      JMP         CMP_MODE_END
000037F6                          3019  CMP_MODE_END:
000037F6  49F9 0000465B           3020      LEA         COMMA, A4        ; Print comma
000037FC  4EB9 00004566           3021      JSR         WRITE2MEM
00003802  4EB8 2B44               3022      JSR         EA_OPMODE_COMBO     ; get register bits in D7, opmode bits not used
00003806  4EB8 2B7C               3023      JSR         EA_PRINT_DN         ; print register
0000380A                          3024  CMP_END:
0000380A  4EB8 2B0E               3025      JSR         EA_UPDATE_POINTER   ; Update global pointer
0000380E  4CDF 3FFF               3026      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003812  4E75                    3027      RTS
00003814                          3028  EA_DIVU_W:
00003814  48E7 FFFC               3029      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003818  4EB8 2B1A               3030      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000381C  4EB8 2B1E               3031      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003820  41F9 0000382E           3032      LEA         DIVU_W_MODE, A0       ; Set index '0' for jump table
00003826  CCFC 0006               3033      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000382A  4EF0 6000               3034      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000382E                          3035  DIVU_W_MODE:
0000382E  4EF9 0000385E           3036      JMP         DIVU_W_MODE_000     ; Dn
00003834  4EF9 00003868           3037      JMP         DIVU_W_MODE_001     ; Invalid: An
0000383A  4EF9 00003872           3038      JMP         DIVU_W_MODE_010     ; (An)
00003840  4EF9 0000387C           3039      JMP         DIVU_W_MODE_011     ; (An)+
00003846  4EF9 00003886           3040      JMP         DIVU_W_MODE_100     ; -(An)
0000384C  4EF9 00003890           3041      JMP         DIVU_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003852  4EF9 0000389A           3042      JMP         DIVU_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003858  4EF9 000038A4           3043      JMP         DIVU_W_MODE_111     ; The rest (not all valid, validated by register number)
0000385E                          3044  DIVU_W_MODE_000: ; Dn
0000385E  4EB8 2B7C               3045      JSR         EA_PRINT_DN         ; Print data register direct operand
00003862  4EF9 000038E8           3046      JMP         DIVU_W_DEST         ; Go to: print destination operand
00003868                          3047  DIVU_W_MODE_001: ; Invalid: An
00003868  4EB8 2AFC               3048      JSR         EA_INVALID          ; Address register direct is invalid mode
0000386C  4EF9 000038FA           3049      JMP         DIVU_W_END
00003872                          3050  DIVU_W_MODE_010: ; (An)
00003872  4EB8 2C5C               3051      JSR         EA_PRINT_IND         ; Print address register indirect
00003876  4EF9 000038E8           3052      JMP         DIVU_W_DEST
0000387C                          3053  DIVU_W_MODE_011: ; (An)+
0000387C  4EB8 2CFA               3054      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003880  4EF9 000038E8           3055      JMP         DIVU_W_DEST
00003886                          3056  DIVU_W_MODE_100: ; -(An)
00003886  4EB8 2D7C               3057      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000388A  4EF9 000038E8           3058      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
00003890                          3059  DIVU_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003890  4EB8 2AFC               3060      JSR         EA_INVALID          ; Opcode word is Invalid
00003894  4EF9 000038FA           3061      JMP         DIVU_W_END
0000389A                          3062  DIVU_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000389A  4EB8 2AFC               3063      JSR         EA_INVALID          ; Opcode word is Invalid
0000389E  4EF9 000038FA           3064      JMP         DIVU_W_END
000038A4                          3065  DIVU_W_MODE_111: ; The rest (not all valid, validated by register number)
000038A4  BE3C 0000               3066      CMP.B       #$00, D7            ; Test for absolute word address
000038A8  6700 001C               3067      BEQ         DIVU_W_ABS_W
000038AC  BE3C 0001               3068      CMP.B       #$01, D7            ; Test for absolute long address
000038B0  6700 001E               3069      BEQ         DIVU_W_ABS_L
000038B4  BE3C 0004               3070      CMP.B       #$04, D7            ; Test for immediate data
000038B8  6700 0020               3071      BEQ         DIVU_W_IMM
000038BC  4EB8 2AFC               3072      JSR         EA_INVALID          ; Else: invalid
000038C0  4EF9 000038FA           3073      JMP         DIVU_W_END
000038C6                          3074  DIVU_W_ABS_W:
000038C6  4EB8 2E0E               3075      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000038CA  4EF9 000038E8           3076      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000038D0                          3077  DIVU_W_ABS_L:
000038D0  4EB8 2DFE               3078      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000038D4  4EF9 000038E8           3079      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000038DA                          3080  DIVU_W_IMM:
000038DA  1A3C 0002               3081      MOVE.B      #2, D5              ; Size is word
000038DE  4EB8 2CD8               3082      JSR         EA_PRINT_IMM        ; Print immediate data
000038E2  4EF9 000038E8           3083      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000038E8                          3084  DIVU_W_DEST:
000038E8                          3085      *print COMMA
000038E8                          3086      *Get destination register
000038E8  3E16                    3087      MOVE.W      (A6), D7            ; Load word at current pointer to D1
000038EA  143C 0004               3088      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
000038EE  E56F                    3089      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000038F0  143C 000D               3090      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
000038F4  E46F                    3091      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000038F6  4EB8 2B7C               3092      JSR         EA_PRINT_DN         ; Print data register direct operand
000038FA                          3093  DIVU_W_END:
000038FA  4EB8 2B0E               3094      JSR         EA_UPDATE_POINTER   ; Update global pointer
000038FE  4CDF 3FFF               3095      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003902  4E75                    3096      RTS
00003904                          3097  EA_JSR:
00003904  48E7 FFFC               3098      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003908  4EB8 2B1A               3099      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
0000390C  4EB8 2B1E               3100      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003910  41F9 0000391E           3101      LEA         JSR_MODE, A0        ; Set index '0' for jump table
00003916  CCFC 0006               3102      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000391A  4EF0 6000               3103      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000391E                          3104  JSR_MODE:
0000391E  4EF9 0000394E           3105      JMP         JSR_MODE_000        ; Invalid: Dn
00003924  4EF9 00003958           3106      JMP         JSR_MODE_001        ; Invalid: An
0000392A  4EF9 00003962           3107      JMP         JSR_MODE_010        ; (An)
00003930  4EF9 0000396C           3108      JMP         JSR_MODE_011        ; Invalid: (An)+
00003936  4EF9 00003976           3109      JMP         JSR_MODE_100        ; Invalid: -(An)
0000393C  4EF9 00003980           3110      JMP         JSR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003942  4EF9 0000398A           3111      JMP         JSR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003948  4EF9 00003994           3112      JMP         JSR_MODE_111        ; The rest (not all valid, validated by register number)
0000394E                          3113  JSR_MODE_000: ; Invalid: Dn
0000394E  4EB8 2AFC               3114      JSR         EA_INVALID          ; Data register direct is invalid mode
00003952  4EF9 000039C2           3115      JMP         JSR_END
00003958                          3116  JSR_MODE_001: ; Invalid: An
00003958  4EB8 2AFC               3117      JSR         EA_INVALID          ; Address register direct is invalid mode
0000395C  4EF9 000039C2           3118      JMP         JSR_END
00003962                          3119  JSR_MODE_010: ; (An)
00003962  4EB8 2C5C               3120      JSR         EA_PRINT_IND         ; Print address register indirect
00003966  4EF9 000039C2           3121      JMP         JSR_END
0000396C                          3122  JSR_MODE_011: ; (An)+
0000396C  4EB8 2AFC               3123      JSR         EA_INVALID          ; Address register indirect w/ post increment is invalid mode
00003970  4EF9 000039C2           3124      JMP         JSR_END
00003976                          3125  JSR_MODE_100: ; -(An)
00003976  4EB8 2AFC               3126      JSR         EA_INVALID          ; Address register indirect w/ pre decrement is invalid mode
0000397A  4EF9 000039C2           3127      JMP         JSR_END
00003980                          3128  JSR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003980  4EB8 2AFC               3129      JSR         EA_INVALID          ; Opcode word is Invalid
00003984  4EF9 000039C2           3130      JMP         JSR_END
0000398A                          3131  JSR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000398A  4EB8 2AFC               3132      JSR         EA_INVALID          ; Opcode word is Invalid
0000398E  4EF9 000039C2           3133      JMP         JSR_END
00003994                          3134  JSR_MODE_111: ; The rest (not all valid, validated by register number)
00003994  BE3C 0000               3135      CMP.B       #$00, D7            ; Test for absolute word address
00003998  6700 0014               3136      BEQ         JSR_ABS_W
0000399C  BE3C 0001               3137      CMP.B       #$01, D7            ; Test for absolute long address
000039A0  6700 0016               3138      BEQ         JSR_ABS_L
000039A4  4EB8 2AFC               3139      JSR         EA_INVALID          ; Else: invalid
000039A8  4EF9 000039C2           3140      JMP         JSR_END
000039AE                          3141  JSR_ABS_W:
000039AE  4EB8 2E0E               3142      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000039B2  4EF9 000039C2           3143      JMP         JSR_END
000039B8                          3144  JSR_ABS_L:
000039B8  4EB8 2DFE               3145      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000039BC  4EF9 000039C2           3146      JMP         JSR_END
000039C2                          3147  JSR_END:
000039C2  4EB8 2B0E               3148      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000039C6  4CDF 3FFF               3149      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000039CA  4E75                    3150      RTS
000039CC                          3151  EA_LEA:
000039CC  48E7 FFFC               3152      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000039D0  4EB8 2B1A               3153      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000039D4  4EB8 2B1E               3154      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000039D8  41F9 000039E6           3155      LEA         LEA_MODE, A0        ; Set index '0' for jump table
000039DE  CCFC 0006               3156      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000039E2  4EF0 6000               3157      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000039E6                          3158  LEA_MODE:
000039E6  4EF9 00003A16           3159      JMP         LEA_MODE_000        ; Dn
000039EC  4EF9 00003A20           3160      JMP         LEA_MODE_001        ; Invalid: An
000039F2  4EF9 00003A2A           3161      JMP         LEA_MODE_010        ; (An)
000039F8  4EF9 00003A34           3162      JMP         LEA_MODE_011        ; (An)+
000039FE  4EF9 00003A3E           3163      JMP         LEA_MODE_100        ; -(An)
00003A04  4EF9 00003A48           3164      JMP         LEA_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003A0A  4EF9 00003A52           3165      JMP         LEA_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A10  4EF9 00003A5C           3166      JMP         LEA_MODE_111        ; The rest (not all valid, validated by register number)
00003A16                          3167  LEA_MODE_000: ; Invalid: Dn
00003A16  4EB8 2AFC               3168      JSR         EA_INVALID          ; Data register direct is invalid mode
00003A1A  4EF9 00003A9E           3169      JMP         LEA_END
00003A20                          3170  LEA_MODE_001: ; Invalid: An
00003A20  4EB8 2AFC               3171      JSR         EA_INVALID          ; Address register direct is invalid mode
00003A24  4EF9 00003A9E           3172      JMP         LEA_END
00003A2A                          3173  LEA_MODE_010: ; (An)
00003A2A  4EB8 2C5C               3174      JSR         EA_PRINT_IND         ; Print address register indirect
00003A2E  4EF9 00003A8A           3175      JMP         LEA_DEST
00003A34                          3176  LEA_MODE_011: ; (An)+
00003A34  4EB8 2AFC               3177      JSR         EA_INVALID          ; Address register indirect with post increment is invalid
00003A38  4EF9 00003A9E           3178      JMP         LEA_END
00003A3E                          3179  LEA_MODE_100: ; -(An)
00003A3E  4EB8 2AFC               3180      JSR         EA_INVALID          ; Adress register indirect with pre decrement is invalid
00003A42  4EF9 00003A9E           3181      JMP         LEA_END             ; Continue with parsing destination operand
00003A48                          3182  LEA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003A48  4EB8 2AFC               3183      JSR         EA_INVALID          ; Opcode word is Invalid
00003A4C  4EF9 00003A9E           3184      JMP         LEA_END
00003A52                          3185  LEA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A52  4EB8 2AFC               3186      JSR         EA_INVALID          ; Opcode word is Invalid
00003A56  4EF9 00003A9E           3187      JMP         LEA_END
00003A5C                          3188  LEA_MODE_111: ; The rest (not all valid, validated by register number)
00003A5C  BE3C 0000               3189      CMP.B       #$00, D7            ; Test for absolute word address
00003A60  6700 0014               3190      BEQ         LEA_ABS_W
00003A64  BE3C 0001               3191      CMP.B       #$01, D7            ; Test for absolute long address
00003A68  6700 0016               3192      BEQ         LEA_ABS_L
00003A6C  4EB8 2AFC               3193      JSR         EA_INVALID          ; Else: invalid
00003A70  4EF9 00003A8A           3194      JMP         LEA_DEST
00003A76                          3195  LEA_ABS_W:
00003A76  4EB8 2E0E               3196      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003A7A  4EF9 00003A8A           3197      JMP         LEA_DEST
00003A80                          3198  LEA_ABS_L:
00003A80  4EB8 2DFE               3199      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003A84  4EF9 00003A8A           3200      JMP         LEA_DEST
00003A8A                          3201  LEA_DEST:
00003A8A  49F9 0000465B           3202      LEA         COMMA, A4        ; Print comma
00003A90  4EB9 00004566           3203      JSR         WRITE2MEM
00003A96  4EB8 2B44               3204      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, opmode bits unused
00003A9A  4EB8 2BEC               3205      JSR         EA_PRINT_AN         ; Print address register
00003A9E                          3206  LEA_END:
00003A9E  4EB8 2B0E               3207      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003AA2  4CDF 3FFF               3208      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003AA6  4E75                    3209      RTS
00003AA8                          3210  EA_LSd:
00003AA8  48E7 FFFC               3211      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003AAC  4EB8 2B1A               3212      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003AB0  4EB8 2B6A               3213      JSR         EA_SIZE_BITS        ; get size bits in D7
00003AB4  BE3C 0003               3214      CMP.B       #$03, D7            ; test if memory shift
00003AB8  6700 005E               3215      BEQ         LSd_MEM
00003ABC  6000 0002               3216      BRA         LSd_REG             ; else, register shfit
00003AC0                          3217  LSd_REG:
00003AC0  3E16                    3218      MOVE.W      (A6), D7            ; read opcode word in memory and save,
00003AC2                          3219                                      ; (using D7 because EA_PRINT_DN uses D7)
00003AC2  143C 0004               3220      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
00003AC6  E56F                    3221      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003AC8  143C 000D               3222      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
00003ACC  E46F                    3223      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003ACE  3016                    3224      MOVE.W      (A6), D0            ; read opcode word in memory and save
00003AD0  143C 000A               3225      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
00003AD4  E568                    3226      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00003AD6  143C 000F               3227      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
00003ADA  E468                    3228      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00003ADC  B03C 0000               3229      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
00003AE0  6700 000C               3230      BEQ         LSd_REG_COUNT
00003AE4                          3231  LSd_REG_REG:                        ; Else, count/register field contains register number
00003AE4  4EB8 2B7C               3232      JSR         EA_PRINT_DN         ; Print register value, stored in D7
00003AE8  4EF9 00003AFE           3233      JMP         LSd_REG_END         ; Jump to end of LSd_REG
00003AEE                          3234  LSd_REG_COUNT:
00003AEE  49F9 00004655           3235      LEA         POUND, A4         ; Print '#'
00003AF4  4EB9 00004566           3236      JSR         WRITE2MEM
00003AFA  4EB8 2B06               3237      JSR         EA_PRINT_DATA  *print hex value in D7 as byte todo, continue on to LSd_REG_END
00003AFE                          3238  LSd_REG_END:
00003AFE  49F9 0000465B           3239      LEA         COMMA, A4        ; Print comma
00003B04  4EB9 00004566           3240      JSR         WRITE2MEM
00003B0A  4EB8 2B1E               3241      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
00003B0E  4EB8 2B7C               3242      JSR         EA_PRINT_DN         ; Print register value in D7
00003B12  4EF9 00003BCE           3243      JMP         LSd_END
00003B18                          3244  LSd_MEM:
00003B18  4EB8 2B1E               3245      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003B1C  41F9 00003B2A           3246      LEA         LSd_MEM_MODE, A0    ; Set index '0' for jump table
00003B22  CCFC 0006               3247      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003B26  4EF0 6000               3248      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003B2A                          3249  LSd_MEM_MODE:
00003B2A  4EF9 00003B5A           3250      JMP         LSd_MEM_MODE_000     ; Invalid: Dn
00003B30  4EF9 00003B64           3251      JMP         LSd_MEM_MODE_001     ; Invalid: An
00003B36  4EF9 00003B6E           3252      JMP         LSd_MEM_MODE_010     ; (An)
00003B3C  4EF9 00003B78           3253      JMP         LSd_MEM_MODE_011     ; (An)+
00003B42  4EF9 00003B82           3254      JMP         LSd_MEM_MODE_100     ; -(An)
00003B48  4EF9 00003B8C           3255      JMP         LSd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003B4E  4EF9 00003B96           3256      JMP         LSd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003B54  4EF9 00003BA0           3257      JMP         LSd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00003B5A                          3258  LSd_MEM_MODE_000: ; Invalid: Dn
00003B5A  4EB8 2AFC               3259      JSR         EA_INVALID          ; Data register direct is invalid mode
00003B5E  4EF9 00003BCE           3260      JMP         LSd_END
00003B64                          3261  LSd_MEM_MODE_001: ; Invalid: An
00003B64  4EB8 2AFC               3262      JSR         EA_INVALID          ; Address register direct is invalid mode
00003B68  4EF9 00003BCE           3263      JMP         LSd_END
00003B6E                          3264  LSd_MEM_MODE_010: ; (An)
00003B6E  4EB8 2C5C               3265      JSR         EA_PRINT_IND         ; Print address register indirect
00003B72  4EF9 00003BCE           3266      JMP         LSd_END
00003B78                          3267  LSd_MEM_MODE_011: ; (An)+
00003B78  4EB8 2CFA               3268      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003B7C  4EF9 00003BCE           3269      JMP         LSd_END
00003B82                          3270  LSd_MEM_MODE_100: ; -(An)
00003B82  4EB8 2D7C               3271      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003B86  4EF9 00003BCE           3272      JMP         LSd_END         ; Continue with parsing destination operand
00003B8C                          3273  LSd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003B8C  4EB8 2AFC               3274      JSR         EA_INVALID          ; Opcode word is Invalid
00003B90  4EF9 00003BCE           3275      JMP         LSd_END
00003B96                          3276  LSd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003B96  4EB8 2AFC               3277      JSR         EA_INVALID          ; Opcode word is Invalid
00003B9A  4EF9 00003BCE           3278      JMP         LSd_END
00003BA0                          3279  LSd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
00003BA0  BE3C 0000               3280      CMP.B       #$00, D7            ; Test for absolute word address
00003BA4  6700 0014               3281      BEQ         LSd_MEM_ABS_W
00003BA8  BE3C 0001               3282      CMP.B       #$01, D7            ; Test for absolute long address
00003BAC  6700 0016               3283      BEQ         LSd_MEM_ABS_L
00003BB0  4EB8 2AFC               3284      JSR         EA_INVALID          ; Else: invalid
00003BB4  4EF9 00003BCE           3285      JMP         LSd_END
00003BBA                          3286  LSd_MEM_ABS_W:
00003BBA  4EB8 2E0E               3287      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003BBE  4EF9 00003BCE           3288      JMP         LSd_END
00003BC4                          3289  LSd_MEM_ABS_L:
00003BC4  4EB8 2DFE               3290      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003BC8  4EF9 00003BCE           3291      JMP         LSd_END
00003BCE                          3292  LSd_END:
00003BCE  4EB8 2B0E               3293      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003BD2  4CDF 3FFF               3294      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003BD6  4E75                    3295      RTS
00003BD8                          3296  EA_MOVE:
00003BD8  48E7 FFFC               3297      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003BDC  4EB8 2B1A               3298      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003BE0  2A16                    3299      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
00003BE2  143C 0002               3300      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
00003BE6  E56D                    3301      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
00003BE8  143C 000E               3302      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
00003BEC  E46D                    3303      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
00003BEE  BA3C 0003               3304      CMP.B       #$03, D5            ; if size bits are 11, correct D5
00003BF2                          3305                                      ; to 10 for use with immediate data subroutine
00003BF2  6700 0010               3306      BEQ         MOVE_ADJUST_W
00003BF6  BA3C 0002               3307      CMP.B       #$02, D5            ; if size bits are 10, correct D5
00003BFA                          3308                                      ; to 11 for use with immediate data subroutine
00003BFA  6700 0012               3309      BEQ         MOVE_ADJUST_L
00003BFE  4EF9 00003C18           3310      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003C04                          3311  MOVE_ADJUST_W:
00003C04  1A3C 0002               3312      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
00003C08  4EF9 00003C18           3313      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003C0E                          3314  MOVE_ADJUST_L:
00003C0E  1A3C 0003               3315      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
00003C12  4EF9 00003C18           3316      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003C18                          3317  MOVE_SOURCE:
00003C18  4EB8 2B1E               3318      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003C1C  41F9 00003C2A           3319      LEA         MOVE_SRC_MODE, A0   ; Set index '0' for jump table
00003C22  CCFC 0006               3320      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003C26  4EF0 6000               3321      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003C2A                          3322  MOVE_SRC_MODE:
00003C2A  4EF9 00003C5A           3323      JMP         MOVE_SRC_MODE_000   ; Dn
00003C30  4EF9 00003C64           3324      JMP         MOVE_SRC_MODE_001   ; An
00003C36  4EF9 00003C6E           3325      JMP         MOVE_SRC_MODE_010   ; (An)
00003C3C  4EF9 00003C78           3326      JMP         MOVE_SRC_MODE_011   ; (An)+
00003C42  4EF9 00003C82           3327      JMP         MOVE_SRC_MODE_100   ; -(An)
00003C48  4EF9 00003C8C           3328      JMP         MOVE_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003C4E  4EF9 00003C96           3329      JMP         MOVE_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003C54  4EF9 00003CA0           3330      JMP         MOVE_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003C5A                          3331  MOVE_SRC_MODE_000: ; Dn
00003C5A  4EB8 2B7C               3332      JSR         EA_PRINT_DN         ; Print data register in D7
00003C5E  4EF9 00003CE0           3333      JMP         MOVE_DESTINATION
00003C64                          3334  MOVE_SRC_MODE_001: ; Invalid: An
00003C64  4EB8 2BEC               3335      JSR         EA_PRINT_AN         ; Print address register in D7
00003C68  4EF9 00003CE0           3336      JMP         MOVE_DESTINATION
00003C6E                          3337  MOVE_SRC_MODE_010: ; (An)
00003C6E  4EB8 2C5C               3338      JSR         EA_PRINT_IND         ; Print address register indirect
00003C72  4EF9 00003CE0           3339      JMP         MOVE_DESTINATION
00003C78                          3340  MOVE_SRC_MODE_011: ; (An)+
00003C78  4EB8 2CFA               3341      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003C7C  4EF9 00003CE0           3342      JMP         MOVE_DESTINATION
00003C82                          3343  MOVE_SRC_MODE_100: ; -(An)
00003C82  4EB8 2D7C               3344      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003C86  4EF9 00003CE0           3345      JMP         MOVE_DESTINATION    ; Continue with parsing destination operand
00003C8C                          3346  MOVE_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003C8C  4EB8 2AFC               3347      JSR         EA_INVALID          ; Opcode word is Invalid
00003C90  4EF9 00003DA2           3348      JMP         MOVE_END
00003C96                          3349  MOVE_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003C96  4EB8 2AFC               3350      JSR         EA_INVALID          ; Opcode word is Invalid
00003C9A  4EF9 00003DA2           3351      JMP         MOVE_END
00003CA0                          3352  MOVE_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003CA0  BE3C 0000               3353      CMP.B       #$00, D7            ; Test for absolute word address
00003CA4  6700 001C               3354      BEQ         MOVE_SRC_ABS_W
00003CA8  BE3C 0001               3355      CMP.B       #$01, D7            ; Test for absolute long address
00003CAC  6700 001E               3356      BEQ         MOVE_SRC_ABS_L
00003CB0  BE3C 0004               3357      CMP.B       #$04, D7            ; Test for immediate data
00003CB4  6700 0020               3358      BEQ         MOVE_SRC_IMM
00003CB8  4EB8 2AFC               3359      JSR         EA_INVALID          ; Else: invalid
00003CBC  4EF9 00003DA2           3360      JMP         MOVE_END
00003CC2                          3361  MOVE_SRC_ABS_W:
00003CC2  4EB8 2E0E               3362      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003CC6  4EF9 00003CE0           3363      JMP         MOVE_DESTINATION
00003CCC                          3364  MOVE_SRC_ABS_L:
00003CCC  4EB8 2DFE               3365      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003CD0  4EF9 00003CE0           3366      JMP         MOVE_DESTINATION
00003CD6                          3367  MOVE_SRC_IMM:
00003CD6  4EB8 2CD8               3368      JSR         EA_PRINT_IMM        ; Print immediate data
00003CDA  4EF9 00003CE0           3369      JMP         MOVE_DESTINATION
00003CE0                          3370  MOVE_DESTINATION:
00003CE0  49F9 0000465B           3371      LEA         COMMA, A4        ; Print comma
00003CE6  4EB9 00004566           3372      JSR         WRITE2MEM
00003CEC  4EB8 2B44               3373      JSR         EA_OPMODE_COMBO     ; mode: D6, register: D7 (destination bits)
00003CF0  41F9 00003CFE           3374      LEA         MOVE_DST_MODE, A0   ; Set index '0' for jump table
00003CF6  CCFC 0006               3375      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003CFA  4EF0 6000               3376      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003CFE                          3377  MOVE_DST_MODE:
00003CFE  4EF9 00003D2E           3378      JMP         MOVE_DST_MODE_000   ; Dn
00003D04  4EF9 00003D38           3379      JMP         MOVE_DST_MODE_001   ; Invalid: An
00003D0A  4EF9 00003D42           3380      JMP         MOVE_DST_MODE_010   ; (An)
00003D10  4EF9 00003D4C           3381      JMP         MOVE_DST_MODE_011   ; (An)+
00003D16  4EF9 00003D56           3382      JMP         MOVE_DST_MODE_100   ; -(An)
00003D1C  4EF9 00003D60           3383      JMP         MOVE_DST_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003D22  4EF9 00003D6A           3384      JMP         MOVE_DST_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003D28  4EF9 00003D74           3385      JMP         MOVE_DST_MODE_111   ; The rest (not all valid, validated by register number)
00003D2E                          3386  MOVE_DST_MODE_000: ; Dn
00003D2E  4EB8 2B7C               3387      JSR         EA_PRINT_DN         ; Print data register in D7
00003D32  4EF9 00003DA2           3388      JMP         MOVE_END
00003D38                          3389  MOVE_DST_MODE_001: ; Invalid: An
00003D38  4EB8 2AFC               3390      JSR         EA_INVALID          ; Print address register in D7
00003D3C  4EF9 00003DA2           3391      JMP         MOVE_END
00003D42                          3392  MOVE_DST_MODE_010: ; (An)
00003D42  4EB8 2C5C               3393      JSR         EA_PRINT_IND         ; Print address register indirect
00003D46  4EF9 00003DA2           3394      JMP         MOVE_END
00003D4C                          3395  MOVE_DST_MODE_011: ; (An)+
00003D4C  4EB8 2CFA               3396      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003D50  4EF9 00003DA2           3397      JMP         MOVE_END
00003D56                          3398  MOVE_DST_MODE_100: ; -(An)
00003D56  4EB8 2D7C               3399      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003D5A  4EF9 00003DA2           3400      JMP         MOVE_END    ; Continue with parsing destination operand
00003D60                          3401  MOVE_DST_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003D60  4EB8 2AFC               3402      JSR         EA_INVALID          ; Opcode word is Invalid
00003D64  4EF9 00003DA2           3403      JMP         MOVE_END
00003D6A                          3404  MOVE_DST_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003D6A  4EB8 2AFC               3405      JSR         EA_INVALID          ; Opcode word is Invalid
00003D6E  4EF9 00003DA2           3406      JMP         MOVE_END
00003D74                          3407  MOVE_DST_MODE_111: ; The rest (not all valid, validated by register number)
00003D74  BE3C 0000               3408      CMP.B       #$00, D7            ; Test for absolute word address
00003D78  6700 0014               3409      BEQ         MOVE_DST_ABS_W
00003D7C  BE3C 0001               3410      CMP.B       #$01, D7            ; Test for absolute long address
00003D80  6700 0016               3411      BEQ         MOVE_DST_ABS_L
00003D84  4EB8 2AFC               3412      JSR         EA_INVALID          ; Else: invalid
00003D88  4EF9 00003DA2           3413      JMP         MOVE_END
00003D8E                          3414  MOVE_DST_ABS_W:
00003D8E  4EB8 2E0E               3415      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003D92  4EF9 00003DA2           3416      JMP         MOVE_END
00003D98                          3417  MOVE_DST_ABS_L:
00003D98  4EB8 2DFE               3418      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003D9C  4EF9 00003DA2           3419      JMP         MOVE_END
00003DA2                          3420  MOVE_END:
00003DA2  4EB8 2B0E               3421      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003DA6  4CDF 3FFF               3422      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003DAA  4E75                    3423      RTS
00003DAC                          3424  EA_MOVEA:
00003DAC  48E7 FFFC               3425      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003DB0  4EB8 2B1A               3426      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003DB4  2A16                    3427      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
00003DB6  143C 0002               3428      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
00003DBA  E56D                    3429      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
00003DBC  143C 000E               3430      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
00003DC0  E46D                    3431      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
00003DC2  BA3C 0003               3432      CMP.B       #$03, D5            ; if size bits are 11, correct D5
00003DC6                          3433                                      ; to 10 for use with immediate data subroutine
00003DC6  6700 0010               3434      BEQ         MOVEA_ADJUST_W
00003DCA  BA3C 0002               3435      CMP.B       #$02, D5            ; if size bits are 10, correct D5
00003DCE                          3436                                      ; to 11 for use with immediate data subroutine
00003DCE  6700 0012               3437      BEQ         MOVEA_ADJUST_L
00003DD2  4EF9 00003DEC           3438      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003DD8                          3439  MOVEA_ADJUST_W:
00003DD8  1A3C 0002               3440      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
00003DDC  4EF9 00003DEC           3441      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003DE2                          3442  MOVEA_ADJUST_L:
00003DE2  1A3C 0003               3443      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
00003DE6  4EF9 00003DEC           3444      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003DEC                          3445  MOVEA_SOURCE:
00003DEC  4EB8 2B1E               3446      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003DF0  41F9 00003DFE           3447      LEA         MOVEA_SRC_MODE, A0   ; Set index '0' for jump table
00003DF6  CCFC 0006               3448      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003DFA  4EF0 6000               3449      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003DFE                          3450  MOVEA_SRC_MODE:
00003DFE  4EF9 00003E2E           3451      JMP         MOVEA_SRC_MODE_000   ; Dn
00003E04  4EF9 00003E38           3452      JMP         MOVEA_SRC_MODE_001   ; An
00003E0A  4EF9 00003E42           3453      JMP         MOVEA_SRC_MODE_010   ; (An)
00003E10  4EF9 00003E4C           3454      JMP         MOVEA_SRC_MODE_011   ; (An)+
00003E16  4EF9 00003E56           3455      JMP         MOVEA_SRC_MODE_100   ; -(An)
00003E1C  4EF9 00003E60           3456      JMP         MOVEA_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003E22  4EF9 00003E6A           3457      JMP         MOVEA_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E28  4EF9 00003E74           3458      JMP         MOVEA_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003E2E                          3459  MOVEA_SRC_MODE_000: ; Dn
00003E2E  4EB8 2B7C               3460      JSR         EA_PRINT_DN         ; Print data register in D7
00003E32  4EF9 00003EB4           3461      JMP         MOVEA_DESTINATION
00003E38                          3462  MOVEA_SRC_MODE_001: ; Invalid: An
00003E38  4EB8 2BEC               3463      JSR         EA_PRINT_AN         ; Print address register in D7
00003E3C  4EF9 00003EB4           3464      JMP         MOVEA_DESTINATION
00003E42                          3465  MOVEA_SRC_MODE_010: ; (An)
00003E42  4EB8 2C5C               3466      JSR         EA_PRINT_IND         ; Print address register indirect
00003E46  4EF9 00003EB4           3467      JMP         MOVEA_DESTINATION
00003E4C                          3468  MOVEA_SRC_MODE_011: ; (An)+
00003E4C  4EB8 2CFA               3469      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003E50  4EF9 00003EB4           3470      JMP         MOVEA_DESTINATION
00003E56                          3471  MOVEA_SRC_MODE_100: ; -(An)
00003E56  4EB8 2D7C               3472      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003E5A  4EF9 00003EB4           3473      JMP         MOVEA_DESTINATION    ; Continue with parsing destination operand
00003E60                          3474  MOVEA_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003E60  4EB8 2AFC               3475      JSR         EA_INVALID          ; Opcode word is Invalid
00003E64  4EF9 00003EC8           3476      JMP         MOVEA_END
00003E6A                          3477  MOVEA_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E6A  4EB8 2AFC               3478      JSR         EA_INVALID          ; Opcode word is Invalid
00003E6E  4EF9 00003EC8           3479      JMP         MOVEA_END
00003E74                          3480  MOVEA_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003E74  BE3C 0000               3481      CMP.B       #$00, D7            ; Test for absolute word address
00003E78  6700 001C               3482      BEQ         MOVEA_SRC_ABS_W
00003E7C  BE3C 0001               3483      CMP.B       #$01, D7            ; Test for absolute long address
00003E80  6700 001E               3484      BEQ         MOVEA_SRC_ABS_L
00003E84  BE3C 0004               3485      CMP.B       #$04, D7            ; Test for immediate data
00003E88  6700 0020               3486      BEQ         MOVEA_SRC_IMM
00003E8C  4EB8 2AFC               3487      JSR         EA_INVALID          ; Else: invalid
00003E90  4EF9 00003EC8           3488      JMP         MOVEA_END
00003E96                          3489  MOVEA_SRC_ABS_W:
00003E96  4EB8 2E0E               3490      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003E9A  4EF9 00003EB4           3491      JMP         MOVEA_DESTINATION
00003EA0                          3492  MOVEA_SRC_ABS_L:
00003EA0  4EB8 2DFE               3493      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003EA4  4EF9 00003EB4           3494      JMP         MOVEA_DESTINATION
00003EAA                          3495  MOVEA_SRC_IMM:
00003EAA  4EB8 2CD8               3496      JSR         EA_PRINT_IMM        ; Print immediate data
00003EAE  4EF9 00003EB4           3497      JMP         MOVEA_DESTINATION
00003EB4                          3498  MOVEA_DESTINATION:
00003EB4  49F9 0000465B           3499      LEA         COMMA, A4        ; Print comma
00003EBA  4EB9 00004566           3500      JSR         WRITE2MEM
00003EC0  4EB8 2B44               3501      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003EC4  4EB8 2BEC               3502      JSR         EA_PRINT_AN         ; Print address register, continue to end
00003EC8                          3503  MOVEA_END:
00003EC8  4EB8 2B0E               3504      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003ECC  4CDF 3FFF               3505      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003ED0  4E75                    3506      RTS
00003ED2                          3507  EA_MOVEM:
00003ED2                          3508      *seems complicated, todo
00003ED2  4EB8 2AF2               3509      JSR         EA_UNIMPLEMENTED
00003ED6  4E75                    3510      RTS
00003ED8                          3511  EA_MOVEQ:
00003ED8  48E7 FFFC               3512      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003EDC  4EB8 2B1A               3513      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003EE0  2216                    3514      MOVE.L      (A6), D1            ; Load opcode to data register 1
00003EE2  143C 0008               3515      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003EE6  E569                    3516      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00003EE8  143C 0008               3517      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine data bits
00003EEC  E469                    3518      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00003EEE  2616                    3519      MOVE.L      (A6), D3            ; Save mode bits to D6
00003EF0  143C 0008               3520      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003EF4  E56B                    3521      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
00003EF6  143C 000F               3522      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
00003EFA  E46B                    3523      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003EFC  B63C 0000               3524      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003F00  6700 0008               3525      BEQ         MOVEQ_PRINT_DATA
00003F04  0681 FFFFFF00           3526      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
00003F0A                          3527  MOVEQ_PRINT_DATA:
00003F0A  49F9 00004655           3528      LEA         POUND, A4         ; Print '#'
00003F10  4EB9 00004566           3529      JSR         WRITE2MEM
00003F16  4EB8 2B06               3530      JSR         EA_PRINT_DATA *print data todo
00003F1A  49F9 0000465B           3531      LEA         COMMA, A4        ; Print comma
00003F20  4EB9 00004566           3532      JSR         WRITE2MEM
00003F26  4EB8 2B44               3533      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003F2A  4EB8 2B7C               3534      JSR         EA_PRINT_DN         ; Print data register
00003F2E  4EB8 2B0E               3535      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003F32  4CDF 3FFF               3536      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003F36  4E75                    3537      RTS
00003F38                          3538  EA_MULS_W:
00003F38  48E7 FFFC               3539      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003F3C  4EB8 2B1A               3540      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003F40  4EB8 2B1E               3541      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003F44  41F9 00003F52           3542      LEA         MULS_W_MODE, A0     ; Set index '0' for jump table
00003F4A  CCFC 0006               3543      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003F4E  4EF0 6000               3544      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003F52                          3545  MULS_W_MODE:
00003F52  4EF9 00003F82           3546      JMP         MULS_W_MODE_000     ; Dn
00003F58  4EF9 00003F8C           3547      JMP         MULS_W_MODE_001     ; Invalid: An
00003F5E  4EF9 00003F96           3548      JMP         MULS_W_MODE_010     ; (An)
00003F64  4EF9 00003FA0           3549      JMP         MULS_W_MODE_011     ; (An)+
00003F6A  4EF9 00003FAA           3550      JMP         MULS_W_MODE_100     ; -(An)
00003F70  4EF9 00003FB4           3551      JMP         MULS_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003F76  4EF9 00003FBE           3552      JMP         MULS_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003F7C  4EF9 00003FC8           3553      JMP         MULS_W_MODE_111     ; The rest (not all valid, validated by register number)
00003F82                          3554  MULS_W_MODE_000: ; Dn
00003F82  4EB8 2B7C               3555      JSR         EA_PRINT_DN         ; Print data register direct operand
00003F86  4EF9 0000400C           3556      JMP         MULS_W_DEST         ; Go to: print destination operand
00003F8C                          3557  MULS_W_MODE_001: ; Invalid: An
00003F8C  4EB8 2AFC               3558      JSR         EA_INVALID          ; Address register direct is invalid mode
00003F90  4EF9 0000401E           3559      JMP         MULS_W_END
00003F96                          3560  MULS_W_MODE_010: ; (An)
00003F96  4EB8 2C5C               3561      JSR         EA_PRINT_IND         ; Print address register indirect
00003F9A  4EF9 0000400C           3562      JMP         MULS_W_DEST
00003FA0                          3563  MULS_W_MODE_011: ; (An)+
00003FA0  4EB8 2CFA               3564      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003FA4  4EF9 0000400C           3565      JMP         MULS_W_DEST
00003FAA                          3566  MULS_W_MODE_100: ; -(An)
00003FAA  4EB8 2D7C               3567      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003FAE  4EF9 0000400C           3568      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003FB4                          3569  MULS_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003FB4  4EB8 2AFC               3570      JSR         EA_INVALID          ; Opcode word is Invalid
00003FB8  4EF9 0000401E           3571      JMP         MULS_W_END
00003FBE                          3572  MULS_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003FBE  4EB8 2AFC               3573      JSR         EA_INVALID          ; Opcode word is Invalid
00003FC2  4EF9 0000401E           3574      JMP         MULS_W_END
00003FC8                          3575  MULS_W_MODE_111: ; The rest (not all valid, validated by register number)
00003FC8  BE3C 0000               3576      CMP.B       #$00, D7            ; Test for absolute word address
00003FCC  6700 001C               3577      BEQ         MULS_W_ABS_W
00003FD0  BE3C 0001               3578      CMP.B       #$01, D7            ; Test for absolute long address
00003FD4  6700 001E               3579      BEQ         MULS_W_ABS_L
00003FD8  BE3C 0004               3580      CMP.B       #$04, D7            ; Test for immediate data
00003FDC  6700 0020               3581      BEQ         MULS_W_IMM
00003FE0  4EB8 2AFC               3582      JSR         EA_INVALID          ; Else: invalid
00003FE4  4EF9 0000401E           3583      JMP         MULS_W_END
00003FEA                          3584  MULS_W_ABS_W:
00003FEA  4EB8 2E0E               3585      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003FEE  4EF9 0000400C           3586      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003FF4                          3587  MULS_W_ABS_L:
00003FF4  4EB8 2DFE               3588      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003FF8  4EF9 0000400C           3589      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003FFE                          3590  MULS_W_IMM:
00003FFE  1A3C 0002               3591      MOVE.B      #2, D5              ; Size is word
00004002  4EB8 2CD8               3592      JSR         EA_PRINT_IMM        ; Print immediate data
00004006  4EF9 0000400C           3593      JMP         MULS_W_DEST         ; Continue with parsing destination operand
0000400C                          3594  MULS_W_DEST:
0000400C                          3595      *print COMMA
0000400C                          3596      *Get destination register
0000400C  3E16                    3597      MOVE.W      (A6), D7            ; Load word at current pointer to D1
0000400E  143C 0004               3598      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00004012  E56F                    3599      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00004014  143C 000D               3600      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
00004018  E46F                    3601      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
0000401A  4EB8 2B7C               3602      JSR         EA_PRINT_DN         ; Print data register direct operand
0000401E                          3603  MULS_W_END:
0000401E  4EB8 2B0E               3604      JSR         EA_UPDATE_POINTER   ; Update global pointer
00004022  4CDF 3FFF               3605      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00004026  4E75                    3606      RTS
00004028                          3607  
00004028                          3608  EA_OR:
00004028  48E7 FFFC               3609      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000402C  4EB8 2B1A               3610      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00004030  4EB8 2B44               3611      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00004034  41F9 00004042           3612      LEA         OR_OPMODE, A0       ; Set index '0' for jump table
0000403A  CCFC 0006               3613      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000403E  4EF0 6000               3614      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00004042                          3615  OR_OPMODE:
00004042  4EF9 00004072           3616      JMP         OR_OPMODE_000       ; mode 1, byte
00004048  4EF9 0000407C           3617      JMP         OR_OPMODE_001       ; mode 1, word
0000404E  4EF9 00004086           3618      JMP         OR_OPMODE_010       ; mode 1, long
00004054  4EF9 00004090           3619      JMP         OR_OPMODE_011       ; Invalid value
0000405A  4EF9 0000409A           3620      JMP         OR_OPMODE_100       ; mode 2, byte
00004060  4EF9 000040A4           3621      JMP         OR_OPMODE_101       ; mode 2, word
00004066  4EF9 000040AE           3622      JMP         OR_OPMODE_110       ; mode 2, long
0000406C  4EF9 000040B8           3623      JMP         OR_OPMODE_111       ; Invalid value
00004072                          3624  OR_OPMODE_000: ; mode 1, byte
00004072  1A3C 0001               3625      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004076  4EF9 000040C2           3626      JMP         OR_MODE_1
0000407C                          3627  OR_OPMODE_001: ; mode 1, word
0000407C  1A3C 0002               3628      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00004080  4EF9 000040C2           3629      JMP         OR_MODE_1
00004086                          3630  OR_OPMODE_010: ; mode 1, long
00004086  1A3C 0003               3631      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
0000408A  4EF9 000040C2           3632      JMP         OR_MODE_1
00004090                          3633  OR_OPMODE_011: ; Invalid value
00004090  4EB8 2AFC               3634      JSR         EA_INVALID
00004094  4EF9 000041E2           3635      JMP         OR_END
0000409A                          3636  OR_OPMODE_100: ; mode 2, byte
0000409A  1A3C 0001               3637      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000409E  4EF9 000040EC           3638      JMP         OR_MODE_2
000040A4                          3639  OR_OPMODE_101: ; mode 2, word
000040A4  1A3C 0001               3640      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
000040A8  4EF9 000040EC           3641      JMP         OR_MODE_2
000040AE                          3642  OR_OPMODE_110: ; mode 2, long
000040AE  1A3C 0001               3643      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
000040B2  4EF9 000040EC           3644      JMP         OR_MODE_2
000040B8                          3645  OR_OPMODE_111: ; Invalid value
000040B8  4EB8 2AFC               3646      JSR         EA_INVALID
000040BC  4EF9 000041E2           3647      JMP         OR_END
000040C2                          3648  OR_MODE_1:
000040C2  4280                    3649      CLR.L       D0                  ; Clear data register 0
000040C4  103C 0001               3650      MOVE.B      #1, D0              ; Save mode number to D0
000040C8  3207                    3651      MOVE.W      D7, D1              ; Save register value for printing dest. operand
000040CA  4EB8 2B1E               3652      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
000040CE  4EB9 00004112           3653      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
000040D4  49F9 0000465B           3654      LEA         COMMA, A4        ; Print comma
000040DA  4EB9 00004566           3655      JSR         WRITE2MEM
000040E0  3E01                    3656      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
000040E2  4EB8 2B7C               3657      JSR         EA_PRINT_DN         ; Print data register
000040E6  4EF9 000041E2           3658      JMP         OR_END
000040EC                          3659  OR_MODE_2:
000040EC  4280                    3660      CLR.L       D0                  ; Clear data register 0
000040EE  103C 0002               3661      MOVE.B      #2, D0              ; Save mode number to D0
000040F2  4EB8 2B7C               3662      JSR         EA_PRINT_DN         ; Print data register
000040F6  49F9 0000465B           3663      LEA         COMMA, A4        ; Print comma
000040FC  4EB9 00004566           3664      JSR         WRITE2MEM
00004102  4EB8 2B1E               3665      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00004106  4EB9 00004112           3666      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
0000410C  4EF9 000041E2           3667      JMP         OR_END
00004112                          3668  OR_EVAL_EA:
00004112  41F9 00004120           3669      LEA         OR_MODE, A0         ; Set index '0' for jump table
00004118  CCFC 0006               3670      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000411C  4EF0 6000               3671      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00004120                          3672  OR_MODE:
00004120  4EF9 00004150           3673      JMP         OR_MODE_000         ; Invalid: Dn
00004126  4EF9 0000415A           3674      JMP         OR_MODE_001         ; An (invalid if opmode 2)
0000412C  4EF9 0000416C           3675      JMP         OR_MODE_010         ; (An)
00004132  4EF9 00004176           3676      JMP         OR_MODE_011         ; (An)+
00004138  4EF9 00004180           3677      JMP         OR_MODE_100         ; -(An)
0000413E  4EF9 0000418A           3678      JMP         OR_MODE_101         ; Invalid: Address Register Indirect with Displacement Mode
00004144  4EF9 00004190           3679      JMP         OR_MODE_110         ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000414A  4EF9 00004196           3680      JMP         OR_MODE_111         ; The rest (not all valid, validated by register number)
00004150                          3681  OR_MODE_000: ; Invalid: Dn
00004150  4EB8 2AFC               3682      JSR         EA_INVALID          ; Invalid for both opmodes
00004154  4EF9 000041DA           3683      JMP         OR_MODE_END         ; End evaluation of ea mode
0000415A                          3684  OR_MODE_001: ; An (invalid if opmode 2)
0000415A  B07C 0002               3685      CMP         #2, D0
0000415E  6700 007C               3686      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
00004162  4EB8 2BEC               3687      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00004166  4EF9 000041DA           3688      JMP         OR_MODE_END         ; End evaluation of ea mode
0000416C                          3689  OR_MODE_010: ; (An)
0000416C  4EB8 2C5C               3690      JSR         EA_PRINT_IND         ; Print address register indirect
00004170  4EF9 000041DA           3691      JMP         OR_MODE_END         ; End evaluation of ea mode
00004176                          3692  OR_MODE_011: ; (An)+
00004176  4EB8 2CFA               3693      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000417A  4EF9 000041DA           3694      JMP         OR_MODE_END         ; End evaluation of ea mode
00004180                          3695  OR_MODE_100: ; -(An)
00004180  4EB8 2D7C               3696      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00004184  4EF9 000041DA           3697      JMP         OR_MODE_END         ; End evaluation of ea mode
0000418A                          3698  OR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000418A  4EF9 000041DC           3699      JMP         OR_MODE_INVALID
00004190                          3700  OR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004190  4EF9 000041DC           3701      JMP         OR_MODE_INVALID
00004196                          3702  OR_MODE_111: ; The rest (not all valid, validated by register number)
00004196  BE3C 0000               3703      CMP.B       #$00, D7            ; Test for absolute word address
0000419A  6700 0018               3704      BEQ         OR_ABS_W
0000419E  BE3C 0001               3705      CMP.B       #$01, D7            ; Test for absolute long address
000041A2  6700 001A               3706      BEQ         OR_ABS_L
000041A6  BE3C 0004               3707      CMP.B       #$04, D7            ; Test for immediate data
000041AA  6700 001C               3708      BEQ         OR_IMM
000041AE  4EF9 000041DC           3709      JMP         OR_MODE_INVALID     ; else, invalid
000041B4                          3710  OR_ABS_W:
000041B4  4EB8 2E0E               3711      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000041B8  4EF9 000041DA           3712      JMP         OR_MODE_END
000041BE                          3713  OR_ABS_L:
000041BE  4EB8 2DFE               3714      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000041C2  4EF9 000041DA           3715      JMP         OR_MODE_END
000041C8                          3716  OR_IMM: ; invalid if opmode is 2
000041C8  B07C 0002               3717      CMP         #2, D0
000041CC  6700 000E               3718      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
000041D0  4EB8 2CD8               3719      JSR         EA_PRINT_IMM        ; Print immediate data
000041D4  4EF9 000041DA           3720      JMP         OR_MODE_END
000041DA                          3721  OR_MODE_END:
000041DA  4E75                    3722      RTS                             ; Finish evaluating EA bits
000041DC                          3723  OR_MODE_INVALID:
000041DC  4EB8 2AFC               3724      JSR         EA_INVALID          ; Opcode word is Invalid
000041E0  4E75                    3725      RTS
000041E2                          3726  OR_END:
000041E2  4EB8 2B0E               3727      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000041E6  4CDF 3FFF               3728      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000041EA  4E75                    3729      RTS
000041EC                          3730  EA_ROd:
000041EC  48E7 FFFC               3731      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000041F0  4EB8 2B1A               3732      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000041F4  4EB8 2B6A               3733      JSR         EA_SIZE_BITS        ; get size bits in D7
000041F8  BE3C 0003               3734      CMP.B       #$03, D7            ; test if memory shift
000041FC  6700 005E               3735      BEQ         ROd_MEM
00004200  6000 0002               3736      BRA         ROd_REG             ; else, register shfit
00004204                          3737  ROd_REG:
00004204  3E16                    3738      MOVE.W      (A6), D7            ; read opcode word in memory and save,
00004206                          3739                                      ; (using D7 because EA_PRINT_DN uses D7)
00004206  143C 0004               3740      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
0000420A  E56F                    3741      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
0000420C  143C 000D               3742      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
00004210  E46F                    3743      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00004212  3016                    3744      MOVE.W      (A6), D0            ; read opcode word in memory and save
00004214  143C 000A               3745      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
00004218  E568                    3746      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
0000421A  143C 000F               3747      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
0000421E  E468                    3748      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00004220  B03C 0000               3749      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
00004224  6700 000C               3750      BEQ         ROd_REG_COUNT
00004228                          3751  ROd_REG_REG:                        ; Else, count/register field contains register number
00004228  4EB8 2B7C               3752      JSR         EA_PRINT_DN         ; Print register value, stored in D7
0000422C  4EF9 00004242           3753      JMP         ROd_REG_END         ; Jump to end of ROd_REG
00004232                          3754  ROd_REG_COUNT:
00004232  49F9 00004655           3755      LEA         POUND, A4         ; Print '#'''
00004238  4EB9 00004566           3756      JSR         WRITE2MEM
0000423E  4EB8 2B06               3757      JSR         EA_PRINT_DATA       *print hex value in D7 as byte todo, continue on to ROd_REG_END
00004242                          3758  ROd_REG_END:
00004242  49F9 0000465B           3759      LEA         COMMA, A4        ; Print comma
00004248  4EB9 00004566           3760      JSR         WRITE2MEM
0000424E  4EB8 2B1E               3761      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
00004252  4EB8 2B7C               3762      JSR         EA_PRINT_DN         ; Print register value in D7
00004256  4EF9 00004312           3763      JMP         ROd_END
0000425C                          3764  ROd_MEM:
0000425C  4EB8 2B1E               3765      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00004260  41F9 0000426E           3766      LEA         ROd_MEM_MODE, A0    ; Set index '0' for jump table
00004266  CCFC 0006               3767      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000426A  4EF0 6000               3768      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000426E                          3769  ROd_MEM_MODE:
0000426E  4EF9 0000429E           3770      JMP         ROd_MEM_MODE_000     ; Invalid: Dn
00004274  4EF9 000042A8           3771      JMP         ROd_MEM_MODE_001     ; Invalid: An
0000427A  4EF9 000042B2           3772      JMP         ROd_MEM_MODE_010     ; (An)
00004280  4EF9 000042BC           3773      JMP         ROd_MEM_MODE_011     ; (An)+
00004286  4EF9 000042C6           3774      JMP         ROd_MEM_MODE_100     ; -(An)
0000428C  4EF9 000042D0           3775      JMP         ROd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00004292  4EF9 000042DA           3776      JMP         ROd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004298  4EF9 000042E4           3777      JMP         ROd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
0000429E                          3778  ROd_MEM_MODE_000: ; Invalid: Dn
0000429E  4EB8 2AFC               3779      JSR         EA_INVALID          ; Data register direct is invalid mode
000042A2  4EF9 00004312           3780      JMP         ROd_END
000042A8                          3781  ROd_MEM_MODE_001: ; Invalid: An
000042A8  4EB8 2AFC               3782      JSR         EA_INVALID          ; Address register direct is invalid mode
000042AC  4EF9 00004312           3783      JMP         ROd_END
000042B2                          3784  ROd_MEM_MODE_010: ; (An)
000042B2  4EB8 2C5C               3785      JSR         EA_PRINT_IND         ; Print address register indirect
000042B6  4EF9 00004312           3786      JMP         ROd_END
000042BC                          3787  ROd_MEM_MODE_011: ; (An)+
000042BC  4EB8 2CFA               3788      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000042C0  4EF9 00004312           3789      JMP         ROd_END
000042C6                          3790  ROd_MEM_MODE_100: ; -(An)
000042C6  4EB8 2D7C               3791      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000042CA  4EF9 00004312           3792      JMP         ROd_END         ; Continue with parsing destination operand
000042D0                          3793  ROd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000042D0  4EB8 2AFC               3794      JSR         EA_INVALID          ; Opcode word is Invalid
000042D4  4EF9 00004312           3795      JMP         ROd_END
000042DA                          3796  ROd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000042DA  4EB8 2AFC               3797      JSR         EA_INVALID          ; Opcode word is Invalid
000042DE  4EF9 00004312           3798      JMP         ROd_END
000042E4                          3799  ROd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
000042E4  BE3C 0000               3800      CMP.B       #$00, D7            ; Test for absolute word address
000042E8  6700 0014               3801      BEQ         ROd_MEM_ABS_W
000042EC  BE3C 0001               3802      CMP.B       #$01, D7            ; Test for absolute long address
000042F0  6700 0016               3803      BEQ         ROd_MEM_ABS_L
000042F4  4EB8 2AFC               3804      JSR         EA_INVALID          ; Else: invalid
000042F8  4EF9 00004312           3805      JMP         ROd_END
000042FE                          3806  ROd_MEM_ABS_W:
000042FE  4EB8 2E0E               3807      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00004302  4EF9 00004312           3808      JMP         ROd_END
00004308                          3809  ROd_MEM_ABS_L:
00004308  4EB8 2DFE               3810      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000430C  4EF9 00004312           3811      JMP         ROd_END
00004312                          3812  ROd_END:
00004312  4EB8 2B0E               3813      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00004316  4CDF 3FFF               3814      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000431A  4E75                    3815      RTS
0000431C                          3816  EA_SUB:
0000431C  4EB8 2B44               3817      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00004320  41F9 0000432E           3818      LEA         SUB_OPMODE, A0      ; Set index '0' for jump table
00004326  CCFC 0006               3819      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000432A  4EF0 6000               3820      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000432E                          3821  SUB_OPMODE:
0000432E  4EF9 0000435E           3822      JMP         SUB_OPMODE_000      ; mode 1, byte
00004334  4EF9 00004368           3823      JMP         SUB_OPMODE_001      ; mode 1, word
0000433A  4EF9 00004372           3824      JMP         SUB_OPMODE_010      ; mode 1, long
00004340  4EF9 0000437C           3825      JMP         SUB_OPMODE_011      ; Invalid value
00004346  4EF9 00004386           3826      JMP         SUB_OPMODE_100      ; mode 2, byte
0000434C  4EF9 00004390           3827      JMP         SUB_OPMODE_101      ; mode 2, word
00004352  4EF9 0000439A           3828      JMP         SUB_OPMODE_110      ; mode 2, long
00004358  4EF9 000043A4           3829      JMP         SUB_OPMODE_111      ; Invalid value
0000435E                          3830  SUB_OPMODE_000: ; mode 1, byte
0000435E  1A3C 0001               3831      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004362  4EF9 000043AE           3832      JMP         SUB_MODE_1
00004368                          3833  SUB_OPMODE_001: ; mode 1, word
00004368  1A3C 0002               3834      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
0000436C  4EF9 000043AE           3835      JMP         SUB_MODE_1
00004372                          3836  SUB_OPMODE_010: ; mode 1, long
00004372  1A3C 0003               3837      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00004376  4EF9 000043AE           3838      JMP         SUB_MODE_1
0000437C                          3839  SUB_OPMODE_011: ; Invalid value
0000437C  4EB8 2AFC               3840      JSR         EA_INVALID
00004380  4EF9 000044D6           3841      JMP         SUB_END
00004386                          3842  SUB_OPMODE_100: ; mode 2, byte
00004386  1A3C 0001               3843      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000438A  4EF9 000043D8           3844      JMP         SUB_MODE_2
00004390                          3845  SUB_OPMODE_101: ; mode 2, word
00004390  1A3C 0001               3846      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004394  4EF9 000043D8           3847      JMP         SUB_MODE_2
0000439A                          3848  SUB_OPMODE_110: ; mode 2, long
0000439A  1A3C 0001               3849      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000439E  4EF9 000043D8           3850      JMP         SUB_MODE_2
000043A4                          3851  SUB_OPMODE_111: ; Invalid value
000043A4  4EB8 2AFC               3852      JSR         EA_INVALID
000043A8  4EF9 000044D6           3853      JMP         SUB_END
000043AE                          3854  SUB_MODE_1:
000043AE  4280                    3855      CLR.L       D0                  ; Clear data register 0
000043B0  103C 0001               3856      MOVE.B      #1, D0              ; Save mode number to D0
000043B4  3207                    3857      MOVE.W      D7, D1              ; Save register value for printing dest. operand
000043B6  4EB8 2B1E               3858      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
000043BA  4EB9 000043FE           3859      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
000043C0  49F9 0000465B           3860      LEA         COMMA, A4        ; Print comma
000043C6  4EB9 00004566           3861      JSR         WRITE2MEM
000043CC  3E01                    3862      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
000043CE  4EB8 2B7C               3863      JSR         EA_PRINT_DN         ; Print data register
000043D2  4EF9 000044D6           3864      JMP         SUB_END
000043D8                          3865  SUB_MODE_2:
000043D8  4280                    3866      CLR.L       D0                  ; Clear data register 0
000043DA  103C 0002               3867      MOVE.B      #2, D0              ; Save mode number to D0
000043DE  4EB8 2B7C               3868      JSR         EA_PRINT_DN         ; Print data register
000043E2  49F9 0000465B           3869      LEA         COMMA, A4        ; Print comma
000043E8  4EB9 00004566           3870      JSR         WRITE2MEM
000043EE  4EB8 2B1E               3871      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
000043F2  4EB9 000043FE           3872      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
000043F8  4EF9 000044D6           3873      JMP         SUB_END
000043FE                          3874  SUB_EVAL_EA:
000043FE  41F9 0000440C           3875      LEA         SUB_MODE, A0        ; Set index '0' for jump table
00004404  CCFC 0006               3876      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00004408  4EF0 6000               3877      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000440C                          3878  SUB_MODE:
0000440C  4EF9 0000443C           3879      JMP         SUB_MODE_000        ; Dn (invalid if opmode 2)
00004412  4EF9 0000444E           3880      JMP         SUB_MODE_001        ; An (invalid if opmode 2)
00004418  4EF9 00004460           3881      JMP         SUB_MODE_010        ; (An)
0000441E  4EF9 0000446A           3882      JMP         SUB_MODE_011        ; (An)+
00004424  4EF9 00004474           3883      JMP         SUB_MODE_100        ; -(An)
0000442A  4EF9 0000447E           3884      JMP         SUB_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00004430  4EF9 00004484           3885      JMP         SUB_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004436  4EF9 0000448A           3886      JMP         SUB_MODE_111        ; The rest (not all valid, validated by register number)
0000443C                          3887  SUB_MODE_000: ; Dn (invalid if opmode 2)
0000443C  B07C 0002               3888      CMP         #2, D0
00004440  6700 008E               3889      BEQ         SUB_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00004444  4EB8 2B7C               3890      JSR         EA_PRINT_DN         ; Print data register direct operand
00004448  4EF9 000044CE           3891      JMP         SUB_MODE_END        ; End evaluation of ea mode
0000444E                          3892  SUB_MODE_001: ; An (invalid if opmode 2)
0000444E  B07C 0002               3893      CMP         #2, D0
00004452  6700 007C               3894      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00004456  4EB8 2BEC               3895      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
0000445A  4EF9 000044CE           3896      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004460                          3897  SUB_MODE_010: ; (An)
00004460  4EB8 2C5C               3898      JSR         EA_PRINT_IND         ; Print address register indirect
00004464  4EF9 000044CE           3899      JMP         SUB_MODE_END        ; End evaluation of ea mode
0000446A                          3900  SUB_MODE_011: ; (An)+
0000446A  4EB8 2CFA               3901      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000446E  4EF9 000044CE           3902      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004474                          3903  SUB_MODE_100: ; -(An)
00004474  4EB8 2D7C               3904      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00004478  4EF9 000044CE           3905      JMP         SUB_MODE_END        ; End evaluation of ea mode
0000447E                          3906  SUB_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000447E  4EF9 000044D0           3907      JMP         SUB_MODE_INVALID
00004484                          3908  SUB_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004484  4EF9 000044D0           3909      JMP         SUB_MODE_INVALID
0000448A                          3910  SUB_MODE_111: ; The rest (not all valid, validated by register number)
0000448A  BE3C 0000               3911      CMP.B       #$00, D7            ; Test for absolute word address
0000448E  6700 0018               3912      BEQ         SUB_ABS_W
00004492  BE3C 0001               3913      CMP.B       #$01, D7            ; Test for absolute long address
00004496  6700 001A               3914      BEQ         SUB_ABS_L
0000449A  BE3C 0004               3915      CMP.B       #$04, D7            ; Test for immediate data
0000449E  6700 001C               3916      BEQ         SUB_IMM
000044A2  4EF9 000044D0           3917      JMP         SUB_MODE_INVALID    ; else, invalid
000044A8                          3918  SUB_ABS_W:
000044A8  4EB8 2E0E               3919      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000044AC  4EF9 000044CE           3920      JMP         SUB_MODE_END
000044B2                          3921  SUB_ABS_L:
000044B2  4EB8 2DFE               3922      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000044B6  4EF9 000044CE           3923      JMP         SUB_MODE_END
000044BC                          3924  SUB_IMM: ; invalid if opmode is 2
000044BC  B07C 0002               3925      CMP         #2, D0
000044C0  6700 000E               3926      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
000044C4  4EB8 2CD8               3927      JSR         EA_PRINT_IMM        ; Print immediate data
000044C8  4EF9 000044CE           3928      JMP         SUB_MODE_END
000044CE                          3929  SUB_MODE_END:
000044CE  4E75                    3930      RTS                             ; Finish evaluating EA bits
000044D0                          3931  SUB_MODE_INVALID:
000044D0  4EB8 2AFC               3932      JSR         EA_INVALID          ; Opcode word is Invalid
000044D4  4E75                    3933      RTS
000044D6                          3934  SUB_END:
000044D6  4EB8 2B0E               3935      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000044DA  4CDF 3FFF               3936      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000044DE  4E75                    3937      RTS
000044E0                          3938  
000044E0                          3939  
000044E0                          3940  
000044E0                          3941  -------------------- end include --------------------
000044E0                          3942      INCLUDE 'EndProgram.X68'
000044E0                          3943  
000044E0                          3944  
000044E0                          3945  
000044E0  =00000059               3946  UPYES     EQU   'Y'
000044E0  =00000079               3947  LOWYES    EQU   'y'
000044E0                          3948  
000044E0                          3949  
000044E0                          3950  
000044E0                          3951  KEEP_RUNNING
000044E0  6100 0004               3952      BSR.W       RERUN               * Run welcome subroutine
000044E4  4E75                    3953      RTS                             * Return to Disassembler
000044E6                          3954      
000044E6                          3955  
000044E6                          3956  
000044E6                          3957             
000044E6                          3958  
000044E6                          3959  RERUN 
000044E6  43F9 0000451A           3960      LEA         ENDQUESTION,A1      * Loads message into A1
000044EC  103C 000E               3961      MOVE.B      #14,D0              * Moves the Task 14 into D0
000044F0  4E4F                    3962      TRAP        #15                 * Displays Intro Message
000044F2                          3963      
000044F2  103C 0005               3964      MOVE.B      #5,D0               * Move task 5 to read one char
000044F6  4E4F                    3965      TRAP        #15                 * Trap 15 for IO
000044F8                          3966      
000044F8  0C01 0059               3967      CMPI.B      #UPYES,D1           * Is char = Y
000044FC  6700 0012               3968      BEQ         NOTDONE             * If yes, notdone
00004500  0C01 0079               3969      CMPI.B      #LOWYES,D1          * Is char = y   
00004504  6700 000A               3970      BEQ         NOTDONE             * If yes, notdone
00004508  11FC 0000 6000          3971      MOVE.B      #0,(RUNAGAIN)       * 0 for false to end program
0000450E  4E75                    3972      RTS 
00004510                          3973      
00004510                          3974  NOTDONE
00004510  11FC 0001 6000          3975      MOVE.B      #1,(RUNAGAIN)       * 1 for true to rerun program
00004516  6000 CDB8               3976      BRA.W       CLEARSCRN           * Clear screen and return from subroutine         
0000451A                          3977          
0000451A                          3978  
0000451A                          3979  
0000451A                          3980  
0000451A= 57 4F 55 4C 44 20 ...   3981  ENDQUESTION     DC.B 'WOULD YOU LIKE TO RUN THE PROGRAM AGAIN (Y/N)? ',0
0000454A                          3982  
0000454A                          3983  
0000454A                          3984  
0000454A                          3985  -------------------- end include --------------------
0000454A                          3986      INCLUDE 'WriteBuffer.X68'
0000454A                          3987  
0000454A  =0000000D               3988  CR      EQU     $0D                 * Carriage return
0000454A  =0000000A               3989  LF      EQU     $0A                 * Line feed
0000454A                          3990  
0000454A  =00002000               3991  BUFFER  EQU     $2000               * Buffer address for string
0000454A  =0000001E               3992  RCOUNT  EQU     30                  * Counters
0000454A                          3993  
0000454A                          3994  WRITE_LINE
0000454A  163C 001E               3995      MOVE.B      #RCOUNT,D3          * Move row counter to D3
0000454E  45F8 2000               3996      LEA         BUFFER,A2           * Load BUFFER address to A2 for use
00004552                          3997  
00004552  6112                    3998      BSR.S       WRITE2MEM
00004554  4E75                    3999      RTS
00004556                          4000  
00004556                          4001  
00004556                          4002  
00004556                          4003      *BSR.S       PRINTLN             * Subroutine to print buffer
00004556                          4004  
00004556                          4005      *LEA         BUFFER,A2           * Reset A2 for buffer cleaning
00004556                          4006      *BSR.S       CLEAN_BUFF          * Subroutine to reset buffer to all F's
00004556                          4007  
00004556  5303                    4008      SUBI.B      #1,D3               * Decrement RCOUNT by 1
00004558  0C03 0000               4009      CMPI.B      #0,D3               * Is RCOUNT = 0
0000455C  6700 004C               4010      BEQ         NEW_PAGE            * If yes, prompt user and make new page
00004560  61E8                    4011      BSR.S       WRITE_LINE          * If no, keep writing lines
00004562                          4012  
00004562  6000 005E               4013      BRA         PAUSE               * Pause program (SIMHALT)
00004566                          4014  
00004566                          4015  WRITE2MEM
00004566  0C14 0000               4016      CMP.B       #$00,(A4)           * Check if byte is string terminator
0000456A  6700 0006               4017      BEQ         SKIP_WRITE          * If yes, skip write and return
0000456E  14DC                    4018      MOVE.B      (A4)+,(A2)+         * If no, write byte to memory
00004570  60F4                    4019      BRA         WRITE2MEM           * Keep writing, not end of string
00004572                          4020  SKIP_WRITE
00004572  287C 00000000           4021      MOVEA.L     #$00000000,A4       * Clean up A4
00004578  4E75                    4022      RTS                             * Return to main
0000457A                          4023  
0000457A                          4024  WRITE_ENDL
0000457A  14FC 000D               4025      MOVE.B      #CR,(A2)+           * Move carriage return into memory
0000457E  14FC 000A               4026      MOVE.B      #LF,(A2)+           * Move line feed into memory
00004582  14FC 0000               4027      MOVE.B      #$00,(A2)+          * Move string terminator into memory
00004586  4E75                    4028      RTS
00004588                          4029  
00004588                          4030  PRINTLN
00004588  45F8 2000               4031      LEA         BUFFER,A2           * Reset A2 to BUFFER address beginning
0000458C  43D2                    4032      LEA         (A2),A1             * Load BUFFER address into A1
0000458E  103C 000E               4033      MOVE.B      #14,D0              * Task 14, no CR or LF
00004592  4E4F                    4034      TRAP        #15                 * Display string held in BUFFER
00004594  4E75                    4035      RTS                             * Return to main
00004596                          4036  
00004596                          4037  CLEAN_BUFF
00004596  0C92 FFFFFFFF           4038      CMPI.L      #$FFFFFFFF,(A2)     *
0000459C  6700 000A               4039      BEQ         BUFFDONE            * Buffer has been cleaned
000045A0  24FC FFFFFFFF           4040      MOVE.L      #$FFFFFFFF,(A2)+    * Fill with F's
000045A6  60EE                    4041      BRA         CLEAN_BUFF          * Continue cleaning buffer
000045A8                          4042  BUFFDONE
000045A8  4E75                    4043      RTS                             * Return to main
000045AA                          4044  
000045AA                          4045  NEW_PAGE
000045AA  4283                    4046      CLR.L       D3                  * Clear counter
000045AC  43F9 000045CA           4047      LEA         ENTER,A1            * Load enter message into A1
000045B2  103C 000E               4048      MOVE.B      #14,D0              * Moves the Task 14 into D0
000045B6  4E4F                    4049      TRAP        #15                 * Displays contents of A1
000045B8  103C 0005               4050      MOVE.B      #5,D0               * Read single character from
000045BC  4E4F                    4051      TRAP        #15                 * The keyboard into D1.B
000045BE  6000 CD10               4052      BRA.W       CLEARSCRN           * Clear the screen.
000045C2                          4053  
000045C2                          4054  PAUSE
000045C2  FFFF FFFF               4055          SIMHALT                     * Halt simulator
000045C6  6000 00A3               4056          BRA     QUIT                * End program
000045CA                          4057  
000045CA                          4058  
000045CA= 2D 2D 2D 2D 2D 2D ...   4059  ENTER           DC.B '------------------------- Press Enter ------------------------',0
00004609                          4060  
00004609                          4061  
00004609= 4D 4F 56 45 00          4062  MV              DC.B 'MOVE',0
0000460E= 41 44 44 20 00          4063  AD              DC.B 'ADD ',0
00004613                          4064  
00004613= 2E 42 20 20 00          4065  BYTE            DC.B '.B  ',0
00004618= 2E 57 20 20 00          4066  WORD            DC.B '.W  ',0
0000461D= 2E 4C 20 20 00          4067  LONG            DC.B '.L  ',0
00004622= 0D 0A 00                4068  ENDL            DC.B CR,LF,0
00004625                          4069  
00004625= 44 30 00                4070  DREG0           DC.B 'D0',0
00004628= 44 31 00                4071  DREG1           DC.B 'D1',0
0000462B= 44 32 00                4072  DREG2           DC.B 'D2',0
0000462E= 44 33 00                4073  DREG3           DC.B 'D3',0
00004631= 44 34 00                4074  DREG4           DC.B 'D4',0
00004634= 44 35 00                4075  DREG5           DC.B 'D5',0
00004637= 44 36 00                4076  DREG6           DC.B 'D6',0
0000463A= 44 37 00                4077  DREG7           DC.B 'D7',0
0000463D= 41 30 00                4078  AREG0           DC.B 'A0',0
00004640= 41 31 00                4079  AREG1           DC.B 'A1',0
00004643= 41 32 00                4080  AREG2           DC.B 'A2',0
00004646= 41 33 00                4081  AREG3           DC.B 'A3',0
00004649= 41 34 00                4082  AREG4           DC.B 'A4',0
0000464C= 41 35 00                4083  AREG5           DC.B 'A5',0
0000464F= 41 36 00                4084  AREG6           DC.B 'A6',0
00004652= 41 37 00                4085  AREG7           DC.B 'A7',0
00004655                          4086  
00004655= 23 00                   4087  POUND           DC.B '#',0
00004657= 24 00                   4088  DOLLAR          DC.B '$',0
00004659= 25 00                   4089  PERCENT         DC.B '%',0
0000465B= 2C 20 00                4090  COMMA           DC.B ', ',0
0000465E= 28 00                   4091  OPAREN          DC.B '(',0
00004660= 29 00                   4092  CPAREN          DC.B ')',0
00004662= 2B 00                   4093  PLUS            DC.B '+',0
00004664= 2D 00                   4094  MINUS           DC.B '-',0
00004666                          4095  
00004666= 20 20 20 20 00          4096  TAB             DC.B '    ',0
0000466B                          4097  
0000466B                          4098  QUIT
0000466B                          4099          *END     START        ; last line of source
0000466B                          4100  
0000466B                          4101  
0000466B                          4102  -------------------- end include --------------------
0000466B                          4103  
0000466B                          4104  *********** END INCLUDES *****************************************************
0000466B                          4105  
0000466B                          4106  
0000466B                          4107  ******************************************************************************
0000466B                          4108  *           BEGIN CODE                                                       *
0000466B                          4109  ******************************************************************************
0000466B                          4110  
0000466B                          4111  *---------- START ------------------------------------------------------------
0000466B                          4112  * Begins program's logical flow. Similar to main in C/C++
0000466B                          4113  *-----------------------------------------------------------------------------
0000466B                          4114  START
0000466C  4FF8 7000               4115      LEA         STACK,SP            * SP is stored in A7
00004670  4EB8 1000               4116      JSR         GET_ADDRESSES       * Runs GET_ADDRESSES and IO_WELCOME
00004674  2C78 5000               4117      MOVEA.L     BEGINADDR,A6        * Assign beginning address to A6 for use
00004678                          4118  
00004678                          4119  LOOP
00004678                          4120      * OC_PARSE Command doesn't work due to issues in the Opcode include
00004678                          4121      * many errors need to be fixed. Same with EA include
00004678                          4122  
00004678  45F8 2000               4123      LEA         BUFFER, A2
0000467C  4EB8 167D               4124      JSR         OC_PARSE            * Determine if there is an initial opcode match
00004680  4EB8 457A               4125      JSR         WRITE_ENDL
Line 4126 ERROR: Undefined symbol
00004684  4EB9 004DBB8E           4126      JSR         PRINTLINE
0000468A  45F8 2000               4127      LEA         BUFFER, A2
0000468E  4EB8 4596               4128      JSR         CLEAN_BUFF
00004692                          4129  
00004692                          4130      * decrement row count
00004692                          4131      * if at 0, prompt for next page
00004692                          4132      * else, continue
00004692                          4133  
00004692                          4134      *JSR         INVALID_DATA
00004692                          4135      *ADDA.L      #$00000002,A6            * Advance address to test LOOP (test only)
00004692                          4136  
00004692                          4137  LOOP_CHECK
00004692                          4138      * Changed the following code from:
00004692                          4139      * CMPA        A6, ENDADDR
00004692                          4140      * to:
00004692                          4141      * CMPA      (ENDADDR),A6
00004692                          4142      * When using the CMPA, destination must be an address so A6
00004692  BDF8 5010               4143      CMPA.L      ENDADDR,A6          * Is pointer at end of address range?
00004696                          4144  
00004696  6E00 0004               4145      BGT         END_LOOP            * If yes, END_LOOP
0000469A                          4146      ; in case this resets status register, do another compare TODO
0000469A                          4147  
0000469A  66DC                    4148      BNE         LOOP                * If not, continue processing addresses
0000469C                          4149      ; If at end of address range, check if user wants to continue
0000469C                          4150      ; if user wants to continue, restart
0000469C                          4151      ; else, end
0000469C                          4152  
0000469C                          4153  END_LOOP
0000469C  4EB8 44E0               4154      JSR         KEEP_RUNNING        * Does the user want to run program again
000046A0  0C38 0001 6000          4155      CMPI.B      #1,(RUNAGAIN)       * Does RUNAGAIN = TRUE?
000046A6  67C3                    4156      BEQ         START               * If yes, rerun program
000046A8  4E72 3000               4157      STOP        #$3000              * Else, end program
000046AC                          4158  
000046AC                          4159  *---------- END - START ------------------------------------------------------
000046AC                          4160  
000046AC                          4161  *********** END BEGIN CODE ***************************************************
000046AC                          4162  
000046AC                          4163  
000046AC                          4164  ******************************************************************************
000046AC                          4165  *           VARIABLES AND CONSTANTS                                          *
000046AC                          4166  ******************************************************************************
000046AC                          4167  
000046AC                          4168  
000046AC                          4169  
000046AC                          4170  *---------- Reserved Registers -----------------------------
000046AC                          4171  *   A7: stack pointer
000046AC                          4172  *   A6: current address (updated by subroutines)
000046AC                          4173  *   D0: instruction validity flag (reset by main control
000046AC                          4174  *       code, can be set to false by subroutines)
000046AC                          4175  *-----------------------------------------------------------
000046AC                          4176  
000046AC                          4177  *---------- End --------------------------------------------
Line 4178 WARNING: Origin value is odd (Location counter set to next highest address)
000046AC                          4178                 END  START          * Last line of source

52 errors detected
1 warning generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AD                  460E
ADDA_ABS_L          309A
ADDA_ABS_W          3090
ADDA_END            30D0
ADDA_IMM            30A4
ADDA_MODE           3004
ADDA_MODE_000       3034
ADDA_MODE_001       303E
ADDA_MODE_010       3048
ADDA_MODE_011       3052
ADDA_MODE_100       305C
ADDA_MODE_101       3066
ADDA_MODE_110       306C
ADDA_MODE_111       3072
ADDA_MODE_END       30BC
ADDA_MODE_INVALID   30B2
ADDCODE000          1C5C
ADDCODE001          1C64
ADDCODE010          1C6C
ADDCODE011          1C74
ADDCODE100          1C7C
ADDCODE101          1C84
ADDCODE110          1C8C
ADDCODE111          1C94
ADDIBCODE00         20BA
ADDILCODE10         20CA
ADDILCODE11         20D2
ADDIWCODE01         20C2
ADDI_ABS_L          31E2
ADDI_ABS_W          31D8
ADDI_B              3108
ADDI_BORADDI_WORADDI_L  2084
ADDI_END            31EC
ADDI_GET_DEST       3136
ADDI_L              3130
ADDI_MODE           3148
ADDI_MODE_000       3178
ADDI_MODE_001       3182
ADDI_MODE_010       318C
ADDI_MODE_011       3196
ADDI_MODE_100       31A0
ADDI_MODE_101       31AA
ADDI_MODE_110       31B4
ADDI_MODE_111       31BE
ADDI_W              3122
ADDQCODE00          1DB6
ADDQCODE01          1DBE
ADDQCODE10          1DC6
ADDQCODE11          1DCE
ADDQ_ABS_L          32E0
ADDQ_ABS_W          32D6
ADDQ_BORADDQ_WORADDQ_L  1D80
ADDQ_END            32EA
ADDQ_MODE           3246
ADDQ_MODE_000       3276
ADDQ_MODE_001       3280
ADDQ_MODE_010       328A
ADDQ_MODE_011       3294
ADDQ_MODE_100       329E
ADDQ_MODE_101       32A8
ADDQ_MODE_110       32B2
ADDQ_MODE_111       32BC
ADDQ_PRINT_IMM      3218
ADDRESS_ERR         12DC
ADD_ABS_L           2FBC
ADD_ABS_W           2FB2
ADD_BORADD_WORADD_L  1C0E
ADD_END             2FE0
ADD_EVAL_EA         2F08
ADD_IMM             2FC6
ADD_MODE            2F16
ADD_MODE_000        2F46
ADD_MODE_001        2F58
ADD_MODE_010        2F6A
ADD_MODE_011        2F74
ADD_MODE_1          2EB8
ADD_MODE_100        2F7E
ADD_MODE_101        2F88
ADD_MODE_110        2F8E
ADD_MODE_111        2F94
ADD_MODE_2          2EE2
ADD_MODE_END        2FD8
ADD_MODE_INVALID    2FDA
ADD_OPMODE          2E38
ADD_OPMODE_000      2E68
ADD_OPMODE_001      2E72
ADD_OPMODE_010      2E7C
ADD_OPMODE_011      2E86
ADD_OPMODE_100      2E90
ADD_OPMODE_101      2E9A
ADD_OPMODE_110      2EA4
ADD_OPMODE_111      2EAE
ADR_ERR_NOTLT       143C
ANDCODE000          1BCE
ANDCODE001          1BD6
ANDCODE010          1BDE
ANDCODE011          1BE6
ANDCODE100          1BEE
ANDCODE101          1BF6
ANDCODE110          1BFE
ANDCODE111          1C06
AND_ABS_L           3484
AND_ABS_W           347A
AND_BORAND_WORAND_LORMULS_W  1B80
AND_END             34A8
AND_EVAL_EA         33DC
AND_IMM             348E
AND_MODE            33EA
AND_MODE_000        341A
AND_MODE_001        342C
AND_MODE_010        3432
AND_MODE_011        343C
AND_MODE_1          338C
AND_MODE_100        3446
AND_MODE_101        3450
AND_MODE_110        3456
AND_MODE_111        345C
AND_MODE_2          33B6
AND_MODE_END        34A0
AND_MODE_INVALID    34A2
AND_OPMODE          330C
AND_OPMODE_000      333C
AND_OPMODE_001      3346
AND_OPMODE_010      3350
AND_OPMODE_011      335A
AND_OPMODE_100      3364
AND_OPMODE_101      336E
AND_OPMODE_110      3378
AND_OPMODE_111      3382
AN_000              2C2A
AN_001              2C30
AN_010              2C36
AN_011              2C3C
AN_100              2C42
AN_101              2C48
AN_110              2C4E
AN_111              2C54
AN_JMP              2BFA
AREG0               463D
AREG1               4640
AREG2               4643
AREG3               4646
AREG4               4649
AREG5               464C
AREG6               464F
AREG7               4652
ASCII_TO_HEX        1124
ASD_END             35D8
ASD_MEM             3522
ASD_MEM_ABS_L       35CE
ASD_MEM_ABS_W       35C4
ASD_MEM_MODE        3534
ASD_MEM_MODE_000    3564
ASD_MEM_MODE_001    356E
ASD_MEM_MODE_010    3578
ASD_MEM_MODE_011    3582
ASD_MEM_MODE_100    358C
ASD_MEM_MODE_101    3596
ASD_MEM_MODE_110    35A0
ASD_MEM_MODE_111    35AA
ASD_REG             34CA
ASD_REG_COUNT       34F8
ASD_REG_END         3508
ASD_REG_REG         34EE
ASLCODE00           1916
ASLCODE01           191E
ASLCODE10           1926
ASLCODE11           192E
ASL_ASR             1AFA
ASL_ASRCODE0        1B24
ASL_ASRCODE1        1B2A
ASRCODE00           18C0
ASRCODE01           18C8
ASRCODE10           18D0
ASRCODE11           18D8
BCCORBGTORBLE       17A6
BCCORBGTORBLECODE00  17DC
BCCORBGTORBLECODE01  17E4
BCCORBGTORBLECODE10  17EC
BCCORBGTORBLECODE11  17F4
BCC_B               3610
BCC_DISPLAY         3664
BCC_L               3656
BCC_W               3634
BEGINADDR           5000
BMESSAGE            13FE
BUFFDONE            45A8
BUFFER              2000
BYTE                4613
CHECK_BADDR_IS_LESS_THAN_EADDR  10A4
CLEAN_BUFF          4596
CLEAR               10D8
CLEARSCRN           12D0
CLRCODE00           1E0C
CLRCODE01           1E14
CLRCODE10           1E1C
CLRCODE11           1E24
CLR_ABS_L           3724
CLR_ABS_W           371A
CLR_END             372E
CLR_MODE            368A
CLR_MODE_000        36BA
CLR_MODE_001        36C4
CLR_MODE_010        36CE
CLR_MODE_011        36D8
CLR_MODE_100        36E2
CLR_MODE_101        36EC
CLR_MODE_110        36F6
CLR_MODE_111        3700
CMPCODE00           1D60
CMPCODE01           1D68
CMPCODE10           1D70
CMPCODE11           1D78
CMP_ABS_L           37EC
CMP_ABS_W           37E2
CMP_BORCMP_WORCMP_L  1D2A
CMP_END             380A
CMP_MODE            3752
CMP_MODE_000        3782
CMP_MODE_001        378C
CMP_MODE_010        3796
CMP_MODE_011        37A0
CMP_MODE_100        37AA
CMP_MODE_101        37B4
CMP_MODE_110        37BE
CMP_MODE_111        37C8
CMP_MODE_END        37F6
CODE0000            16FA
CODE0001            1700
CODE0010            170C
CODE0011            1712
CODE0100            1718
CODE0101            1724
CODE0110            1730
CODE0111            173C
CODE1000            1748
CODE1001            1754
CODE1010            1760
CODE1011            1768
CODE1100            1774
CODE1101            1780
CODE1110            178C
CODE1111            1798
COMMA               465B
CPAREN              4660
CR                  D
DATA                14E7
DIVU_W_ABS_L        38D0
DIVU_W_ABS_W        38C6
DIVU_W_DEST         38E8
DIVU_W_END          38FA
DIVU_W_IMM          38DA
DIVU_W_MODE         382E
DIVU_W_MODE_000     385E
DIVU_W_MODE_001     3868
DIVU_W_MODE_010     3872
DIVU_W_MODE_011     387C
DIVU_W_MODE_100     3886
DIVU_W_MODE_101     3890
DIVU_W_MODE_110     389A
DIVU_W_MODE_111     38A4
DN_000              2BBA
DN_001              2BC0
DN_010              2BC6
DN_011              2BCC
DN_100              2BD2
DN_101              2BD8
DN_110              2BDE
DN_111              2BE4
DOLLAR              4657
DONE                17A0
DREG0               4625
DREG1               4628
DREG2               462B
DREG3               462E
DREG4               4631
DREG5               4634
DREG6               4637
DREG7               463A
EA_ADD              2E1E
EA_ADDA             2FEA
EA_ADDI             30DA
EA_ADDQ             31F6
EA_AND              32F4
EA_ASD              34B2
EA_BCC              35E2
EA_CLR              3670
EA_CMP              3738
EA_COPY_PTR         2B1A
EA_DEFAULT_COMBO    2B1E
EA_DIVU_W           3814
EA_INVALID          2AFC
EA_JSR              3904
EA_LEA              39CC
EA_LSD              3AA8
EA_MOVE             3BD8
EA_MOVEA            3DAC
EA_MOVEM            3ED2
EA_MOVEQ            3ED8
EA_MSG_A0           2AA0
EA_MSG_A1           2AA3
EA_MSG_A2           2AA6
EA_MSG_A3           2AA9
EA_MSG_A4           2AAC
EA_MSG_A5           2AAF
EA_MSG_A6           2AB2
EA_MSG_A7           2AB5
EA_MSG_CLOSEPAREN   2A7E
EA_MSG_COMMA        2A79
EA_MSG_D0           2A88
EA_MSG_D1           2A8B
EA_MSG_D2           2A8E
EA_MSG_D3           2A91
EA_MSG_D4           2A94
EA_MSG_D5           2A97
EA_MSG_D6           2A9A
EA_MSG_D7           2A9D
EA_MSG_HASH         2A84
EA_MSG_HEX          2A86
EA_MSG_MIN          2A80
EA_MSG_NULL         2A76
EA_MSG_OPENPAREN    2A7C
EA_MSG_PLUS         2A82
EA_MSG_PRINT_DATA   2AD2
EA_MSG_SPACE        2A77
EA_MSG_UNIMP        2AB8
EA_MULS_W           3F38
EA_OPMODE_COMBO     2B44
EA_OR               4028
EA_PRINT_ABS_L      2DFE
EA_PRINT_ABS_W      2E0E
EA_PRINT_AN         2BEC
EA_PRINT_AN_END     2C5A
EA_PRINT_DATA       2B06
EA_PRINT_DN         2B7C
EA_PRINT_DN_END     2BEA
EA_PRINT_DN_JMP     2B8A
EA_PRINT_IMM        2CD8
EA_PRINT_IND        2C5C
EA_PRINT_IND_END    2CD0
EA_PRINT_PD_END     2DF6
EA_PRINT_PI_END     2D6E
EA_PRINT_POSTINC    2CFA
EA_PRINT_PREDEC     2D7C
EA_ROD              41EC
EA_SIZE_BITS        2B6A
EA_SUB              431C
EA_UNIMPLEMENTED    2AF2
EA_UPDATE_POINTER   2B0E
EMESSAGE            141D
ENDADDR             5010
ENDL                4622
ENDQUESTION         451A
END_LOOP            469C
ENTER               45CA
FINISHED            10C2
FOUND               11E0
GET_ADDRESSES       1000
GET_FIRST_ADDRESS   100C
GET_HEXSTRING       10F2
GET_SECOND_ADDRESS  1058
HEXA                1230
HEXB                1238
HEXC                1240
HEXD                1248
HEXE                1250
HEXEIGHT            1224
HEXF                1258
HEXFIVE             1218
HEXFLAG             5021
HEXFOUR             1214
HEXNINE             1228
HEXONE              1208
HEXSEVEN            1220
HEXSIX              121C
HEXSTRING           1497
HEXTHREE            1210
HEXTWO              120C
HEXVALUE            5030
HEXZERO             1200
IND_000             2CA0
IND_001             2CA6
IND_010             2CAC
IND_011             2CB2
IND_100             2CB8
IND_101             2CBE
IND_110             2CC4
IND_111             2CCA
IND_JMP             2C70
INITIAL_TABLE       169A
INTRO               1344
INVALID_DATA        12EE
IO_WELCOME          10C4
ISADDAL             261C
ISADDAW             25F8
ISADDB              2640
ISADDIB             2A52
ISADDIL             2A2E
ISADDIW             2A0A
ISADDL              2688
ISADDQB             2784
ISADDQL             27CC
ISADDQW             27A8
ISADDW              2664
ISANDB              258C
ISANDL              25D4
ISANDW              25B0
ISASLB              236A
ISASLL              23A8
ISASLW              238E
ISASRB              22FE
ISASRL              2346
ISASRW              2322
ISBCC               2206
ISBGT               222A
ISBLE               224E
ISCLR               2926
ISCLRB              280A
ISCLRL              2852
ISCLRW              282E
ISCMPB              2718
ISCMPL              2760
ISCMPW              273C
ISDIVUW             2272
ISJSR               28E2
ISLEA               28BE
ISLSLB              2438
ISLSLL              2476
ISLSLW              2452
ISLSRB              23CC
ISLSRL              2414
ISLSRW              23F0
ISMOVEAL            29CC
ISMOVEAW            2984
ISMOVEB             29F0
ISMOVEL             29A8
ISMOVEML            2876
ISMOVEMW            289A
ISMOVEQL            27E6
ISMOVEW             2960
ISMULSW             2568
ISNOP               2940
ISORB               2296
ISORL               22DE
ISORW               22BA
ISROLB              24FC
ISROLL              2544
ISROLW              2520
ISRORB              249A
ISRORL              24D8
ISRORW              24BE
ISRTS               2906
ISSUBB              26AC
ISSUBL              26F4
ISSUBW              26D0
IS_HEX_EVEN         1280
IS_LESSTHAN         1260
JSRORCLRCODE0000    1ECE
JSRORCLRCODE0001    1ED6
JSRORCLRCODE0010    1EDE
JSRORCLRCODE0011    1EE4
JSRORCLRCODE0100    1EEC
JSRORCLRCODE0101    1EF4
JSRORCLRCODE0110    1EFC
JSRORCLRCODE0111    1F04
JSRORCLRCODE1000    1F0C
JSRORCLRCODE1001    1F14
JSRORCLRCODE1010    1F1C
JSRORCLRCODE1011    1F24
JSRORCLRCODE1100    1F2C
JSRORCLRCODE1101    1F34
JSRORCLRCODE1110    1F3C
JSRORCLRCODE1111    1F44
JSR_ABS_L           39B8
JSR_ABS_W           39AE
JSR_END             39C2
JSR_MODE            391E
JSR_MODE_000        394E
JSR_MODE_001        3958
JSR_MODE_010        3962
JSR_MODE_011        396C
JSR_MODE_100        3976
JSR_MODE_101        3980
JSR_MODE_110        398A
JSR_MODE_111        3994
KEEP_RUNNING        44E0
LEA_ABS_L           3A80
LEA_ABS_W           3A76
LEA_DEST            3A8A
LEA_END             3A9E
LEA_MODE            39E6
LEA_MODE_000        3A16
LEA_MODE_001        3A20
LEA_MODE_010        3A2A
LEA_MODE_011        3A34
LEA_MODE_100        3A3E
LEA_MODE_101        3A48
LEA_MODE_110        3A52
LEA_MODE_111        3A5C
LF                  A
LONG                461D
LOOP                4678
LOOP_CHECK          4692
LOTSCODE0000        200A
LOTSCODE0001        2012
LOTSCODE0010        201A
LOTSCODE0011        2020
LOTSCODE0100        2028
LOTSCODE0101        2030
LOTSCODE0110        2038
LOTSCODE0111        2040
LOTSCODE1000        2048
LOTSCODE1001        204E
LOTSCODE1010        2056
LOTSCODE1011        205C
LOTSCODE1100        2064
LOTSCODE1101        206C
LOTSCODE1110        2074
LOTSCODE1111        207C
LOWYES              79
LSD_END             3BCE
LSD_MEM             3B18
LSD_MEM_ABS_L       3BC4
LSD_MEM_ABS_W       3BBA
LSD_MEM_MODE        3B2A
LSD_MEM_MODE_000    3B5A
LSD_MEM_MODE_001    3B64
LSD_MEM_MODE_010    3B6E
LSD_MEM_MODE_011    3B78
LSD_MEM_MODE_100    3B82
LSD_MEM_MODE_101    3B8C
LSD_MEM_MODE_110    3B96
LSD_MEM_MODE_111    3BA0
LSD_REG             3AC0
LSD_REG_COUNT       3AEE
LSD_REG_END         3AFE
LSD_REG_REG         3AE4
LSLCODE00           19C2
LSLCODE01           19CA
LSLCODE10           19D2
LSLCODE11           19DA
LSL_LSR             1AC4
LSL_LSRCODE0        1AEE
LSL_LSRCODE1        1AF4
LSRCODE00           196C
LSRCODE01           1974
LSRCODE10           197C
LSRCODE11           1984
LT                  1278
MESSAGEADDAL        15B0
MESSAGEADDAW        15A9
MESSAGEADDB         1597
MESSAGEADDIB        1515
MESSAGEADDIL        150E
MESSAGEADDIW        1507
MESSAGEADDL         15A3
MESSAGEADDQB        155E
MESSAGEADDQL        156C
MESSAGEADDQW        1565
MESSAGEADDW         159D
MESSAGEANDB         15BF
MESSAGEANDL         15CB
MESSAGEANDW         15C5
MESSAGEASLB         15EA
MESSAGEASLL         15F6
MESSAGEASLW         15F0
MESSAGEASRB         15D8
MESSAGEASRL         15E4
MESSAGEASRW         15DE
MESSAGEBCC          165A
MESSAGEBGT          165E
MESSAGEBLE          1662
MESSAGECLR          1540
MESSAGECLRB         154C
MESSAGECLRL         1558
MESSAGECLRW         1552
MESSAGECMPB         1573
MESSAGECMPL         157F
MESSAGECMPW         1579
MESSAGEDIVUW        1653
MESSAGEJSR          153C
MESSAGELEA          1548
MESSAGELSLB         1632
MESSAGELSLL         163E
MESSAGELSLW         1638
MESSAGELSRB         1620
MESSAGELSRL         162C
MESSAGELSRW         1626
MESSAGEMOVEAL       151C
MESSAGEMOVEAW       1524
MESSAGEMOVEB        1500
MESSAGEMOVEL        14F9
MESSAGEMOVEML       152C
MESSAGEMOVEMW       1534
MESSAGEMOVEQL       15B7
MESSAGEMOVEW        14F2
MESSAGEMULSW        15D1
MESSAGENOP          14EE
MESSAGEOPCODE_INVALID  1666
MESSAGEORB          1644
MESSAGEORL          164E
MESSAGEORW          1649
MESSAGEROLB         160E
MESSAGEROLL         161A
MESSAGEROLW         1614
MESSAGERORB         15FC
MESSAGERORL         1608
MESSAGERORW         1602
MESSAGERTS          1544
MESSAGESPACE        14EC
MESSAGESUBB         1585
MESSAGESUBL         1591
MESSAGESUBW         158B
MINUS               4664
MOD                 2
MOVEACODE001        2130
MOVEAWCODE001       21BE
MOVEA_ADJUST_L      3DE2
MOVEA_ADJUST_W      3DD8
MOVEA_DESTINATION   3EB4
MOVEA_END           3EC8
MOVEA_LORMOVE_L     20DA
MOVEA_SOURCE        3DEC
MOVEA_SRC_ABS_L     3EA0
MOVEA_SRC_ABS_W     3E96
MOVEA_SRC_IMM       3EAA
MOVEA_SRC_MODE      3DFE
MOVEA_SRC_MODE_000  3E2E
MOVEA_SRC_MODE_001  3E38
MOVEA_SRC_MODE_010  3E42
MOVEA_SRC_MODE_011  3E4C
MOVEA_SRC_MODE_100  3E56
MOVEA_SRC_MODE_101  3E60
MOVEA_SRC_MODE_110  3E6A
MOVEA_SRC_MODE_111  3E74
MOVEA_WORMOVE_W     2168
MOVECODE000         2128
MOVECODE010         2138
MOVECODE011         2140
MOVECODE100         2148
MOVECODE101         2150
MOVECODE110         2158
MOVECODE111         2160
MOVEMCODE0          1F76
MOVEMCODE1          1F7E
MOVEQ_PRINT_DATA    3F0A
MOVEWCODE000        21B6
MOVEWCODE010        21C6
MOVEWCODE011        21CE
MOVEWCODE100        21D6
MOVEWCODE101        21DE
MOVEWCODE110        21E6
MOVEWCODE111        21EE
MOVE_ADJUST_L       3C0E
MOVE_ADJUST_W       3C04
MOVE_DESTINATION    3CE0
MOVE_DST_ABS_L      3D98
MOVE_DST_ABS_W      3D8E
MOVE_DST_MODE       3CFE
MOVE_DST_MODE_000   3D2E
MOVE_DST_MODE_001   3D38
MOVE_DST_MODE_010   3D42
MOVE_DST_MODE_011   3D4C
MOVE_DST_MODE_100   3D56
MOVE_DST_MODE_101   3D60
MOVE_DST_MODE_110   3D6A
MOVE_DST_MODE_111   3D74
MOVE_END            3DA2
MOVE_SOURCE         3C18
MOVE_SRC_ABS_L      3CCC
MOVE_SRC_ABS_W      3CC2
MOVE_SRC_IMM        3CD6
MOVE_SRC_MODE       3C2A
MOVE_SRC_MODE_000   3C5A
MOVE_SRC_MODE_001   3C64
MOVE_SRC_MODE_010   3C6E
MOVE_SRC_MODE_011   3C78
MOVE_SRC_MODE_100   3C82
MOVE_SRC_MODE_101   3C8C
MOVE_SRC_MODE_110   3C96
MOVE_SRC_MODE_111   3CA0
MULS_W_ABS_L        3FF4
MULS_W_ABS_W        3FEA
MULS_W_DEST         400C
MULS_W_END          401E
MULS_W_IMM          3FFE
MULS_W_MODE         3F52
MULS_W_MODE_000     3F82
MULS_W_MODE_001     3F8C
MULS_W_MODE_010     3F96
MULS_W_MODE_011     3FA0
MULS_W_MODE_100     3FAA
MULS_W_MODE_101     3FB4
MULS_W_MODE_110     3FBE
MULS_W_MODE_111     3FC8
MV                  4609
NEW_LINE            12C2
NEW_PAGE            45AA
NOPCOMMAND          1EC6
NOPORCLRORRTSORJSR  1E2C
NOP_MOVEM_LEA_JSR_CLR_RTS  1F86
NOTDONE             4510
NOTEVEN             12AA
OC_PARSE            167D
OPAREN              465E
OPCODE_INVALID      21F6
OR_ABS_L            41BE
OR_ABS_W            41B4
OR_BOROR_WOROR_LORDIVU  17FC
OR_DIVUCODE000      184A
OR_DIVUCODE001      1852
OR_DIVUCODE010      185A
OR_DIVUCODE011      1862
OR_DIVUCODE100      186A
OR_DIVUCODE101      1872
OR_DIVUCODE110      187A
OR_DIVUCODE111      1882
OR_END              41E2
OR_EVAL_EA          4112
OR_IMM              41C8
OR_MODE             4120
OR_MODE_000         4150
OR_MODE_001         415A
OR_MODE_010         416C
OR_MODE_011         4176
OR_MODE_1           40C2
OR_MODE_100         4180
OR_MODE_101         418A
OR_MODE_110         4190
OR_MODE_111         4196
OR_MODE_2           40EC
OR_MODE_END         41DA
OR_MODE_INVALID     41DC
OR_OPMODE           4042
OR_OPMODE_000       4072
OR_OPMODE_001       407C
OR_OPMODE_010       4086
OR_OPMODE_011       4090
OR_OPMODE_100       409A
OR_OPMODE_101       40A4
OR_OPMODE_110       40AE
OR_OPMODE_111       40B8
PAUSE               45C2
PERCENT             4659
PLUS                4662
POSTINC_000         2D3E
POSTINC_001         2D44
POSTINC_010         2D4A
POSTINC_011         2D50
POSTINC_100         2D56
POSTINC_101         2D5C
POSTINC_110         2D62
POSTINC_111         2D68
POSTINC_JMP         2D0E
POUND               4655
PREDEC_000          2DC6
PREDEC_001          2DCC
PREDEC_010          2DD2
PREDEC_011          2DD8
PREDEC_100          2DDE
PREDEC_101          2DE4
PREDEC_110          2DEA
PREDEC_111          2DF0
PREDEC_JMP          2D96
PRINTLN             4588
PRINT_HEXVALUE      12B4
PRINT_IMM_END       2CF6
PRINT_IMM_L         2CF2
PS1                 136C
PS2                 13B6
QUIT                466B
RCOUNT              1E
REMAINDER           5050
REPEAT              128C
RERUN               44E6
ROD_END             4312
ROD_LSD_ASD         1B30
ROD_LSD_ASDCODE00   1B66
ROD_LSD_ASDCODE01   1B6C
ROD_LSD_ASDCODE10   1B72
ROD_LSD_ASDCODE11   1B7A
ROD_MEM             425C
ROD_MEM_ABS_L       4308
ROD_MEM_ABS_W       42FE
ROD_MEM_MODE        426E
ROD_MEM_MODE_000    429E
ROD_MEM_MODE_001    42A8
ROD_MEM_MODE_010    42B2
ROD_MEM_MODE_011    42BC
ROD_MEM_MODE_100    42C6
ROD_MEM_MODE_101    42D0
ROD_MEM_MODE_110    42DA
ROD_MEM_MODE_111    42E4
ROD_REG             4204
ROD_REG_COUNT       4232
ROD_REG_END         4242
ROD_REG_REG         4228
ROLCODE00           1A18
ROLCODE01           1A20
ROLCODE10           1A28
ROLCODE11           1A30
ROL_ROR             1A8E
ROL_RORCODE0        1AB8
ROL_RORCODE1        1ABE
RORCODE00           1A6E
RORCODE01           1A76
RORCODE10           1A7E
RORCODE11           1A86
RTSCOMMAND          1EBE
RUNAGAIN            6000
SHIFTLEFT           11FA
SKIP_WRITE          4572
SOMEASL             18E0
SOMEASR             188A
SOMECLR             1DD6
SOMELSL             198C
SOMELSR             1936
SOMEMOVEM           1F4C
SOMEROL             19E2
SOMEROR             1A38
STACK               7000
START               466B
STR_LEN             5020
SUBCODE000          1CEA
SUBCODE001          1CF2
SUBCODE010          1CFA
SUBCODE011          1D02
SUBCODE100          1D0A
SUBCODE101          1D12
SUBCODE110          1D1A
SUBCODE111          1D22
SUB_ABS_L           44B2
SUB_ABS_W           44A8
SUB_BORSUB_WORSUB_L  1C9C
SUB_END             44D6
SUB_EVAL_EA         43FE
SUB_IMM             44BC
SUB_MODE            440C
SUB_MODE_000        443C
SUB_MODE_001        444E
SUB_MODE_010        4460
SUB_MODE_011        446A
SUB_MODE_1          43AE
SUB_MODE_100        4474
SUB_MODE_101        447E
SUB_MODE_110        4484
SUB_MODE_111        448A
SUB_MODE_2          43D8
SUB_MODE_END        44CE
SUB_MODE_INVALID    44D0
SUB_OPMODE          432E
SUB_OPMODE_000      435E
SUB_OPMODE_001      4368
SUB_OPMODE_010      4372
SUB_OPMODE_011      437C
SUB_OPMODE_100      4386
SUB_OPMODE_101      4390
SUB_OPMODE_110      439A
SUB_OPMODE_111      43A4
TAB                 4666
TABLEADDI_BORADDI_WORADDI_L  20A2
TABLEADDQ_BORADDQ_WORADDQ_L  1D9E
TABLEADD_BORADD_WORADD_L  1C2C
TABLEAND_BORAND_WORAND_LORMULS_W  1B9E
TABLEASL_ASR        1B18
TABLEBCCORBGTORBLE  17C4
TABLECMP_BORCMP_WORCMP_L  1D48
TABLELSL_LSR        1AE2
TABLEMOVEA_LORMOVE_L  20F8
TABLEMOVEA_WORMOVE_W  2186
TABLENOPORCLRORRTSORJSR  1E5E
TABLENOP_MOVEM_LEA_JSR_CLR_RTS  1FAA
TABLEOR_BOROR_WOROR_LORDIVU  181A
TABLEROD_LSD_ASD    1B4E
TABLEROL_ROR        1AAC
TABLESOMEASL        18FE
TABLESOMEASR        18A8
TABLESOMECLR        1DF4
TABLESOMELSL        19AA
TABLESOMELSR        1954
TABLESOMEMOVEM      1F6A
TABLESOMEROL        1A00
TABLESOMEROR        1A56
TABLESUB_BORSUB_WORSUB_L  1CBA
UPDATE_PTR          2B16
UPYES               59
WORD                4618
WRITE2MEM           4566
WRITE_ENDL          457A
WRITE_LINE          454A
