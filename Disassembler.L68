00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/2/2016 2:51:35 PM

00000000                             1  ******************************************************************************
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Brandon Authier (Hblkr), Jack S. Eldridge
00000000                             4  *              (JackScottie), Marijn Burger (marijnburger)
00000000                             5  * Date       : 16 May 2016
00000000                             6  * Description: An inverse assembler that will convert a memory
00000000                             7  *              image of instructions and data back to the display.
00000000                             8  *              The following will be decoded:
00000000                             9  *
00000000                            10  *              Addressing Modes
00000000                            11  *
00000000                            12  *                Data Register Direct
00000000                            13  *                Address Register Direct
00000000                            14  *                Address Register Indirect
00000000                            15  *                Immediate Data
00000000                            16  *                Address Register Indirect with Post Increment
00000000                            17  *                Address Register Indirect with Pre Decrement
00000000                            18  *                Absolute Long Address
00000000                            19  *                Absolute Word Address
00000000                            20  *
00000000                            21  *              Instructions
00000000                            22  *
00000000                            23  *                NOP
00000000                            24  *                MOVE
00000000                            25  *                MOVEA
00000000                            26  *                MOVEQ
00000000                            27  *                MOVEM
00000000                            28  *                ADD
00000000                            29  *                ADDA
00000000                            30  *                ADDI
00000000                            31  *                ADDQ
00000000                            32  *                SUB
00000000                            33  *                MULS
00000000                            34  *                DIVU
00000000                            35  *                LEA
00000000                            36  *                CLR
00000000                            37  *                AND
00000000                            38  *                OR
00000000                            39  *                LSL
00000000                            40  *                LSR
00000000                            41  *                ASR
00000000                            42  *                ASL
00000000                            43  *                ROL
00000000                            44  *                ROR
00000000                            45  *                CMP
00000000                            46  *                Bcc (BCC, BGT, BLE)
00000000                            47  *                JSR
00000000                            48  *                RTS
00000000                            49  *
00000000                            50  ******************************************************************************
00000000                            51  
00000000                            52  ******************************************************************************
00000000                            53  *           DEFINITIONS                                                      *
00000000                            54  ******************************************************************************
00000000  =00007000                 55  STACK     EQU   $7000               * Beginning address for stack pointer
00000000                            56  
00000000  =00005000                 57  BEGINADDR EQU   $5000               * Variable to hold beginning address value
00000000  =00005010                 58  ENDADDR   EQU   $5010               * Variable to hold ending address value
00000000                            59  
00000000  =00006000                 60  RUNAGAIN  EQU   $6000               * Value equivalent to 'true'
00000000                            61  
00001000                            62  START     ORG   $1000               * Program begins at address 1000
00001000                            63  
00001000                            64  *********** END DEFINITIONS **************************************************
00001000                            65  
00001000                            66  
00001000                            67  ******************************************************************************
00001000                            68  *           BEGIN CODE                                                       *
00001000                            69  ******************************************************************************
00001000                            70  
00001000                            71  *---------- START ------------------------------------------------------------
00001000                            72  * Begins program's logical flow. Similar to main in C/C++
00001000                            73  *-----------------------------------------------------------------------------
00001000  4FF8 7000                 74      LEA         STACK,SP            * SP is stored in A7
00001004  4EB9 0000104E             75      JSR         GET_ADDRESSES       * Runs GET_ADDRESSES and IO_WELCOME
0000100A  2C78 5000                 76      MOVEA.L     BEGINADDR,A6        * Assign beginning address to A6 for use
0000100E                            77  
0000100E                            78  LOOP
0000100E                            79      * OC_PARSE Command doesn't work due to issues in the Opcode include
0000100E                            80      * many errors need to be fixed. Same with EA include
0000100E                            81  
0000100E  45F9 00002000             82      LEA         BUFFER, A2
00001014  4EB9 00001392             83      JSR         OC_PARSE            * Determine if there is an initial opcode match
0000101A  4EB9 000043FE             84      JSR         WRITE_ENDL
00001020  4EB9 0000440C             85      JSR         PRINTLN
00001026  45F9 00002000             86      LEA         BUFFER, A2
0000102C  4EB9 0000441A             87      JSR         CLEAN_BUFF
00001032                            88  
00001032                            89      * decrement row count
00001032                            90      * if at 0, prompt for next page
00001032                            91      * else, continue
00001032                            92  
00001032                            93      *JSR         INVALID_DATA
00001032                            94      *ADDA.L      #$00000002,A6            * Advance address to test LOOP (test only)
00001032                            95  
00001032                            96  LOOP_CHECK
00001032                            97      * Changed the following code from:
00001032                            98      * CMPA        A6, ENDADDR
00001032                            99      * to:
00001032                           100      * CMPA      (ENDADDR),A6
00001032                           101      * When using the CMPA, destination must be an address so A6
00001032  BDF8 5010                102      CMPA.L      ENDADDR,A6          * Is pointer at end of address range?
00001036                           103  
00001036  6E00 0004                104      BGT         END_LOOP            * If yes, END_LOOP
0000103A                           105      ; in case this resets status register, do another compare TODO
0000103A                           106  
0000103A  66D2                     107      BNE         LOOP                * If not, continue processing addresses
0000103C                           108      ; If at end of address range, check if user wants to continue
0000103C                           109      ; if user wants to continue, restart
0000103C                           110      ; else, end
0000103C                           111  
0000103C                           112  END_LOOP
0000103C  4EB9 00004394            113      JSR         KEEP_RUNNING        * Does the user want to run program again
00001042  0C38 0001 6000           114      CMPI.B      #1,(RUNAGAIN)       * Does RUNAGAIN = TRUE?
00001048  67B6                     115      BEQ         START               * If yes, rerun program
0000104A  4E72 3000                116      STOP        #$3000              * Else, end program
0000104E                           117  
0000104E                           118  *---------- END - START ------------------------------------------------------
0000104E                           119  
0000104E                           120  *********** END BEGIN CODE ***************************************************
0000104E                           121  
0000104E                           122  
0000104E                           123  ******************************************************************************
0000104E                           124  *           VARIABLES AND CONSTANTS                                          *
0000104E                           125  ******************************************************************************
0000104E                           126  
0000104E                           127  ******************************************************************************
0000104E                           128  *           INCLUDES                                                         *
0000104E                           129  ******************************************************************************
0000104E                           130  
0000104E                           131      INCLUDE 'IO.X68'
0000104E                           132  
0000104E                           133  
0000104E                           134  
0000104E  =00005020                135  STR_LEN   EQU   $5020
0000104E  =00005021                136  HEXFLAG   EQU   $5021
0000104E  =00005030                137  HEXVALUE  EQU   $5030
0000104E  =00005050                138  REMAINDER EQU   $5050
0000104E  =00000002                139  MOD       EQU   2
0000104E                           140  
0000104E  =0000000D                141  CR        EQU   $0D
0000104E  =0000000A                142  LF        EQU   $0A
0000104E                           143  
0000104E                           144  
0000104E                           145  GET_ADDRESSES
0000104E  4EB9 0000131E            146      JSR         CLEARSCRN
00001054  4EB9 00001112            147      JSR         IO_WELCOME          * Run welcome subroutine
0000105A                           148  
0000105A                           149  GET_FIRST_ADDRESS
0000105A  43F9 00004476            150      LEA         PS1,A1              * Loads message into A1
00001060  4EB9 00001140            151      JSR         GET_HEXSTRING       * Get string from user
00001066  0C38 0001 5021           152      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000106C  66EC                     153      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000106E                           154  
0000106E  4EB9 00001172            155      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001074  0C38 0001 5021           156      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000107A  66DE                     157      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000107C                           158  
0000107C  4EB9 000012CE            159      JSR         IS_HEX_EVEN         * Check that hex value is even
00001082  0C38 0001 5021           160      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001088  66D0                     161      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000108A                           162  
0000108A  21F8 5030 5000           163      MOVE.L      HEXVALUE,BEGINADDR  * Copy hex value to begin
00001090  43F9 00004508            164      LEA         BMESSAGE,A1         * Load message in A1 for display
00001096  2238 5030                165      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display
0000109A  4EB9 00001310            166      JSR         NEW_LINE            * Space
000010A0                           167  
000010A0  4EB9 00001126            168      JSR         CLEAR               * Clear values for next hex
000010A6                           169  
000010A6                           170  GET_SECOND_ADDRESS
000010A6  43F9 000044C0            171      LEA         PS2,A1              * Loads message into A1
000010AC  4EB9 00001140            172      JSR         GET_HEXSTRING       * Get string from user
000010B2  0C38 0001 5021           173      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000010B8  66EC                     174      BNE         GET_SECOND_ADDRESS  * If no, get hex again
000010BA                           175  
000010BA  4EB9 00001172            176      JSR         ASCII_TO_HEX        * Convert ascii to hex
000010C0  0C38 0001 5021           177      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000010C6  66DE                     178      BNE         GET_SECOND_ADDRESS  * If no, get hex again
000010C8                           179  
000010C8  4EB9 000012CE            180      JSR         IS_HEX_EVEN         * Check that hex value is even
000010CE  0C38 0001 5021           181      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000010D4  66D0                     182      BNE         GET_SECOND_ADDRESS  * If no, get hex again
000010D6                           183  
000010D6  21F8 5030 5010           184      MOVE.L      HEXVALUE,ENDADDR    * Copy hex value to begin
000010DC  43F9 00004527            185      LEA         EMESSAGE,A1         * Load message in A1 for display
000010E2  2238 5030                186      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display
000010E6  4EB9 00001310            187      JSR         NEW_LINE            * Space
000010EC                           188  
000010EC  4EB9 00001126            189      JSR         CLEAR               * Clear values for next hex
000010F2                           190  
000010F2                           191  CHECK_BADDR_IS_LESS_THAN_EADDR
000010F2  4EB9 000012AE            192      JSR         IS_LESSTHAN         *
000010F8  0C38 0001 5021           193      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000010FE  6700 0010                194      BEQ         FINISHED            * If yes, finished
00001102  43F9 00004546            195      LEA         ADR_ERR_NOTLT,A1    * Else, load error message
00001108  6100 0220                196      BSR.W       ADDRESS_ERR
0000110C  6100 FEF2                197      BSR.W       START
00001110                           198  
00001110                           199  
00001110                           200  FINISHED
00001110  4E75                     201      RTS                             * Return to Disassembler
00001112                           202  
00001112                           203  
00001112                           204  
00001112                           205  
00001112                           206  
00001112                           207  IO_WELCOME:
00001112  43F9 0000444E            208      LEA         INTRO,A1            * Loads message into A1
00001118  103C 000E                209      MOVE.B      #14,D0              * Moves the Task 14 into D0
0000111C  4E4F                     210      TRAP        #15                 * Displays Intro Message
0000111E                           211  
0000111E  4EB9 00001310            212      JSR         NEW_LINE            * Call Subroutine
00001124  4E75                     213      RTS                             * Return from subroutine
00001126                           214  
00001126                           215  
00001126                           216  
00001126                           217  CLEAR
00001126  4286                     218      CLR.L       D6                   * Clear
00001128  31FC FFFF 5020           219      MOVE.W      #$FFFF,STR_LEN       * Clear
0000112E  21FC FFFFFFFF 5030       220      MOVE.L      #$FFFFFFFF,HEXVALUE  * Clear
00001136  21FC FFFFFFFF 5050       221      MOVE.L      #$FFFFFFFF,REMAINDER * Clear
0000113E  4E75                     222      RTS                              * Return to main to get hex
00001140                           223  
00001140                           224  
00001140                           225  
00001140                           226  GET_HEXSTRING
00001140  103C 000E                227      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001144  323C 004A                228      MOVE.W      #(PS2-PS1),D1       * The prompt string length
00001148  4E4F                     229      TRAP        #15                 * Displays contents of A1
0000114A                           230  
0000114A  43F9 000045A1            231      LEA         HEXSTRING,A1        * Pointer to store the sentence
00001150  103C 0002                232      MOVE.B      #2,D0               * Set up readstring function
00001154  4E4F                     233      TRAP        #15                 * Get string from keyboard
00001156  11C1 5020                234      MOVE.B      D1,STR_LEN          * Save length of input string
0000115A                           235  
0000115A  0C38 0008 5020           236      CMPI.B      #8,(STR_LEN)        * Is length > 8?
00001160  6E00 FEF8                237      BGT         GET_FIRST_ADDRESS   * If yes, get hex again
00001164                           238  
00001164  41F9 000045A1            239      LEA         HEXSTRING,A0        * Load address for verification
0000116A  11FC 0001 5021           240      MOVE.B      #1,(HEXFLAG)
00001170  4E75                     241      RTS                             * Return from subroutine
00001172                           242  
00001172                           243  
00001172                           244  
00001172                           245  ASCII_TO_HEX
00001172  1618                     246      MOVE.B      (A0)+,D3            * Move first char into D3
00001174  0C03 0030                247      CMPI.B      #'0',D3             * Is Char equal to 0?
00001178  6700 00D4                248      BEQ         HEXZERO
0000117C  0C03 0031                249      CMPI.B      #'1',D3             * Is Char equal to 1?
00001180  6700 00D4                250      BEQ         HEXONE
00001184  0C03 0032                251      CMPI.B      #'2',D3             * Is Char equal to 2?
00001188  6700 00D0                252      BEQ         HEXTWO
0000118C  0C03 0033                253      CMPI.B      #'3',D3             * Is Char equal to 3?
00001190  6700 00CC                254      BEQ         HEXTHREE
00001194  0C03 0034                255      CMPI.B      #'4',D3             * Is Char equal to 4?
00001198  6700 00C8                256      BEQ         HEXFOUR
0000119C  0C03 0035                257      CMPI.B      #'5',D3             * Is Char equal to 5?
000011A0  6700 00C4                258      BEQ         HEXFIVE
000011A4  0C03 0036                259      CMPI.B      #'6',D3             * Is Char equal to 6?
000011A8  6700 00C0                260      BEQ         HEXSIX
000011AC  0C03 0037                261      CMPI.B      #'7',D3             * Is Char equal to 7?
000011B0  6700 00BC                262      BEQ         HEXSEVEN
000011B4  0C03 0038                263      CMPI.B      #'8',D3             * Is Char equal to 8?
000011B8  6700 00B8                264      BEQ         HEXEIGHT
000011BC  0C03 0039                265      CMPI.B      #'9',D3             * Is Char equal to 9?
000011C0  6700 00B4                266      BEQ         HEXNINE
000011C4  0C03 0041                267      CMPI.B      #'A',D3             * Is Char equal to A?
000011C8  6700 00B4                268      BEQ         HEXA
000011CC  0C03 0042                269      CMPI.B      #'B',D3             * Is Char equal to B?
000011D0  6700 00B4                270      BEQ         HEXB
000011D4  0C03 0043                271      CMPI.B      #'C',D3             * Is Char equal to C?
000011D8  6700 00B4                272      BEQ         HEXC
000011DC  0C03 0044                273      CMPI.B      #'D',D3             * Is Char equal to D?
000011E0  6700 00B4                274      BEQ         HEXD
000011E4  0C03 0045                275      CMPI.B      #'E',D3             * Is Char equal to E?
000011E8  6700 00B4                276      BEQ         HEXE
000011EC  0C03 0046                277      CMPI.B      #'F',D3             * Is Char equal to F?
000011F0  6700 00B4                278      BEQ         HEXF
000011F4  0C03 0061                279      CMPI.B      #'a',D3             * Is Char equal to a?
000011F8  6700 0084                280      BEQ         HEXA
000011FC  0C03 0062                281      CMPI.B      #'b',D3             * Is Char equal to b?
00001200  6700 0084                282      BEQ         HEXB
00001204  0C03 0063                283      CMPI.B      #'c',D3             * Is Char equal to c?
00001208  6700 0084                284      BEQ         HEXC
0000120C  0C03 0064                285      CMPI.B      #'d',D3             * Is Char equal to d?
00001210  6700 0084                286      BEQ         HEXD
00001214  0C03 0065                287      CMPI.B      #'e',D3             * Is Char equal to e?
00001218  6700 0084                288      BEQ         HEXE
0000121C  0C03 0066                289      CMPI.B      #'f',D3             * Is Char equal to f?
00001220  6700 0084                290      BEQ         HEXF
00001224                           291  
00001224  11FC 0000 5021           292      MOVE.B      #0,HEXFLAG          * Set false
0000122A  6000 FEFA                293      BRA         CLEAR               * Clear some values
0000122E                           294  
0000122E                           295  FOUND
0000122E  5338 5020                296      SUBI.B      #1,STR_LEN          * Decrease string by one
00001232  0C38 0000 5020           297      CMPI.B      #0,STR_LEN          * Is string = 0?
00001238  6600 000E                298      BNE         SHIFTLEFT           * If no, shift value left
0000123C  21C6 5030                299      MOVE.L      D6,HEXVALUE         * If yes, save hex value
00001240  11FC 0001 5021           300      MOVE.B      #1,HEXFLAG          * Set true
00001246  4E75                     301      RTS                             * Then, return to main
00001248                           302  
00001248                           303  SHIFTLEFT
00001248  E98E                     304      LSL.L       #4,D6               * Shift the value left
0000124A  6000 FF26                305      BRA         ASCII_TO_HEX        * Check next char
0000124E                           306  
0000124E                           307  HEXZERO
0000124E  0686 00000000            308      ADD.L       #$0,D6              * Add value
00001254  60D8                     309      BRA         FOUND               * found, decrease strlen, shift value left
00001256                           310  HEXONE
00001256  5286                     311      ADD.L       #$1,D6              * Add value
00001258  60D4                     312      BRA         FOUND               * found, decrease strlen, shift value left
0000125A                           313  HEXTWO
0000125A  5486                     314      ADD.L       #$2,D6              * Add value
0000125C  60D0                     315      BRA         FOUND               * found, decrease strlen, shift value left
0000125E                           316  HEXTHREE
0000125E  5686                     317      ADD.L       #$3,D6              * Add value
00001260  60CC                     318      BRA         FOUND               * found, decrease strlen, shift value left
00001262                           319  HEXFOUR
00001262  5886                     320      ADD.L       #$4,D6              * Add value
00001264  60C8                     321      BRA         FOUND               * found, decrease strlen, shift value left
00001266                           322  HEXFIVE
00001266  5A86                     323      ADD.L       #$5,D6              * Add value
00001268  60C4                     324      BRA         FOUND               * found, decrease strlen, shift value left
0000126A                           325  HEXSIX
0000126A  5C86                     326      ADD.L       #$6,D6              * Add value
0000126C  60C0                     327      BRA         FOUND               * found, decrease strlen, shift value left
0000126E                           328  HEXSEVEN
0000126E  5E86                     329      ADD.L       #$7,D6              * Add value
00001270  60BC                     330      BRA         FOUND               * found, decrease strlen, shift value left
00001272                           331  HEXEIGHT
00001272  5086                     332      ADD.L       #$8,D6              * Add value
00001274  60B8                     333      BRA         FOUND               * found, decrease strlen, shift value left
00001276                           334  HEXNINE
00001276  0686 00000009            335      ADD.L       #$9,D6              * Add value
0000127C  60B0                     336      BRA         FOUND               * found, decrease strlen, shift value left
0000127E                           337  HEXA
0000127E  0686 0000000A            338      ADD.L       #$A,D6              * Add value
00001284  60A8                     339      BRA         FOUND               * found, decrease strlen, shift value left
00001286                           340  HEXB
00001286  0686 0000000B            341      ADD.L       #$B,D6              * Add value
0000128C  60A0                     342      BRA         FOUND               * found, decrease strlen, shift value left
0000128E                           343  HEXC
0000128E  0686 0000000C            344      ADD.L       #$C,D6              * Add value
00001294  6098                     345      BRA         FOUND               * found, decrease strlen, shift value left
00001296                           346  HEXD
00001296  0686 0000000D            347      ADD.L       #$D,D6              * Add value
0000129C  6090                     348      BRA         FOUND               * found, decrease strlen, shift value left
0000129E                           349  HEXE
0000129E  0686 0000000E            350      ADD.L       #$E,D6              * Add value
000012A4  6088                     351      BRA         FOUND               * found, decrease strlen, shift value left
000012A6                           352  HEXF
000012A6  0686 0000000F            353      ADD.L       #$F,D6              * Add value
000012AC  6080                     354      BRA         FOUND               * found, decrease strlen, shift value left
000012AE                           355  
000012AE                           356  
000012AE                           357  
000012AE                           358  IS_LESSTHAN
000012AE  2838 5000                359      MOVE.L      BEGINADDR,D4        * Store beginning address in D4
000012B2  2C38 5010                360      MOVE.L      ENDADDR,D6          * Store ending address in D6
000012B6  B886                     361      CMP.L       D6,D4               * Is D4 < D6
000012B8  6D00 000C                362      BLT         LT                  * Yes, mark true return to main
000012BC  11FC 0000 5021           363      MOVE.B      #0,HEXFLAG          * No, mark false
000012C2  6000 FE62                364      BRA         CLEAR               * Clear values, return to main
000012C6                           365  
000012C6                           366  LT
000012C6  11FC 0001 5021           367      MOVE.B      #1,HEXFLAG          * Mark true
000012CC  4E75                     368      RTS                             * Return to main
000012CE                           369  
000012CE                           370  
000012CE                           371  
000012CE                           372  IS_HEX_EVEN
000012CE  3606                     373      MOVE.W      D6,D3               * Move value to be modded into D3
000012D0  3A3C 0002                374      MOVE.W      #MOD,D5             * Move mod value into D5
000012D4  86C5                     375      DIVU        D5,D3               * Divide D3 by D5
000012D6  123C 0003                376      MOVE.B      #3,D1               * Set counter to shift value into word
000012DA                           377                                      * position
000012DA                           378  REPEAT
000012DA  E88B                     379      LSR.L       #4,D3               * Shift remainder to lower word
000012DC  57C9 FFFC                380      DBEQ        D1,REPEAT           * UNTIL [D0] = - 1
000012E0  4241                     381      CLR         D1                  * Clear
000012E2                           382  
000012E2  B6BC 00000000            383      CMP.L       #0,D3               * Is hex even?
000012E8  6600 000E                384      BNE         NOTEVEN             * No, clear and go back to get_hex
000012EC  31C3 5050                385      MOVE.W      D3,REMAINDER        * Save remainder
000012F0  11FC 0001 5021           386      MOVE.B      #1,HEXFLAG          * Set true
000012F6  4E75                     387      RTS                             * Return to main
000012F8                           388  
000012F8                           389  NOTEVEN
000012F8  11FC 0000 5021           390      MOVE.B      #0,HEXFLAG          * Set false
000012FE  6000 FE26                391      BRA         CLEAR               * Clear values
00001302                           392  
00001302                           393  
00001302                           394  
00001302                           395  PRINT_HEXVALUE
00001302  103C 000E                396      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001306  4E4F                     397      TRAP        #15                 * Displays contents of A1
00001308                           398  
00001308  103C 0003                399      MOVE.B      #3,D0               * Moves the Task 3 into D0
0000130C  4E4F                     400      TRAP        #15                 * Displays contents of D1
0000130E                           401  
0000130E  4E75                     402      RTS                             * Return from subroutine
00001310                           403  
00001310                           404  
00001310                           405  NEW_LINE
00001310  43F9 0000488B            406      LEA         ENDL,A1             * Loads message into A1
00001316  103C 000E                407      MOVE.B      #14,D0              * Moves the TRACK 14 into D0
0000131A  4E4F                     408      TRAP        #15                 * Displays New line
0000131C  4E75                     409      RTS                             * Return from subroutine
0000131E                           410  
0000131E                           411  
0000131E                           412  CLEARSCRN
0000131E  103C 000B                413      MOVE.B      #11,D0              * Task 11 for clearing screen
00001322  323C FF00                414      MOVE.W      #$FF00,D1           * FF00, Clear screen
00001326  4E4F                     415      TRAP        #15                 * Wait for keystroke
00001328  4E75                     416      RTS                             * Return from subroutine
0000132A                           417  
0000132A                           418  
0000132A                           419  
0000132A                           420  
0000132A                           421  ADDRESS_ERR
0000132A  6100 FFF2                422      BSR.W       CLEARSCRN           * Clear output before displaying error
0000132E  103C 000D                423      MOVE.B      #13,D0              * Moves the Task 13 into D0
00001332  4E4F                     424      TRAP        #15                 * Displays contents of A1
00001334  103C 0005                425      MOVE.B      #5,D0               * Read single character from
00001338  4E4F                     426      TRAP        #15                 * The keyboard into D1.B
0000133A  4E75                     427      RTS                             * Return from subroutine
0000133C                           428  
0000133C                           429  
0000133C                           430  
0000133C                           431  INVALID_DATA
0000133C  220E                     432      MOVE.L      A6,D1               * Move the address location to D1
0000133E  143C 0010                433      MOVE.B      #16,D2              * Move base 16 to D2
00001342  103C 000F                434      MOVE.B      #15,D0              * Moves Task 15 into D0
00001346  4E4F                     435      TRAP        #15                 * Displays contents of D1
00001348                           436  
00001348  43F9 000048CF            437      LEA         TAB,A1              * Load TAB to A1
0000134E  103C 000E                438      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001352  4E4F                     439      TRAP        #15                 * Displays a tab of A1
00001354                           440  
00001354  43F9 000045F1            441      LEA         DATA,A1             * Load address location to A1
0000135A  103C 000E                442      MOVE.B      #14,D0              * Moves the Task 14 into D0
0000135E  4E4F                     443      TRAP        #15                 * Displays location of A1
00001360                           444  
00001360  43F9 000048CF            445      LEA         TAB,A1              * Load TAB to A1
00001366  103C 000E                446      MOVE.B      #14,D0              * Moves the Task 14 into D0
0000136A  4E4F                     447      TRAP        #15                 * Displays a tab of A1
0000136C                           448  
0000136C  43F9 000048C0            449      LEA         DOLLAR,A1           * Load TAB to A1
00001372  103C 000E                450      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001376  4E4F                     451      TRAP        #15                 * Displays a tab of A1
00001378                           452  
00001378  3216                     453      MOVE.W      (A6),D1             * Move the address value to D1
0000137A  143C 0010                454      MOVE.B      #16,D2              * Move base 16 to D2
0000137E  103C 000F                455      MOVE.B      #15,D0              * Moves Task 15 into D0
00001382  4E4F                     456      TRAP        #15                 * Displays value of D1
00001384                           457  
00001384  43F9 0000488B            458      LEA         ENDL,A1             * Load TAB to A1
0000138A  103C 000E                459      MOVE.B      #14,D0              * Moves the Task 14 into D0
0000138E  4E4F                     460      TRAP        #15                 * Displays a tab of A1
00001390                           461  
00001390  4E75                     462      RTS                             * Return from subroutine
00001392                           463  
00001392                           464  
00001392                           465  
00001392                           466  
00001392                           467  
00001392                           468  
00001392                           469  
00001392                           470  
00001392                           471  
00001392                           472  
00001392                           473  -------------------- end include --------------------
00001392                           474      INCLUDE 'OpCodes.X68'
00001392                           475  
00001392                           476  
00001392                           477  OC_PARSE:
00001392  48E7 FFFE                478          MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001396  41F9 000013AE            479          LEA         initial_table,A0 ; Index into the table
0000139C  4280                     480          CLR.L       D0              ; Zero it
0000139E  3012                     481          MOVE.W      (A2),D0         ; We'll play with it here
000013A0  123C 000C                482          MOVE.B      #12,D1          ; Shift 12 bits to the right
000013A4  E268                     483          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000013A6                           484                                      ; and the rest are zeroed out)
000013A6  C0FC 0006                485          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000013AA  4EF0 0000                486          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000013AE                           487  
000013AE                           488  initial_table:
000013AE  4EF9 0000140E            489          JMP         code0000        ; ADDI.B, ADDI.W, or ADDI.L
000013B4  4EF9 00001414            490          JMP         code0001        ; MOVE.B
000013BA  4EF9 00001420            491          JMP         code0010        ; MOVEA.L or MOVE.L
000013C0  4EF9 00001426            492          JMP         code0011        ; MOVEA.W or MOVE.W
000013C6  4EF9 0000142C            493          JMP         code0100        ; NOP or MOVEM.W or MOVEM.L or LEA or CLR.B or CLR.W or CLR.L or JSR or RTS or MULS.W
000013CC  4EF9 00001438            494          JMP         code0101        ; ADDQ.B or ADDQ.W or ADDQ.L
000013D2  4EF9 00001444            495          JMP         code0110        ; BCC or BGT or BLE
000013D8  4EF9 00001450            496          JMP         code0111        ; MOVEQ.L
000013DE  4EF9 0000145C            497          JMP         code1000        ; OR.B or OR.W or OR.L or DIVU (DIVU is either word or long depending on ea)
000013E4  4EF9 00001468            498          JMP         code1001        ; SUB.B or SUB.W or SUB.L
000013EA  4EF9 00001474            499          JMP         code1010
000013F0  4EF9 0000147C            500          JMP         code1011        ; CMP.B or CMP.W or CMP.L
000013F6  4EF9 00001488            501          JMP         code1100        ; AND_BorAND_WorAND_LorMULS_W
000013FC  4EF9 00001494            502          JMP         code1101        ; ADD.B or ADD.W or ADD.L
00001402  4EF9 000014A0            503          JMP         code1110        ; ROd_LSd_ASd
00001408  4EF9 000014AC            504          JMP         code1111
0000140E                           505  
0000140E  4EB9 00001D98            506  code0000 JSR        ADDI_BorADDI_WorADDI_L
00001414  4EB9 000027E6            507  code0001 JSR        ISMOVEB
0000141A  4EB9 000014B4            508           JSR        DONE
00001420  4EB9 00001DEE            509  code0010 JSR        MOVEA_LorMOVE_L
00001426  4EB9 00001E7C            510  code0011 JSR        MOVEA_WorMOVE_W
0000142C  4EB9 00001C9A            511  code0100 JSR        NOP_MOVEM_LEA_JSR_CLR_RTS
00001432  4EB9 000014B4            512           JSR        DONE
00001438  4EB9 00001A94            513  code0101 JSR        ADDQ_BorADDQ_WorADDQ_L
0000143E  4EB9 000014B4            514           JSR        DONE
00001444  4EB9 000014BA            515  code0110 JSR        BCCorBGTorBLE
0000144A  4EB9 000014B4            516           JSR        DONE
00001450  4EB9 000025A2            517  code0111 JSR        ISMOVEQL
00001456  4EB9 000014B4            518           JSR        DONE
0000145C  4EB9 00001510            519  code1000 JSR        OR_BorOR_WorOR_LorDIVU
00001462  4EB9 000014B4            520           JSR        DONE
00001468  4EB9 000019B0            521  code1001 JSR        SUB_BorSUB_WorSUB_L
0000146E  4EB9 000014B4            522           JSR        DONE
00001474  4EB9 00001F0A            523  code1010 JSR    OPCODE_INVALID              ;INVALID
0000147A  4E75                     524           RTS
0000147C  4EB9 00001A3E            525  code1011 JSR        CMP_BorCMP_WorCMP_L
00001482  4EB9 000014B4            526           JSR        DONE
00001488  4EB9 00001894            527  code1100 JSR        AND_BorAND_WorAND_LorMULS_W
0000148E  4EB9 000014B4            528           JSR        DONE
00001494  4EB9 00001922            529  code1101 JSR        ADD_BorADD_WorADD_L
0000149A  4EB9 000014B4            530           JSR        DONE
000014A0  4EB9 00001844            531  code1110 JSR        ROd_LSd_ASd
000014A6  4EB9 000014B4            532           JSR        DONE
000014AC  4EB9 00001F0A            533  code1111 JSR    OPCODE_INVALID              ;INVALID
000014B2  4E75                     534           RTS
000014B4  4CDF 7FFF                535  DONE    MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000014B8  4E75                     536          RTS
000014BA                           537  
000014BA  41F9 000014D8            538  BCCorBGTorBLE       LEA     tableBCCorBGTorBLE, A0            ; Index into the table
000014C0  4280                     539                      CLR.L   D0                  ; Zero it
000014C2  3016                     540                      MOVE.W  (A6),D0         ; We'll play with it here
000014C4  123C 0006                541                      MOVE.B  #6,D1           ; Shift 6 bits left
000014C8  E360                     542                      ASL.W   D1,D0
000014CA  123C 000E                543                      MOVE.B  #14,D1           ; Shift 14 bits to the right
000014CE  E268                     544                      LSR.W   D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
000014D0                           545                                      ; and the rest are zeroed out)
000014D0  C0FC 0006                546                      MULU    #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
000014D4  4EF0 0000                547                      JMP     0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
000014D8                           548  
000014D8  4EF9 000014F0            549  tableBCCorBGTorBLE   JMP    BCCorBGTorBLEcode00   ; BCC
000014DE  4EF9 000014F8            550                       JMP    BCCorBGTorBLEcode01   ;
000014E4  4EF9 00001500            551                       JMP    BCCorBGTorBLEcode10   ; BGT
000014EA  4EF9 00001508            552                       JMP    BCCorBGTorBLEcode11   ; BLE
000014F0                           553  
000014F0                           554  
000014F0                           555  
000014F0  4EB9 00001F1A            556  BCCorBGTorBLEcode00    JSR     ISBCC
000014F6  4E75                     557                         RTS
000014F8  4EB9 00001F0A            558  BCCorBGTorBLEcode01    JSR    OPCODE_INVALID              ;INVALID
000014FE  4E75                     559                         RTS
00001500  4EB9 00001F42            560  BCCorBGTorBLEcode10    JSR     ISBGT
00001506  4E75                     561                         RTS
00001508  4EB9 00001F6A            562  BCCorBGTorBLEcode11    JSR     ISBLE
0000150E  4E75                     563                         RTS
00001510                           564  
00001510                           565  
00001510                           566  OR_BorOR_WorOR_LorDIVU:
00001510  41F9 0000152E            567          LEA         tableOR_BorOR_WorOR_LorDIVU, A0 ; Index into the table
00001516  4280                     568          CLR.L       D0              ; Zero it
00001518  3016                     569          MOVE.W      (A6),D0     ; We'll play with it here
0000151A  123C 0007                570          MOVE.B      #7,D1           ; Shift 7 bits left
0000151E  E360                     571          ASL.W       D1,D0
00001520  123C 000D                572          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001524  E268                     573          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001526                           574                                      ; and the rest are zeroed out)
00001526  C0FC 0006                575          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000152A  4EF0 0000                576          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000152E                           577  
0000152E                           578  tableOR_BorOR_WorOR_LorDIVU
0000152E  4EF9 0000155E            579          JMP         OR_DIVUcode000  ; OR.B
00001534  4EF9 00001566            580          JMP         OR_DIVUcode001  ; OR.W
0000153A  4EF9 0000156E            581          JMP         OR_DIVUcode010  ; OR.L
00001540  4EF9 00001576            582          JMP         OR_DIVUcode011  ; DIVU.W
00001546  4EF9 0000157E            583          JMP         OR_DIVUcode100  ; OR.B
0000154C  4EF9 00001586            584          JMP         OR_DIVUcode101  ; OR.W
00001552  4EF9 0000158E            585          JMP         OR_DIVUcode110  ; OR.L
00001558  4EF9 00001596            586          JMP         OR_DIVUcode111  ; INVALID
0000155E                           587  
0000155E                           588  
0000155E  4EB9 00001FBA            589  OR_DIVUcode000 JSR  ISORB
00001564  4E75                     590                 RTS
00001566  4EB9 00001FE2            591  OR_DIVUcode001 JSR  ISORW
0000156C  4E75                     592                 RTS
0000156E  4EB9 0000200A            593  OR_DIVUcode010 JSR  ISORL
00001574  4E75                     594                 RTS
00001576  4EB9 00001F92            595  OR_DIVUcode011 JSR  ISDIVUW
0000157C  4E75                     596                 RTS
0000157E  4EB9 00001FBA            597  OR_DIVUcode100 JSR  ISORB
00001584  4E75                     598                 RTS
00001586  4EB9 00001FE2            599  OR_DIVUcode101 JSR  ISORW
0000158C  4E75                     600                 RTS
0000158E  4EB9 0000200A            601  OR_DIVUcode110 JSR  ISORL
00001594  4E75                     602                 RTS
00001596  4EB9 00001F0A            603  OR_DIVUcode111 JSR    OPCODE_INVALID              ;INVALID
0000159C  4E75                     604                 RTS
0000159E                           605  
0000159E                           606  
0000159E                           607  someASR:
0000159E  41F9 000015BC            608          LEA         tableSomeASR, A0 ; Index into the table
000015A4  4280                     609          CLR.L       D0              ; Zero it
000015A6  3016                     610          MOVE.W      (A6),D0         ; We'll play with it here
000015A8  123C 0008                611          MOVE.B      #8,D1           ; Shift 8 bits left
000015AC  E360                     612          ASL.W       D1,D0
000015AE  123C 000E                613          MOVE.B      #14,D1          ; Shift 14 bits to the right
000015B2  E268                     614          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000015B4                           615                                      ; and the rest are zeroed out)
000015B4  C0FC 0006                616          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000015B8  4EF0 0000                617          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000015BC                           618  
000015BC                           619  tableSomeASR:
000015BC  4EF9 000015D4            620          JMP         ASRcode00       *ASR.B
000015C2  4EF9 000015DC            621          JMP         ASRcode01       *ASR.W
000015C8  4EF9 000015E4            622          JMP         ASRcode10       *ASR.L
000015CE  4EF9 000015EC            623          JMP         ASRcode11       *ASR.W
000015D4                           624  
000015D4  4EB9 00002032            625  ASRcode00 JSR       ISASRB
000015DA  4E75                     626            RTS
000015DC  4EB9 0000205A            627  ASRcode01 JSR       ISASRW
000015E2  4E75                     628            RTS
000015E4  4EB9 00002082            629  ASRcode10 JSR       ISASRL
000015EA  4E75                     630            RTS
000015EC  4EB9 0000205A            631  ASRcode11 JSR       ISASRW
000015F2  4E75                     632            RTS
000015F4                           633  
000015F4                           634  someASL:
000015F4  41F9 00001612            635          LEA         tableSomeASL, A0 ; Index into the table
000015FA  4280                     636          CLR.L       D0              ; Zero it
000015FC  3016                     637          MOVE.W      (A6),D0     ; We'll play with it here
000015FE  123C 0008                638          MOVE.B      #8,D1           ; Shift 8 bits left
00001602  E360                     639          ASL.W       D1,D0
00001604  123C 000E                640          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001608  E268                     641          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000160A                           642                                      ; and the rest are zeroed out)
0000160A  C0FC 0006                643          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000160E  4EF0 0000                644          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001612                           645  
00001612                           646  tableSomeASL:
00001612  4EF9 0000162A            647          JMP         ASLcode00       *ASL.B
00001618  4EF9 00001632            648          JMP         ASLcode01       *ASL.W
0000161E  4EF9 0000163A            649          JMP         ASLcode10       *ASL.L
00001624  4EF9 00001642            650          JMP         ASLcode11       *ASL.W
0000162A                           651  
0000162A  4EB9 000020AA            652  ASLcode00 JSR       ISASLB
00001630  4E75                     653            RTS
00001632  4EB9 000020D2            654  ASLcode01 JSR       ISASLW
00001638  4E75                     655            RTS
0000163A  4EB9 000020EE            656  ASLcode10 JSR       ISASLL
00001640  4E75                     657            RTS
00001642  4EB9 000020D2            658  ASLcode11 JSR       ISASLW
00001648  4E75                     659            RTS
0000164A                           660  
0000164A                           661  someLSR:
0000164A  41F9 00001668            662          LEA         tableSomeLSR, A0 ; Index into the table
00001650  4280                     663          CLR.L       D0              ; Zero it
00001652  3016                     664          MOVE.W      (A6),D0     ; We'll play with it here
00001654  123C 0008                665          MOVE.B      #8,D1           ; Shift 8 bits left
00001658  E360                     666          ASL.W       D1,D0
0000165A  123C 000E                667          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000165E  E268                     668          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001660                           669                                      ; and the rest are zeroed out)
00001660  C0FC 0006                670          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001664  4EF0 0000                671          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001668                           672  
00001668                           673  tableSomeLSR:
00001668  4EF9 00001680            674          JMP         LSRcode00       *LSR.B
0000166E  4EF9 00001688            675          JMP         LSRcode01       *LSR.W
00001674  4EF9 00001690            676          JMP         LSRcode10       *LSR.L
0000167A  4EF9 00001698            677          JMP         LSRcode11       *LSR.W
00001680  4EB9 00002116            678  LSRcode00 JSR       ISLSRB
00001686  4E75                     679            RTS
00001688  4EB9 0000213E            680  LSRcode01 JSR       ISLSRW
0000168E  4E75                     681            RTS
00001690  4EB9 00002166            682  LSRcode10 JSR       ISLSRL
00001696  4E75                     683            RTS
00001698  4EB9 0000213E            684  LSRcode11 JSR       ISLSRW
0000169E  4E75                     685            RTS
000016A0                           686  
000016A0                           687  someLSL:
000016A0  41F9 000016BE            688          LEA         tableSomeLSL, A0 ; Index into the table
000016A6  4280                     689          CLR.L       D0              ; Zero it
000016A8  3016                     690          MOVE.W      (A6),D0     ; We'll play with it here
000016AA  123C 0008                691          MOVE.B      #8,D1           ; Shift 8 bits left
000016AE  E360                     692          ASL.W       D1,D0
000016B0  123C 000E                693          MOVE.B      #14,D1          ; Shift 14 bits to the right
000016B4  E268                     694          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000016B6                           695                                      ; and the rest are zeroed out)
000016B6  C0FC 0006                696          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000016BA  4EF0 0000                697          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000016BE                           698  
000016BE                           699  tableSomeLSL:
000016BE  4EF9 000016D6            700          JMP         LSLcode00       *LSL.B
000016C4  4EF9 000016DE            701          JMP         LSLcode01       *LSL.W
000016CA  4EF9 000016E6            702          JMP         LSLcode10       *LSL.L
000016D0  4EF9 000016EE            703          JMP         LSLcode11       *LSL.W
000016D6                           704  
000016D6  4EB9 0000218E            705  LSLcode00 JSR       ISLSLB
000016DC  4E75                     706            RTS
000016DE  4EB9 000021AA            707  LSLcode01 JSR       ISLSLW
000016E4  4E75                     708            RTS
000016E6  4EB9 000021D2            709  LSLcode10 JSR       ISLSLL
000016EC  4E75                     710            RTS
000016EE  4EB9 000021AA            711  LSLcode11 JSR       ISLSLW
000016F4  4E75                     712            RTS
000016F6                           713  
000016F6                           714  someROL:
000016F6  41F9 00001714            715          LEA         tableSomeROL, A0 ; Index into the table
000016FC  4280                     716          CLR.L       D0              ; Zero it
000016FE  3016                     717          MOVE.W      (A6),D0     ; We'll play with it here
00001700  123C 0008                718          MOVE.B      #8,D1           ; Shift 8 bits left
00001704  E360                     719          ASL.W       D1,D0
00001706  123C 000E                720          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000170A  E268                     721          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000170C                           722                                      ; and the rest are zeroed out)
0000170C  C0FC 0006                723          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001710  4EF0 0000                724          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001714                           725  
00001714                           726  tableSomeROL:
00001714  4EF9 0000172C            727          JMP         ROLcode00       *ROL.B
0000171A  4EF9 00001734            728          JMP         ROLcode01       *ROL.W
00001720  4EF9 0000173C            729          JMP         ROLcode10       *ROL.L
00001726  4EF9 00001744            730          JMP         ROLcode11       *ROL.W
0000172C                           731  
0000172C  4EB9 00002266            732  ROLcode00 JSR       ISROLB
00001732  4E75                     733            RTS
00001734  4EB9 0000228E            734  ROLcode01 JSR       ISROLW
0000173A  4E75                     735            RTS
0000173C  4EB9 000022B6            736  ROLcode10 JSR       ISROLL
00001742  4E75                     737            RTS
00001744  4EB9 0000228E            738  ROLcode11 JSR       ISROLW
0000174A  4E75                     739            RTS
0000174C                           740  
0000174C                           741  
0000174C                           742  someROR:
0000174C  41F9 0000176A            743          LEA         tableSomeROR, A0 ; Index into the table
00001752  4280                     744          CLR.L       D0              ; Zero it
00001754  3016                     745          MOVE.W      (A6),D0     ; We'll play with it here
00001756  123C 0008                746          MOVE.B      #8,D1           ; Shift 8 bits left
0000175A  E360                     747          ASL.W       D1,D0
0000175C  123C 000E                748          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001760  E268                     749          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001762                           750                                      ; and the rest are zeroed out)
00001762  C0FC 0006                751          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001766  4EF0 0000                752          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000176A                           753  
0000176A                           754  tableSomeROR:
0000176A  4EF9 00001782            755          JMP         RORcode00       *ROR.B
00001770  4EF9 0000178A            756          JMP         RORcode01       *ROR.W
00001776  4EF9 00001792            757          JMP         RORcode10       *ROR.L
0000177C  4EF9 0000179A            758          JMP         RORcode11       *ROR.W
00001782                           759  
00001782  4EB9 000021FA            760  RORcode00 JSR       ISRORB
00001788  4E75                     761            RTS
0000178A  4EB9 00002222            762  RORcode01 JSR       ISRORW
00001790  4E75                     763            RTS
00001792  4EB9 0000223E            764  RORcode10 JSR       ISRORL
00001798  4E75                     765            RTS
0000179A  4EB9 00002222            766  RORcode11 JSR       ISRORW
000017A0  4E75                     767            RTS
000017A2                           768  
000017A2                           769  ROL_ROR:
000017A2  41F9 000017C0            770          LEA         tableROL_ROR, A0 ; Index into the table
000017A8  4280                     771          CLR.L       D0              ; Zero it
000017AA  3016                     772          MOVE.W      (A6),D0     ; We'll play with it here
000017AC  123C 0007                773          MOVE.B      #7,D1           ; Shift 7 bits left
000017B0  E360                     774          ASL.W       D1,D0
000017B2  123C 000F                775          MOVE.B      #15,D1          ; Shift 15 bits to the right
000017B6  E268                     776          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000017B8                           777                                      ; and the rest are zeroed out)
000017B8  C0FC 0006                778          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000017BC  4EF0 0000                779          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000017C0                           780  
000017C0                           781  tableROL_ROR:
000017C0  4EF9 000017CC            782          JMP         ROL_RORcode0    ; ROR
000017C6  4EF9 000017D2            783          JMP         ROL_RORcode1    ; ROL
000017CC                           784  
000017CC  4EB8 174C                785  ROL_RORcode0 JSR    someROR
000017D0  4E75                     786               RTS
000017D2  4EB8 16F6                787  ROL_RORcode1 JSR    someROL
000017D6  4E75                     788               RTS
000017D8                           789  
000017D8                           790  LSL_LSR:
000017D8  41F9 000017F6            791          LEA         tableLSL_LSR, A0 ; Index into the table
000017DE  4280                     792          CLR.L       D0              ; Zero it
000017E0  3016                     793          MOVE.W      (A6),D0     ; We'll play with it here
000017E2  123C 0007                794          MOVE.B      #7,D1           ; Shift 7 bits left
000017E6  E360                     795          ASL.W       D1,D0
000017E8  123C 000F                796          MOVE.B      #15,D1          ; Shift 15 bits to the right
000017EC  E268                     797          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000017EE                           798                                      ; and the rest are zeroed out)
000017EE  C0FC 0006                799          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000017F2  4EF0 0000                800          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000017F6                           801  
000017F6                           802  tableLSL_LSR:
000017F6  4EF9 00001802            803          JMP         LSL_LSRcode0    ; LSR
000017FC  4EF9 00001808            804          JMP         LSL_LSRcode1    ; LSL
00001802                           805  
00001802  4EB8 164A                806  LSL_LSRcode0 JSR    someLSR
00001806  4E75                     807               RTS
00001808  4EB8 16A0                808  LSL_LSRcode1 JSR    someLSL
0000180C  4E75                     809               RTS
0000180E                           810  
0000180E                           811  ASL_ASR:
0000180E  41F9 0000182C            812          LEA         tableASL_ASR, A0 ; Index into the table
00001814  4280                     813          CLR.L       D0              ; Zero it
00001816  3016                     814          MOVE.W      (A6),D0     ; We'll play with it here
00001818  123C 0007                815          MOVE.B      #7,D1           ; Shift 7 bits left
0000181C  E360                     816          ASL.W       D1,D0
0000181E  123C 000F                817          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001822  E268                     818          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001824                           819                                      ; and the rest are zeroed out)
00001824  C0FC 0006                820          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001828  4EF0 0000                821          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000182C                           822  
0000182C                           823  tableASL_ASR:
0000182C  4EF9 00001838            824          JMP         ASL_ASRcode0    ; ASR
00001832  4EF9 0000183E            825          JMP         ASL_ASRcode1    ; ASL
00001838                           826  
00001838  4EB8 159E                827  ASL_ASRcode0 JSR    someASR
0000183C  4E75                     828               RTS
0000183E  4EB8 15F4                829  ASL_ASRcode1 JSR    someASL
00001842  4E75                     830               RTS
00001844                           831  
00001844                           832  ROd_LSd_ASd:
00001844  41F9 00001862            833          LEA         tableROd_LSd_ASd, A0 ; Index into the table
0000184A  4280                     834          CLR.L       D0              ; Zero it
0000184C  3016                     835          MOVE.W      (A6),D0     ; We'll play with it here
0000184E  123C 000B                836          MOVE.B      #11,D1          ; Shift 11 bits left
00001852  E360                     837          ASL.W       D1,D0
00001854  123C 000F                838          MOVE.B      #15,D1          ; Shift 12 bits to the right
00001858  E268                     839          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000185A                           840                                      ; and the rest are zeroed out)
0000185A  C0FC 0006                841          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000185E  4EF0 0000                842          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001862                           843  
00001862                           844  tableROd_LSd_ASd:
00001862  4EF9 0000187A            845          JMP         ROd_LSd_ASdcode00 ; ASL_ASR
00001868  4EF9 00001880            846          JMP         ROd_LSd_ASdcode01 ; LSL_LSR
0000186E  4EF9 00001886            847          JMP         ROd_LSd_ASdcode10
00001874  4EF9 0000188E            848          JMP         ROd_LSd_ASdcode11 ; ROL_ROR
0000187A                           849  
0000187A  4EB8 180E                850  ROd_LSd_ASdcode00 JSR ASL_ASR
0000187E  4E75                     851                    RTS
00001880  4EB8 17D8                852  ROd_LSd_ASdcode01 JSR LSL_LSR
00001884  4E75                     853                    RTS
00001886  4EB9 00001F0A            854  ROd_LSd_ASdcode10 JSR    OPCODE_INVALID              ;INVALID
0000188C  4E75                     855                    RTS
0000188E  4EB8 17A2                856  ROd_LSd_ASdcode11 JSR ROL_ROR
00001892  4E75                     857                    RTS
00001894                           858  
00001894                           859  AND_BorAND_WorAND_LorMULS_W:
00001894  41F9 000018B2            860          LEA         tableAND_BorAND_WorAND_LorMULS_W, A0            ; Index into the table
0000189A  4280                     861          CLR.L       D0                  ; Zero it
0000189C  3016                     862          MOVE.W      (A6),D0         ; We'll play with it here
0000189E  123C 0007                863          MOVE.B      #7,D1           ; Shift 7 bits left
000018A2  E360                     864          ASL.W       D1,D0
000018A4  123C 000D                865          MOVE.B      #13,D1              ; Shift 13 bits to the right
000018A8  E268                     866          LSR.W       D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
000018AA                           867                                  ; and the rest are zeroed out)
000018AA  C0FC 0006                868          MULU        #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
000018AE  4EF0 0000                869          JMP         0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
000018B2                           870  
000018B2                           871  tableAND_BorAND_WorAND_LorMULS_W:
000018B2  4EF9 000018E2            872          JMP         ANDcode000   ; AND.B
000018B8  4EF9 000018EA            873          JMP         ANDcode001   ; AND.W
000018BE  4EF9 000018F2            874          JMP         ANDcode010   ; AND.L
000018C4  4EF9 000018FA            875          JMP         ANDcode011
000018CA  4EF9 00001902            876          JMP         ANDcode100   ; AND.B
000018D0  4EF9 0000190A            877          JMP         ANDcode101   ; AND.W
000018D6  4EF9 00001912            878          JMP         ANDcode110   ; AND.L
000018DC  4EF9 0000191A            879          JMP         ANDcode111   ; MULS.W
000018E2                           880  
000018E2  4EB9 00002306            881  ANDcode000 JSR      ISANDB
000018E8  4E75                     882             RTS
000018EA  4EB9 0000232E            883  ANDcode001 JSR      ISANDW
000018F0  4E75                     884             RTS
000018F2  4EB9 00002356            885  ANDcode010 JSR      ISANDL
000018F8  4E75                     886             RTS
000018FA  4EB9 00001F0A            887  ANDcode011 JSR    OPCODE_INVALID              ;INVALID
00001900  4E75                     888             RTS
00001902  4EB9 00002306            889  ANDcode100 JSR      ISANDB
00001908  4E75                     890             RTS
0000190A  4EB9 0000232E            891  ANDcode101 JSR      ISANDW
00001910  4E75                     892             RTS
00001912  4EB9 00002356            893  ANDcode110 JSR      ISANDL
00001918  4E75                     894             RTS
0000191A  4EB9 000022DE            895  ANDcode111 JSR      ISMULSW
00001920  4E75                     896             RTS
00001922                           897  
00001922                           898  ADD_BorADD_WorADD_L:
00001922  41F9 00001940            899          LEA         tableADD_BorADD_WorADD_L, A0 ; Index into the table
00001928  4280                     900          CLR.L       D0              ; Zero it
0000192A  3016                     901          MOVE.W      (A6),D0     ; We'll play with it here
0000192C  123C 0007                902          MOVE.B      #7,D1           ; Shift 7 bits left
00001930  E360                     903          ASL.W       D1,D0
00001932  123C 000D                904          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001936  E268                     905          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001938                           906                                      ; and the rest are zeroed out)
00001938  C0FC 0006                907          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000193C  4EF0 0000                908          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001940                           909  
00001940                           910  tableADD_BorADD_WorADD_L:
00001940  4EF9 00001970            911          JMP         ADDcode000      *ADD.B
00001946  4EF9 00001978            912          JMP         ADDcode001      *ADD.W
0000194C  4EF9 00001980            913          JMP         ADDcode010      *ADD.L
00001952  4EF9 00001988            914          JMP         ADDcode011      *ADDA.W
00001958  4EF9 00001990            915          JMP         ADDcode100      *ADD.B
0000195E  4EF9 00001998            916          JMP         ADDcode101      *ADD.W
00001964  4EF9 000019A0            917          JMP         ADDcode110      *ADD.L
0000196A  4EF9 000019A8            918          JMP         ADDcode111      *ADDA.L
00001970                           919  
00001970  4EB9 000023CE            920  ADDcode000 JSR      ISADDB
00001976  4E75                     921             RTS
00001978  4EB9 000023F6            922  ADDcode001 JSR      ISADDW
0000197E  4E75                     923             RTS
00001980  4EB9 0000241E            924  ADDcode010 JSR      ISADDL
00001986  4E75                     925             RTS
00001988  4EB9 0000237E            926  ADDcode011 JSR      ISADDAW
0000198E  4E75                     927             RTS
00001990  4EB9 000023CE            928  ADDcode100 JSR      ISADDB
00001996  4E75                     929             RTS
00001998  4EB9 000023F6            930  ADDcode101 JSR      ISADDW
0000199E  4E75                     931             RTS
000019A0  4EB9 0000241E            932  ADDcode110 JSR      ISADDL
000019A6  4E75                     933             RTS
000019A8  4EB9 000023A6            934  ADDcode111 JSR      ISADDAL
000019AE  4E75                     935             RTS
000019B0                           936  
000019B0                           937  SUB_BorSUB_WorSUB_L:
000019B0  41F9 000019CE            938          LEA         tableSUB_BorSUB_WorSUB_L, A0 ; Index into the table
000019B6  4280                     939          CLR.L       D0              ; Zero it
000019B8  3016                     940          MOVE.W      (A6),D0     ; We'll play with it here
000019BA  123C 0007                941          MOVE.B      #7,D1           ; Shift 7 bits left
000019BE  E360                     942          ASL.W       D1,D0
000019C0  123C 000D                943          MOVE.B      #13,D1          ; Shift 13 bits to the right
000019C4  E268                     944          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000019C6                           945                                      ; and the rest are zeroed out)
000019C6  C0FC 0006                946          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000019CA  4EF0 0000                947          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000019CE                           948  
000019CE                           949  tableSUB_BorSUB_WorSUB_L:
000019CE  4EF9 000019FE            950          JMP         SUBcode000      *SUB.B
000019D4  4EF9 00001A06            951          JMP         SUBcode001      *SUB.W
000019DA  4EF9 00001A0E            952          JMP         SUBcode010      *SUB.L
000019E0  4EF9 00001A16            953          JMP         SUBcode011
000019E6  4EF9 00001A1E            954          JMP         SUBcode100      *SUB.B
000019EC  4EF9 00001A26            955          JMP         SUBcode101      *SUB.W
000019F2  4EF9 00001A2E            956          JMP         SUBcode110      *SUB.L
000019F8  4EF9 00001A36            957          JMP         SUBcode111      ; INVALID
000019FE                           958  
000019FE  4EB9 00002446            959  SUBcode000 JSR      ISSUBB
00001A04  4E75                     960             RTS
00001A06  4EB9 0000246E            961  SUBcode001 JSR      ISSUBW
00001A0C  4E75                     962             RTS
00001A0E  4EB9 00002496            963  SUBcode010 JSR      ISSUBL
00001A14  4E75                     964             RTS
00001A16  4EB9 00001F0A            965  SUBcode011 JSR      OPCODE_INVALID              ;INVALID
00001A1C  4E75                     966             RTS
00001A1E  4EB9 00002446            967  SUBcode100 JSR      ISSUBB
00001A24  4E75                     968             RTS
00001A26  4EB9 0000246E            969  SUBcode101 JSR      ISSUBW
00001A2C  4E75                     970             RTS
00001A2E  4EB9 00002496            971  SUBcode110 JSR      ISSUBL
00001A34  4E75                     972             RTS
00001A36  4EB9 00001F0A            973  SUBcode111 JSR      OPCODE_INVALID              ;INVALID
00001A3C  4E75                     974             RTS
00001A3E                           975  
00001A3E                           976  CMP_BorCMP_WorCMP_L:
00001A3E  41F9 00001A5C            977          LEA         tableCMP_BorCMP_WorCMP_L, A0 ; Index into the table
00001A44  4280                     978          CLR.L       D0              ; Zero it
00001A46  3016                     979          MOVE.W      (A6),D0     ; We'll play with it here
00001A48  123C 0008                980          MOVE.B      #8,D1           ; Shift 8 bits left
00001A4C  E360                     981          ASL.W       D1,D0
00001A4E  123C 000E                982          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001A52  E268                     983          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001A54                           984                                      ; and the rest are zeroed out)
00001A54  C0FC 0006                985          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001A58  4EF0 0000                986          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A5C                           987  
00001A5C                           988  tableCMP_BorCMP_WorCMP_L:
00001A5C  4EF9 00001A74            989          JMP         CMPcode00       *CMP.B
00001A62  4EF9 00001A7C            990          JMP         CMPcode01       *CMP.W
00001A68  4EF9 00001A84            991          JMP         CMPcode10       *CMP.L
00001A6E  4EF9 00001A8C            992          JMP         CMPcode11       ; INVALID
00001A74                           993  
00001A74  4EB9 000024BE            994  CMPcode00   JSR      ISCMPB
00001A7A  4E75                     995              RTS
00001A7C  4EB9 000024E6            996  CMPcode01   JSR      ISCMPW
00001A82  4E75                     997              RTS
00001A84  4EB9 0000250E            998  CMPcode10   JSR      ISCMPL
00001A8A  4E75                     999              RTS
00001A8C  4EB9 00001F0A           1000  CMPcode11   JSR    OPCODE_INVALID              ;INVALID
00001A92  4E75                    1001              RTS
00001A94                          1002  
00001A94                          1003  ADDQ_BorADDQ_WorADDQ_L:
00001A94  41F9 00001AB2           1004          LEA         tableADDQ_BorADDQ_WorADDQ_L, A0 ; Index into the table
00001A9A  4280                    1005          CLR.L       D0              ; Zero it
00001A9C  3016                    1006          MOVE.W      (A6),D0     ; We'll play with it here
00001A9E  123C 0008               1007          MOVE.B      #8,D1           ; Shift 8 bits left
00001AA2  E360                    1008          ASL.W       D1,D0
00001AA4  123C 000E               1009          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001AA8  E268                    1010          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001AAA                          1011                                      ; and the rest are zeroed out)
00001AAA  C0FC 0006               1012          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001AAE  4EF0 0000               1013          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001AB2                          1014  
00001AB2                          1015  tableADDQ_BorADDQ_WorADDQ_L:
00001AB2  4EF9 00001ACA           1016          JMP         ADDQcode00      *ADDQ.B
00001AB8  4EF9 00001AD2           1017          JMP         ADDQcode01      *ADDQ.W
00001ABE  4EF9 00001ADA           1018          JMP         ADDQcode10      *ADDQ.L
00001AC4  4EF9 00001AE2           1019          JMP         ADDQcode11      ; INVALID
00001ACA                          1020  
00001ACA  4EB9 00002536           1021  ADDQcode00 JSR      ISADDQB
00001AD0  4E75                    1022             RTS
00001AD2  4EB9 0000255E           1023  ADDQcode01 JSR      ISADDQW
00001AD8  4E75                    1024             RTS
00001ADA  4EB9 00002586           1025  ADDQcode10 JSR      ISADDQL
00001AE0  4E75                    1026             RTS
00001AE2  4EB9 00001F0A           1027  ADDQcode11   JSR    OPCODE_INVALID              ;INVALID
00001AE8  4E75                    1028              RTS
00001AEA                          1029  
00001AEA                          1030  someCLR:
00001AEA  41F9 00001B08           1031          LEA         tableSomeCLR, A0 ; Index into the table
00001AF0  4280                    1032          CLR.L       D0              ; Zero it
00001AF2  3016                    1033          MOVE.W      (A6),D0     ; We'll play with it here
00001AF4  123C 0008               1034          MOVE.B      #8,D1           ; Shift 8 bits left
00001AF8  E360                    1035          ASL.W       D1,D0
00001AFA  123C 000E               1036          MOVE.B      #14,D1       ; Shift 12 bits to the right
00001AFE  E268                    1037          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B00                          1038                                      ; and the rest are zeroed out)
00001B00  C0FC 0006               1039          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B04  4EF0 0000               1040          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B08                          1041  
00001B08                          1042  tableSomeCLR:
00001B08  4EF9 00001B20           1043          JMP         CLRcode00       *CLR.B
00001B0E  4EF9 00001B28           1044          JMP         CLRcode01       *CLR.W
00001B14  4EF9 00001B30           1045          JMP         CLRcode10       *CLR.L
00001B1A  4EF9 00001B38           1046          JMP         CLRcode11       ; INVALID
00001B20                          1047  
00001B20  4EB9 000025CA           1048  CLRcode00 JSR       ISCLRB
00001B26  4E75                    1049            RTS
00001B28  4EB9 000025F2           1050  CLRcode01 JSR       ISCLRW
00001B2E  4E75                    1051            RTS
00001B30  4EB9 0000261A           1052  CLRcode10 JSR       ISCLRL
00001B36  4E75                    1053            RTS
00001B38  4EB9 00001F0A           1054  CLRcode11 JSR    OPCODE_INVALID              ;INVALID
00001B3E  4E75                    1055            RTS
00001B40                          1056  
00001B40                          1057  NOPorCLRorRTSorJSR:
00001B40  41F9 00001B72           1058          LEA         tableNOPorCLRorRTSorJSR, A0 ; Index into the table
00001B46  4280                    1059          CLR.L       D0              ; Zero it
00001B48  3016                    1060          MOVE.W      (A6),D0     ; We'll play with it here
00001B4A                          1061  
00001B4A  323C 4E71               1062          MOVE.W      #%0100111001110001, D1 ; 0100111001110001 = NOP
00001B4E  B240                    1063          CMP.W       D0, D1
00001B50  6700 0088               1064          BEQ         NOPcommand
00001B54                          1065  
00001B54  323C 4E75               1066          MOVE.W      #%0100111001110101, D1 ; 0100111001110101 = RTS
00001B58  B240                    1067          CMP.W       D0, D1
00001B5A  6700 0076               1068          BEQ         RTScommand
00001B5E                          1069  
00001B5E  123C 0004               1070          MOVE.B      #4,D1           ; Shift 4 bits left
00001B62  E360                    1071          ASL.W       D1,D0
00001B64  123C 000C               1072          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001B68  E268                    1073          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B6A                          1074                                      ; and the rest are zeroed out)
00001B6A  C0FC 0006               1075          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B6E  4EF0 0000               1076          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B72                          1077  
00001B72                          1078  tableNOPorCLRorRTSorJSR:
00001B72  4EF9 00001BE2           1079          JMP         JSRorCLRcode0000
00001B78  4EF9 00001BEA           1080          JMP         JSRorCLRcode0001
00001B7E  4EF9 00001BF2           1081          JMP         JSRorCLRcode0010
00001B84  4EF9 00001BF8           1082          JMP         JSRorCLRcode0011
00001B8A  4EF9 00001C00           1083          JMP         JSRorCLRcode0100
00001B90  4EF9 00001C08           1084          JMP         JSRorCLRcode0101
00001B96  4EF9 00001C10           1085          JMP         JSRorCLRcode0110
00001B9C  4EF9 00001C18           1086          JMP         JSRorCLRcode0111
00001BA2  4EF9 00001C20           1087          JMP         JSRorCLRcode1000
00001BA8  4EF9 00001C28           1088          JMP         JSRorCLRcode1001
00001BAE  4EF9 00001C30           1089          JMP         JSRorCLRcode1010
00001BB4  4EF9 00001C38           1090          JMP         JSRorCLRcode1011
00001BBA  4EF9 00001C40           1091          JMP         JSRorCLRcode1100
00001BC0  4EF9 00001C48           1092          JMP         JSRorCLRcode1101
00001BC6  4EF9 00001C50           1093          JMP         JSRorCLRcode1110
00001BCC  4EF9 00001C58           1094          JMP         JSRorCLRcode1111
00001BD2                          1095  
00001BD2  4EB9 000026E2           1096  RTScommand JSR      ISRTS
00001BD8  4E75                    1097             RTS
00001BDA  4EB9 00002722           1098  NOPcommand JSR      ISNOP
00001BE0  4E75                    1099             RTS
00001BE2  4EB9 00001F0A           1100  JSRorCLRcode0000 JSR    OPCODE_INVALID              ;INVALID
00001BE8  4E75                    1101                   RTS
00001BEA  4EB9 00001F0A           1102  JSRorCLRcode0001 JSR    OPCODE_INVALID              ;INVALID
00001BF0  4E75                    1103                   RTS
00001BF2  4EB8 1AEA               1104  JSRorCLRcode0010 JSR someCLR
00001BF6  4E75                    1105                   RTS
00001BF8  4EB9 00001F0A           1106  JSRorCLRcode0011 JSR    OPCODE_INVALID              ;INVALID
00001BFE  4E75                    1107                   RTS
00001C00  4EB9 00001F0A           1108  JSRorCLRcode0100 JSR    OPCODE_INVALID              ;INVALID
00001C06  4E75                    1109                   RTS
00001C08  4EB9 00001F0A           1110  JSRorCLRcode0101 JSR    OPCODE_INVALID              ;INVALID
00001C0E  4E75                    1111                   RTS
00001C10  4EB9 00001F0A           1112  JSRorCLRcode0110 JSR    OPCODE_INVALID              ;INVALID
00001C16  4E75                    1113                   RTS
00001C18  4EB9 00001F0A           1114  JSRorCLRcode0111 JSR    OPCODE_INVALID              ;INVALID
00001C1E  4E75                    1115                   RTS
00001C20  4EB9 00001F0A           1116  JSRorCLRcode1000 JSR    OPCODE_INVALID              ;INVALID
00001C26  4E75                    1117                   RTS
00001C28  4EB9 00001F0A           1118  JSRorCLRcode1001 JSR    OPCODE_INVALID              ;INVALID
00001C2E  4E75                    1119                   RTS
00001C30  4EB9 00001F0A           1120  JSRorCLRcode1010 JSR    OPCODE_INVALID              ;INVALID
00001C36  4E75                    1121                   RTS
00001C38  4EB9 00001F0A           1122  JSRorCLRcode1011 JSR    OPCODE_INVALID              ;INVALID
00001C3E  4E75                    1123                   RTS
00001C40  4EB9 00001F0A           1124  JSRorCLRcode1100 JSR    OPCODE_INVALID              ;INVALID
00001C46  4E75                    1125                   RTS
00001C48  4EB9 00001F0A           1126  JSRorCLRcode1101 JSR    OPCODE_INVALID              ;INVALID
00001C4E  4E75                    1127                   RTS
00001C50  4EB9 000026BA           1128  JSRorCLRcode1110 JSR ISJSR
00001C56  4E75                    1129                   RTS
00001C58  4EB9 00001F0A           1130  JSRorCLRcode1111 JSR    OPCODE_INVALID              ;INVALID
00001C5E  4E75                    1131                   RTS
00001C60                          1132  
00001C60                          1133  someMOVEM:
00001C60  41F9 00001C7E           1134          LEA         tableSomeMOVEM, A0 ; Index into the table
00001C66  4280                    1135          CLR.L       D0              ; Zero it
00001C68  3016                    1136          MOVE.W      (A6),D0     ; We'll play with it here
00001C6A  123C 0009               1137          MOVE.B      #9,D1           ; Shift 9 bits left
00001C6E  E360                    1138          ASL.W       D1,D0
00001C70  123C 000F               1139          MOVE.B      #15,D1       ; Shift 12 bits to the right
00001C74  E268                    1140          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001C76                          1141                                      ; and the rest are zeroed out)
00001C76  C0FC 0006               1142          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001C7A  4EF0 0000               1143          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001C7E                          1144  
00001C7E                          1145  tableSomeMOVEM:
00001C7E  4EF9 00001C8A           1146          JMP         MOVEMcode0      ; MOVEM.W
00001C84  4EF9 00001C92           1147          JMP         MOVEMcode1      ; MOVEM.L
00001C8A                          1148  
00001C8A  4EB9 0000266A           1149  MOVEMcode0 JSR      ISMOVEMW
00001C90  4E75                    1150             RTS
00001C92  4EB9 00002642           1151  MOVEMcode1 JSR      ISMOVEML
00001C98  4E75                    1152             RTS
00001C9A                          1153  
00001C9A                          1154  NOP_MOVEM_LEA_JSR_CLR_RTS:
00001C9A  41F9 00001CBE           1155          LEA         tableNOP_MOVEM_LEA_JSR_CLR_RTS, A0 ; Index into the table
00001CA0  4280                    1156          CLR.L       D0              ; Zero it
00001CA2  3016                    1157          MOVE.W      (A6),D0     ; We'll play with it here
00001CA4  123C 0007               1158          MOVE.B      #7,D1           ; Shift 7 bits right
00001CA8  E260                    1159          ASR.W       D1,D0
00001CAA  123C 000D               1160          MOVE.B      #13,D1          ; Shift 13 bits left
00001CAE  E360                    1161          ASL.W       D1,D0
00001CB0  123C 000C               1162          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001CB4  E268                    1163          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001CB6                          1164                                      ; and the rest are zeroed out)
00001CB6  C0FC 0006               1165          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001CBA  4EF0 0000               1166          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001CBE                          1167  
00001CBE                          1168  tableNOP_MOVEM_LEA_JSR_CLR_RTS:
00001CBE  4EF9 00001D1E           1169          JMP         LOTScode0000
00001CC4  4EF9 00001D26           1170          JMP         LOTScode0001
00001CCA  4EF9 00001D2E           1171          JMP         LOTScode0010
00001CD0  4EF9 00001D34           1172          JMP         LOTScode0011
00001CD6  4EF9 00001D3C           1173          JMP         LOTScode0100
00001CDC  4EF9 00001D44           1174          JMP         LOTScode0101
00001CE2  4EF9 00001D4C           1175          JMP         LOTScode0110
00001CE8  4EF9 00001D54           1176          JMP         LOTScode0111
00001CEE  4EF9 00001D5C           1177          JMP         LOTScode1000
00001CF4  4EF9 00001D62           1178          JMP         LOTScode1001
00001CFA  4EF9 00001D6A           1179          JMP         LOTScode1010
00001D00  4EF9 00001D70           1180          JMP         LOTScode1011
00001D06  4EF9 00001D78           1181          JMP         LOTScode1100
00001D0C  4EF9 00001D80           1182          JMP         LOTScode1101
00001D12  4EF9 00001D88           1183          JMP         LOTScode1110
00001D18  4EF9 00001D90           1184          JMP         LOTScode1111
00001D1E                          1185  
00001D1E  4EB9 00001F0A           1186  LOTScode0000 JSR    OPCODE_INVALID              ; MULS.L and DIVU.L are not supported for 68000 Disassember
00001D24  4E75                    1187               RTS
00001D26  4EB9 00001F0A           1188  LOTScode0001 JSR    OPCODE_INVALID              ;INVALID
00001D2C  4E75                    1189               RTS
00001D2E  4EB8 1C60               1190  LOTScode0010 JSR    someMOVEM
00001D32  4E75                    1191               RTS
00001D34  4EB9 00001F0A           1192  LOTScode0011 JSR    OPCODE_INVALID              ;INVALID
00001D3A  4E75                    1193               RTS
00001D3C  4EB9 00001F0A           1194  LOTScode0100 JSR    OPCODE_INVALID              ;INVALID
00001D42  4E75                    1195               RTS
00001D44  4EB9 00001F0A           1196  LOTScode0101 JSR    OPCODE_INVALID              ;INVALID
00001D4A  4E75                    1197               RTS
00001D4C  4EB9 00002692           1198  LOTScode0110 JSR    ISLEA
00001D52  4E75                    1199               RTS
00001D54  4EB9 00001F0A           1200  LOTScode0111 JSR    OPCODE_INVALID              ;INVALID
00001D5A  4E75                    1201               RTS
00001D5C  4EB8 1B40               1202  LOTScode1000 JSR    NOPorCLRorRTSorJSR
00001D60  4E75                    1203               RTS
00001D62  4EB9 00001F0A           1204  LOTScode1001 JSR    OPCODE_INVALID              ;INVALID
00001D68  4E75                    1205               RTS
00001D6A  4EB8 1B40               1206  LOTScode1010 JSR    NOPorCLRorRTSorJSR
00001D6E  4E75                    1207               RTS
00001D70  4EB9 00001F0A           1208  LOTScode1011 JSR    OPCODE_INVALID              ;INVALID
00001D76  4E75                    1209               RTS
00001D78  4EB9 00001F0A           1210  LOTScode1100 JSR    OPCODE_INVALID              ;INVALID
00001D7E  4E75                    1211               RTS
00001D80  4EB9 00001F0A           1212  LOTScode1101 JSR    OPCODE_INVALID              ;INVALID
00001D86  4E75                    1213               RTS
00001D88  4EB9 00002692           1214  LOTScode1110 JSR    ISLEA
00001D8E  4E75                    1215               RTS
00001D90  4EB9 00001F0A           1216  LOTScode1111 JSR    OPCODE_INVALID              ;INVALID
00001D96  4E75                    1217               RTS
00001D98                          1218  
00001D98                          1219  ADDI_BorADDI_WorADDI_L:
00001D98  41F9 00001DB6           1220          LEA         tableADDI_BorADDI_WorADDI_L,A0 ; Index into the table
00001D9E  4280                    1221          CLR.L       D0              ; Zero it
00001DA0  3016                    1222          MOVE.W      (A6),D0     ; We'll play with it here
00001DA2  123C 0007               1223          MOVE.B      #7,D1           ; Shift 7 bits left
00001DA6  E360                    1224          ASL.W       D1,D0
00001DA8  123C 000D               1225          MOVE.B      #13,D1          ; Shift 13 bits right
00001DAC  E260                    1226          ASR.W       D1,D0
00001DAE  C0FC 0006               1227          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001DB2  4EF0 0000               1228          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001DB6                          1229  
00001DB6                          1230  tableADDI_BorADDI_WorADDI_L:
00001DB6  4EF9 00001DCE           1231          JMP         ADDIBcode00
00001DBC  4EF9 00001DD6           1232          JMP         ADDIWcode01
00001DC2  4EF9 00001DDE           1233          JMP         ADDILcode10
00001DC8  4EF9 00001DE6           1234          JMP         ADDILcode11
00001DCE                          1235  
00001DCE  4EB9 00002852           1236  ADDIBcode00 JSR     ISADDIB
00001DD4  4E75                    1237              RTS
00001DD6  4EB9 00002802           1238  ADDIWcode01 JSR     ISADDIW
00001DDC  4E75                    1239              RTS
00001DDE  4EB9 0000282A           1240  ADDILcode10 JSR     ISADDIL
00001DE4  4E75                    1241              RTS
00001DE6  4EB9 00001F0A           1242  ADDILcode11 JSR    OPCODE_INVALID              ;INVALID
00001DEC  4E75                    1243              RTS
00001DEE                          1244  
00001DEE                          1245  MOVEA_LorMOVE_L:
00001DEE  41F9 00001E0C           1246          LEA         tableMOVEA_LorMOVE_L,A0 ; Index into the table
00001DF4  4280                    1247          CLR.L       D0              ; Zero it
00001DF6  3016                    1248          MOVE.W      (A6),D0         ; We'll play with it here
00001DF8  123C 0007               1249          MOVE.B      #7,D1           ; Shift 7 bits left
00001DFC  E360                    1250          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
00001DFE  123C 000D               1251          MOVE.B      #13,D1          ; Shift 13 bits right
00001E02  E260                    1252          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
00001E04  C0FC 0006               1253          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001E08  4EF0 0000               1254          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001E0C                          1255  
00001E0C                          1256  tableMOVEA_LorMOVE_L:
00001E0C  4EF9 00001E3C           1257          JMP         MOVEcode000
00001E12  4EF9 00001E44           1258          JMP         MOVEAcode001
00001E18  4EF9 00001E4C           1259          JMP         MOVEcode010
00001E1E  4EF9 00001E54           1260          JMP         MOVEcode011
00001E24  4EF9 00001E5C           1261          JMP         MOVEcode100
00001E2A  4EF9 00001E64           1262          JMP         MOVEcode101
00001E30  4EF9 00001E6C           1263          JMP         MOVEcode110
00001E36  4EF9 00001E74           1264          JMP         MOVEcode111
00001E3C                          1265  
00001E3C  4EB9 00002796           1266  MOVEcode000 JSR     ISMOVEL
00001E42  4E75                    1267              RTS
00001E44  4EB9 000027BE           1268  MOVEAcode001 JSR    ISMOVEAL
00001E4A  4E75                    1269               RTS
00001E4C  4EB9 00002796           1270  MOVEcode010 JSR     ISMOVEL
00001E52  4E75                    1271              RTS
00001E54  4EB9 00002796           1272  MOVEcode011 JSR     ISMOVEL
00001E5A  4E75                    1273              RTS
00001E5C  4EB9 00002796           1274  MOVEcode100 JSR     ISMOVEL
00001E62  4E75                    1275              RTS
00001E64  4EB9 00002796           1276  MOVEcode101 JSR     ISMOVEL
00001E6A  4E75                    1277              RTS
00001E6C  4EB9 00002796           1278  MOVEcode110 JSR     ISMOVEL
00001E72  4E75                    1279              RTS
00001E74  4EB9 00002796           1280  MOVEcode111 JSR     ISMOVEL
00001E7A  4E75                    1281              RTS
00001E7C                          1282  
00001E7C                          1283  MOVEA_WorMOVE_W:
00001E7C  41F9 00001E9A           1284          LEA         tableMOVEA_WorMOVE_W,A0 ; Index into the table
00001E82  4280                    1285          CLR.L       D0              ; Zero it
00001E84  3016                    1286          MOVE.W      (A6),D0     ; We'll play with it here
00001E86  123C 0007               1287          MOVE.B      #7,D1           ; Shift 7 bits left
00001E8A  E360                    1288          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
00001E8C  123C 000D               1289          MOVE.B      #13,D1          ; Shift 13 bits right
00001E90  E260                    1290          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
00001E92  C0FC 0006               1291          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001E96  4EF0 0000               1292          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001E9A                          1293  
00001E9A                          1294  tableMOVEA_WorMOVE_W:
00001E9A  4EF9 00001ECA           1295          JMP         MOVEWcode000
00001EA0  4EF9 00001ED2           1296          JMP         MOVEAWcode001
00001EA6  4EF9 00001EDA           1297          JMP         MOVEWcode010
00001EAC  4EF9 00001EE2           1298          JMP         MOVEWcode011
00001EB2  4EF9 00001EEA           1299          JMP         MOVEWcode100
00001EB8  4EF9 00001EF2           1300          JMP         MOVEWcode101
00001EBE  4EF9 00001EFA           1301          JMP         MOVEWcode110
00001EC4  4EF9 00001F02           1302          JMP         MOVEWcode111
00001ECA                          1303  
00001ECA  4EB9 00002746           1304  MOVEWcode000 JSR    ISMOVEW
00001ED0  4E75                    1305               RTS
00001ED2  4EB9 0000276E           1306  MOVEAWcode001 JSR   ISMOVEAW
00001ED8  4E75                    1307                RTS
00001EDA  4EB9 00002746           1308  MOVEWcode010 JSR    ISMOVEW
00001EE0  4E75                    1309               RTS
00001EE2  4EB9 00002746           1310  MOVEWcode011 JSR    ISMOVEW
00001EE8  4E75                    1311               RTS
00001EEA  4EB9 00002746           1312  MOVEWcode100 JSR    ISMOVEW
00001EF0  4E75                    1313               RTS
00001EF2  4EB9 00002746           1314  MOVEWcode101 JSR    ISMOVEW
00001EF8  4E75                    1315               RTS
00001EFA  4EB9 00002746           1316  MOVEWcode110 JSR    ISMOVEW
00001F00  4E75                    1317               RTS
00001F02  4EB9 00002746           1318  MOVEWcode111 JSR    ISMOVEW
00001F08  4E75                    1319               RTS
00001F0A                          1320  
00001F0A                          1321  ; TODO: adjust workflow to:
00001F0A                          1322  ;   1) save message address to buffer pointer
00001F0A  48E7 FFFE               1323  OPCODE_INVALID  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001F0E  4EB8 133C               1324              JSR     INVALID_DATA
00001F12  548E                    1325              ADDA.L      #$00000002, A6          ; Increment past current opcode word
00001F14  4CDF 7FFF               1326              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001F18  4E75                    1327              RTS
00001F1A                          1328  
00001F1A  48E7 FFFE               1329  ISBCC  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001F1E  49F9 00004764           1330              LEA    MESSAGEBCC, A4
00001F24  4EB9 000043EA           1331              JSR    WRITE2MEM
00001F2A  49F9 000045F6           1332              LEA    MESSAGESPACE, A4
00001F30  4EB9 000043EA           1333              JSR    WRITE2MEM
00001F36  4EB9 00003496           1334              JSR     EA_Bcc
00001F3C  4CDF 7FFF               1335              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001F40  4E75                    1336              RTS
00001F42  48E7 FFFE               1337  ISBGT  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001F46  49F9 00004768           1338              LEA MESSAGEBGT, A4
00001F4C  4EB9 000043EA           1339              JSR    WRITE2MEM
00001F52  49F9 000045F6           1340              LEA    MESSAGESPACE, A4
00001F58  4EB9 000043EA           1341              JSR    WRITE2MEM
00001F5E  4EB9 00003496           1342              JSR     EA_Bcc
00001F64  4CDF 7FFF               1343              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001F68  4E75                    1344              RTS
00001F6A                          1345  
00001F6A  48E7 FFFE               1346  ISBLE  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001F6E  49F9 0000476C           1347              LEA MESSAGEBLE, A4
00001F74  4EB9 000043EA           1348              JSR    WRITE2MEM
00001F7A  49F9 000045F6           1349              LEA    MESSAGESPACE, A4
00001F80  4EB9 000043EA           1350              JSR    WRITE2MEM
00001F86  4EB9 00003496           1351              JSR     EA_Bcc
00001F8C  4CDF 7FFF               1352              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001F90  4E75                    1353              RTS
00001F92                          1354  
00001F92  48E7 FFFE               1355  ISDIVUW     MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001F96  49F9 0000475D           1356              LEA MESSAGEDIVUW, A4
00001F9C  4EB9 000043EA           1357              JSR    WRITE2MEM
00001FA2  49F9 000045F6           1358              LEA    MESSAGESPACE, A4
00001FA8  4EB9 000043EA           1359              JSR    WRITE2MEM
00001FAE  4EB9 000036C8           1360              JSR     EA_DIVU_W
00001FB4  4CDF 7FFF               1361              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001FB8  4E75                    1362              RTS
00001FBA                          1363  
00001FBA  48E7 FFFE               1364  ISORB   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001FBE  49F9 0000474E           1365          LEA         MESSAGEORB, A4
00001FC4  4EB9 000043EA           1366          JSR    WRITE2MEM
00001FCA  49F9 000045F6           1367          LEA    MESSAGESPACE, A4
00001FD0  4EB9 000043EA           1368          JSR    WRITE2MEM
00001FD6  4EB9 00003EDC           1369          JSR         EA_OR
00001FDC  4CDF 7FFF               1370          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00001FE0  4E75                    1371          RTS
00001FE2                          1372  
00001FE2  48E7 FFFE               1373  ISORW   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001FE6  49F9 00004753           1374          LEA         MESSAGEORW, A4
00001FEC  4EB9 000043EA           1375          JSR    WRITE2MEM
00001FF2  49F9 000045F6           1376          LEA    MESSAGESPACE, A4
00001FF8  4EB9 000043EA           1377          JSR    WRITE2MEM
00001FFE  4EB9 00003EDC           1378          JSR         EA_OR
00002004  4CDF 7FFF               1379          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002008  4E75                    1380          RTS
0000200A                          1381  
0000200A  48E7 FFFE               1382  ISORL   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000200E  49F9 00004758           1383          LEA         MESSAGEORL, A4
00002014  4EB9 000043EA           1384          JSR    WRITE2MEM
0000201A  49F9 000045F6           1385          LEA    MESSAGESPACE, A4
00002020  4EB9 000043EA           1386          JSR    WRITE2MEM
00002026  4EB9 00003EDC           1387          JSR         EA_OR
0000202C  4CDF 7FFF               1388          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002030  4E75                    1389          RTS
00002032                          1390  
00002032  48E7 FFFE               1391  ISASRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002036  49F9 000046E2           1392          LEA         MESSAGEASRB, A4
0000203C  4EB9 000043EA           1393          JSR    WRITE2MEM
00002042  49F9 000045F6           1394          LEA    MESSAGESPACE, A4
00002048  4EB9 000043EA           1395          JSR    WRITE2MEM
0000204E  4EB9 00003366           1396          JSR         EA_ASd
00002054  4CDF 7FFF               1397          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002058  4E75                    1398          RTS
0000205A                          1399  
0000205A  48E7 FFFE               1400  ISASRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000205E  49F9 000046E8           1401          LEA         MESSAGEASRW, A4
00002064  4EB9 000043EA           1402          JSR    WRITE2MEM
0000206A  49F9 000045F6           1403          LEA    MESSAGESPACE, A4
00002070  4EB9 000043EA           1404          JSR    WRITE2MEM
00002076  4EB9 00003366           1405          JSR         EA_ASd
0000207C  4CDF 7FFF               1406          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002080  4E75                    1407          RTS
00002082                          1408  
00002082  48E7 FFFE               1409  ISASRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002086  49F9 000046EE           1410          LEA         MESSAGEASRL, A4
0000208C  4EB9 000043EA           1411          JSR    WRITE2MEM
00002092  49F9 000045F6           1412          LEA    MESSAGESPACE, A4
00002098  4EB9 000043EA           1413          JSR    WRITE2MEM
0000209E  4EB9 00003366           1414          JSR         EA_ASd
000020A4  4CDF 7FFF               1415          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000020A8  4E75                    1416          RTS
000020AA                          1417  
000020AA  48E7 FFFE               1418  ISASLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000020AE  49F9 000046F4           1419          LEA         MESSAGEASLB, A4
000020B4  4EB9 000043EA           1420          JSR    WRITE2MEM
000020BA  49F9 000045F6           1421          LEA    MESSAGESPACE, A4
000020C0  4EB9 000043EA           1422          JSR    WRITE2MEM
000020C6  4EB9 00003366           1423          JSR         EA_ASd
000020CC  4CDF 7FFF               1424          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000020D0  4E75                    1425          RTS
000020D2                          1426  
000020D2  48E7 FFFE               1427  ISASLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000020D6  43F9 000046FA           1428          LEA         MESSAGEASLW, A1
000020DC  103C 000E               1429          MOVE.B      #14, D0
000020E0  4E4F                    1430          TRAP        #15
000020E2  4EB9 00003366           1431          JSR         EA_ASd
000020E8  4CDF 7FFF               1432          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000020EC  4E75                    1433          RTS
000020EE                          1434  
000020EE  48E7 FFFE               1435  ISASLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000020F2  49F9 00004700           1436          LEA         MESSAGEASLL, A4
000020F8  4EB9 000043EA           1437          JSR    WRITE2MEM
000020FE  49F9 000045F6           1438          LEA    MESSAGESPACE, A4
00002104  4EB9 000043EA           1439          JSR    WRITE2MEM
0000210A  4EB9 00003366           1440          JSR         EA_ASd
00002110  4CDF 7FFF               1441          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002114  4E75                    1442          RTS
00002116                          1443  
00002116  48E7 FFFE               1444  ISLSRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000211A  49F9 0000472A           1445          LEA         MESSAGELSRB, A4
00002120  4EB9 000043EA           1446          JSR    WRITE2MEM
00002126  49F9 000045F6           1447          LEA    MESSAGESPACE, A4
0000212C  4EB9 000043EA           1448          JSR    WRITE2MEM
00002132  4EB9 0000395C           1449          JSR         EA_LSd
00002138  4CDF 7FFF               1450          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000213C  4E75                    1451          RTS
0000213E                          1452  
0000213E  48E7 FFFE               1453  ISLSRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002142  49F9 00004730           1454          LEA         MESSAGELSRW, A4
00002148  4EB9 000043EA           1455          JSR    WRITE2MEM
0000214E  49F9 000045F6           1456          LEA    MESSAGESPACE, A4
00002154  4EB9 000043EA           1457          JSR    WRITE2MEM
0000215A  4EB9 0000395C           1458          JSR         EA_LSd
00002160  4CDF 7FFF               1459          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002164  4E75                    1460          RTS
00002166                          1461  
00002166  48E7 FFFE               1462  ISLSRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000216A  49F9 00004736           1463          LEA         MESSAGELSRL, A4
00002170  4EB9 000043EA           1464          JSR    WRITE2MEM
00002176  49F9 000045F6           1465          LEA    MESSAGESPACE, A4
0000217C  4EB9 000043EA           1466          JSR    WRITE2MEM
00002182  4EB9 0000395C           1467          JSR         EA_LSd
00002188  4CDF 7FFF               1468          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000218C  4E75                    1469          RTS
0000218E                          1470  
0000218E  48E7 FFFE               1471  ISLSLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002192  43F9 0000473C           1472          LEA         MESSAGELSLB, A1
00002198  103C 000E               1473          MOVE.B      #14, D0
0000219C  4E4F                    1474          TRAP        #15
0000219E  4EB9 0000395C           1475          JSR         EA_LSd
000021A4  4CDF 7FFF               1476          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000021A8  4E75                    1477          RTS
000021AA                          1478  
000021AA  48E7 FFFE               1479  ISLSLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000021AE  49F9 00004742           1480          LEA         MESSAGELSLW, A4
000021B4  4EB9 000043EA           1481          JSR    WRITE2MEM
000021BA  49F9 000045F6           1482          LEA    MESSAGESPACE, A4
000021C0  4EB9 000043EA           1483          JSR    WRITE2MEM
000021C6  4EB9 0000395C           1484          JSR         EA_LSd
000021CC  4CDF 7FFF               1485          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000021D0  4E75                    1486          RTS
000021D2                          1487  
000021D2  48E7 FFFE               1488  ISLSLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000021D6  49F9 00004748           1489          LEA         MESSAGELSLL, A4
000021DC  4EB9 000043EA           1490          JSR    WRITE2MEM
000021E2  49F9 000045F6           1491          LEA    MESSAGESPACE, A4
000021E8  4EB9 000043EA           1492          JSR    WRITE2MEM
000021EE  4EB9 0000395C           1493          JSR         EA_LSd
000021F4  4CDF 7FFF               1494          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000021F8  4E75                    1495          RTS
000021FA                          1496  
000021FA  48E7 FFFE               1497  ISRORB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000021FE  49F9 00004706           1498          LEA         MESSAGERORB, A4
00002204  4EB9 000043EA           1499          JSR    WRITE2MEM
0000220A  49F9 000045F6           1500          LEA    MESSAGESPACE, A4
00002210  4EB9 000043EA           1501          JSR    WRITE2MEM
00002216  4EB9 000040A0           1502          JSR         EA_ROd
0000221C  4CDF 7FFF               1503          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002220  4E75                    1504          RTS
00002222                          1505  
00002222  48E7 FFFE               1506  ISRORW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002226  43F9 0000470C           1507          LEA         MESSAGERORW, A1
0000222C  103C 000E               1508          MOVE.B      #14, D0
00002230  4E4F                    1509          TRAP        #15
00002232  4EB9 000040A0           1510          JSR         EA_ROd
00002238  4CDF 7FFF               1511          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000223C  4E75                    1512          RTS
0000223E                          1513  
0000223E  48E7 FFFE               1514  ISRORL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002242  49F9 00004712           1515          LEA         MESSAGERORL, A4
00002248  4EB9 000043EA           1516          JSR    WRITE2MEM
0000224E  49F9 000045F6           1517          LEA    MESSAGESPACE, A4
00002254  4EB9 000043EA           1518          JSR    WRITE2MEM
0000225A  4EB9 000040A0           1519          JSR         EA_ROd
00002260  4CDF 7FFF               1520          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002264  4E75                    1521          RTS
00002266                          1522  
00002266  48E7 FFFE               1523  ISROLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000226A  49F9 00004718           1524          LEA         MESSAGEROLB, A4
00002270  4EB9 000043EA           1525          JSR    WRITE2MEM
00002276  49F9 000045F6           1526          LEA    MESSAGESPACE, A4
0000227C  4EB9 000043EA           1527          JSR    WRITE2MEM
00002282  4EB9 000040A0           1528          JSR         EA_ROd
00002288  4CDF 7FFF               1529          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000228C  4E75                    1530          RTS
0000228E                          1531  
0000228E  48E7 FFFE               1532  ISROLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002292  49F9 0000471E           1533          LEA         MESSAGEROLW, A4
00002298  4EB9 000043EA           1534          JSR    WRITE2MEM
0000229E  49F9 000045F6           1535          LEA    MESSAGESPACE, A4
000022A4  4EB9 000043EA           1536          JSR    WRITE2MEM
000022AA  4EB9 000040A0           1537          JSR         EA_ROd
000022B0  4CDF 7FFF               1538          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022B4  4E75                    1539          RTS
000022B6                          1540  
000022B6  48E7 FFFE               1541  ISROLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022BA  49F9 00004724           1542          LEA         MESSAGEROLL, A4
000022C0  4EB9 000043EA           1543          JSR    WRITE2MEM
000022C6  49F9 000045F6           1544          LEA    MESSAGESPACE, A4
000022CC  4EB9 000043EA           1545          JSR    WRITE2MEM
000022D2  4EB9 000040A0           1546          JSR         EA_ROd
000022D8  4CDF 7FFF               1547          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022DC  4E75                    1548          RTS
000022DE                          1549  
000022DE  48E7 FFFE               1550  ISMULSW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022E2  49F9 000046DB           1551          LEA         MESSAGEMULSW, A4
000022E8  4EB9 000043EA           1552          JSR    WRITE2MEM
000022EE  49F9 000045F6           1553          LEA    MESSAGESPACE, A4
000022F4  4EB9 000043EA           1554          JSR    WRITE2MEM
000022FA  4EB9 00003DEC           1555          JSR         EA_MULS_W
00002300  4CDF 7FFF               1556          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002304  4E75                    1557          RTS
00002306                          1558  
00002306  48E7 FFFE               1559  ISANDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000230A  49F9 000046C9           1560          LEA         MESSAGEANDB, A4
00002310  4EB9 000043EA           1561          JSR    WRITE2MEM
00002316  49F9 000045F6           1562          LEA    MESSAGESPACE, A4
0000231C  4EB9 000043EA           1563          JSR    WRITE2MEM
00002322  4EB9 000031A8           1564          JSR         EA_AND
00002328  4CDF 7FFF               1565          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000232C  4E75                    1566          RTS
0000232E                          1567  
0000232E  48E7 FFFE               1568  ISANDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002332  49F9 000046CF           1569          LEA         MESSAGEANDW, A4
00002338  4EB9 000043EA           1570          JSR    WRITE2MEM
0000233E  49F9 000045F6           1571          LEA    MESSAGESPACE, A4
00002344  4EB9 000043EA           1572          JSR    WRITE2MEM
0000234A  4EB9 000031A8           1573          JSR         EA_AND
00002350  4CDF 7FFF               1574          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002354  4E75                    1575          RTS
00002356                          1576  
00002356  48E7 FFFE               1577  ISANDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000235A  49F9 000046D5           1578          LEA         MESSAGEANDL, A4
00002360  4EB9 000043EA           1579          JSR    WRITE2MEM
00002366  49F9 000045F6           1580          LEA    MESSAGESPACE, A4
0000236C  4EB9 000043EA           1581          JSR    WRITE2MEM
00002372  4EB9 000031A8           1582          JSR         EA_AND
00002378  4CDF 7FFF               1583          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000237C  4E75                    1584          RTS
0000237E                          1585  
0000237E  48E7 FFFE               1586  ISADDAW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002382  49F9 000046B3           1587          LEA         MESSAGEADDAW, A4
00002388  4EB9 000043EA           1588          JSR    WRITE2MEM
0000238E  49F9 000045F6           1589          LEA    MESSAGESPACE, A4
00002394  4EB9 000043EA           1590          JSR    WRITE2MEM
0000239A  4EB9 00002E9E           1591          JSR         EA_ADDA
000023A0  4CDF 7FFF               1592          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023A4  4E75                    1593          RTS
000023A6                          1594  
000023A6  48E7 FFFE               1595  ISADDAL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023AA  49F9 000046BA           1596          LEA         MESSAGEADDAL, A4
000023B0  4EB9 000043EA           1597          JSR    WRITE2MEM
000023B6  49F9 000045F6           1598          LEA    MESSAGESPACE, A4
000023BC  4EB9 000043EA           1599          JSR    WRITE2MEM
000023C2  4EB9 00002E9E           1600          JSR         EA_ADDA
000023C8  4CDF 7FFF               1601          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023CC  4E75                    1602          RTS
000023CE                          1603  
000023CE  48E7 FFFE               1604  ISADDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023D2  49F9 000046A1           1605          LEA         MESSAGEADDB, A4
000023D8  4EB9 000043EA           1606          JSR    WRITE2MEM
000023DE  49F9 000045F6           1607          LEA    MESSAGESPACE, A4
000023E4  4EB9 000043EA           1608          JSR    WRITE2MEM
000023EA  4EB9 00002CD2           1609          JSR         EA_ADD
000023F0  4CDF 7FFF               1610          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023F4  4E75                    1611          RTS
000023F6                          1612  
000023F6  48E7 FFFE               1613  ISADDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023FA  49F9 000046A7           1614          LEA         MESSAGEADDW, A4
00002400  4EB9 000043EA           1615          JSR    WRITE2MEM
00002406  49F9 000045F6           1616          LEA    MESSAGESPACE, A4
0000240C  4EB9 000043EA           1617          JSR    WRITE2MEM
00002412  4EB9 00002CD2           1618          JSR         EA_ADD
00002418  4CDF 7FFF               1619          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000241C  4E75                    1620          RTS
0000241E                          1621  
0000241E  48E7 FFFE               1622  ISADDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002422  49F9 000046AD           1623          LEA         MESSAGEADDL, A4
00002428  4EB9 000043EA           1624          JSR    WRITE2MEM
0000242E  49F9 000045F6           1625          LEA    MESSAGESPACE, A4
00002434  4EB9 000043EA           1626          JSR    WRITE2MEM
0000243A  4EB9 00002CD2           1627          JSR         EA_ADD
00002440  4CDF 7FFF               1628          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002444  4E75                    1629          RTS
00002446                          1630  
00002446  48E7 FFFE               1631  ISSUBB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000244A  49F9 0000468F           1632          LEA         MESSAGESUBB, A4
00002450  4EB9 000043EA           1633          JSR    WRITE2MEM
00002456  49F9 000045F6           1634          LEA    MESSAGESPACE, A4
0000245C  4EB9 000043EA           1635          JSR    WRITE2MEM
00002462  4EB9 000041D0           1636          JSR         EA_SUB
00002468  4CDF 7FFF               1637          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000246C  4E75                    1638          RTS
0000246E                          1639  
0000246E  48E7 FFFE               1640  ISSUBW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002472  49F9 00004695           1641          LEA         MESSAGESUBW, A4
00002478  4EB9 000043EA           1642          JSR    WRITE2MEM
0000247E  49F9 000045F6           1643          LEA    MESSAGESPACE, A4
00002484  4EB9 000043EA           1644          JSR    WRITE2MEM
0000248A  4EB9 000041D0           1645          JSR         EA_SUB
00002490  4CDF 7FFF               1646          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002494  4E75                    1647          RTS
00002496                          1648  
00002496  48E7 FFFE               1649  ISSUBL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000249A  49F9 0000469B           1650          LEA         MESSAGESUBL, A4
000024A0  4EB9 000043EA           1651          JSR    WRITE2MEM
000024A6  49F9 000045F6           1652          LEA    MESSAGESPACE, A4
000024AC  4EB9 000043EA           1653          JSR    WRITE2MEM
000024B2  4EB9 000041D0           1654          JSR         EA_SUB
000024B8  4CDF 7FFF               1655          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024BC  4E75                    1656          RTS
000024BE                          1657  
000024BE  48E7 FFFE               1658  ISCMPB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024C2  49F9 0000467D           1659          LEA         MESSAGECMPB, A4
000024C8  4EB9 000043EA           1660          JSR    WRITE2MEM
000024CE  49F9 000045F6           1661          LEA    MESSAGESPACE, A4
000024D4  4EB9 000043EA           1662          JSR    WRITE2MEM
000024DA  4EB9 000035EC           1663          JSR         EA_CMP
000024E0  4CDF 7FFF               1664          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024E4  4E75                    1665          RTS
000024E6                          1666  
000024E6  48E7 FFFE               1667  ISCMPW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024EA  49F9 00004683           1668          LEA         MESSAGECMPW, A4
000024F0  4EB9 000043EA           1669          JSR    WRITE2MEM
000024F6  49F9 000045F6           1670          LEA    MESSAGESPACE, A4
000024FC  4EB9 000043EA           1671          JSR    WRITE2MEM
00002502  4EB9 000035EC           1672          JSR         EA_CMP
00002508  4CDF 7FFF               1673          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000250C  4E75                    1674          RTS
0000250E                          1675  
0000250E  48E7 FFFE               1676  ISCMPL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002512  49F9 00004689           1677          LEA         MESSAGECMPL, A4
00002518  4EB9 000043EA           1678          JSR    WRITE2MEM
0000251E  49F9 000045F6           1679          LEA    MESSAGESPACE, A4
00002524  4EB9 000043EA           1680          JSR    WRITE2MEM
0000252A  4EB9 000035EC           1681          JSR         EA_CMP
00002530  4CDF 7FFF               1682          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002534  4E75                    1683          RTS
00002536                          1684  
00002536  48E7 FFFE               1685  ISADDQB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000253A  49F9 00004668           1686          LEA         MESSAGEADDQB, A4
00002540  4EB9 000043EA           1687          JSR    WRITE2MEM
00002546  49F9 000045F6           1688          LEA    MESSAGESPACE, A4
0000254C  4EB9 000043EA           1689          JSR    WRITE2MEM
00002552  4EB9 000030AA           1690          JSR         EA_ADDQ
00002558  4CDF 7FFF               1691          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000255C  4E75                    1692          RTS
0000255E                          1693  
0000255E  48E7 FFFE               1694  ISADDQW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002562  49F9 0000466F           1695          LEA         MESSAGEADDQW, A4
00002568  4EB9 000043EA           1696          JSR    WRITE2MEM
0000256E  49F9 000045F6           1697          LEA    MESSAGESPACE, A4
00002574  4EB9 000043EA           1698          JSR    WRITE2MEM
0000257A  4EB9 000030AA           1699          JSR         EA_ADDQ
00002580  4CDF 7FFF               1700          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002584  4E75                    1701          RTS
00002586                          1702  
00002586  48E7 FFFE               1703  ISADDQL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000258A  43F9 00004676           1704          LEA         MESSAGEADDQL, A1 *OPCODE is ADDQ.L
00002590  103C 000E               1705          MOVE.B      #14, D0
00002594  4E4F                    1706          TRAP        #15
00002596  4EB9 000030AA           1707          JSR         EA_ADDQ
0000259C  4CDF 7FFF               1708          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025A0  4E75                    1709          RTS
000025A2                          1710  
000025A2  48E7 FFFE               1711  ISMOVEQL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000025A6  49F9 000046C1           1712          LEA         MESSAGEMOVEQL, A4
000025AC  4EB9 000043EA           1713          JSR    WRITE2MEM
000025B2  49F9 000045F6           1714          LEA    MESSAGESPACE, A4
000025B8  4EB9 000043EA           1715          JSR    WRITE2MEM
000025BE  4EB9 00003D8C           1716          JSR         EA_MOVEQ
000025C4  4CDF 7FFF               1717          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025C8  4E75                    1718          RTS
000025CA                          1719  
000025CA  48E7 FFFE               1720  ISCLRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025CE  49F9 00004656           1721          LEA         MESSAGECLRB, A4
000025D4  4EB9 000043EA           1722          JSR    WRITE2MEM
000025DA  49F9 000045F6           1723          LEA    MESSAGESPACE, A4
000025E0  4EB9 000043EA           1724          JSR    WRITE2MEM
000025E6  4EB9 00003D8C           1725          JSR         EA_MOVEQ
000025EC  4CDF 7FFF               1726          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025F0  4E75                    1727          RTS
000025F2                          1728  
000025F2  48E7 FFFE               1729  ISCLRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025F6  49F9 0000465C           1730          LEA         MESSAGECLRW, A4
000025FC  4EB9 000043EA           1731          JSR    WRITE2MEM
00002602  49F9 000045F6           1732          LEA    MESSAGESPACE, A4
00002608  4EB9 000043EA           1733          JSR    WRITE2MEM
0000260E  4EB9 00003524           1734          JSR         EA_CLR
00002614  4CDF 7FFF               1735          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002618  4E75                    1736          RTS
0000261A                          1737  
0000261A  48E7 FFFE               1738  ISCLRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000261E  49F9 00004662           1739          LEA         MESSAGECLRL, A4
00002624  4EB9 000043EA           1740          JSR    WRITE2MEM
0000262A  49F9 000045F6           1741          LEA    MESSAGESPACE, A4
00002630  4EB9 000043EA           1742          JSR    WRITE2MEM
00002636  4EB9 00003524           1743          JSR         EA_CLR
0000263C  4CDF 7FFF               1744          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002640  4E75                    1745          RTS
00002642                          1746  
00002642  48E7 FFFE               1747  ISMOVEML MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
00002646  49F9 00004636           1748          LEA         MESSAGEMOVEML, A4
0000264C  4EB9 000043EA           1749          JSR    WRITE2MEM
00002652  49F9 000045F6           1750          LEA    MESSAGESPACE, A4
00002658  4EB9 000043EA           1751          JSR    WRITE2MEM
0000265E  4EB9 00003D86           1752          JSR         EA_MOVEM
00002664  4CDF 7FFF               1753          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002668  4E75                    1754          RTS
0000266A                          1755  
0000266A  48E7 FFFE               1756  ISMOVEMW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
0000266E  49F9 0000463E           1757          LEA         MESSAGEMOVEMW, A4
00002674  4EB9 000043EA           1758          JSR    WRITE2MEM
0000267A  49F9 000045F6           1759          LEA    MESSAGESPACE, A4
00002680  4EB9 000043EA           1760          JSR    WRITE2MEM
00002686  4EB9 00003D86           1761          JSR         EA_MOVEM
0000268C  4CDF 7FFF               1762          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002690  4E75                    1763          RTS
00002692                          1764  
00002692  48E7 FFFE               1765  ISLEA   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002696  49F9 00004652           1766          LEA         MESSAGELEA, A4
0000269C  4EB9 000043EA           1767          JSR    WRITE2MEM
000026A2  49F9 000045F6           1768          LEA    MESSAGESPACE, A4
000026A8  4EB9 000043EA           1769          JSR    WRITE2MEM
000026AE  4EB9 00003880           1770          JSR         EA_LEA
000026B4  4CDF 7FFF               1771          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026B8  4E75                    1772          RTS                         ; Exit subroutine
000026BA                          1773  
000026BA  48E7 FFFE               1774  ISJSR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026BE  49F9 00004646           1775          LEA         MESSAGEJSR, A4
000026C4  4EB9 000043EA           1776          JSR    WRITE2MEM
000026CA  49F9 000045F6           1777          LEA    MESSAGESPACE, A4
000026D0  4EB9 000043EA           1778          JSR    WRITE2MEM
000026D6  4EB9 000037B8           1779          JSR         EA_JSR
000026DC  4CDF 7FFF               1780          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026E0  4E75                    1781          RTS                         ; Exit subroutine
000026E2                          1782  
000026E2  48E7 FFFE               1783  ISRTS   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026E6  49F9 0000464E           1784          LEA         MESSAGERTS, A4
000026EC  4EB9 000043EA           1785          JSR    WRITE2MEM
000026F2  49F9 000045F6           1786          LEA    MESSAGESPACE, A4
000026F8  4EB9 000043EA           1787          JSR    WRITE2MEM
000026FE  548E                    1788          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
00002700  4CDF 7FFF               1789          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002704  4E75                    1790          RTS
00002706                          1791  
00002706  48E7 FFFE               1792  ISCLR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000270A  43F9 0000464A           1793          LEA         MESSAGECLR, A1  *OPCODE is CLR
00002710  103C 000E               1794          MOVE.B      #14, D0
00002714  4E4F                    1795          TRAP        #15
00002716  4EB9 00003524           1796          JSR         EA_CLR
0000271C  4CDF 7FFF               1797          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002720  4E75                    1798          RTS
00002722                          1799  
00002722  48E7 FFFE               1800  ISNOP   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002726  49F9 000045F8           1801          LEA         MESSAGENOP, A4
0000272C  4EB9 000043EA           1802          JSR    WRITE2MEM
00002732  49F9 000045F6           1803          LEA    MESSAGESPACE, A4
00002738  4EB9 000043EA           1804          JSR    WRITE2MEM
0000273E  548E                    1805          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
00002740  4CDF 7FFF               1806          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002744  4E75                    1807          RTS                         ; Exit subroutine
00002746                          1808  
00002746  48E7 FFFE               1809  ISMOVEW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000274A  49F9 000045FC           1810          LEA         MESSAGEMOVEW, A4
00002750  4EB9 000043EA           1811          JSR    WRITE2MEM
00002756  49F9 000045F6           1812          LEA    MESSAGESPACE, A4
0000275C  4EB9 000043EA           1813          JSR    WRITE2MEM
00002762  4EB9 00003A8C           1814          JSR         EA_MOVE
00002768  4CDF 7FFF               1815          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000276C  4E75                    1816          RTS                         ; Exit subroutine
0000276E                          1817  
0000276E  48E7 FFFE               1818  ISMOVEAW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
00002772  49F9 0000462E           1819          LEA         MESSAGEMOVEAW, A4
00002778  4EB9 000043EA           1820          JSR    WRITE2MEM
0000277E  49F9 000045F6           1821          LEA    MESSAGESPACE, A4
00002784  4EB9 000043EA           1822          JSR    WRITE2MEM
0000278A  4EB9 00003C60           1823          JSR         EA_MOVEA
00002790  4CDF 7FFF               1824          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002794  4E75                    1825          RTS                         ; Exit subroutine
00002796                          1826  
00002796  48E7 FFFE               1827  ISMOVEL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000279A  49F9 00004603           1828          LEA         MESSAGEMOVEL, A4
000027A0  4EB9 000043EA           1829          JSR    WRITE2MEM
000027A6  49F9 000045F6           1830          LEA    MESSAGESPACE, A4
000027AC  4EB9 000043EA           1831          JSR    WRITE2MEM
000027B2  4EB9 00003A8C           1832          JSR         EA_MOVE
000027B8  4CDF 7FFF               1833          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027BC  4E75                    1834          RTS                         ; Exit subroutine
000027BE                          1835  
000027BE  48E7 FFFE               1836  ISMOVEAL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000027C2  49F9 00004626           1837          LEA         MESSAGEMOVEAL, A4
000027C8  4EB9 000043EA           1838          JSR    WRITE2MEM
000027CE  49F9 000045F6           1839          LEA    MESSAGESPACE, A4
000027D4  4EB9 000043EA           1840          JSR    WRITE2MEM
000027DA  4EB9 00003C60           1841          JSR         EA_MOVEA
000027E0  4CDF 7FFF               1842          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027E4  4E75                    1843          RTS                         ; Exit subroutine
000027E6                          1844  
000027E6  48E7 FFFE               1845  ISMOVEB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027EA  43F9 0000460A           1846          LEA         MESSAGEMOVEB, A1 *OPCODE is MOVE.B so display MOVEB message
000027F0  103C 000E               1847          MOVE.B      #14, D0
000027F4  4E4F                    1848          TRAP        #15
000027F6  4EB9 00003A8C           1849          JSR         EA_MOVE
000027FC  4CDF 7FFF               1850          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002800  4E75                    1851          RTS                         ; Exit subroutine
00002802                          1852  
00002802  48E7 FFFE               1853  ISADDIW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002806  49F9 00004611           1854          LEA         MESSAGEADDIW, A4
0000280C  4EB9 000043EA           1855          JSR    WRITE2MEM
00002812  49F9 000045F6           1856          LEA    MESSAGESPACE, A4
00002818  4EB9 000043EA           1857          JSR    WRITE2MEM
0000281E  4EB9 00002F8E           1858          JSR         EA_ADDI
00002824  4CDF 7FFF               1859          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002828  4E75                    1860          RTS                         ; Exit subroutine
0000282A                          1861  
0000282A  48E7 FFFE               1862  ISADDIL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000282E  49F9 00004618           1863          LEA         MESSAGEADDIL, A4
00002834  4EB9 000043EA           1864          JSR    WRITE2MEM
0000283A  49F9 000045F6           1865          LEA    MESSAGESPACE, A4
00002840  4EB9 000043EA           1866          JSR    WRITE2MEM
00002846  4EB9 00002F8E           1867          JSR         EA_ADDI
0000284C  4CDF 7FFF               1868          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002850  4E75                    1869          RTS                         ; Exit subroutine
00002852                          1870  
00002852  48E7 FFFE               1871  ISADDIB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002856  49F9 0000461F           1872          LEA         MESSAGEADDIB, A4
0000285C  4EB9 000043EA           1873          JSR    WRITE2MEM
00002862  49F9 000045F6           1874          LEA    MESSAGESPACE, A4
00002868  4EB9 000043EA           1875          JSR    WRITE2MEM
0000286E  4EB9 00002F8E           1876          JSR         EA_ADDI
00002874  4CDF 7FFF               1877          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002878  4E75                    1878          RTS                         ; Exit subroutine
0000287A                          1879  
0000287A                          1880  
0000287A                          1881  
0000287A                          1882  
0000287A                          1883  
0000287A                          1884  
0000287A                          1885  
0000287A                          1886  
0000287A                          1887  -------------------- end include --------------------
0000287A                          1888      INCLUDE 'EA.X68'
0000287A                          1889  
0000287A                          1890      INCLUDE 'EA_UTIL.X68'
0000287A                          1891  
0000287A                          1892  
0000287A                          1893  EA_UNIMPLEMENTED:
0000287A  548E                    1894      ADDA.L      #$00000002, A6      ; Increment past current opcode word
0000287C  49F9 000047C9           1895      LEA         EA_MSG_UNIMP, A4
00002882  4EB9 000043EA           1896      JSR         WRITE2MEM
00002888  4E75                    1897      RTS
0000288A                          1898  
0000288A                          1899  EA_INVALID:
0000288A  2A4E                    1900      MOVEA.L     A6, A5              ; Copy global pointer
0000288C  548D                    1901      ADDA.L      #$00000002, A5      ; Increment past current opcode word
0000288E  4EB8 133C               1902      JSR         INVALID_DATA        ; Print data error message
00002892  4E75                    1903      RTS
00002894                          1904  
00002894                          1905  EA_PRINT_DATA:
00002894  49F9 000047E3           1906      LEA         EA_MSG_PRINT_DATA, A4
0000289A  4EB9 000043EA           1907      JSR         WRITE2MEM
000028A0  4E75                    1908      RTS
000028A2                          1909  
000028A2                          1910  
000028A2                          1911  EA_UPDATE_POINTER:
000028A2  BDCD                    1912      CMP.L       A5, A6              ; Check if A5==A6
000028A4  6600 0004               1913      BNE         UPDATE_PTR          ; If NOT equal (a.k.a if any extra operands
000028A8                          1914                                      ; were read, and is already up to date),
000028A8                          1915                                      ; update global with current
000028A8  548D                    1916      ADDA.L      #$00000002, A5      ; Else, increment past current opcode word, then update
000028AA                          1917  UPDATE_PTR:
000028AA  2C4D                    1918      MOVEA.L     A5, A6              ; Update global pointer
000028AC  4E75                    1919      RTS
000028AE                          1920  
000028AE                          1921  EA_COPY_PTR:
000028AE  2A4E                    1922      MOVEA.L     A6, A5              ; Save global pointer
000028B0  4E75                    1923      RTS
000028B2                          1924  
000028B2                          1925  EA_DEFAULT_COMBO:
000028B2  4286                    1926      CLR.L       D6                  ; Clear space for mode bits
000028B4  4287                    1927      CLR.L       D7                  ; Clear space for register bits
000028B6  2216                    1928      MOVE.L      (A6), D1            ; Load opcode to data register 1
000028B8  143C 000A               1929      MOVE.B      #10, D2             ; Clear upper 10 bits of opcode word
000028BC  E569                    1930      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000028BE  143C 000D               1931      MOVE.B      #13, D2             ; 'Right-align' bits 3-5 to determine mode bits
000028C2  E469                    1932      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000028C4  1C01                    1933      MOVE.B      D1, D6              ; Save mode bits to D6
000028C6  2216                    1934      MOVE.L      (A6), D1            ; Reload opcode to data register 1
000028C8  143C 000D               1935      MOVE.B      #13, D2             ; Clear upper 13 bits of opcode word
000028CC  E569                    1936      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000028CE  143C 000D               1937      MOVE.B      #13, D2             ; 'Right-align' bits 0-2 to determine register bits
000028D2  E469                    1938      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000028D4  1E01                    1939      MOVE.B      D1, D7              ; Save register bits to D7
000028D6  4E75                    1940      RTS                             ; Return from subroutine
000028D8                          1941  
000028D8                          1942  EA_OPMODE_COMBO:
000028D8  4286                    1943      CLR.L       D6                  ; Clear space for mode bits
000028DA  4287                    1944      CLR.L       D7                  ; Clear space for register bits
000028DC  2216                    1945      MOVE.L      (A6), D1            ; Load opcode to data register 1
000028DE  143C 0007               1946      MOVE.B      #7, D2              ; Clear upper 7 bits of opcode word
000028E2  E569                    1947      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000028E4  143C 000D               1948      MOVE.B      #13, D2             ; 'Right-align' bits 6-8 to determine opmode bits
000028E8  E469                    1949      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000028EA  1C01                    1950      MOVE.B      D1, D6              ; Save opmode bits to D6
000028EC  2216                    1951      MOVE.L      (A6), D1            ; Reload opcode to data register 1
000028EE  143C 0004               1952      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
000028F2  E569                    1953      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000028F4  143C 000D               1954      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register bits
000028F8  E469                    1955      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000028FA  1E01                    1956      MOVE.B      D1, D7              ; Save register bits to D7
000028FC  4E75                    1957      RTS                             ; Return from subroutine
000028FE                          1958  
000028FE                          1959  EA_SIZE_BITS:
000028FE  4287                    1960      CLR.L       D7
00002900  2E16                    1961      MOVE.L      (A6), D7            ; Load opcode to data register 1
00002902  143C 0008               1962      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00002906  E56F                    1963      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00002908  143C 000E               1964      MOVE.B      #14, D2             ; 'Right-align' bits 6-7 to determine size bits
0000290C  E46F                    1965      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
0000290E  4E75                    1966      RTS
00002910                          1967  
00002910                          1968  
00002910                          1969  EA_PRINT_DN:
00002910  41F9 0000291E           1970      LEA         EA_PRINT_DN_JMP, A0 ; Set index '0' for jump table
00002916  CEFC 0006               1971      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000291A  4EF0 7000               1972      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000291E                          1973  EA_PRINT_DN_JMP:
0000291E  4EF9 0000294E           1974      JMP         DN_000 ; D0
00002924  4EF9 0000295A           1975      JMP         DN_001 ; D1
0000292A  4EF9 00002966           1976      JMP         DN_010 ; D2
00002930  4EF9 00002972           1977      JMP         DN_011 ; D3
00002936  4EF9 0000297E           1978      JMP         DN_100 ; D4
0000293C  4EF9 0000298A           1979      JMP         DN_101 ; D5
00002942  4EF9 00002996           1980      JMP         DN_110 ; D6
00002948  4EF9 000029A2           1981      JMP         DN_111 ; D7
0000294E                          1982  DN_000: ; D0
0000294E  49F9 00004799           1983      LEA         EA_MSG_D0, A4
00002954  4EB9 000043EA           1984      JSR         WRITE2MEM
0000295A                          1985  DN_001: ; D1
0000295A  49F9 0000479C           1986      LEA         EA_MSG_D1, A4
00002960  4EB9 000043EA           1987      JSR         WRITE2MEM
00002966                          1988  DN_010: ; D2
00002966  49F9 0000479F           1989      LEA         EA_MSG_D2, A4
0000296C  4EB9 000043EA           1990      JSR         WRITE2MEM
00002972                          1991  DN_011: ; D3
00002972  49F9 000047A2           1992      LEA         EA_MSG_D3, A4
00002978  4EB9 000043EA           1993      JSR         WRITE2MEM
0000297E                          1994  DN_100: ; D4
0000297E  49F9 000047A5           1995      LEA         EA_MSG_D4, A4
00002984  4EB9 000043EA           1996      JSR         WRITE2MEM
0000298A                          1997  DN_101: ; D5
0000298A  49F9 000047A8           1998      LEA         EA_MSG_D5, A4
00002990  4EB9 000043EA           1999      JSR         WRITE2MEM
00002996                          2000  DN_110: ; D6
00002996  49F9 000047AB           2001      LEA         EA_MSG_D6, A4
0000299C  4EB9 000043EA           2002      JSR         WRITE2MEM
000029A2                          2003  DN_111: ; D7
000029A2  49F9 000047AE           2004      LEA         EA_MSG_D7, A4
000029A8  4EB9 000043EA           2005      JSR         WRITE2MEM
000029AE                          2006  
000029AE                          2007  EA_PRINT_DN_END:
000029AE  4E75                    2008      RTS
000029B0                          2009  
000029B0                          2010  EA_PRINT_AN:
000029B0  41F9 000029BE           2011      LEA         AN_JMP, A0          ; Set index '0' for jump table
000029B6  CEFC 0006               2012      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000029BA  4EF0 7000               2013      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000029BE                          2014  AN_JMP:
000029BE  4EF9 000029EE           2015      JMP         AN_000 ; A0
000029C4  4EF9 000029FA           2016      JMP         AN_001 ; A1
000029CA  4EF9 00002A06           2017      JMP         AN_010 ; A2
000029D0  4EF9 00002A12           2018      JMP         AN_011 ; A3
000029D6  4EF9 00002A1E           2019      JMP         AN_100 ; A4
000029DC  4EF9 00002A2A           2020      JMP         AN_101 ; A5
000029E2  4EF9 00002A36           2021      JMP         AN_110 ; A6
000029E8  4EF9 00002A42           2022      JMP         AN_111 ; A7
000029EE                          2023  AN_000: ; A0
000029EE  49F9 000047B1           2024      LEA         EA_MSG_A0, A4
000029F4  4EB9 000043EA           2025      JSR         WRITE2MEM
000029FA                          2026  AN_001: ; A1
000029FA  49F9 000047B4           2027      LEA         EA_MSG_A1, A4
00002A00  4EB9 000043EA           2028      JSR         WRITE2MEM
00002A06                          2029  AN_010: ; A2
00002A06  49F9 000047B7           2030      LEA         EA_MSG_A2, A4
00002A0C  4EB9 000043EA           2031      JSR         WRITE2MEM
00002A12                          2032  AN_011: ; A3
00002A12  49F9 000047BA           2033      LEA         EA_MSG_A3, A4
00002A18  4EB9 000043EA           2034      JSR         WRITE2MEM
00002A1E                          2035  AN_100: ; A4
00002A1E  49F9 000047BD           2036      LEA         EA_MSG_A4, A4
00002A24  4EB9 000043EA           2037      JSR         WRITE2MEM
00002A2A                          2038  AN_101: ; A5
00002A2A  49F9 000047C0           2039      LEA         EA_MSG_A5, A4
00002A30  4EB9 000043EA           2040      JSR         WRITE2MEM
00002A36                          2041  AN_110: ; A6
00002A36  49F9 000047C3           2042      LEA         EA_MSG_A6, A4
00002A3C  4EB9 000043EA           2043      JSR         WRITE2MEM
00002A42                          2044  AN_111: ; A7
00002A42  49F9 000047C6           2045      LEA         EA_MSG_A7, A4
00002A48  4EB9 000043EA           2046      JSR         WRITE2MEM
00002A4E                          2047  
00002A4E                          2048  EA_PRINT_AN_END:
00002A4E  4E75                    2049      RTS
00002A50                          2050  EA_PRINT_IND:
00002A50  49F9 000048C7           2051      LEA         OPAREN, A4    ; Print open parentheses
00002A56  4EB9 000043EA           2052      JSR         WRITE2MEM
00002A5C  41F9 00002A6A           2053      LEA         IND_JMP, A0         ; Set index '0' for jump table
00002A62  CEFC 0006               2054      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002A66  4EF0 7000               2055      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002A6A                          2056  IND_JMP:
00002A6A  4EF9 00002A9A           2057      JMP         IND_000 ; (A0)
00002A70  4EF9 00002AA6           2058      JMP         IND_001 ; (A1)
00002A76  4EF9 00002AB2           2059      JMP         IND_010 ; (A2)
00002A7C  4EF9 00002ABE           2060      JMP         IND_011 ; (A3)
00002A82  4EF9 00002ACA           2061      JMP         IND_100 ; (A4)
00002A88  4EF9 00002AD6           2062      JMP         IND_101 ; (A5)
00002A8E  4EF9 00002AE2           2063      JMP         IND_110 ; (A6)
00002A94  4EF9 00002AEE           2064      JMP         IND_111 ; (A7)
00002A9A                          2065  IND_000: ; (A0)
00002A9A  49F9 000047B1           2066      LEA         EA_MSG_A0, A4
00002AA0  4EB9 000043EA           2067      JSR         WRITE2MEM
00002AA6                          2068  IND_001: ; (A1)
00002AA6  49F9 000047B4           2069      LEA         EA_MSG_A1, A4
00002AAC  4EB9 000043EA           2070      JSR         WRITE2MEM
00002AB2                          2071  IND_010: ; (A2)
00002AB2  49F9 000047B7           2072      LEA         EA_MSG_A2, A4
00002AB8  4EB9 000043EA           2073      JSR         WRITE2MEM
00002ABE                          2074  IND_011: ; (A3)
00002ABE  49F9 000047BA           2075      LEA         EA_MSG_A3, A4
00002AC4  4EB9 000043EA           2076      JSR         WRITE2MEM
00002ACA                          2077  IND_100: ; (A4)
00002ACA  49F9 000047BD           2078      LEA         EA_MSG_A4, A4
00002AD0  4EB9 000043EA           2079      JSR         WRITE2MEM
00002AD6                          2080  IND_101: ; (A5)
00002AD6  49F9 000047C0           2081      LEA         EA_MSG_A5, A4
00002ADC  4EB9 000043EA           2082      JSR         WRITE2MEM
00002AE2                          2083  IND_110: ; (A6)
00002AE2  49F9 000047C3           2084      LEA         EA_MSG_A6, A4
00002AE8  4EB9 000043EA           2085      JSR         WRITE2MEM
00002AEE                          2086  IND_111: ; (A7)
00002AEE  49F9 000047C6           2087      LEA         EA_MSG_A7, A4
00002AF4  4EB9 000043EA           2088      JSR         WRITE2MEM
00002AFA                          2089  EA_PRINT_IND_END:
00002AFA  49F9 000048C9           2090      LEA         CPAREN, A4   ; Print close parentheses
00002B00  4EB9 000043EA           2091      JSR         WRITE2MEM
00002B06  4E75                    2092      RTS
00002B08                          2093  EA_PRINT_IMM:
00002B08  224D                    2094      MOVEA.L     A5, A1              ; copy pointer to temp
00002B0A  5489                    2095      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002B0C  BA7C 0003               2096      CMP         #3, D5
00002B10  6700 0010               2097      BEQ         PRINT_IMM_L         ; if L, branch
00002B14  3011                    2098      MOVE.W      (A1), D0            ; store value in a register (todo, register tbd)
00002B16  4EB8 2894               2099      JSR         EA_PRINT_DATA *print value TODO
00002B1A  5489                    2100      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002B1C  4EF9 00002B26           2101      JMP         PRINT_IMM_END
00002B22                          2102  PRINT_IMM_L:
00002B22  2011                    2103      MOVE.L      (A1), D0            ; store value in a register (todo, register tbd)
00002B24                          2104      *print value TODO
00002B24  5889                    2105      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002B26                          2106  PRINT_IMM_END:
00002B26  2A49                    2107      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002B28  4E75                    2108      RTS
00002B2A                          2109  EA_PRINT_POSTINC:
00002B2A  49F9 000048C7           2110      LEA         OPAREN, A4    ; Print open parentheses
00002B30  4EB9 000043EA           2111      JSR         WRITE2MEM
00002B36  41F9 00002B44           2112      LEA         POSTINC_JMP, A0     ; Set index '0' for jump table
00002B3C  CEFC 0006               2113      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002B40  4EF0 7000               2114      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002B44                          2115  POSTINC_JMP:
00002B44  4EF9 00002B74           2116      JMP         POSTINC_000 ; (A0)+
00002B4A  4EF9 00002B80           2117      JMP         POSTINC_001 ; (A1)+
00002B50  4EF9 00002B8C           2118      JMP         POSTINC_010 ; (A2)+
00002B56  4EF9 00002B98           2119      JMP         POSTINC_011 ; (A3)+
00002B5C  4EF9 00002BA4           2120      JMP         POSTINC_100 ; (A4)+
00002B62  4EF9 00002BB0           2121      JMP         POSTINC_101 ; (A5)+
00002B68  4EF9 00002BBC           2122      JMP         POSTINC_110 ; (A6)+
00002B6E  4EF9 00002BC8           2123      JMP         POSTINC_111 ; (A7)+
00002B74                          2124  POSTINC_000: ; (A0)+
00002B74  49F9 000047B1           2125      LEA         EA_MSG_A0, A4
00002B7A  4EB9 000043EA           2126      JSR         WRITE2MEM
00002B80                          2127  POSTINC_001: ; (A1)+
00002B80  49F9 000047B4           2128      LEA         EA_MSG_A1, A4
00002B86  4EB9 000043EA           2129      JSR         WRITE2MEM
00002B8C                          2130  POSTINC_010: ; (A2)+
00002B8C  49F9 000047B7           2131      LEA         EA_MSG_A2, A4
00002B92  4EB9 000043EA           2132      JSR         WRITE2MEM
00002B98                          2133  POSTINC_011: ; (A3)+
00002B98  49F9 000047BA           2134      LEA         EA_MSG_A3, A4
00002B9E  4EB9 000043EA           2135      JSR         WRITE2MEM
00002BA4                          2136  POSTINC_100: ; (A4)+
00002BA4  49F9 000047BD           2137      LEA         EA_MSG_A4, A4
00002BAA  4EB9 000043EA           2138      JSR         WRITE2MEM
00002BB0                          2139  POSTINC_101: ; (A5)+
00002BB0  49F9 000047C0           2140      LEA         EA_MSG_A5, A4
00002BB6  4EB9 000043EA           2141      JSR         WRITE2MEM
00002BBC                          2142  POSTINC_110: ; (A6)+
00002BBC  49F9 000047C3           2143      LEA         EA_MSG_A6, A4
00002BC2  4EB9 000043EA           2144      JSR         WRITE2MEM
00002BC8                          2145  POSTINC_111: ; (A7)+
00002BC8  49F9 000047C6           2146      LEA         EA_MSG_A7, A4
00002BCE  4EB9 000043EA           2147      JSR         WRITE2MEM
00002BD4                          2148  EA_PRINT_PI_END:
00002BD4  49F9 000048C9           2149      LEA         CPAREN, A4   ; Print close parentheses
00002BDA  4EB9 000043EA           2150      JSR         WRITE2MEM
00002BE0  49F9 000048CB           2151      LEA         PLUS, A4         ; Print plus sign
00002BE6  4EB9 000043EA           2152      JSR         WRITE2MEM
00002BEC  4E75                    2153      RTS
00002BEE                          2154  EA_PRINT_PREDEC:
00002BEE  49F9 000048CD           2155      LEA         MINUS, A4               ; Print minus sign
00002BF4  4EB9 000043EA           2156      JSR         WRITE2MEM
00002BFA  49F9 000048C7           2157      LEA         OPAREN, A4              ; Print open parentheses
00002C00  4EB9 000043EA           2158      JSR         WRITE2MEM
00002C06  41F9 00002C14           2159      LEA         PREDEC_JMP, A0      ; Set index '0' for jump table
00002C0C  CEFC 0006               2160      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002C10  4EF0 7000               2161      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002C14                          2162  PREDEC_JMP:
00002C14  4EF9 00002C44           2163      JMP         PREDEC_000 ; -(A0)
00002C1A  4EF9 00002C50           2164      JMP         PREDEC_001 ; -(A1)
00002C20  4EF9 00002C5C           2165      JMP         PREDEC_010 ; -(A2)
00002C26  4EF9 00002C68           2166      JMP         PREDEC_011 ; -(A3)
00002C2C  4EF9 00002C74           2167      JMP         PREDEC_100 ; -(A4)
00002C32  4EF9 00002C80           2168      JMP         PREDEC_101 ; -(A5)
00002C38  4EF9 00002C8C           2169      JMP         PREDEC_110 ; -(A6)
00002C3E  4EF9 00002C98           2170      JMP         PREDEC_111 ; -(A7)
00002C44                          2171  
00002C44                          2172  PREDEC_000: ; -(A0)
00002C44  49F9 000047B1           2173      LEA         EA_MSG_A0, A4
00002C4A  4EB9 000043EA           2174      JSR         WRITE2MEM
00002C50                          2175  PREDEC_001: ; -(A1)
00002C50  49F9 000047B4           2176      LEA         EA_MSG_A1, A4
00002C56  4EB9 000043EA           2177      JSR         WRITE2MEM
00002C5C                          2178  PREDEC_010: ; -(A2)
00002C5C  49F9 000047B7           2179      LEA         EA_MSG_A2, A4
00002C62  4EB9 000043EA           2180      JSR         WRITE2MEM
00002C68                          2181  PREDEC_011: ; -(A3)
00002C68  49F9 000047BA           2182      LEA         EA_MSG_A3, A4
00002C6E  4EB9 000043EA           2183      JSR         WRITE2MEM
00002C74                          2184  PREDEC_100: ; -(A4)
00002C74  49F9 000047BD           2185      LEA         EA_MSG_A4, A4
00002C7A  4EB9 000043EA           2186      JSR         WRITE2MEM
00002C80                          2187  PREDEC_101: ; -(A5)
00002C80  49F9 000047C0           2188      LEA         EA_MSG_A5, A4
00002C86  4EB9 000043EA           2189      JSR         WRITE2MEM
00002C8C                          2190  PREDEC_110: ; -(A6)
00002C8C  49F9 000047C3           2191      LEA         EA_MSG_A6, A4
00002C92  4EB9 000043EA           2192      JSR         WRITE2MEM
00002C98                          2193  PREDEC_111: ; -(A7)
00002C98  49F9 000047C6           2194      LEA         EA_MSG_A7, A4
00002C9E  4EB9 000043EA           2195      JSR         WRITE2MEM
00002CA4                          2196  
00002CA4                          2197  EA_PRINT_PD_END:
00002CA4  49F9 000048C9           2198      LEA         CPAREN, A4   ; Print close parentheses
00002CAA  4EB9 000043EA           2199      JSR         WRITE2MEM
00002CB0  4E75                    2200      RTS
00002CB2                          2201  EA_PRINT_ABS_L:
00002CB2  224D                    2202      MOVEA.L     A5, A1              ; copy pointer to temp
00002CB4  5489                    2203      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002CB6  2011                    2204      MOVE.L      (A1), D0            ; store longword address to print TODO
00002CB8  4EB8 2894               2205      JSR         EA_PRINT_DATA *print value TODO
00002CBC  5889                    2206      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002CBE  2A49                    2207      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002CC0  4E75                    2208      RTS
00002CC2                          2209  EA_PRINT_ABS_W:
00002CC2  224D                    2210      MOVEA.L     A5, A1              ; copy pointer to temp
00002CC4  5489                    2211      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002CC6  2011                    2212      MOVE.L      (A1), D0            ; store word address to print in TODO
00002CC8  4EB8 2894               2213      JSR         EA_PRINT_DATA *print value TODO
00002CCC  5489                    2214      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002CCE  2A49                    2215      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002CD0  4E75                    2216      RTS
00002CD2                          2217  
00002CD2                          2218  
00002CD2                          2219  -------------------- end include --------------------
00002CD2                          2220  
00002CD2                          2221  EA_ADD:
00002CD2  48E7 FFFC               2222      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002CD6  4EB8 28AE               2223      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002CDA  4EB8 28D8               2224      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00002CDE  41F9 00002CEC           2225      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
00002CE4  CCFC 0006               2226      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002CE8  4EF0 6000               2227      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002CEC                          2228  ADD_OPMODE:
00002CEC  4EF9 00002D1C           2229      JMP         ADD_OPMODE_000      ; mode 1, byte
00002CF2  4EF9 00002D26           2230      JMP         ADD_OPMODE_001      ; mode 1, word
00002CF8  4EF9 00002D30           2231      JMP         ADD_OPMODE_010      ; mode 1, long
00002CFE  4EF9 00002D3A           2232      JMP         ADD_OPMODE_011      ; Invalid value
00002D04  4EF9 00002D44           2233      JMP         ADD_OPMODE_100      ; mode 2, byte
00002D0A  4EF9 00002D4E           2234      JMP         ADD_OPMODE_101      ; mode 2, word
00002D10  4EF9 00002D58           2235      JMP         ADD_OPMODE_110      ; mode 2, long
00002D16  4EF9 00002D62           2236      JMP         ADD_OPMODE_111      ; Invalid value
00002D1C                          2237  ADD_OPMODE_000: ; mode 1, byte
00002D1C  1A3C 0001               2238      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002D20  4EF9 00002D6C           2239      JMP         ADD_MODE_1
00002D26                          2240  ADD_OPMODE_001: ; mode 1, word
00002D26  1A3C 0002               2241      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00002D2A  4EF9 00002D6C           2242      JMP         ADD_MODE_1
00002D30                          2243  ADD_OPMODE_010: ; mode 1, long
00002D30  1A3C 0003               2244      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00002D34  4EF9 00002D6C           2245      JMP         ADD_MODE_1
00002D3A                          2246  ADD_OPMODE_011: ; Invalid value
00002D3A  4EB8 288A               2247      JSR         EA_INVALID
00002D3E  4EF9 00002E94           2248      JMP         ADD_END
00002D44                          2249  ADD_OPMODE_100: ; mode 2, byte
00002D44  1A3C 0001               2250      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002D48  4EF9 00002D96           2251      JMP         ADD_MODE_2
00002D4E                          2252  ADD_OPMODE_101: ; mode 2, word
00002D4E  1A3C 0001               2253      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002D52  4EF9 00002D96           2254      JMP         ADD_MODE_2
00002D58                          2255  ADD_OPMODE_110: ; mode 2, long
00002D58  1A3C 0001               2256      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002D5C  4EF9 00002D96           2257      JMP         ADD_MODE_2
00002D62                          2258  ADD_OPMODE_111: ; Invalid value
00002D62  4EB8 288A               2259      JSR         EA_INVALID
00002D66  4EF9 00002E94           2260      JMP         ADD_END
00002D6C                          2261  ADD_MODE_1:
00002D6C  4280                    2262      CLR.L       D0                  ; Clear data register 0
00002D6E  103C 0001               2263      MOVE.B      #1, D0              ; Save mode number to D0
00002D72  3207                    2264      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00002D74  4EB8 28B2               2265      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002D78  4EB9 00002DBC           2266      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002D7E  49F9 000048C4           2267      LEA         COMMA, A4        ; Print comma
00002D84  4EB9 000043EA           2268      JSR         WRITE2MEM
00002D8A  3E01                    2269      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00002D8C  4EB8 2910               2270      JSR         EA_PRINT_DN         ; Print data register
00002D90  4EF9 00002E94           2271      JMP         ADD_END
00002D96                          2272  ADD_MODE_2:
00002D96  4280                    2273      CLR.L       D0                  ; Clear data register 0
00002D98  103C 0002               2274      MOVE.B      #2, D0              ; Save mode number to D0
00002D9C  4EB8 2910               2275      JSR         EA_PRINT_DN         ; Print data register
00002DA0  49F9 000048C4           2276      LEA         COMMA, A4        ; Print comma
00002DA6  4EB9 000043EA           2277      JSR         WRITE2MEM
00002DAC  4EB8 28B2               2278      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002DB0  4EB9 00002DBC           2279      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002DB6  4EF9 00002E94           2280      JMP         ADD_END
00002DBC                          2281  ADD_EVAL_EA:
00002DBC  41F9 00002DCA           2282      LEA         ADD_MODE, A0        ; Set index '0' for jump table
00002DC2  CCFC 0006               2283      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002DC6  4EF0 6000               2284      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002DCA                          2285  ADD_MODE:
00002DCA  4EF9 00002DFA           2286      JMP         ADD_MODE_000        ; Dn (invalid if opmode 2)
00002DD0  4EF9 00002E0C           2287      JMP         ADD_MODE_001        ; An (invalid if opmode 2)
00002DD6  4EF9 00002E1E           2288      JMP         ADD_MODE_010        ; (An)
00002DDC  4EF9 00002E28           2289      JMP         ADD_MODE_011        ; (An)+
00002DE2  4EF9 00002E32           2290      JMP         ADD_MODE_100        ; -(An)
00002DE8  4EF9 00002E3C           2291      JMP         ADD_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00002DEE  4EF9 00002E42           2292      JMP         ADD_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002DF4  4EF9 00002E48           2293      JMP         ADD_MODE_111        ; The rest (not all valid, validated by register number)
00002DFA                          2294  ADD_MODE_000: ; Dn (invalid if opmode 2)
00002DFA  B07C 0002               2295      CMP         #2, D0
00002DFE  6700 008E               2296      BEQ         ADD_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00002E02  4EB8 2910               2297      JSR         EA_PRINT_DN         ; Print data register direct operand
00002E06  4EF9 00002E8C           2298      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E0C                          2299  ADD_MODE_001: ; An (invalid if opmode 2)
00002E0C  B07C 0002               2300      CMP         #2, D0
00002E10  6700 007C               2301      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002E14  4EB8 29B0               2302      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002E18  4EF9 00002E8C           2303      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E1E                          2304  ADD_MODE_010: ; (An)
00002E1E  4EB8 2A50               2305      JSR         EA_PRINT_IND         ; Print address register indirect
00002E22  4EF9 00002E8C           2306      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E28                          2307  ADD_MODE_011: ; (An)+
00002E28  4EB8 2B2A               2308      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002E2C  4EF9 00002E8C           2309      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E32                          2310  ADD_MODE_100: ; -(An)
00002E32  4EB8 2BEE               2311      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002E36  4EF9 00002E8C           2312      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E3C                          2313  ADD_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002E3C  4EF9 00002E8E           2314      JMP         ADD_MODE_INVALID
00002E42                          2315  ADD_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002E42  4EF9 00002E8E           2316      JMP         ADD_MODE_INVALID
00002E48                          2317  ADD_MODE_111: ; The rest (not all valid, validated by register number)
00002E48  BE3C 0000               2318      CMP.B       #$00, D7            ; Test for absolute word address
00002E4C  6700 0018               2319      BEQ         ADD_ABS_W
00002E50  BE3C 0001               2320      CMP.B       #$01, D7            ; Test for absolute long address
00002E54  6700 001A               2321      BEQ         ADD_ABS_L
00002E58  BE3C 0004               2322      CMP.B       #$04, D7            ; Test for immediate data
00002E5C  6700 001C               2323      BEQ         ADD_IMM
00002E60  4EF9 00002E8E           2324      JMP         ADD_MODE_INVALID    ; else, invalid
00002E66                          2325  ADD_ABS_W:
00002E66  4EB8 2CC2               2326      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002E6A  4EF9 00002E8C           2327      JMP         ADD_MODE_END
00002E70                          2328  ADD_ABS_L:
00002E70  4EB8 2CB2               2329      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002E74  4EF9 00002E8C           2330      JMP         ADD_MODE_END
00002E7A                          2331  ADD_IMM: ; invalid if opmode is 2
00002E7A  B07C 0002               2332      CMP         #2, D0
00002E7E  6700 000E               2333      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002E82  4EB8 2B08               2334      JSR         EA_PRINT_IMM        ; Print immediate data
00002E86  4EF9 00002E8C           2335      JMP         ADD_MODE_END
00002E8C                          2336  ADD_MODE_END:
00002E8C  4E75                    2337      RTS                             ; Finish evaluating EA bits
00002E8E                          2338  ADD_MODE_INVALID:
00002E8E  4EB8 288A               2339      JSR         EA_INVALID          ; Opcode word is Invalid
00002E92  4E75                    2340      RTS                             ; Finish evaluating EA bits
00002E94                          2341  ADD_END:
00002E94  4EB8 28A2               2342      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00002E98  4CDF 3FFF               2343      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002E9C  4E75                    2344      RTS
00002E9E                          2345  
00002E9E                          2346  EA_ADDA:
00002E9E  48E7 FFFC               2347      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002EA2  4EB8 28AE               2348      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002EA6  4EB8 28B2               2349      JSR         EA_DEFAULT_COMBO    ; Mode: D6, register: D7
00002EAA  41F9 00002EB8           2350      LEA         ADDA_MODE, A0       ; Set index '0' for jump table
00002EB0  CCFC 0006               2351      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002EB4  4EF0 6000               2352      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002EB8                          2353  ADDA_MODE:
00002EB8  4EF9 00002EE8           2354      JMP         ADDA_MODE_000       ; Dn
00002EBE  4EF9 00002EF2           2355      JMP         ADDA_MODE_001       ; An
00002EC4  4EF9 00002EFC           2356      JMP         ADDA_MODE_010       ; (An)
00002ECA  4EF9 00002F06           2357      JMP         ADDA_MODE_011       ; (An)+
00002ED0  4EF9 00002F10           2358      JMP         ADDA_MODE_100       ; -(An)
00002ED6  4EF9 00002F1A           2359      JMP         ADDA_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00002EDC  4EF9 00002F20           2360      JMP         ADDA_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002EE2  4EF9 00002F26           2361      JMP         ADDA_MODE_111       ; The rest (not all valid, validated by register number)
00002EE8                          2362  ADDA_MODE_000: ; Dn
00002EE8  4EB8 2910               2363      JSR         EA_PRINT_DN         ; Print data register direct operand
00002EEC  4EF9 00002F70           2364      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002EF2                          2365  ADDA_MODE_001: ; An
00002EF2  4EB8 29B0               2366      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002EF6  4EF9 00002F70           2367      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002EFC                          2368  ADDA_MODE_010: ; (An)
00002EFC  4EB8 2A50               2369      JSR         EA_PRINT_IND         ; Print address register indirect
00002F00  4EF9 00002F70           2370      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002F06                          2371  ADDA_MODE_011: ; (An)+
00002F06  4EB8 2B2A               2372      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002F0A  4EF9 00002F70           2373      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002F10                          2374  ADDA_MODE_100: ; -(An)
00002F10  4EB8 2BEE               2375      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002F14  4EF9 00002F70           2376      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002F1A                          2377  ADDA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002F1A  4EF9 00002F66           2378      JMP         ADDA_MODE_INVALID
00002F20                          2379  ADDA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002F20  4EF9 00002F66           2380      JMP         ADDA_MODE_INVALID
00002F26                          2381  ADDA_MODE_111: ; The rest (not all valid, validated by register number)
00002F26  BE3C 0000               2382      CMP.B       #$00, D7            ; Test for absolute word address
00002F2A  6700 0018               2383      BEQ         ADDA_ABS_W
00002F2E  BE3C 0001               2384      CMP.B       #$01, D7            ; Test for absolute long address
00002F32  6700 001A               2385      BEQ         ADDA_ABS_L
00002F36  BE3C 0004               2386      CMP.B       #$04, D7            ; Test for immediate data
00002F3A  6700 001C               2387      BEQ         ADDA_IMM
00002F3E  4EF9 00002F66           2388      JMP         ADDA_MODE_INVALID   ; Else, invalid
00002F44                          2389  ADDA_ABS_W:
00002F44  4EB8 2CC2               2390      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002F48  4EF9 00002F70           2391      JMP         ADDA_MODE_END
00002F4E                          2392  ADDA_ABS_L:
00002F4E  4EB8 2CB2               2393      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002F52  4EF9 00002F70           2394      JMP         ADDA_MODE_END
00002F58                          2395  ADDA_IMM:
00002F58  4EB8 28D8               2396      JSR         EA_OPMODE_COMBO     ; Get opmode bits in
00002F5C  4EB8 2B08               2397      JSR         EA_PRINT_IMM        ; Print immediate data
00002F60  4EF9 00002F70           2398      JMP         ADDA_MODE_END
00002F66                          2399  ADDA_MODE_INVALID:
00002F66  4EB8 288A               2400      JSR         EA_INVALID          ; Opcode word is Invalid
00002F6A  4EF9 00002F84           2401      JMP         ADDA_END
00002F70                          2402  ADDA_MODE_END:
00002F70  49F9 000048C4           2403      LEA         COMMA, A4        ; Print comma
00002F76  4EB9 000043EA           2404      JSR         WRITE2MEM
00002F7C  4EB8 28D8               2405      JSR         EA_OPMODE_COMBO     ; Opmode: D6, register: D7
00002F80  4EB8 29B0               2406      JSR         EA_PRINT_AN         ; Print address register
00002F84                          2407  ADDA_END:
00002F84  4EB8 28A2               2408      JSR         EA_UPDATE_POINTER   ; Update global pointer
00002F88  4CDF 3FFF               2409      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002F8C  4E75                    2410      RTS
00002F8E                          2411  
00002F8E                          2412  EA_ADDI:
00002F8E  48E7 FFFC               2413      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002F92  4EB8 28AE               2414      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002F96  4EB8 28FE               2415      JSR         EA_SIZE_BITS        ; get size bits in D7
00002F9A  BE3C 0000               2416      CMP.B       #$00, D7            ; Test if size: byte
00002F9E  6700 001C               2417      BEQ         ADDI_B
00002FA2  BE3C 0001               2418      CMP.B       #$01, D7            ; Test if size: word
00002FA6  6700 002E               2419      BEQ         ADDI_W
00002FAA  BE3C 0002               2420      CMP.B       #$02, D7            ; Test if size: long
00002FAE  6700 0034               2421      BEQ         ADDI_L
00002FB2  4EB8 288A               2422      JSR         EA_INVALID          ; Else, invalid
00002FB6  4EF9 000030A0           2423      JMP         ADDI_END
00002FBC                          2424  ADDI_B:
00002FBC  548D                    2425      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002FBE  4280                    2426      CLR.L       D0
00002FC0  3015                    2427      MOVE.W      (A5), D0            ; read next word in memory and save
00002FC2  143C 0008               2428      MOVE.B      #8, D2              ; Clear upper 8 bits of operand word
00002FC6  E568                    2429      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00002FC8  143C 0008               2430      MOVE.B      #8, D2             ; 'Right-align' bits 0-7 to get value
00002FCC  E468                    2431      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00002FCE                          2432      *print data
00002FCE  548D                    2433      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
00002FD0  4EF9 00002FEA           2434      JMP         ADDI_GET_DEST
00002FD6                          2435  ADDI_W:
00002FD6  548D                    2436      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002FD8  4280                    2437      CLR.L       D0
00002FDA  3015                    2438      MOVE.W      (A5), D0            ; read next word in memory and save
00002FDC                          2439      *print data
00002FDC  548D                    2440      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
00002FDE  4EF9 00002FEA           2441      JMP         ADDI_GET_DEST
00002FE4                          2442  ADDI_L:
00002FE4  548D                    2443      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002FE6  2015                    2444      MOVE.L      (A5), D0            ; read next two words in memory and save
00002FE8  588D                    2445      ADDA.L      #$00000004, A5      ; Increment A5 past operand longword
00002FEA                          2446  ADDI_GET_DEST:
00002FEA                          2447      *PRINT COMMA
00002FEA  4EB8 28B2               2448      JSR         EA_DEFAULT_COMBO    ; get mode bits in D6, register bits in D7
00002FEE  41F9 00002FFC           2449      LEA         ADDI_MODE, A0       ; Set index '0' for jump table
00002FF4  CCFC 0006               2450      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002FF8  4EF0 6000               2451      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002FFC                          2452  ADDI_MODE:
00002FFC  4EF9 0000302C           2453      JMP         ADDI_MODE_000       ; Dn
00003002  4EF9 00003036           2454      JMP         ADDI_MODE_001       ; Invalid: An
00003008  4EF9 00003040           2455      JMP         ADDI_MODE_010       ; (An)
0000300E  4EF9 0000304A           2456      JMP         ADDI_MODE_011       ; (An)+
00003014  4EF9 00003054           2457      JMP         ADDI_MODE_100       ; -(An)
0000301A  4EF9 0000305E           2458      JMP         ADDI_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00003020  4EF9 00003068           2459      JMP         ADDI_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003026  4EF9 00003072           2460      JMP         ADDI_MODE_111       ; The rest (not all valid, validated by register number)
0000302C                          2461  ADDI_MODE_000: ; Dn
0000302C  4EB8 2910               2462      JSR         EA_PRINT_DN         ; Print data register direct operand
00003030  4EF9 000030A0           2463      JMP         ADDI_END
00003036                          2464  ADDI_MODE_001: ; Invalid: An
00003036  4EB8 288A               2465      JSR         EA_INVALID          ; Opcode word is Invalid
0000303A  4EF9 000030A0           2466      JMP         ADDI_END
00003040                          2467  ADDI_MODE_010: ; (An)
00003040  4EB8 2A50               2468      JSR         EA_PRINT_IND         ; Print address register indirect
00003044  4EF9 000030A0           2469      JMP         ADDI_END            ; End evaluation of ea mode
0000304A                          2470  ADDI_MODE_011: ; (An)+
0000304A  4EB8 2B2A               2471      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000304E  4EF9 000030A0           2472      JMP         ADDI_END            ; End evaluation of ea mode
00003054                          2473  ADDI_MODE_100: ; -(An)
00003054  4EB8 2BEE               2474      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003058  4EF9 000030A0           2475      JMP         ADDI_END            ; End evaluation of ea mode
0000305E                          2476  ADDI_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000305E  4EB8 288A               2477      JSR         EA_INVALID          ; Opcode word is Invalid
00003062  4EF9 000030A0           2478      JMP         ADDI_END
00003068                          2479  ADDI_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003068  4EB8 288A               2480      JSR         EA_INVALID          ; Opcode word is Invalid
0000306C  4EF9 000030A0           2481      JMP         ADDI_END
00003072                          2482  ADDI_MODE_111: ; The rest (not all valid, validated by register number)
00003072  BE3C 0000               2483      CMP.B       #$00, D7            ; Test for absolute word address
00003076  6700 0014               2484      BEQ         ADDI_ABS_W
0000307A  BE3C 0001               2485      CMP.B       #$01, D7            ; Test for absolute long address
0000307E  6700 0016               2486      BEQ         ADDI_ABS_L
00003082  4EB8 288A               2487      JSR         EA_INVALID          ; else, invalid
00003086  4EF9 000030A0           2488      JMP         ADDI_END
0000308C                          2489  ADDI_ABS_W:
0000308C  4EB8 2CC2               2490      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003090  4EF9 000030A0           2491      JMP         ADDI_END
00003096                          2492  ADDI_ABS_L:
00003096  4EB8 2CB2               2493      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000309A  4EF9 000030A0           2494      JMP         ADDI_END
000030A0                          2495  ADDI_END:
000030A0  4EB8 28A2               2496      JSR         EA_UPDATE_POINTER   ; Update global pointer
000030A4  4CDF 3FFF               2497      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000030A8  4E75                    2498      RTS
000030AA                          2499  EA_ADDQ:
000030AA  48E7 FFFC               2500      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000030AE  4EB8 28AE               2501      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000030B2  2216                    2502      MOVE.L      (A6), D1            ; Load opcode to data register 1
000030B4  143C 0004               2503      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
000030B8  E569                    2504      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000030BA  143C 000D               2505      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine mode bits
000030BE  E469                    2506      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000030C0  B23C 0000               2507      CMP.B       #$00, D1            ; Check for special case (if imm. data is 0, value is actually 8)
000030C4  6600 0006               2508      BNE         ADDQ_PRINT_IMM      ; If any value other than 0, print the data
000030C8  123C 0008               2509      MOVE.B      #$08, D1            ; Else, the value is 0 and therefore symbolic of the value 8, so replace with the value 8
000030CC                          2510  ADDQ_PRINT_IMM:
000030CC  49F9 000048BE           2511      LEA         POUND, A4         ; Print '#'
000030D2  4EB9 000043EA           2512      JSR         WRITE2MEM
000030D8  4EB8 2894               2513      JSR         EA_PRINT_DATA
000030DC  49F9 000048C4           2514      LEA         COMMA, A4        ; Print comma
000030E2  4EB9 000043EA           2515      JSR         WRITE2MEM
000030E8  4EB8 28B2               2516      JSR         EA_DEFAULT_COMBO
000030EC  41F9 000030FA           2517      LEA         ADDQ_MODE, A0       ; Set index '0' for jump table
000030F2  CCFC 0006               2518      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000030F6  4EF0 6000               2519      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000030FA                          2520  ADDQ_MODE:
000030FA  4EF9 0000312A           2521      JMP         ADDQ_MODE_000       ; Dn
00003100  4EF9 00003134           2522      JMP         ADDQ_MODE_001       ; An
00003106  4EF9 0000313E           2523      JMP         ADDQ_MODE_010       ; (An)
0000310C  4EF9 00003148           2524      JMP         ADDQ_MODE_011       ; (An)+
00003112  4EF9 00003152           2525      JMP         ADDQ_MODE_100       ; -(An)
00003118  4EF9 0000315C           2526      JMP         ADDQ_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
0000311E  4EF9 00003166           2527      JMP         ADDQ_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003124  4EF9 00003170           2528      JMP         ADDQ_MODE_111       ; The rest (not all valid, validated by register number)
0000312A                          2529  ADDQ_MODE_000: ; Dn
0000312A  4EB8 2910               2530      JSR         EA_PRINT_DN         ; Print data register direct operand
0000312E  4EF9 0000319E           2531      JMP         ADDQ_END            ; End evaluation of ea mode
00003134                          2532  ADDQ_MODE_001: ; An
00003134  4EB8 29B0               2533      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00003138  4EF9 0000319E           2534      JMP         ADDQ_END            ; End evaluation of ea mode
0000313E                          2535  ADDQ_MODE_010: ; (An)
0000313E  4EB8 2A50               2536      JSR         EA_PRINT_IND         ; Print address register indirect
00003142  4EF9 0000319E           2537      JMP         ADDQ_END            ; End evaluation of ea mode
00003148                          2538  ADDQ_MODE_011: ; (An)+
00003148  4EB8 2B2A               2539      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000314C  4EF9 0000319E           2540      JMP         ADDQ_END            ; End evaluation of ea mode
00003152                          2541  ADDQ_MODE_100: ; -(An)
00003152  4EB8 2BEE               2542      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003156  4EF9 0000319E           2543      JMP         ADDQ_END            ; End evaluation of ea mode
0000315C                          2544  ADDQ_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000315C  4EB8 288A               2545      JSR         EA_INVALID          ; Opcode word is Invalid
00003160  4EF9 0000319E           2546      JMP         ADDQ_END
00003166                          2547  ADDQ_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003166  4EB8 288A               2548      JSR         EA_INVALID          ; Opcode word is Invalid
0000316A  4EF9 0000319E           2549      JMP         ADDQ_END
00003170                          2550  ADDQ_MODE_111: ; The rest (not all valid, validated by register number)
00003170  BE3C 0000               2551      CMP.B       #$00, D7            ; Test for absolute word address
00003174  6700 0014               2552      BEQ         ADDQ_ABS_W
00003178  BE3C 0001               2553      CMP.B       #$01, D7            ; Test for absolute long address
0000317C  6700 0016               2554      BEQ         ADDQ_ABS_L
00003180  4EB8 288A               2555      JSR         EA_INVALID          ; Opcode word is Invalid
00003184  4EF9 0000319E           2556      JMP         ADDQ_END
0000318A                          2557  ADDQ_ABS_W:
0000318A  4EB8 2CC2               2558      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000318E  4EF9 0000319E           2559      JMP         ADDQ_END
00003194                          2560  ADDQ_ABS_L:
00003194  4EB8 2CB2               2561      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003198  4EF9 0000319E           2562      JMP         ADDQ_END
0000319E                          2563  
0000319E                          2564  ADDQ_END:
0000319E  4EB8 28A2               2565      JSR         EA_UPDATE_POINTER   ; Update global pointer
000031A2  4CDF 3FFF               2566      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000031A6  4E75                    2567      RTS
000031A8                          2568  EA_AND:
000031A8  48E7 FFFC               2569      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000031AC  4EB8 28AE               2570      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000031B0  4EB8 28D8               2571      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
000031B4  41F8 2CEC               2572      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
000031B8  CCFC 0006               2573      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000031BC  4EF0 6000               2574      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000031C0                          2575  AND_OPMODE:
000031C0  4EF9 000031F0           2576      JMP         AND_OPMODE_000      ; mode 1, byte
000031C6  4EF9 000031FA           2577      JMP         AND_OPMODE_001      ; mode 1, word
000031CC  4EF9 00003204           2578      JMP         AND_OPMODE_010      ; mode 1, long
000031D2  4EF9 0000320E           2579      JMP         AND_OPMODE_011      ; Invalid value
000031D8  4EF9 00003218           2580      JMP         AND_OPMODE_100      ; mode 2, byte
000031DE  4EF9 00003222           2581      JMP         AND_OPMODE_101      ; mode 2, word
000031E4  4EF9 0000322C           2582      JMP         AND_OPMODE_110      ; mode 2, long
000031EA  4EF9 00003236           2583      JMP         AND_OPMODE_111      ; Invalid value
000031F0                          2584  AND_OPMODE_000: ; mode 1, byte
000031F0  1A3C 0001               2585      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
000031F4  4EF9 00003240           2586      JMP         AND_MODE_1
000031FA                          2587  AND_OPMODE_001: ; mode 1, word
000031FA  1A3C 0002               2588      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
000031FE  4EF9 00003240           2589      JMP         AND_MODE_1
00003204                          2590  AND_OPMODE_010: ; mode 1, long
00003204  1A3C 0003               2591      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00003208  4EF9 00003240           2592      JMP         AND_MODE_1
0000320E                          2593  AND_OPMODE_011: ; Invalid value
0000320E  4EB8 288A               2594      JSR         EA_INVALID
00003212  4EF9 0000335C           2595      JMP         AND_END
00003218                          2596  AND_OPMODE_100: ; mode 2, byte
00003218  1A3C 0001               2597      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000321C  4EF9 0000326A           2598      JMP         AND_MODE_2
00003222                          2599  AND_OPMODE_101: ; mode 2, word
00003222  1A3C 0001               2600      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003226  4EF9 0000326A           2601      JMP         AND_MODE_2
0000322C                          2602  AND_OPMODE_110: ; mode 2, long
0000322C  1A3C 0001               2603      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003230  4EF9 0000326A           2604      JMP         AND_MODE_2
00003236                          2605  AND_OPMODE_111: ; Invalid value
00003236  4EB8 288A               2606      JSR         EA_INVALID
0000323A  4EF9 0000335C           2607      JMP         AND_END
00003240                          2608  AND_MODE_1:
00003240  4280                    2609      CLR.L       D0                  ; Clear data register 0
00003242  103C 0001               2610      MOVE.B      #1, D0              ; Save mode number to D0
00003246  3207                    2611      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003248  4EB8 28B2               2612      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
0000324C  4EB9 00003290           2613      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
00003252  49F9 000048C4           2614      LEA         COMMA, A4        ; Print comma
00003258  4EB9 000043EA           2615      JSR         WRITE2MEM
0000325E  3E01                    2616      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003260  4EB8 2910               2617      JSR         EA_PRINT_DN         ; Print data register
00003264  4EF9 0000335C           2618      JMP         AND_END
0000326A                          2619  AND_MODE_2:
0000326A  4280                    2620      CLR.L       D0                  ; Clear data register 0
0000326C  103C 0002               2621      MOVE.B      #2, D0              ; Save mode number to D0
00003270  4EB8 2910               2622      JSR         EA_PRINT_DN         ; Print data register
00003274  49F9 000048C4           2623      LEA         COMMA, A4        ; Print comma
0000327A  4EB9 000043EA           2624      JSR         WRITE2MEM
00003280  4EB8 28B2               2625      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003284  4EB9 00003290           2626      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
0000328A  4EF9 0000335C           2627      JMP         AND_END
00003290                          2628  AND_EVAL_EA:
00003290  41F9 0000329E           2629      LEA         AND_MODE, A0        ; Set index '0' for jump table
00003296  CCFC 0006               2630      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000329A  4EF0 6000               2631      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000329E                          2632  AND_MODE:
0000329E  4EF9 000032CE           2633      JMP         AND_MODE_000        ; Dn (invalid if opmode 2)
000032A4  4EF9 000032E0           2634      JMP         AND_MODE_001        ; Invalid: An
000032AA  4EF9 000032E6           2635      JMP         AND_MODE_010        ; (An)
000032B0  4EF9 000032F0           2636      JMP         AND_MODE_011        ; (An)+
000032B6  4EF9 000032FA           2637      JMP         AND_MODE_100        ; -(An)
000032BC  4EF9 00003304           2638      JMP         AND_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000032C2  4EF9 0000330A           2639      JMP         AND_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000032C8  4EF9 00003310           2640      JMP         AND_MODE_111        ; The rest (not all valid, validated by register number)
000032CE                          2641  AND_MODE_000: ; Dn (invalid if opmode 2)
000032CE  B07C 0002               2642      CMP         #2, D0
000032D2  6700 0082               2643      BEQ         AND_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
000032D6  4EB8 2910               2644      JSR         EA_PRINT_DN         ; Print data register direct operand
000032DA  4EF9 00003354           2645      JMP         AND_MODE_END        ; End evaluation of ea mode
000032E0                          2646  AND_MODE_001: ; Invalid: An
000032E0  4EF9 00003356           2647      JMP         AND_MODE_INVALID
000032E6                          2648  AND_MODE_010: ; (An)
000032E6  4EB8 2A50               2649      JSR         EA_PRINT_IND         ; Print address register indirect
000032EA  4EF9 00003354           2650      JMP         AND_MODE_END        ; End evaluation of ea mode
000032F0                          2651  AND_MODE_011: ; (An)+
000032F0  4EB8 2B2A               2652      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000032F4  4EF9 00003354           2653      JMP         AND_MODE_END        ; End evaluation of ea mode
000032FA                          2654  AND_MODE_100: ; -(An)
000032FA  4EB8 2BEE               2655      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000032FE  4EF9 00003354           2656      JMP         AND_MODE_END        ; End evaluation of ea mode
00003304                          2657  AND_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003304  4EF9 00003356           2658      JMP         AND_MODE_INVALID
0000330A                          2659  AND_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000330A  4EF9 00003356           2660      JMP         AND_MODE_INVALID
00003310                          2661  AND_MODE_111: ; The rest (not all valid, validated by register number)
00003310  BE3C 0000               2662      CMP.B       #$00, D7            ; Test for absolute word address
00003314  6700 0018               2663      BEQ         AND_ABS_W
00003318  BE3C 0001               2664      CMP.B       #$01, D7            ; Test for absolute long address
0000331C  6700 001A               2665      BEQ         AND_ABS_L
00003320  BE3C 0004               2666      CMP.B       #$04, D7            ; Test for immediate data
00003324  6700 001C               2667      BEQ         AND_IMM
00003328  4EF9 00003356           2668      JMP         AND_MODE_INVALID    ; else, invalid
0000332E                          2669  AND_ABS_W:
0000332E  4EB8 2CC2               2670      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003332  4EF9 00003354           2671      JMP         AND_MODE_END
00003338                          2672  AND_ABS_L:
00003338  4EB8 2CB2               2673      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000333C  4EF9 00003354           2674      JMP         AND_MODE_END
00003342                          2675  AND_IMM: ; invalid if opmode is 2
00003342  B07C 0002               2676      CMP         #2, D0
00003346  6700 000E               2677      BEQ         AND_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
0000334A  4EB8 2B08               2678      JSR         EA_PRINT_IMM        ; Print immediate data
0000334E  4EF9 00003354           2679      JMP         AND_MODE_END
00003354                          2680  AND_MODE_END:
00003354  4E75                    2681      RTS                             ; Finish evaluating EA bits
00003356                          2682  AND_MODE_INVALID:
00003356  4EB8 288A               2683      JSR         EA_INVALID          ; Opcode word is Invalid
0000335A  4E75                    2684      RTS                             ; Finish evaluating EA bits
0000335C                          2685  AND_END:
0000335C  4EB8 28A2               2686      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003360  4CDF 3FFF               2687      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003364  4E75                    2688      RTS
00003366                          2689  EA_ASd:
00003366  48E7 FFFC               2690      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000336A  4EB8 28AE               2691      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000336E  4EB8 28FE               2692      JSR         EA_SIZE_BITS        ; get size bits in D7
00003372  BE3C 0003               2693      CMP.B       #$03, D7            ; test if memory shift
00003376  6700 005E               2694      BEQ         ASd_MEM
0000337A  6000 0002               2695      BRA         ASd_REG             ; else, register shfit
0000337E                          2696  ASd_REG:
0000337E  3E16                    2697      MOVE.W      (A6), D7            ; read opcode word in memory and save,
00003380                          2698                                      ; (using D7 because EA_PRINT_DN uses D7)
00003380  143C 0004               2699      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
00003384  E56F                    2700      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003386  143C 000D               2701      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
0000338A  E46F                    2702      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
0000338C  3016                    2703      MOVE.W      (A6), D0            ; read opcode word in memory and save
0000338E  143C 000A               2704      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
00003392  E568                    2705      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00003394  143C 000F               2706      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
00003398  E468                    2707      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
0000339A  B03C 0000               2708      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
0000339E  6700 000C               2709      BEQ         ASd_REG_COUNT
000033A2                          2710  ASd_REG_REG:                        ; Else, count/register field contains register number
000033A2  4EB8 2910               2711      JSR         EA_PRINT_DN         ; Print register value, stored in D7
000033A6  4EF9 000033BC           2712      JMP         ASd_REG_END         ; Jump to end of ASd_REG
000033AC                          2713  ASd_REG_COUNT:
000033AC  49F9 000048BE           2714      LEA         POUND, A4        ; Print '#'
000033B2  4EB9 000043EA           2715      JSR         WRITE2MEM
000033B8  4EB8 2894               2716      JSR         EA_PRINT_DATA *print hex value in D7 as byte todo, continue on to ASd_REG_END
000033BC                          2717  ASd_REG_END:
000033BC  49F9 000048C4           2718      LEA         COMMA, A4        ; Print comma
000033C2  4EB9 000043EA           2719      JSR         WRITE2MEM
000033C8  4EB8 28B2               2720      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
000033CC  4EB8 2910               2721      JSR         EA_PRINT_DN         ; Print register value in D7
000033D0  4EF9 0000348C           2722      JMP         ASd_END
000033D6                          2723  ASd_MEM:
000033D6  4EB8 28B2               2724      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000033DA  41F9 000033E8           2725      LEA         ASd_MEM_MODE, A0    ; Set index '0' for jump table
000033E0  CCFC 0006               2726      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000033E4  4EF0 6000               2727      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000033E8                          2728  ASd_MEM_MODE:
000033E8  4EF9 00003418           2729      JMP         ASd_MEM_MODE_000     ; Invalid: Dn
000033EE  4EF9 00003422           2730      JMP         ASd_MEM_MODE_001     ; Invalid: An
000033F4  4EF9 0000342C           2731      JMP         ASd_MEM_MODE_010     ; (An)
000033FA  4EF9 00003436           2732      JMP         ASd_MEM_MODE_011     ; (An)+
00003400  4EF9 00003440           2733      JMP         ASd_MEM_MODE_100     ; -(An)
00003406  4EF9 0000344A           2734      JMP         ASd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
0000340C  4EF9 00003454           2735      JMP         ASd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003412  4EF9 0000345E           2736      JMP         ASd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00003418                          2737  ASd_MEM_MODE_000: ; Invalid: Dn
00003418  4EB8 288A               2738      JSR         EA_INVALID          ; Data register direct is invalid mode
0000341C  4EF9 0000348C           2739      JMP         ASd_END
00003422                          2740  ASd_MEM_MODE_001: ; Invalid: An
00003422  4EB8 288A               2741      JSR         EA_INVALID          ; Address register direct is invalid mode
00003426  4EF9 0000348C           2742      JMP         ASd_END
0000342C                          2743  ASd_MEM_MODE_010: ; (An)
0000342C  4EB8 2A50               2744      JSR         EA_PRINT_IND         ; Print address register indirect
00003430  4EF9 0000348C           2745      JMP         ASd_END
00003436                          2746  ASd_MEM_MODE_011: ; (An)+
00003436  4EB8 2B2A               2747      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000343A  4EF9 0000348C           2748      JMP         ASd_END
00003440                          2749  ASd_MEM_MODE_100: ; -(An)
00003440  4EB8 2BEE               2750      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003444  4EF9 0000348C           2751      JMP         ASd_END         ; Continue with parsing destination operand
0000344A                          2752  ASd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000344A  4EB8 288A               2753      JSR         EA_INVALID          ; Opcode word is Invalid
0000344E  4EF9 0000348C           2754      JMP         ASd_END
00003454                          2755  ASd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003454  4EB8 288A               2756      JSR         EA_INVALID          ; Opcode word is Invalid
00003458  4EF9 0000348C           2757      JMP         ASd_END
0000345E                          2758  ASd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
0000345E  BE3C 0000               2759      CMP.B       #$00, D7            ; Test for absolute word address
00003462  6700 0014               2760      BEQ         ASd_MEM_ABS_W
00003466  BE3C 0001               2761      CMP.B       #$01, D7            ; Test for absolute long address
0000346A  6700 0016               2762      BEQ         ASd_MEM_ABS_L
0000346E  4EB8 288A               2763      JSR         EA_INVALID          ; Else: invalid
00003472  4EF9 0000348C           2764      JMP         ASd_END
00003478                          2765  ASd_MEM_ABS_W:
00003478  4EB8 2CC2               2766      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000347C  4EF9 0000348C           2767      JMP         ASd_END
00003482                          2768  ASd_MEM_ABS_L:
00003482  4EB8 2CB2               2769      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003486  4EF9 0000348C           2770      JMP         ASd_END
0000348C                          2771  ASd_END:
0000348C  4EB8 28A2               2772      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003490  4CDF 3FFF               2773      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003494  4E75                    2774      RTS
00003496                          2775  EA_Bcc:
00003496  48E7 FFFC               2776      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000349A  4EB8 28AE               2777      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000349E  2216                    2778      MOVE.L      (A6), D1            ; Load opcode to data register 1
000034A0  143C 0008               2779      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
000034A4  E569                    2780      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000034A6  143C 0008               2781      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine condition
000034AA  E469                    2782      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000034AC                          2783      *save ultimate address to be printed
000034AC  284E                    2784      MOVEA.L     A6, A4              ; Copy global pointer for dislay
000034AE  B23C 0000               2785      CMP.B       #$00, D1            ; If value is zero, real value is next word in memory
000034B2  6700 0034               2786      BEQ         BCC_W
000034B6  B23C 00FF               2787      CMP.B       #$FF, D1            ; If value is FF, real value is next longword
000034BA  6700 004E               2788      BEQ         BCC_L
000034BE  4EF9 000034C4           2789      JMP         BCC_B               ; Else, parse lower-order byte of opcode word
000034C4                          2790  BCC_B:
000034C4  548C                    2791      ADDA.L      #$00000002, A4      ; Increment display pointer past opcode word
000034C6  3616                    2792      MOVE.W      (A6), D3            ; Save opcode word
000034C8  143C 0008               2793      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
000034CC  E56B                    2794      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
000034CE  143C 000F               2795      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
000034D2  E46B                    2796      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
000034D4  B63C 0000               2797      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
000034D8  6700 003E               2798      BEQ         BCC_DISPLAY
000034DC  0681 FFFFFF00           2799      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
000034E2  4EF9 00003518           2800      JMP         BCC_DISPLAY
000034E8                          2801  BCC_W:
000034E8  588C                    2802      ADDA.L      #$00000004, A4      ; Increment display pointer past opcode word
000034EA                          2803                                      ; and displacement word in memory
000034EA  548D                    2804      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
000034EC  3615                    2805      MOVE.W      (A5), D3            ; Read word displacement from memory
000034EE  548D                    2806      ADDA.L      #$00000002, A5      ; Increment A5 past word read
000034F0  143C 000F               2807      MOVE.B      #15, D2             ; 'Right-align' bit 15 to determine MSB
000034F4  E46B                    2808      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
000034F6  B63C 0000               2809      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
000034FA  6700 001C               2810      BEQ         BCC_DISPLAY
000034FE  0681 FFFF0000           2811      ADD.L       #$FFFF0000, D1      ; Else, sign extend data with F
00003504  4EF9 00003518           2812      JMP         BCC_DISPLAY
0000350A                          2813  BCC_L:
0000350A  5C8C                    2814      ADDA.L      #$00000006, A4      ; Increment display pointer past opcode word
0000350C                          2815                                      ; and displacement longword in memory
0000350C  548D                    2816      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
0000350E  2215                    2817      MOVE.L      (A5), D1            ; Read longword displacement from memory
00003510  588D                    2818      ADDA.L      #$00000004, A5      ; Increment A5 past longword read
00003512  4EF9 00003518           2819      JMP         BCC_DISPLAY
00003518                          2820  BCC_DISPLAY:
00003518  D9C1                    2821      ADDA.L      D1, A4              ; add displacement to current addressing
0000351A                          2822      *print address in A4
0000351A  4EB8 28A2               2823      JSR         EA_UPDATE_POINTER   ; Updates global pointer
0000351E  4CDF 3FFF               2824      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003522  4E75                    2825      RTS
00003524                          2826  EA_CLR:
00003524  48E7 FFFC               2827      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003528  4EB8 28AE               2828      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
0000352C  4EB8 28B2               2829      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003530  41F9 0000353E           2830      LEA         CLR_MODE, A0        ; Set index '0' for jump table
00003536  CCFC 0006               2831      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000353A  4EF0 6000               2832      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000353E                          2833  CLR_MODE:
0000353E  4EF9 0000356E           2834      JMP         CLR_MODE_000        ; Dn
00003544  4EF9 00003578           2835      JMP         CLR_MODE_001        ; Invalid: An
0000354A  4EF9 00003582           2836      JMP         CLR_MODE_010        ; (An)
00003550  4EF9 0000358C           2837      JMP         CLR_MODE_011        ; (An)+
00003556  4EF9 00003596           2838      JMP         CLR_MODE_100        ; -(An)
0000355C  4EF9 000035A0           2839      JMP         CLR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003562  4EF9 000035AA           2840      JMP         CLR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003568  4EF9 000035B4           2841      JMP         CLR_MODE_111        ; The rest (not all valid, validated by register number)
0000356E                          2842  CLR_MODE_000: ; Dn
0000356E  4EB8 2910               2843      JSR         EA_PRINT_DN
00003572  4EF9 000035E2           2844      JMP         CLR_END
00003578                          2845  CLR_MODE_001: ; Invalid: An
00003578  4EB8 288A               2846      JSR         EA_INVALID          ; Address register direct is invalid mode
0000357C  4EF9 000035E2           2847      JMP         CLR_END
00003582                          2848  CLR_MODE_010: ; (An)
00003582  4EB8 2A50               2849      JSR         EA_PRINT_IND         ; Print address register indirect
00003586  4EF9 000035E2           2850      JMP         CLR_END
0000358C                          2851  CLR_MODE_011: ; (An)+
0000358C  4EB8 2B2A               2852      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003590  4EF9 000035E2           2853      JMP         CLR_END
00003596                          2854  CLR_MODE_100: ; -(An)
00003596  4EB8 2BEE               2855      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000359A  4EF9 000035E2           2856      JMP         CLR_END             ; Continue with parsing destination operand
000035A0                          2857  CLR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000035A0  4EB8 288A               2858      JSR         EA_INVALID          ; Opcode word is Invalid
000035A4  4EF9 000035E2           2859      JMP         CLR_END
000035AA                          2860  CLR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000035AA  4EB8 288A               2861      JSR         EA_INVALID          ; Opcode word is Invalid
000035AE  4EF9 000035E2           2862      JMP         CLR_END
000035B4                          2863  CLR_MODE_111: ; The rest (not all valid, validated by register number)
000035B4  BE3C 0000               2864      CMP.B       #$00, D7            ; Test for absolute word address
000035B8  6700 0014               2865      BEQ         CLR_ABS_W
000035BC  BE3C 0001               2866      CMP.B       #$01, D7            ; Test for absolute long address
000035C0  6700 0016               2867      BEQ         CLR_ABS_L
000035C4  4EB8 288A               2868      JSR         EA_INVALID          ; Else: invalid
000035C8  4EF9 000035E2           2869      JMP         CLR_END
000035CE                          2870  CLR_ABS_W:
000035CE  4EB8 2CC2               2871      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000035D2  4EF9 000035E2           2872      JMP         CLR_END
000035D8                          2873  CLR_ABS_L:
000035D8  4EB8 2CB2               2874      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000035DC  4EF9 000035E2           2875      JMP         CLR_END
000035E2                          2876  CLR_END:
000035E2  4EB8 28A2               2877      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000035E6  4CDF 3FFF               2878      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000035EA  4E75                    2879      RTS
000035EC                          2880  EA_CMP:
000035EC  48E7 FFFC               2881      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000035F0  4EB8 28AE               2882      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000035F4  4EB8 28B2               2883      JSR         EA_DEFAULT_COMBO
000035F8  41F9 00003606           2884      LEA         CMP_MODE, A0       ; Set index '0' for jump table
000035FE  CCFC 0006               2885      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003602  4EF0 6000               2886      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003606                          2887  CMP_MODE:
00003606  4EF9 00003636           2888      JMP         CMP_MODE_000       ; Dn
0000360C  4EF9 00003640           2889      JMP         CMP_MODE_001       ; An
00003612  4EF9 0000364A           2890      JMP         CMP_MODE_010       ; (An)
00003618  4EF9 00003654           2891      JMP         CMP_MODE_011       ; (An)+
0000361E  4EF9 0000365E           2892      JMP         CMP_MODE_100       ; -(An)
00003624  4EF9 00003668           2893      JMP         CMP_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
0000362A  4EF9 00003672           2894      JMP         CMP_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003630  4EF9 0000367C           2895      JMP         CMP_MODE_111       ; The rest (not all valid, validated by register number)
00003636                          2896  CMP_MODE_000: ; Dn
00003636  4EB8 2910               2897      JSR         EA_PRINT_DN         ; Print data register direct operand
0000363A  4EF9 000036AA           2898      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003640                          2899  CMP_MODE_001: ; An
00003640  4EB8 29B0               2900      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00003644  4EF9 000036AA           2901      JMP         CMP_MODE_END        ; End evaluation of ea mode
0000364A                          2902  CMP_MODE_010: ; (An)
0000364A  4EB8 2A50               2903      JSR         EA_PRINT_IND        ; Print address register indirect
0000364E  4EF9 000036AA           2904      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003654                          2905  CMP_MODE_011: ; (An)+
00003654  4EB8 2B2A               2906      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003658  4EF9 000036AA           2907      JMP         CMP_MODE_END        ; End evaluation of ea mode
0000365E                          2908  CMP_MODE_100: ; -(An)
0000365E  4EB8 2BEE               2909      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003662  4EF9 000036AA           2910      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003668                          2911  CMP_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003668  4EB8 288A               2912      JSR         EA_INVALID          ; Opcode word is Invalid
0000366C  4EF9 000036BE           2913      JMP         CMP_END
00003672                          2914  CMP_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003672  4EB8 288A               2915      JSR         EA_INVALID          ; Opcode word is Invalid
00003676  4EF9 000036BE           2916      JMP         CMP_END
0000367C                          2917  CMP_MODE_111: ; The rest (not all valid, validated by register number)
0000367C  BE3C 0000               2918      CMP.B       #$00, D7            ; Test for absolute word address
00003680  6700 0014               2919      BEQ         CMP_ABS_W
00003684  BE3C 0001               2920      CMP.B       #$01, D7            ; Test for absolute long address
00003688  6700 0016               2921      BEQ         CMP_ABS_L
0000368C  4EB8 288A               2922      JSR         EA_INVALID          ; Opcode word is Invalid
00003690  4EF9 000036BE           2923      JMP         CMP_END
00003696                          2924  CMP_ABS_W:
00003696  4EB8 2CC2               2925      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000369A  4EF9 000036AA           2926      JMP         CMP_MODE_END
000036A0                          2927  CMP_ABS_L:
000036A0  4EB8 2CB2               2928      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000036A4  4EF9 000036AA           2929      JMP         CMP_MODE_END
000036AA                          2930  CMP_MODE_END:
000036AA  49F9 000048C4           2931      LEA         COMMA, A4        ; Print comma
000036B0  4EB9 000043EA           2932      JSR         WRITE2MEM
000036B6  4EB8 28D8               2933      JSR         EA_OPMODE_COMBO     ; get register bits in D7, opmode bits not used
000036BA  4EB8 2910               2934      JSR         EA_PRINT_DN         ; print register
000036BE                          2935  CMP_END:
000036BE  4EB8 28A2               2936      JSR         EA_UPDATE_POINTER   ; Update global pointer
000036C2  4CDF 3FFF               2937      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000036C6  4E75                    2938      RTS
000036C8                          2939  EA_DIVU_W:
000036C8  48E7 FFFC               2940      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000036CC  4EB8 28AE               2941      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000036D0  4EB8 28B2               2942      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000036D4  41F9 000036E2           2943      LEA         DIVU_W_MODE, A0       ; Set index '0' for jump table
000036DA  CCFC 0006               2944      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000036DE  4EF0 6000               2945      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000036E2                          2946  DIVU_W_MODE:
000036E2  4EF9 00003712           2947      JMP         DIVU_W_MODE_000     ; Dn
000036E8  4EF9 0000371C           2948      JMP         DIVU_W_MODE_001     ; Invalid: An
000036EE  4EF9 00003726           2949      JMP         DIVU_W_MODE_010     ; (An)
000036F4  4EF9 00003730           2950      JMP         DIVU_W_MODE_011     ; (An)+
000036FA  4EF9 0000373A           2951      JMP         DIVU_W_MODE_100     ; -(An)
00003700  4EF9 00003744           2952      JMP         DIVU_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003706  4EF9 0000374E           2953      JMP         DIVU_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000370C  4EF9 00003758           2954      JMP         DIVU_W_MODE_111     ; The rest (not all valid, validated by register number)
00003712                          2955  DIVU_W_MODE_000: ; Dn
00003712  4EB8 2910               2956      JSR         EA_PRINT_DN         ; Print data register direct operand
00003716  4EF9 0000379C           2957      JMP         DIVU_W_DEST         ; Go to: print destination operand
0000371C                          2958  DIVU_W_MODE_001: ; Invalid: An
0000371C  4EB8 288A               2959      JSR         EA_INVALID          ; Address register direct is invalid mode
00003720  4EF9 000037AE           2960      JMP         DIVU_W_END
00003726                          2961  DIVU_W_MODE_010: ; (An)
00003726  4EB8 2A50               2962      JSR         EA_PRINT_IND         ; Print address register indirect
0000372A  4EF9 0000379C           2963      JMP         DIVU_W_DEST
00003730                          2964  DIVU_W_MODE_011: ; (An)+
00003730  4EB8 2B2A               2965      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003734  4EF9 0000379C           2966      JMP         DIVU_W_DEST
0000373A                          2967  DIVU_W_MODE_100: ; -(An)
0000373A  4EB8 2BEE               2968      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000373E  4EF9 0000379C           2969      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
00003744                          2970  DIVU_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003744  4EB8 288A               2971      JSR         EA_INVALID          ; Opcode word is Invalid
00003748  4EF9 000037AE           2972      JMP         DIVU_W_END
0000374E                          2973  DIVU_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000374E  4EB8 288A               2974      JSR         EA_INVALID          ; Opcode word is Invalid
00003752  4EF9 000037AE           2975      JMP         DIVU_W_END
00003758                          2976  DIVU_W_MODE_111: ; The rest (not all valid, validated by register number)
00003758  BE3C 0000               2977      CMP.B       #$00, D7            ; Test for absolute word address
0000375C  6700 001C               2978      BEQ         DIVU_W_ABS_W
00003760  BE3C 0001               2979      CMP.B       #$01, D7            ; Test for absolute long address
00003764  6700 001E               2980      BEQ         DIVU_W_ABS_L
00003768  BE3C 0004               2981      CMP.B       #$04, D7            ; Test for immediate data
0000376C  6700 0020               2982      BEQ         DIVU_W_IMM
00003770  4EB8 288A               2983      JSR         EA_INVALID          ; Else: invalid
00003774  4EF9 000037AE           2984      JMP         DIVU_W_END
0000377A                          2985  DIVU_W_ABS_W:
0000377A  4EB8 2CC2               2986      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000377E  4EF9 0000379C           2987      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
00003784                          2988  DIVU_W_ABS_L:
00003784  4EB8 2CB2               2989      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003788  4EF9 0000379C           2990      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
0000378E                          2991  DIVU_W_IMM:
0000378E  1A3C 0002               2992      MOVE.B      #2, D5              ; Size is word
00003792  4EB8 2B08               2993      JSR         EA_PRINT_IMM        ; Print immediate data
00003796  4EF9 0000379C           2994      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
0000379C                          2995  DIVU_W_DEST:
0000379C                          2996      *print COMMA
0000379C                          2997      *Get destination register
0000379C  3E16                    2998      MOVE.W      (A6), D7            ; Load word at current pointer to D1
0000379E  143C 0004               2999      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
000037A2  E56F                    3000      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000037A4  143C 000D               3001      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
000037A8  E46F                    3002      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000037AA  4EB8 2910               3003      JSR         EA_PRINT_DN         ; Print data register direct operand
000037AE                          3004  DIVU_W_END:
000037AE  4EB8 28A2               3005      JSR         EA_UPDATE_POINTER   ; Update global pointer
000037B2  4CDF 3FFF               3006      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000037B6  4E75                    3007      RTS
000037B8                          3008  EA_JSR:
000037B8  48E7 FFFC               3009      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000037BC  4EB8 28AE               3010      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000037C0  4EB8 28B2               3011      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000037C4  41F9 000037D2           3012      LEA         JSR_MODE, A0        ; Set index '0' for jump table
000037CA  CCFC 0006               3013      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000037CE  4EF0 6000               3014      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000037D2                          3015  JSR_MODE:
000037D2  4EF9 00003802           3016      JMP         JSR_MODE_000        ; Invalid: Dn
000037D8  4EF9 0000380C           3017      JMP         JSR_MODE_001        ; Invalid: An
000037DE  4EF9 00003816           3018      JMP         JSR_MODE_010        ; (An)
000037E4  4EF9 00003820           3019      JMP         JSR_MODE_011        ; Invalid: (An)+
000037EA  4EF9 0000382A           3020      JMP         JSR_MODE_100        ; Invalid: -(An)
000037F0  4EF9 00003834           3021      JMP         JSR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000037F6  4EF9 0000383E           3022      JMP         JSR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000037FC  4EF9 00003848           3023      JMP         JSR_MODE_111        ; The rest (not all valid, validated by register number)
00003802                          3024  JSR_MODE_000: ; Invalid: Dn
00003802  4EB8 288A               3025      JSR         EA_INVALID          ; Data register direct is invalid mode
00003806  4EF9 00003876           3026      JMP         JSR_END
0000380C                          3027  JSR_MODE_001: ; Invalid: An
0000380C  4EB8 288A               3028      JSR         EA_INVALID          ; Address register direct is invalid mode
00003810  4EF9 00003876           3029      JMP         JSR_END
00003816                          3030  JSR_MODE_010: ; (An)
00003816  4EB8 2A50               3031      JSR         EA_PRINT_IND         ; Print address register indirect
0000381A  4EF9 00003876           3032      JMP         JSR_END
00003820                          3033  JSR_MODE_011: ; (An)+
00003820  4EB8 288A               3034      JSR         EA_INVALID          ; Address register indirect w/ post increment is invalid mode
00003824  4EF9 00003876           3035      JMP         JSR_END
0000382A                          3036  JSR_MODE_100: ; -(An)
0000382A  4EB8 288A               3037      JSR         EA_INVALID          ; Address register indirect w/ pre decrement is invalid mode
0000382E  4EF9 00003876           3038      JMP         JSR_END
00003834                          3039  JSR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003834  4EB8 288A               3040      JSR         EA_INVALID          ; Opcode word is Invalid
00003838  4EF9 00003876           3041      JMP         JSR_END
0000383E                          3042  JSR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000383E  4EB8 288A               3043      JSR         EA_INVALID          ; Opcode word is Invalid
00003842  4EF9 00003876           3044      JMP         JSR_END
00003848                          3045  JSR_MODE_111: ; The rest (not all valid, validated by register number)
00003848  BE3C 0000               3046      CMP.B       #$00, D7            ; Test for absolute word address
0000384C  6700 0014               3047      BEQ         JSR_ABS_W
00003850  BE3C 0001               3048      CMP.B       #$01, D7            ; Test for absolute long address
00003854  6700 0016               3049      BEQ         JSR_ABS_L
00003858  4EB8 288A               3050      JSR         EA_INVALID          ; Else: invalid
0000385C  4EF9 00003876           3051      JMP         JSR_END
00003862                          3052  JSR_ABS_W:
00003862  4EB8 2CC2               3053      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003866  4EF9 00003876           3054      JMP         JSR_END
0000386C                          3055  JSR_ABS_L:
0000386C  4EB8 2CB2               3056      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003870  4EF9 00003876           3057      JMP         JSR_END
00003876                          3058  JSR_END:
00003876  4EB8 28A2               3059      JSR         EA_UPDATE_POINTER   ; Updates global pointer
0000387A  4CDF 3FFF               3060      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000387E  4E75                    3061      RTS
00003880                          3062  EA_LEA:
00003880  48E7 FFFC               3063      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003884  4EB8 28AE               3064      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003888  4EB8 28B2               3065      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
0000388C  41F9 0000389A           3066      LEA         LEA_MODE, A0        ; Set index '0' for jump table
00003892  CCFC 0006               3067      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003896  4EF0 6000               3068      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000389A                          3069  LEA_MODE:
0000389A  4EF9 000038CA           3070      JMP         LEA_MODE_000        ; Dn
000038A0  4EF9 000038D4           3071      JMP         LEA_MODE_001        ; Invalid: An
000038A6  4EF9 000038DE           3072      JMP         LEA_MODE_010        ; (An)
000038AC  4EF9 000038E8           3073      JMP         LEA_MODE_011        ; (An)+
000038B2  4EF9 000038F2           3074      JMP         LEA_MODE_100        ; -(An)
000038B8  4EF9 000038FC           3075      JMP         LEA_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000038BE  4EF9 00003906           3076      JMP         LEA_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000038C4  4EF9 00003910           3077      JMP         LEA_MODE_111        ; The rest (not all valid, validated by register number)
000038CA                          3078  LEA_MODE_000: ; Invalid: Dn
000038CA  4EB8 288A               3079      JSR         EA_INVALID          ; Data register direct is invalid mode
000038CE  4EF9 00003952           3080      JMP         LEA_END
000038D4                          3081  LEA_MODE_001: ; Invalid: An
000038D4  4EB8 288A               3082      JSR         EA_INVALID          ; Address register direct is invalid mode
000038D8  4EF9 00003952           3083      JMP         LEA_END
000038DE                          3084  LEA_MODE_010: ; (An)
000038DE  4EB8 2A50               3085      JSR         EA_PRINT_IND         ; Print address register indirect
000038E2  4EF9 0000393E           3086      JMP         LEA_DEST
000038E8                          3087  LEA_MODE_011: ; (An)+
000038E8  4EB8 288A               3088      JSR         EA_INVALID          ; Address register indirect with post increment is invalid
000038EC  4EF9 00003952           3089      JMP         LEA_END
000038F2                          3090  LEA_MODE_100: ; -(An)
000038F2  4EB8 288A               3091      JSR         EA_INVALID          ; Adress register indirect with pre decrement is invalid
000038F6  4EF9 00003952           3092      JMP         LEA_END             ; Continue with parsing destination operand
000038FC                          3093  LEA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000038FC  4EB8 288A               3094      JSR         EA_INVALID          ; Opcode word is Invalid
00003900  4EF9 00003952           3095      JMP         LEA_END
00003906                          3096  LEA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003906  4EB8 288A               3097      JSR         EA_INVALID          ; Opcode word is Invalid
0000390A  4EF9 00003952           3098      JMP         LEA_END
00003910                          3099  LEA_MODE_111: ; The rest (not all valid, validated by register number)
00003910  BE3C 0000               3100      CMP.B       #$00, D7            ; Test for absolute word address
00003914  6700 0014               3101      BEQ         LEA_ABS_W
00003918  BE3C 0001               3102      CMP.B       #$01, D7            ; Test for absolute long address
0000391C  6700 0016               3103      BEQ         LEA_ABS_L
00003920  4EB8 288A               3104      JSR         EA_INVALID          ; Else: invalid
00003924  4EF9 0000393E           3105      JMP         LEA_DEST
0000392A                          3106  LEA_ABS_W:
0000392A  4EB8 2CC2               3107      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000392E  4EF9 0000393E           3108      JMP         LEA_DEST
00003934                          3109  LEA_ABS_L:
00003934  4EB8 2CB2               3110      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003938  4EF9 0000393E           3111      JMP         LEA_DEST
0000393E                          3112  LEA_DEST:
0000393E  49F9 000048C4           3113      LEA         COMMA, A4        ; Print comma
00003944  4EB9 000043EA           3114      JSR         WRITE2MEM
0000394A  4EB8 28D8               3115      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, opmode bits unused
0000394E  4EB8 29B0               3116      JSR         EA_PRINT_AN         ; Print address register
00003952                          3117  LEA_END:
00003952  4EB8 28A2               3118      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003956  4CDF 3FFF               3119      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000395A  4E75                    3120      RTS
0000395C                          3121  EA_LSd:
0000395C  48E7 FFFC               3122      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003960  4EB8 28AE               3123      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003964  4EB8 28FE               3124      JSR         EA_SIZE_BITS        ; get size bits in D7
00003968  BE3C 0003               3125      CMP.B       #$03, D7            ; test if memory shift
0000396C  6700 005E               3126      BEQ         LSd_MEM
00003970  6000 0002               3127      BRA         LSd_REG             ; else, register shfit
00003974                          3128  LSd_REG:
00003974  3E16                    3129      MOVE.W      (A6), D7            ; read opcode word in memory and save,
00003976                          3130                                      ; (using D7 because EA_PRINT_DN uses D7)
00003976  143C 0004               3131      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
0000397A  E56F                    3132      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
0000397C  143C 000D               3133      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
00003980  E46F                    3134      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003982  3016                    3135      MOVE.W      (A6), D0            ; read opcode word in memory and save
00003984  143C 000A               3136      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
00003988  E568                    3137      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
0000398A  143C 000F               3138      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
0000398E  E468                    3139      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00003990  B03C 0000               3140      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
00003994  6700 000C               3141      BEQ         LSd_REG_COUNT
00003998                          3142  LSd_REG_REG:                        ; Else, count/register field contains register number
00003998  4EB8 2910               3143      JSR         EA_PRINT_DN         ; Print register value, stored in D7
0000399C  4EF9 000039B2           3144      JMP         LSd_REG_END         ; Jump to end of LSd_REG
000039A2                          3145  LSd_REG_COUNT:
000039A2  49F9 000048BE           3146      LEA         POUND, A4         ; Print '#'
000039A8  4EB9 000043EA           3147      JSR         WRITE2MEM
000039AE  4EB8 2894               3148      JSR         EA_PRINT_DATA  *print hex value in D7 as byte todo, continue on to LSd_REG_END
000039B2                          3149  LSd_REG_END:
000039B2  49F9 000048C4           3150      LEA         COMMA, A4        ; Print comma
000039B8  4EB9 000043EA           3151      JSR         WRITE2MEM
000039BE  4EB8 28B2               3152      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
000039C2  4EB8 2910               3153      JSR         EA_PRINT_DN         ; Print register value in D7
000039C6  4EF9 00003A82           3154      JMP         LSd_END
000039CC                          3155  LSd_MEM:
000039CC  4EB8 28B2               3156      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000039D0  41F9 000039DE           3157      LEA         LSd_MEM_MODE, A0    ; Set index '0' for jump table
000039D6  CCFC 0006               3158      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000039DA  4EF0 6000               3159      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000039DE                          3160  LSd_MEM_MODE:
000039DE  4EF9 00003A0E           3161      JMP         LSd_MEM_MODE_000     ; Invalid: Dn
000039E4  4EF9 00003A18           3162      JMP         LSd_MEM_MODE_001     ; Invalid: An
000039EA  4EF9 00003A22           3163      JMP         LSd_MEM_MODE_010     ; (An)
000039F0  4EF9 00003A2C           3164      JMP         LSd_MEM_MODE_011     ; (An)+
000039F6  4EF9 00003A36           3165      JMP         LSd_MEM_MODE_100     ; -(An)
000039FC  4EF9 00003A40           3166      JMP         LSd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003A02  4EF9 00003A4A           3167      JMP         LSd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A08  4EF9 00003A54           3168      JMP         LSd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00003A0E                          3169  LSd_MEM_MODE_000: ; Invalid: Dn
00003A0E  4EB8 288A               3170      JSR         EA_INVALID          ; Data register direct is invalid mode
00003A12  4EF9 00003A82           3171      JMP         LSd_END
00003A18                          3172  LSd_MEM_MODE_001: ; Invalid: An
00003A18  4EB8 288A               3173      JSR         EA_INVALID          ; Address register direct is invalid mode
00003A1C  4EF9 00003A82           3174      JMP         LSd_END
00003A22                          3175  LSd_MEM_MODE_010: ; (An)
00003A22  4EB8 2A50               3176      JSR         EA_PRINT_IND         ; Print address register indirect
00003A26  4EF9 00003A82           3177      JMP         LSd_END
00003A2C                          3178  LSd_MEM_MODE_011: ; (An)+
00003A2C  4EB8 2B2A               3179      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003A30  4EF9 00003A82           3180      JMP         LSd_END
00003A36                          3181  LSd_MEM_MODE_100: ; -(An)
00003A36  4EB8 2BEE               3182      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003A3A  4EF9 00003A82           3183      JMP         LSd_END         ; Continue with parsing destination operand
00003A40                          3184  LSd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003A40  4EB8 288A               3185      JSR         EA_INVALID          ; Opcode word is Invalid
00003A44  4EF9 00003A82           3186      JMP         LSd_END
00003A4A                          3187  LSd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A4A  4EB8 288A               3188      JSR         EA_INVALID          ; Opcode word is Invalid
00003A4E  4EF9 00003A82           3189      JMP         LSd_END
00003A54                          3190  LSd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
00003A54  BE3C 0000               3191      CMP.B       #$00, D7            ; Test for absolute word address
00003A58  6700 0014               3192      BEQ         LSd_MEM_ABS_W
00003A5C  BE3C 0001               3193      CMP.B       #$01, D7            ; Test for absolute long address
00003A60  6700 0016               3194      BEQ         LSd_MEM_ABS_L
00003A64  4EB8 288A               3195      JSR         EA_INVALID          ; Else: invalid
00003A68  4EF9 00003A82           3196      JMP         LSd_END
00003A6E                          3197  LSd_MEM_ABS_W:
00003A6E  4EB8 2CC2               3198      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003A72  4EF9 00003A82           3199      JMP         LSd_END
00003A78                          3200  LSd_MEM_ABS_L:
00003A78  4EB8 2CB2               3201      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003A7C  4EF9 00003A82           3202      JMP         LSd_END
00003A82                          3203  LSd_END:
00003A82  4EB8 28A2               3204      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003A86  4CDF 3FFF               3205      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003A8A  4E75                    3206      RTS
00003A8C                          3207  EA_MOVE:
00003A8C  48E7 FFFC               3208      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003A90  4EB8 28AE               3209      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003A94  2A16                    3210      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
00003A96  143C 0002               3211      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
00003A9A  E56D                    3212      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
00003A9C  143C 000E               3213      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
00003AA0  E46D                    3214      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
00003AA2  BA3C 0003               3215      CMP.B       #$03, D5            ; if size bits are 11, correct D5
00003AA6                          3216                                      ; to 10 for use with immediate data subroutine
00003AA6  6700 0010               3217      BEQ         MOVE_ADJUST_W
00003AAA  BA3C 0002               3218      CMP.B       #$02, D5            ; if size bits are 10, correct D5
00003AAE                          3219                                      ; to 11 for use with immediate data subroutine
00003AAE  6700 0012               3220      BEQ         MOVE_ADJUST_L
00003AB2  4EF9 00003ACC           3221      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003AB8                          3222  MOVE_ADJUST_W:
00003AB8  1A3C 0002               3223      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
00003ABC  4EF9 00003ACC           3224      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003AC2                          3225  MOVE_ADJUST_L:
00003AC2  1A3C 0003               3226      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
00003AC6  4EF9 00003ACC           3227      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003ACC                          3228  MOVE_SOURCE:
00003ACC  4EB8 28B2               3229      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003AD0  41F9 00003ADE           3230      LEA         MOVE_SRC_MODE, A0   ; Set index '0' for jump table
00003AD6  CCFC 0006               3231      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003ADA  4EF0 6000               3232      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003ADE                          3233  MOVE_SRC_MODE:
00003ADE  4EF9 00003B0E           3234      JMP         MOVE_SRC_MODE_000   ; Dn
00003AE4  4EF9 00003B18           3235      JMP         MOVE_SRC_MODE_001   ; An
00003AEA  4EF9 00003B22           3236      JMP         MOVE_SRC_MODE_010   ; (An)
00003AF0  4EF9 00003B2C           3237      JMP         MOVE_SRC_MODE_011   ; (An)+
00003AF6  4EF9 00003B36           3238      JMP         MOVE_SRC_MODE_100   ; -(An)
00003AFC  4EF9 00003B40           3239      JMP         MOVE_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003B02  4EF9 00003B4A           3240      JMP         MOVE_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003B08  4EF9 00003B54           3241      JMP         MOVE_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003B0E                          3242  MOVE_SRC_MODE_000: ; Dn
00003B0E  4EB8 2910               3243      JSR         EA_PRINT_DN         ; Print data register in D7
00003B12  4EF9 00003B94           3244      JMP         MOVE_DESTINATION
00003B18                          3245  MOVE_SRC_MODE_001: ; Invalid: An
00003B18  4EB8 29B0               3246      JSR         EA_PRINT_AN         ; Print address register in D7
00003B1C  4EF9 00003B94           3247      JMP         MOVE_DESTINATION
00003B22                          3248  MOVE_SRC_MODE_010: ; (An)
00003B22  4EB8 2A50               3249      JSR         EA_PRINT_IND         ; Print address register indirect
00003B26  4EF9 00003B94           3250      JMP         MOVE_DESTINATION
00003B2C                          3251  MOVE_SRC_MODE_011: ; (An)+
00003B2C  4EB8 2B2A               3252      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003B30  4EF9 00003B94           3253      JMP         MOVE_DESTINATION
00003B36                          3254  MOVE_SRC_MODE_100: ; -(An)
00003B36  4EB8 2BEE               3255      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003B3A  4EF9 00003B94           3256      JMP         MOVE_DESTINATION    ; Continue with parsing destination operand
00003B40                          3257  MOVE_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003B40  4EB8 288A               3258      JSR         EA_INVALID          ; Opcode word is Invalid
00003B44  4EF9 00003C56           3259      JMP         MOVE_END
00003B4A                          3260  MOVE_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003B4A  4EB8 288A               3261      JSR         EA_INVALID          ; Opcode word is Invalid
00003B4E  4EF9 00003C56           3262      JMP         MOVE_END
00003B54                          3263  MOVE_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003B54  BE3C 0000               3264      CMP.B       #$00, D7            ; Test for absolute word address
00003B58  6700 001C               3265      BEQ         MOVE_SRC_ABS_W
00003B5C  BE3C 0001               3266      CMP.B       #$01, D7            ; Test for absolute long address
00003B60  6700 001E               3267      BEQ         MOVE_SRC_ABS_L
00003B64  BE3C 0004               3268      CMP.B       #$04, D7            ; Test for immediate data
00003B68  6700 0020               3269      BEQ         MOVE_SRC_IMM
00003B6C  4EB8 288A               3270      JSR         EA_INVALID          ; Else: invalid
00003B70  4EF9 00003C56           3271      JMP         MOVE_END
00003B76                          3272  MOVE_SRC_ABS_W:
00003B76  4EB8 2CC2               3273      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003B7A  4EF9 00003B94           3274      JMP         MOVE_DESTINATION
00003B80                          3275  MOVE_SRC_ABS_L:
00003B80  4EB8 2CB2               3276      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003B84  4EF9 00003B94           3277      JMP         MOVE_DESTINATION
00003B8A                          3278  MOVE_SRC_IMM:
00003B8A  4EB8 2B08               3279      JSR         EA_PRINT_IMM        ; Print immediate data
00003B8E  4EF9 00003B94           3280      JMP         MOVE_DESTINATION
00003B94                          3281  MOVE_DESTINATION:
00003B94  49F9 000048C4           3282      LEA         COMMA, A4        ; Print comma
00003B9A  4EB9 000043EA           3283      JSR         WRITE2MEM
00003BA0  4EB8 28D8               3284      JSR         EA_OPMODE_COMBO     ; mode: D6, register: D7 (destination bits)
00003BA4  41F9 00003BB2           3285      LEA         MOVE_DST_MODE, A0   ; Set index '0' for jump table
00003BAA  CCFC 0006               3286      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003BAE  4EF0 6000               3287      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003BB2                          3288  MOVE_DST_MODE:
00003BB2  4EF9 00003BE2           3289      JMP         MOVE_DST_MODE_000   ; Dn
00003BB8  4EF9 00003BEC           3290      JMP         MOVE_DST_MODE_001   ; Invalid: An
00003BBE  4EF9 00003BF6           3291      JMP         MOVE_DST_MODE_010   ; (An)
00003BC4  4EF9 00003C00           3292      JMP         MOVE_DST_MODE_011   ; (An)+
00003BCA  4EF9 00003C0A           3293      JMP         MOVE_DST_MODE_100   ; -(An)
00003BD0  4EF9 00003C14           3294      JMP         MOVE_DST_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003BD6  4EF9 00003C1E           3295      JMP         MOVE_DST_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003BDC  4EF9 00003C28           3296      JMP         MOVE_DST_MODE_111   ; The rest (not all valid, validated by register number)
00003BE2                          3297  MOVE_DST_MODE_000: ; Dn
00003BE2  4EB8 2910               3298      JSR         EA_PRINT_DN         ; Print data register in D7
00003BE6  4EF9 00003C56           3299      JMP         MOVE_END
00003BEC                          3300  MOVE_DST_MODE_001: ; Invalid: An
00003BEC  4EB8 288A               3301      JSR         EA_INVALID          ; Print address register in D7
00003BF0  4EF9 00003C56           3302      JMP         MOVE_END
00003BF6                          3303  MOVE_DST_MODE_010: ; (An)
00003BF6  4EB8 2A50               3304      JSR         EA_PRINT_IND         ; Print address register indirect
00003BFA  4EF9 00003C56           3305      JMP         MOVE_END
00003C00                          3306  MOVE_DST_MODE_011: ; (An)+
00003C00  4EB8 2B2A               3307      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003C04  4EF9 00003C56           3308      JMP         MOVE_END
00003C0A                          3309  MOVE_DST_MODE_100: ; -(An)
00003C0A  4EB8 2BEE               3310      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003C0E  4EF9 00003C56           3311      JMP         MOVE_END    ; Continue with parsing destination operand
00003C14                          3312  MOVE_DST_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003C14  4EB8 288A               3313      JSR         EA_INVALID          ; Opcode word is Invalid
00003C18  4EF9 00003C56           3314      JMP         MOVE_END
00003C1E                          3315  MOVE_DST_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003C1E  4EB8 288A               3316      JSR         EA_INVALID          ; Opcode word is Invalid
00003C22  4EF9 00003C56           3317      JMP         MOVE_END
00003C28                          3318  MOVE_DST_MODE_111: ; The rest (not all valid, validated by register number)
00003C28  BE3C 0000               3319      CMP.B       #$00, D7            ; Test for absolute word address
00003C2C  6700 0014               3320      BEQ         MOVE_DST_ABS_W
00003C30  BE3C 0001               3321      CMP.B       #$01, D7            ; Test for absolute long address
00003C34  6700 0016               3322      BEQ         MOVE_DST_ABS_L
00003C38  4EB8 288A               3323      JSR         EA_INVALID          ; Else: invalid
00003C3C  4EF9 00003C56           3324      JMP         MOVE_END
00003C42                          3325  MOVE_DST_ABS_W:
00003C42  4EB8 2CC2               3326      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003C46  4EF9 00003C56           3327      JMP         MOVE_END
00003C4C                          3328  MOVE_DST_ABS_L:
00003C4C  4EB8 2CB2               3329      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003C50  4EF9 00003C56           3330      JMP         MOVE_END
00003C56                          3331  MOVE_END:
00003C56  4EB8 28A2               3332      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003C5A  4CDF 3FFF               3333      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003C5E  4E75                    3334      RTS
00003C60                          3335  EA_MOVEA:
00003C60  48E7 FFFC               3336      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003C64  4EB8 28AE               3337      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003C68  2A16                    3338      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
00003C6A  143C 0002               3339      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
00003C6E  E56D                    3340      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
00003C70  143C 000E               3341      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
00003C74  E46D                    3342      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
00003C76  BA3C 0003               3343      CMP.B       #$03, D5            ; if size bits are 11, correct D5
00003C7A                          3344                                      ; to 10 for use with immediate data subroutine
00003C7A  6700 0010               3345      BEQ         MOVEA_ADJUST_W
00003C7E  BA3C 0002               3346      CMP.B       #$02, D5            ; if size bits are 10, correct D5
00003C82                          3347                                      ; to 11 for use with immediate data subroutine
00003C82  6700 0012               3348      BEQ         MOVEA_ADJUST_L
00003C86  4EF9 00003CA0           3349      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003C8C                          3350  MOVEA_ADJUST_W:
00003C8C  1A3C 0002               3351      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
00003C90  4EF9 00003CA0           3352      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003C96                          3353  MOVEA_ADJUST_L:
00003C96  1A3C 0003               3354      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
00003C9A  4EF9 00003CA0           3355      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003CA0                          3356  MOVEA_SOURCE:
00003CA0  4EB8 28B2               3357      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003CA4  41F9 00003CB2           3358      LEA         MOVEA_SRC_MODE, A0   ; Set index '0' for jump table
00003CAA  CCFC 0006               3359      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003CAE  4EF0 6000               3360      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003CB2                          3361  MOVEA_SRC_MODE:
00003CB2  4EF9 00003CE2           3362      JMP         MOVEA_SRC_MODE_000   ; Dn
00003CB8  4EF9 00003CEC           3363      JMP         MOVEA_SRC_MODE_001   ; An
00003CBE  4EF9 00003CF6           3364      JMP         MOVEA_SRC_MODE_010   ; (An)
00003CC4  4EF9 00003D00           3365      JMP         MOVEA_SRC_MODE_011   ; (An)+
00003CCA  4EF9 00003D0A           3366      JMP         MOVEA_SRC_MODE_100   ; -(An)
00003CD0  4EF9 00003D14           3367      JMP         MOVEA_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003CD6  4EF9 00003D1E           3368      JMP         MOVEA_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003CDC  4EF9 00003D28           3369      JMP         MOVEA_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003CE2                          3370  MOVEA_SRC_MODE_000: ; Dn
00003CE2  4EB8 2910               3371      JSR         EA_PRINT_DN         ; Print data register in D7
00003CE6  4EF9 00003D68           3372      JMP         MOVEA_DESTINATION
00003CEC                          3373  MOVEA_SRC_MODE_001: ; Invalid: An
00003CEC  4EB8 29B0               3374      JSR         EA_PRINT_AN         ; Print address register in D7
00003CF0  4EF9 00003D68           3375      JMP         MOVEA_DESTINATION
00003CF6                          3376  MOVEA_SRC_MODE_010: ; (An)
00003CF6  4EB8 2A50               3377      JSR         EA_PRINT_IND         ; Print address register indirect
00003CFA  4EF9 00003D68           3378      JMP         MOVEA_DESTINATION
00003D00                          3379  MOVEA_SRC_MODE_011: ; (An)+
00003D00  4EB8 2B2A               3380      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003D04  4EF9 00003D68           3381      JMP         MOVEA_DESTINATION
00003D0A                          3382  MOVEA_SRC_MODE_100: ; -(An)
00003D0A  4EB8 2BEE               3383      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003D0E  4EF9 00003D68           3384      JMP         MOVEA_DESTINATION    ; Continue with parsing destination operand
00003D14                          3385  MOVEA_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003D14  4EB8 288A               3386      JSR         EA_INVALID          ; Opcode word is Invalid
00003D18  4EF9 00003D7C           3387      JMP         MOVEA_END
00003D1E                          3388  MOVEA_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003D1E  4EB8 288A               3389      JSR         EA_INVALID          ; Opcode word is Invalid
00003D22  4EF9 00003D7C           3390      JMP         MOVEA_END
00003D28                          3391  MOVEA_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003D28  BE3C 0000               3392      CMP.B       #$00, D7            ; Test for absolute word address
00003D2C  6700 001C               3393      BEQ         MOVEA_SRC_ABS_W
00003D30  BE3C 0001               3394      CMP.B       #$01, D7            ; Test for absolute long address
00003D34  6700 001E               3395      BEQ         MOVEA_SRC_ABS_L
00003D38  BE3C 0004               3396      CMP.B       #$04, D7            ; Test for immediate data
00003D3C  6700 0020               3397      BEQ         MOVEA_SRC_IMM
00003D40  4EB8 288A               3398      JSR         EA_INVALID          ; Else: invalid
00003D44  4EF9 00003D7C           3399      JMP         MOVEA_END
00003D4A                          3400  MOVEA_SRC_ABS_W:
00003D4A  4EB8 2CC2               3401      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003D4E  4EF9 00003D68           3402      JMP         MOVEA_DESTINATION
00003D54                          3403  MOVEA_SRC_ABS_L:
00003D54  4EB8 2CB2               3404      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003D58  4EF9 00003D68           3405      JMP         MOVEA_DESTINATION
00003D5E                          3406  MOVEA_SRC_IMM:
00003D5E  4EB8 2B08               3407      JSR         EA_PRINT_IMM        ; Print immediate data
00003D62  4EF9 00003D68           3408      JMP         MOVEA_DESTINATION
00003D68                          3409  MOVEA_DESTINATION:
00003D68  49F9 000048C4           3410      LEA         COMMA, A4        ; Print comma
00003D6E  4EB9 000043EA           3411      JSR         WRITE2MEM
00003D74  4EB8 28D8               3412      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003D78  4EB8 29B0               3413      JSR         EA_PRINT_AN         ; Print address register, continue to end
00003D7C                          3414  MOVEA_END:
00003D7C  4EB8 28A2               3415      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003D80  4CDF 3FFF               3416      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003D84  4E75                    3417      RTS
00003D86                          3418  EA_MOVEM:
00003D86                          3419      *seems complicated, todo
00003D86  4EB8 287A               3420      JSR         EA_UNIMPLEMENTED
00003D8A  4E75                    3421      RTS
00003D8C                          3422  EA_MOVEQ:
00003D8C  48E7 FFFC               3423      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003D90  4EB8 28AE               3424      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003D94  2216                    3425      MOVE.L      (A6), D1            ; Load opcode to data register 1
00003D96  143C 0008               3426      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003D9A  E569                    3427      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00003D9C  143C 0008               3428      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine data bits
00003DA0  E469                    3429      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00003DA2  2616                    3430      MOVE.L      (A6), D3            ; Save mode bits to D6
00003DA4  143C 0008               3431      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003DA8  E56B                    3432      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
00003DAA  143C 000F               3433      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
00003DAE  E46B                    3434      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003DB0  B63C 0000               3435      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003DB4  6700 0008               3436      BEQ         MOVEQ_PRINT_DATA
00003DB8  0681 FFFFFF00           3437      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
00003DBE                          3438  MOVEQ_PRINT_DATA:
00003DBE  49F9 000048BE           3439      LEA         POUND, A4         ; Print '#'
00003DC4  4EB9 000043EA           3440      JSR         WRITE2MEM
00003DCA  4EB8 2894               3441      JSR         EA_PRINT_DATA *print data todo
00003DCE  49F9 000048C4           3442      LEA         COMMA, A4        ; Print comma
00003DD4  4EB9 000043EA           3443      JSR         WRITE2MEM
00003DDA  4EB8 28D8               3444      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003DDE  4EB8 2910               3445      JSR         EA_PRINT_DN         ; Print data register
00003DE2  4EB8 28A2               3446      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003DE6  4CDF 3FFF               3447      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003DEA  4E75                    3448      RTS
00003DEC                          3449  EA_MULS_W:
00003DEC  48E7 FFFC               3450      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003DF0  4EB8 28AE               3451      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003DF4  4EB8 28B2               3452      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003DF8  41F9 00003E06           3453      LEA         MULS_W_MODE, A0     ; Set index '0' for jump table
00003DFE  CCFC 0006               3454      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003E02  4EF0 6000               3455      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003E06                          3456  MULS_W_MODE:
00003E06  4EF9 00003E36           3457      JMP         MULS_W_MODE_000     ; Dn
00003E0C  4EF9 00003E40           3458      JMP         MULS_W_MODE_001     ; Invalid: An
00003E12  4EF9 00003E4A           3459      JMP         MULS_W_MODE_010     ; (An)
00003E18  4EF9 00003E54           3460      JMP         MULS_W_MODE_011     ; (An)+
00003E1E  4EF9 00003E5E           3461      JMP         MULS_W_MODE_100     ; -(An)
00003E24  4EF9 00003E68           3462      JMP         MULS_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003E2A  4EF9 00003E72           3463      JMP         MULS_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E30  4EF9 00003E7C           3464      JMP         MULS_W_MODE_111     ; The rest (not all valid, validated by register number)
00003E36                          3465  MULS_W_MODE_000: ; Dn
00003E36  4EB8 2910               3466      JSR         EA_PRINT_DN         ; Print data register direct operand
00003E3A  4EF9 00003EC0           3467      JMP         MULS_W_DEST         ; Go to: print destination operand
00003E40                          3468  MULS_W_MODE_001: ; Invalid: An
00003E40  4EB8 288A               3469      JSR         EA_INVALID          ; Address register direct is invalid mode
00003E44  4EF9 00003ED2           3470      JMP         MULS_W_END
00003E4A                          3471  MULS_W_MODE_010: ; (An)
00003E4A  4EB8 2A50               3472      JSR         EA_PRINT_IND         ; Print address register indirect
00003E4E  4EF9 00003EC0           3473      JMP         MULS_W_DEST
00003E54                          3474  MULS_W_MODE_011: ; (An)+
00003E54  4EB8 2B2A               3475      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003E58  4EF9 00003EC0           3476      JMP         MULS_W_DEST
00003E5E                          3477  MULS_W_MODE_100: ; -(An)
00003E5E  4EB8 2BEE               3478      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003E62  4EF9 00003EC0           3479      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003E68                          3480  MULS_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003E68  4EB8 288A               3481      JSR         EA_INVALID          ; Opcode word is Invalid
00003E6C  4EF9 00003ED2           3482      JMP         MULS_W_END
00003E72                          3483  MULS_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E72  4EB8 288A               3484      JSR         EA_INVALID          ; Opcode word is Invalid
00003E76  4EF9 00003ED2           3485      JMP         MULS_W_END
00003E7C                          3486  MULS_W_MODE_111: ; The rest (not all valid, validated by register number)
00003E7C  BE3C 0000               3487      CMP.B       #$00, D7            ; Test for absolute word address
00003E80  6700 001C               3488      BEQ         MULS_W_ABS_W
00003E84  BE3C 0001               3489      CMP.B       #$01, D7            ; Test for absolute long address
00003E88  6700 001E               3490      BEQ         MULS_W_ABS_L
00003E8C  BE3C 0004               3491      CMP.B       #$04, D7            ; Test for immediate data
00003E90  6700 0020               3492      BEQ         MULS_W_IMM
00003E94  4EB8 288A               3493      JSR         EA_INVALID          ; Else: invalid
00003E98  4EF9 00003ED2           3494      JMP         MULS_W_END
00003E9E                          3495  MULS_W_ABS_W:
00003E9E  4EB8 2CC2               3496      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003EA2  4EF9 00003EC0           3497      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003EA8                          3498  MULS_W_ABS_L:
00003EA8  4EB8 2CB2               3499      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003EAC  4EF9 00003EC0           3500      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003EB2                          3501  MULS_W_IMM:
00003EB2  1A3C 0002               3502      MOVE.B      #2, D5              ; Size is word
00003EB6  4EB8 2B08               3503      JSR         EA_PRINT_IMM        ; Print immediate data
00003EBA  4EF9 00003EC0           3504      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003EC0                          3505  MULS_W_DEST:
00003EC0                          3506      *print COMMA
00003EC0                          3507      *Get destination register
00003EC0  3E16                    3508      MOVE.W      (A6), D7            ; Load word at current pointer to D1
00003EC2  143C 0004               3509      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00003EC6  E56F                    3510      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003EC8  143C 000D               3511      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
00003ECC  E46F                    3512      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003ECE  4EB8 2910               3513      JSR         EA_PRINT_DN         ; Print data register direct operand
00003ED2                          3514  MULS_W_END:
00003ED2  4EB8 28A2               3515      JSR         EA_UPDATE_POINTER   ; Update global pointer
00003ED6  4CDF 3FFF               3516      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003EDA  4E75                    3517      RTS
00003EDC                          3518  
00003EDC                          3519  EA_OR:
00003EDC  48E7 FFFC               3520      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003EE0  4EB8 28AE               3521      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003EE4  4EB8 28D8               3522      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00003EE8  41F9 00003EF6           3523      LEA         OR_OPMODE, A0       ; Set index '0' for jump table
00003EEE  CCFC 0006               3524      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003EF2  4EF0 6000               3525      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003EF6                          3526  OR_OPMODE:
00003EF6  4EF9 00003F26           3527      JMP         OR_OPMODE_000       ; mode 1, byte
00003EFC  4EF9 00003F30           3528      JMP         OR_OPMODE_001       ; mode 1, word
00003F02  4EF9 00003F3A           3529      JMP         OR_OPMODE_010       ; mode 1, long
00003F08  4EF9 00003F44           3530      JMP         OR_OPMODE_011       ; Invalid value
00003F0E  4EF9 00003F4E           3531      JMP         OR_OPMODE_100       ; mode 2, byte
00003F14  4EF9 00003F58           3532      JMP         OR_OPMODE_101       ; mode 2, word
00003F1A  4EF9 00003F62           3533      JMP         OR_OPMODE_110       ; mode 2, long
00003F20  4EF9 00003F6C           3534      JMP         OR_OPMODE_111       ; Invalid value
00003F26                          3535  OR_OPMODE_000: ; mode 1, byte
00003F26  1A3C 0001               3536      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F2A  4EF9 00003F76           3537      JMP         OR_MODE_1
00003F30                          3538  OR_OPMODE_001: ; mode 1, word
00003F30  1A3C 0002               3539      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00003F34  4EF9 00003F76           3540      JMP         OR_MODE_1
00003F3A                          3541  OR_OPMODE_010: ; mode 1, long
00003F3A  1A3C 0003               3542      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00003F3E  4EF9 00003F76           3543      JMP         OR_MODE_1
00003F44                          3544  OR_OPMODE_011: ; Invalid value
00003F44  4EB8 288A               3545      JSR         EA_INVALID
00003F48  4EF9 00004096           3546      JMP         OR_END
00003F4E                          3547  OR_OPMODE_100: ; mode 2, byte
00003F4E  1A3C 0001               3548      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F52  4EF9 00003FA0           3549      JMP         OR_MODE_2
00003F58                          3550  OR_OPMODE_101: ; mode 2, word
00003F58  1A3C 0001               3551      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F5C  4EF9 00003FA0           3552      JMP         OR_MODE_2
00003F62                          3553  OR_OPMODE_110: ; mode 2, long
00003F62  1A3C 0001               3554      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F66  4EF9 00003FA0           3555      JMP         OR_MODE_2
00003F6C                          3556  OR_OPMODE_111: ; Invalid value
00003F6C  4EB8 288A               3557      JSR         EA_INVALID
00003F70  4EF9 00004096           3558      JMP         OR_END
00003F76                          3559  OR_MODE_1:
00003F76  4280                    3560      CLR.L       D0                  ; Clear data register 0
00003F78  103C 0001               3561      MOVE.B      #1, D0              ; Save mode number to D0
00003F7C  3207                    3562      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003F7E  4EB8 28B2               3563      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003F82  4EB9 00003FC6           3564      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
00003F88  49F9 000048C4           3565      LEA         COMMA, A4        ; Print comma
00003F8E  4EB9 000043EA           3566      JSR         WRITE2MEM
00003F94  3E01                    3567      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003F96  4EB8 2910               3568      JSR         EA_PRINT_DN         ; Print data register
00003F9A  4EF9 00004096           3569      JMP         OR_END
00003FA0                          3570  OR_MODE_2:
00003FA0  4280                    3571      CLR.L       D0                  ; Clear data register 0
00003FA2  103C 0002               3572      MOVE.B      #2, D0              ; Save mode number to D0
00003FA6  4EB8 2910               3573      JSR         EA_PRINT_DN         ; Print data register
00003FAA  49F9 000048C4           3574      LEA         COMMA, A4        ; Print comma
00003FB0  4EB9 000043EA           3575      JSR         WRITE2MEM
00003FB6  4EB8 28B2               3576      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003FBA  4EB9 00003FC6           3577      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
00003FC0  4EF9 00004096           3578      JMP         OR_END
00003FC6                          3579  OR_EVAL_EA:
00003FC6  41F9 00003FD4           3580      LEA         OR_MODE, A0         ; Set index '0' for jump table
00003FCC  CCFC 0006               3581      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003FD0  4EF0 6000               3582      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003FD4                          3583  OR_MODE:
00003FD4  4EF9 00004004           3584      JMP         OR_MODE_000         ; Invalid: Dn
00003FDA  4EF9 0000400E           3585      JMP         OR_MODE_001         ; An (invalid if opmode 2)
00003FE0  4EF9 00004020           3586      JMP         OR_MODE_010         ; (An)
00003FE6  4EF9 0000402A           3587      JMP         OR_MODE_011         ; (An)+
00003FEC  4EF9 00004034           3588      JMP         OR_MODE_100         ; -(An)
00003FF2  4EF9 0000403E           3589      JMP         OR_MODE_101         ; Invalid: Address Register Indirect with Displacement Mode
00003FF8  4EF9 00004044           3590      JMP         OR_MODE_110         ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003FFE  4EF9 0000404A           3591      JMP         OR_MODE_111         ; The rest (not all valid, validated by register number)
00004004                          3592  OR_MODE_000: ; Invalid: Dn
00004004  4EB8 288A               3593      JSR         EA_INVALID          ; Invalid for both opmodes
00004008  4EF9 0000408E           3594      JMP         OR_MODE_END         ; End evaluation of ea mode
0000400E                          3595  OR_MODE_001: ; An (invalid if opmode 2)
0000400E  B07C 0002               3596      CMP         #2, D0
00004012  6700 007C               3597      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
00004016  4EB8 29B0               3598      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
0000401A  4EF9 0000408E           3599      JMP         OR_MODE_END         ; End evaluation of ea mode
00004020                          3600  OR_MODE_010: ; (An)
00004020  4EB8 2A50               3601      JSR         EA_PRINT_IND         ; Print address register indirect
00004024  4EF9 0000408E           3602      JMP         OR_MODE_END         ; End evaluation of ea mode
0000402A                          3603  OR_MODE_011: ; (An)+
0000402A  4EB8 2B2A               3604      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000402E  4EF9 0000408E           3605      JMP         OR_MODE_END         ; End evaluation of ea mode
00004034                          3606  OR_MODE_100: ; -(An)
00004034  4EB8 2BEE               3607      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00004038  4EF9 0000408E           3608      JMP         OR_MODE_END         ; End evaluation of ea mode
0000403E                          3609  OR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000403E  4EF9 00004090           3610      JMP         OR_MODE_INVALID
00004044                          3611  OR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004044  4EF9 00004090           3612      JMP         OR_MODE_INVALID
0000404A                          3613  OR_MODE_111: ; The rest (not all valid, validated by register number)
0000404A  BE3C 0000               3614      CMP.B       #$00, D7            ; Test for absolute word address
0000404E  6700 0018               3615      BEQ         OR_ABS_W
00004052  BE3C 0001               3616      CMP.B       #$01, D7            ; Test for absolute long address
00004056  6700 001A               3617      BEQ         OR_ABS_L
0000405A  BE3C 0004               3618      CMP.B       #$04, D7            ; Test for immediate data
0000405E  6700 001C               3619      BEQ         OR_IMM
00004062  4EF9 00004090           3620      JMP         OR_MODE_INVALID     ; else, invalid
00004068                          3621  OR_ABS_W:
00004068  4EB8 2CC2               3622      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000406C  4EF9 0000408E           3623      JMP         OR_MODE_END
00004072                          3624  OR_ABS_L:
00004072  4EB8 2CB2               3625      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00004076  4EF9 0000408E           3626      JMP         OR_MODE_END
0000407C                          3627  OR_IMM: ; invalid if opmode is 2
0000407C  B07C 0002               3628      CMP         #2, D0
00004080  6700 000E               3629      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
00004084  4EB8 2B08               3630      JSR         EA_PRINT_IMM        ; Print immediate data
00004088  4EF9 0000408E           3631      JMP         OR_MODE_END
0000408E                          3632  OR_MODE_END:
0000408E  4E75                    3633      RTS                             ; Finish evaluating EA bits
00004090                          3634  OR_MODE_INVALID:
00004090  4EB8 288A               3635      JSR         EA_INVALID          ; Opcode word is Invalid
00004094  4E75                    3636      RTS
00004096                          3637  OR_END:
00004096  4EB8 28A2               3638      JSR         EA_UPDATE_POINTER   ; Updates global pointer
0000409A  4CDF 3FFF               3639      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000409E  4E75                    3640      RTS
000040A0                          3641  EA_ROd:
000040A0  48E7 FFFC               3642      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000040A4  4EB8 28AE               3643      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000040A8  4EB8 28FE               3644      JSR         EA_SIZE_BITS        ; get size bits in D7
000040AC  BE3C 0003               3645      CMP.B       #$03, D7            ; test if memory shift
000040B0  6700 005E               3646      BEQ         ROd_MEM
000040B4  6000 0002               3647      BRA         ROd_REG             ; else, register shfit
000040B8                          3648  ROd_REG:
000040B8  3E16                    3649      MOVE.W      (A6), D7            ; read opcode word in memory and save,
000040BA                          3650                                      ; (using D7 because EA_PRINT_DN uses D7)
000040BA  143C 0004               3651      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
000040BE  E56F                    3652      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000040C0  143C 000D               3653      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
000040C4  E46F                    3654      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000040C6  3016                    3655      MOVE.W      (A6), D0            ; read opcode word in memory and save
000040C8  143C 000A               3656      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
000040CC  E568                    3657      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
000040CE  143C 000F               3658      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
000040D2  E468                    3659      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
000040D4  B03C 0000               3660      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
000040D8  6700 000C               3661      BEQ         ROd_REG_COUNT
000040DC                          3662  ROd_REG_REG:                        ; Else, count/register field contains register number
000040DC  4EB8 2910               3663      JSR         EA_PRINT_DN         ; Print register value, stored in D7
000040E0  4EF9 000040F6           3664      JMP         ROd_REG_END         ; Jump to end of ROd_REG
000040E6                          3665  ROd_REG_COUNT:
000040E6  49F9 000048BE           3666      LEA         POUND, A4         ; Print '#'''
000040EC  4EB9 000043EA           3667      JSR         WRITE2MEM
000040F2  4EB8 2894               3668      JSR         EA_PRINT_DATA       *print hex value in D7 as byte todo, continue on to ROd_REG_END
000040F6                          3669  ROd_REG_END:
000040F6  49F9 000048C4           3670      LEA         COMMA, A4        ; Print comma
000040FC  4EB9 000043EA           3671      JSR         WRITE2MEM
00004102  4EB8 28B2               3672      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
00004106  4EB8 2910               3673      JSR         EA_PRINT_DN         ; Print register value in D7
0000410A  4EF9 000041C6           3674      JMP         ROd_END
00004110                          3675  ROd_MEM:
00004110  4EB8 28B2               3676      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00004114  41F9 00004122           3677      LEA         ROd_MEM_MODE, A0    ; Set index '0' for jump table
0000411A  CCFC 0006               3678      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000411E  4EF0 6000               3679      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00004122                          3680  ROd_MEM_MODE:
00004122  4EF9 00004152           3681      JMP         ROd_MEM_MODE_000     ; Invalid: Dn
00004128  4EF9 0000415C           3682      JMP         ROd_MEM_MODE_001     ; Invalid: An
0000412E  4EF9 00004166           3683      JMP         ROd_MEM_MODE_010     ; (An)
00004134  4EF9 00004170           3684      JMP         ROd_MEM_MODE_011     ; (An)+
0000413A  4EF9 0000417A           3685      JMP         ROd_MEM_MODE_100     ; -(An)
00004140  4EF9 00004184           3686      JMP         ROd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00004146  4EF9 0000418E           3687      JMP         ROd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000414C  4EF9 00004198           3688      JMP         ROd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00004152                          3689  ROd_MEM_MODE_000: ; Invalid: Dn
00004152  4EB8 288A               3690      JSR         EA_INVALID          ; Data register direct is invalid mode
00004156  4EF9 000041C6           3691      JMP         ROd_END
0000415C                          3692  ROd_MEM_MODE_001: ; Invalid: An
0000415C  4EB8 288A               3693      JSR         EA_INVALID          ; Address register direct is invalid mode
00004160  4EF9 000041C6           3694      JMP         ROd_END
00004166                          3695  ROd_MEM_MODE_010: ; (An)
00004166  4EB8 2A50               3696      JSR         EA_PRINT_IND         ; Print address register indirect
0000416A  4EF9 000041C6           3697      JMP         ROd_END
00004170                          3698  ROd_MEM_MODE_011: ; (An)+
00004170  4EB8 2B2A               3699      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00004174  4EF9 000041C6           3700      JMP         ROd_END
0000417A                          3701  ROd_MEM_MODE_100: ; -(An)
0000417A  4EB8 2BEE               3702      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000417E  4EF9 000041C6           3703      JMP         ROd_END         ; Continue with parsing destination operand
00004184                          3704  ROd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00004184  4EB8 288A               3705      JSR         EA_INVALID          ; Opcode word is Invalid
00004188  4EF9 000041C6           3706      JMP         ROd_END
0000418E                          3707  ROd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000418E  4EB8 288A               3708      JSR         EA_INVALID          ; Opcode word is Invalid
00004192  4EF9 000041C6           3709      JMP         ROd_END
00004198                          3710  ROd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
00004198  BE3C 0000               3711      CMP.B       #$00, D7            ; Test for absolute word address
0000419C  6700 0014               3712      BEQ         ROd_MEM_ABS_W
000041A0  BE3C 0001               3713      CMP.B       #$01, D7            ; Test for absolute long address
000041A4  6700 0016               3714      BEQ         ROd_MEM_ABS_L
000041A8  4EB8 288A               3715      JSR         EA_INVALID          ; Else: invalid
000041AC  4EF9 000041C6           3716      JMP         ROd_END
000041B2                          3717  ROd_MEM_ABS_W:
000041B2  4EB8 2CC2               3718      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000041B6  4EF9 000041C6           3719      JMP         ROd_END
000041BC                          3720  ROd_MEM_ABS_L:
000041BC  4EB8 2CB2               3721      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000041C0  4EF9 000041C6           3722      JMP         ROd_END
000041C6                          3723  ROd_END:
000041C6  4EB8 28A2               3724      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000041CA  4CDF 3FFF               3725      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000041CE  4E75                    3726      RTS
000041D0                          3727  EA_SUB:
000041D0  4EB8 28D8               3728      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
000041D4  41F9 000041E2           3729      LEA         SUB_OPMODE, A0      ; Set index '0' for jump table
000041DA  CCFC 0006               3730      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000041DE  4EF0 6000               3731      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000041E2                          3732  SUB_OPMODE:
000041E2  4EF9 00004212           3733      JMP         SUB_OPMODE_000      ; mode 1, byte
000041E8  4EF9 0000421C           3734      JMP         SUB_OPMODE_001      ; mode 1, word
000041EE  4EF9 00004226           3735      JMP         SUB_OPMODE_010      ; mode 1, long
000041F4  4EF9 00004230           3736      JMP         SUB_OPMODE_011      ; Invalid value
000041FA  4EF9 0000423A           3737      JMP         SUB_OPMODE_100      ; mode 2, byte
00004200  4EF9 00004244           3738      JMP         SUB_OPMODE_101      ; mode 2, word
00004206  4EF9 0000424E           3739      JMP         SUB_OPMODE_110      ; mode 2, long
0000420C  4EF9 00004258           3740      JMP         SUB_OPMODE_111      ; Invalid value
00004212                          3741  SUB_OPMODE_000: ; mode 1, byte
00004212  1A3C 0001               3742      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004216  4EF9 00004262           3743      JMP         SUB_MODE_1
0000421C                          3744  SUB_OPMODE_001: ; mode 1, word
0000421C  1A3C 0002               3745      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00004220  4EF9 00004262           3746      JMP         SUB_MODE_1
00004226                          3747  SUB_OPMODE_010: ; mode 1, long
00004226  1A3C 0003               3748      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
0000422A  4EF9 00004262           3749      JMP         SUB_MODE_1
00004230                          3750  SUB_OPMODE_011: ; Invalid value
00004230  4EB8 288A               3751      JSR         EA_INVALID
00004234  4EF9 0000438A           3752      JMP         SUB_END
0000423A                          3753  SUB_OPMODE_100: ; mode 2, byte
0000423A  1A3C 0001               3754      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000423E  4EF9 0000428C           3755      JMP         SUB_MODE_2
00004244                          3756  SUB_OPMODE_101: ; mode 2, word
00004244  1A3C 0001               3757      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004248  4EF9 0000428C           3758      JMP         SUB_MODE_2
0000424E                          3759  SUB_OPMODE_110: ; mode 2, long
0000424E  1A3C 0001               3760      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004252  4EF9 0000428C           3761      JMP         SUB_MODE_2
00004258                          3762  SUB_OPMODE_111: ; Invalid value
00004258  4EB8 288A               3763      JSR         EA_INVALID
0000425C  4EF9 0000438A           3764      JMP         SUB_END
00004262                          3765  SUB_MODE_1:
00004262  4280                    3766      CLR.L       D0                  ; Clear data register 0
00004264  103C 0001               3767      MOVE.B      #1, D0              ; Save mode number to D0
00004268  3207                    3768      MOVE.W      D7, D1              ; Save register value for printing dest. operand
0000426A  4EB8 28B2               3769      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
0000426E  4EB9 000042B2           3770      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
00004274  49F9 000048C4           3771      LEA         COMMA, A4        ; Print comma
0000427A  4EB9 000043EA           3772      JSR         WRITE2MEM
00004280  3E01                    3773      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00004282  4EB8 2910               3774      JSR         EA_PRINT_DN         ; Print data register
00004286  4EF9 0000438A           3775      JMP         SUB_END
0000428C                          3776  SUB_MODE_2:
0000428C  4280                    3777      CLR.L       D0                  ; Clear data register 0
0000428E  103C 0002               3778      MOVE.B      #2, D0              ; Save mode number to D0
00004292  4EB8 2910               3779      JSR         EA_PRINT_DN         ; Print data register
00004296  49F9 000048C4           3780      LEA         COMMA, A4        ; Print comma
0000429C  4EB9 000043EA           3781      JSR         WRITE2MEM
000042A2  4EB8 28B2               3782      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
000042A6  4EB9 000042B2           3783      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
000042AC  4EF9 0000438A           3784      JMP         SUB_END
000042B2                          3785  SUB_EVAL_EA:
000042B2  41F9 000042C0           3786      LEA         SUB_MODE, A0        ; Set index '0' for jump table
000042B8  CCFC 0006               3787      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000042BC  4EF0 6000               3788      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000042C0                          3789  SUB_MODE:
000042C0  4EF9 000042F0           3790      JMP         SUB_MODE_000        ; Dn (invalid if opmode 2)
000042C6  4EF9 00004302           3791      JMP         SUB_MODE_001        ; An (invalid if opmode 2)
000042CC  4EF9 00004314           3792      JMP         SUB_MODE_010        ; (An)
000042D2  4EF9 0000431E           3793      JMP         SUB_MODE_011        ; (An)+
000042D8  4EF9 00004328           3794      JMP         SUB_MODE_100        ; -(An)
000042DE  4EF9 00004332           3795      JMP         SUB_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000042E4  4EF9 00004338           3796      JMP         SUB_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000042EA  4EF9 0000433E           3797      JMP         SUB_MODE_111        ; The rest (not all valid, validated by register number)
000042F0                          3798  SUB_MODE_000: ; Dn (invalid if opmode 2)
000042F0  B07C 0002               3799      CMP         #2, D0
000042F4  6700 008E               3800      BEQ         SUB_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
000042F8  4EB8 2910               3801      JSR         EA_PRINT_DN         ; Print data register direct operand
000042FC  4EF9 00004382           3802      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004302                          3803  SUB_MODE_001: ; An (invalid if opmode 2)
00004302  B07C 0002               3804      CMP         #2, D0
00004306  6700 007C               3805      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
0000430A  4EB8 29B0               3806      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
0000430E  4EF9 00004382           3807      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004314                          3808  SUB_MODE_010: ; (An)
00004314  4EB8 2A50               3809      JSR         EA_PRINT_IND         ; Print address register indirect
00004318  4EF9 00004382           3810      JMP         SUB_MODE_END        ; End evaluation of ea mode
0000431E                          3811  SUB_MODE_011: ; (An)+
0000431E  4EB8 2B2A               3812      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00004322  4EF9 00004382           3813      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004328                          3814  SUB_MODE_100: ; -(An)
00004328  4EB8 2BEE               3815      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000432C  4EF9 00004382           3816      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004332                          3817  SUB_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00004332  4EF9 00004384           3818      JMP         SUB_MODE_INVALID
00004338                          3819  SUB_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004338  4EF9 00004384           3820      JMP         SUB_MODE_INVALID
0000433E                          3821  SUB_MODE_111: ; The rest (not all valid, validated by register number)
0000433E  BE3C 0000               3822      CMP.B       #$00, D7            ; Test for absolute word address
00004342  6700 0018               3823      BEQ         SUB_ABS_W
00004346  BE3C 0001               3824      CMP.B       #$01, D7            ; Test for absolute long address
0000434A  6700 001A               3825      BEQ         SUB_ABS_L
0000434E  BE3C 0004               3826      CMP.B       #$04, D7            ; Test for immediate data
00004352  6700 001C               3827      BEQ         SUB_IMM
00004356  4EF9 00004384           3828      JMP         SUB_MODE_INVALID    ; else, invalid
0000435C                          3829  SUB_ABS_W:
0000435C  4EB8 2CC2               3830      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00004360  4EF9 00004382           3831      JMP         SUB_MODE_END
00004366                          3832  SUB_ABS_L:
00004366  4EB8 2CB2               3833      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000436A  4EF9 00004382           3834      JMP         SUB_MODE_END
00004370                          3835  SUB_IMM: ; invalid if opmode is 2
00004370  B07C 0002               3836      CMP         #2, D0
00004374  6700 000E               3837      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00004378  4EB8 2B08               3838      JSR         EA_PRINT_IMM        ; Print immediate data
0000437C  4EF9 00004382           3839      JMP         SUB_MODE_END
00004382                          3840  SUB_MODE_END:
00004382  4E75                    3841      RTS                             ; Finish evaluating EA bits
00004384                          3842  SUB_MODE_INVALID:
00004384  4EB8 288A               3843      JSR         EA_INVALID          ; Opcode word is Invalid
00004388  4E75                    3844      RTS
0000438A                          3845  SUB_END:
0000438A  4EB8 28A2               3846      JSR         EA_UPDATE_POINTER   ; Updates global pointer
0000438E  4CDF 3FFF               3847      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00004392  4E75                    3848      RTS
00004394                          3849  
00004394                          3850  
00004394                          3851  
00004394                          3852  -------------------- end include --------------------
00004394                          3853      INCLUDE 'EndProgram.X68'
00004394                          3854  
00004394                          3855  
00004394                          3856  
00004394  =00000059               3857  UPYES     EQU   'Y'
00004394  =00000079               3858  LOWYES    EQU   'y'
00004394                          3859  
00004394                          3860  
00004394                          3861  
00004394                          3862  KEEP_RUNNING
00004394  6100 0004               3863      BSR.W       RERUN               * Run welcome subroutine
00004398  4E75                    3864      RTS                             * Return to Disassembler
0000439A                          3865  
0000439A                          3866  
0000439A                          3867  
0000439A                          3868  
0000439A                          3869  
0000439A                          3870  RERUN
0000439A  43F9 00004803           3871      LEA         ENDQUESTION,A1      * Loads message into A1
000043A0  103C 000E               3872      MOVE.B      #14,D0              * Moves the Task 14 into D0
000043A4  4E4F                    3873      TRAP        #15                 * Displays Intro Message
000043A6                          3874  
000043A6  103C 0005               3875      MOVE.B      #5,D0               * Move task 5 to read one char
000043AA  4E4F                    3876      TRAP        #15                 * Trap 15 for IO
000043AC                          3877  
000043AC  0C01 0059               3878      CMPI.B      #UPYES,D1           * Is char = Y
000043B0  6700 0012               3879      BEQ         NOTDONE             * If yes, notdone
000043B4  0C01 0079               3880      CMPI.B      #LOWYES,D1          * Is char = y
000043B8  6700 000A               3881      BEQ         NOTDONE             * If yes, notdone
000043BC  11FC 0000 6000          3882      MOVE.B      #0,(RUNAGAIN)       * 0 for false to end program
000043C2  4E75                    3883      RTS
000043C4                          3884  
000043C4                          3885  NOTDONE
000043C4  11FC 0001 6000          3886      MOVE.B      #1,(RUNAGAIN)       * 1 for true to rerun program
000043CA  6000 CF52               3887      BRA.W       CLEARSCRN           * Clear screen and return from subroutine
000043CE                          3888  
000043CE                          3889  
000043CE                          3890  
000043CE                          3891  
000043CE                          3892  -------------------- end include --------------------
000043CE                          3893      INCLUDE 'WriteBuffer.X68'
000043CE                          3894  
000043CE  =0000000D               3895  CR      EQU     $0D                 * Carriage return
000043CE  =0000000A               3896  LF      EQU     $0A                 * Line feed
000043CE                          3897  
000043CE  =00002000               3898  BUFFER  EQU     $2000               * Buffer address for string
000043CE  =0000001E               3899  RCOUNT  EQU     30                  * Counters
000043CE                          3900  
000043CE                          3901  WRITE_LINE
000043CE  163C 001E               3902      MOVE.B      #RCOUNT,D3          * Move row counter to D3
000043D2  45F8 2000               3903      LEA         BUFFER,A2           * Load BUFFER address to A2 for use
000043D6                          3904  
000043D6  6112                    3905      BSR.S       WRITE2MEM
000043D8  4E75                    3906      RTS
000043DA                          3907  
000043DA                          3908  
000043DA                          3909  
000043DA                          3910      *BSR.S       PRINTLN             * Subroutine to print buffer
000043DA                          3911  
000043DA                          3912      *LEA         BUFFER,A2           * Reset A2 for buffer cleaning
000043DA                          3913      *BSR.S       CLEAN_BUFF          * Subroutine to reset buffer to all F's
000043DA                          3914  
000043DA  5303                    3915      SUBI.B      #1,D3               * Decrement RCOUNT by 1
000043DC  0C03 0000               3916      CMPI.B      #0,D3               * Is RCOUNT = 0
000043E0  6700 004C               3917      BEQ         NEW_PAGE            * If yes, prompt user and make new page
000043E4  61E8                    3918      BSR.S       WRITE_LINE          * If no, keep writing lines
000043E6                          3919  
000043E6  6000 005E               3920      BRA         PAUSE               * Pause program (SIMHALT)
000043EA                          3921  
000043EA                          3922  WRITE2MEM
000043EA  0C14 0000               3923      CMP.B       #$00,(A4)           * Check if byte is string terminator
000043EE  6700 0006               3924      BEQ         SKIP_WRITE          * If yes, skip write and return
000043F2  14DC                    3925      MOVE.B      (A4)+,(A2)+         * If no, write byte to memory
000043F4  60F4                    3926      BRA         WRITE2MEM           * Keep writing, not end of string
000043F6                          3927  SKIP_WRITE
000043F6  287C 00000000           3928      MOVEA.L     #$00000000,A4       * Clean up A4
000043FC  4E75                    3929      RTS                             * Return to main
000043FE                          3930  
000043FE                          3931  WRITE_ENDL
000043FE  14FC 000D               3932      MOVE.B      #CR,(A2)+           * Move carriage return into memory
00004402  14FC 000A               3933      MOVE.B      #LF,(A2)+           * Move line feed into memory
00004406  14FC 0000               3934      MOVE.B      #$00,(A2)+          * Move string terminator into memory
0000440A  4E75                    3935      RTS
0000440C                          3936  
0000440C                          3937  PRINTLN
0000440C  45F8 2000               3938      LEA         BUFFER,A2           * Reset A2 to BUFFER address beginning
00004410  43D2                    3939      LEA         (A2),A1             * Load BUFFER address into A1
00004412  103C 000E               3940      MOVE.B      #14,D0              * Task 14, no CR or LF
00004416  4E4F                    3941      TRAP        #15                 * Display string held in BUFFER
00004418  4E75                    3942      RTS                             * Return to main
0000441A                          3943  
0000441A                          3944  CLEAN_BUFF
0000441A  0C92 FFFFFFFF           3945      CMPI.L      #$FFFFFFFF,(A2)     *
00004420  6700 000A               3946      BEQ         BUFFDONE            * Buffer has been cleaned
00004424  24FC FFFFFFFF           3947      MOVE.L      #$FFFFFFFF,(A2)+    * Fill with F's
0000442A  60EE                    3948      BRA         CLEAN_BUFF          * Continue cleaning buffer
0000442C                          3949  BUFFDONE
0000442C  4E75                    3950      RTS                             * Return to main
0000442E                          3951  
0000442E                          3952  NEW_PAGE
0000442E  4283                    3953      CLR.L       D3                  * Clear counter
00004430  43F9 00004833           3954      LEA         ENTER,A1            * Load enter message into A1
00004436  103C 000E               3955      MOVE.B      #14,D0              * Moves the Task 14 into D0
0000443A  4E4F                    3956      TRAP        #15                 * Displays contents of A1
0000443C  103C 0005               3957      MOVE.B      #5,D0               * Read single character from
00004440  4E4F                    3958      TRAP        #15                 * The keyboard into D1.B
00004442  6000 CEDA               3959      BRA.W       CLEARSCRN           * Clear the screen.
00004446                          3960  
00004446                          3961  PAUSE
00004446  FFFF FFFF               3962          SIMHALT                     * Halt simulator
0000444A  6000 0002               3963          BRA     QUIT                * End program
0000444E                          3964  
0000444E                          3965  QUIT
0000444E                          3966          *END     START        ; last line of source
0000444E                          3967  
0000444E                          3968  
0000444E                          3969  -------------------- end include --------------------
0000444E                          3970      
0000444E                          3971      INCLUDE 'IOMessages.X68'
0000444E                          3972  
0000444E= 57 45 4C 43 4F 4D ...   3973  INTRO           DC.B 'WELCOME!',CR,LF,'THIS IS A 68K DISASSEMBLER.',CR,LF,0
00004476= 50 4C 45 41 53 45 ...   3974  PS1             DC.B 'PLEASE ENTER THE STARTING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000044C0= 50 4C 45 41 53 45 ...   3975  PS2             DC.B 'PLEASE ENTER THE ENDING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
00004508= 0D 0A 42 45 47 49 ...   3976  BMESSAGE        DC.B CR,LF,'BEGINNING ADDRESS GIVEN IS: ',0
00004527= 0D 0A 45 4E 44 49 ...   3977  EMESSAGE        DC.B CR,LF,'ENDING ADDRESS GIVEN IS   : ',0
00004546                          3978  
00004546= 54 48 45 20 42 45 ...   3979  ADR_ERR_NOTLT   DC.B 'THE BEGINNING ADDRESS MUST BE LESS THAN THE ENDING ADDRESS.',CR,LF,'PRESS ANY KEY TO TRY AGAIN...',0
000045A1                          3980  
000045A1                          3981  HEXSTRING       DS.B 80             * Var for hex string
000045F1                          3982  
000045F1= 44 41 54 41 00          3983  DATA            DC.B 'DATA',0
000045F1= 44 41 54 41 00          3984  -------------------- end include --------------------
000045F6                          3985      INCLUDE 'OCMessages.X68'
000045F6                          3986  
000045F6                          3987  
000045F6  =0000000D               3988  CR      EQU     $0D
000045F6  =0000000A               3989  LF      EQU     $0A
000045F6= 20 00                   3990  MESSAGESPACE DC.B  ' ',0
000045F8= 4E 4F 50 00             3991  MESSAGENOP DC.B    'NOP',0
000045FC                          3992  
000045FC= 4D 4F 56 45 2E 57 00    3993  MESSAGEMOVEW DC.B    'MOVE.W',0
00004603= 4D 4F 56 45 2E 4C 00    3994  MESSAGEMOVEL DC.B    'MOVE.L',0
0000460A= 4D 4F 56 45 2E 42 00    3995  MESSAGEMOVEB DC.B    'MOVE.B',0
00004611                          3996  
00004611= 41 44 44 49 2E 57 00    3997  MESSAGEADDIW DC.B    'ADDI.W',0
00004618= 41 44 44 49 2E 4C 00    3998  MESSAGEADDIL DC.B    'ADDI.L',0
0000461F= 41 44 44 49 2E 42 00    3999  MESSAGEADDIB DC.B    'ADDI.B',0
00004626                          4000  
00004626= 4D 4F 56 45 41 2E ...   4001  MESSAGEMOVEAL DC.B    'MOVEA.L',0
0000462E= 4D 4F 56 45 41 2E ...   4002  MESSAGEMOVEAW DC.B    'MOVEA.W',0
00004636                          4003  
00004636= 4D 4F 56 45 4D 2E ...   4004  MESSAGEMOVEML DC.B    'MOVEM.L',0
0000463E= 4D 4F 56 45 4D 2E ...   4005  MESSAGEMOVEMW DC.B    'MOVEM.W',0
00004646                          4006  
00004646= 4A 53 52 00             4007  MESSAGEJSR DC.B    'JSR',0
0000464A                          4008  
0000464A= 43 4C 52 00             4009  MESSAGECLR DC.B    'CLR',0
0000464E                          4010  
0000464E= 52 54 53 00             4011  MESSAGERTS DC.B    'RTS',0
00004652                          4012  
00004652= 4C 45 41 00             4013  MESSAGELEA DC.B    'LEA',0
00004656                          4014  
00004656= 43 4C 52 2E 42 00       4015  MESSAGECLRB DC.B    'CLR.B',0
0000465C= 43 4C 52 2E 57 00       4016  MESSAGECLRW DC.B    'CLR.W',0
00004662= 43 4C 52 2E 4C 00       4017  MESSAGECLRL DC.B    'CLR.L',0
00004668                          4018  
00004668= 41 44 44 51 2E 42 00    4019  MESSAGEADDQB DC.B    'ADDQ.B',0
0000466F= 41 44 44 51 2E 57 00    4020  MESSAGEADDQW DC.B    'ADDQ.W',0
00004676= 41 44 44 51 2E 4C 00    4021  MESSAGEADDQL DC.B    'ADDQ.L',0
0000467D                          4022  
0000467D= 43 4D 50 2E 42 00       4023  MESSAGECMPB DC.B    'CMP.B',0
00004683= 43 4D 50 2E 57 00       4024  MESSAGECMPW DC.B    'CMP.W',0
00004689= 43 4D 50 2E 4C 00       4025  MESSAGECMPL DC.B    'CMP.L',0
0000468F                          4026  
0000468F= 53 55 42 2E 42 00       4027  MESSAGESUBB DC.B    'SUB.B',0
00004695= 53 55 42 2E 57 00       4028  MESSAGESUBW DC.B    'SUB.W',0
0000469B= 53 55 42 2E 4C 00       4029  MESSAGESUBL DC.B    'SUB.L',0
000046A1                          4030  
000046A1= 41 44 44 2E 42 00       4031  MESSAGEADDB DC.B    'ADD.B',0
000046A7= 41 44 44 2E 57 00       4032  MESSAGEADDW DC.B    'ADD.W',0
000046AD= 41 44 44 2E 4C 00       4033  MESSAGEADDL DC.B    'ADD.L',0
000046B3                          4034  
000046B3= 41 44 44 41 2E 57 00    4035  MESSAGEADDAW DC.B    'ADDA.W',0
000046BA= 41 44 44 41 2E 4C 00    4036  MESSAGEADDAL DC.B    'ADDA.L',0
000046C1                          4037  
000046C1= 4D 4F 56 45 51 2E ...   4038  MESSAGEMOVEQL DC.B    'MOVEQ.L',0
000046C9                          4039  
000046C9= 41 4E 44 2E 42 00       4040  MESSAGEANDB DC.B    'AND.B',0
000046CF= 41 4E 44 2E 57 00       4041  MESSAGEANDW DC.B    'AND.W',0
000046D5= 41 4E 44 2E 4C 00       4042  MESSAGEANDL DC.B    'AND.L',0
000046DB                          4043  
000046DB= 4D 55 4C 53 2E 57 00    4044  MESSAGEMULSW DC.B    'MULS.W',0
000046E2                          4045  
000046E2= 41 53 52 2E 42 00       4046  MESSAGEASRB DC.B    'ASR.B',0
000046E8= 41 53 52 2E 57 00       4047  MESSAGEASRW DC.B    'ASR.W',0
000046EE= 41 53 52 2E 4C 00       4048  MESSAGEASRL DC.B    'ASR.L',0
000046F4                          4049  
000046F4= 41 53 4C 2E 42 00       4050  MESSAGEASLB DC.B    'ASL.B',0
000046FA= 41 53 4C 2E 57 00       4051  MESSAGEASLW DC.B    'ASL.W',0
00004700= 41 53 4C 2E 4C 00       4052  MESSAGEASLL DC.B    'ASL.L',0
00004706                          4053  
00004706= 52 4F 52 2E 42 00       4054  MESSAGERORB DC.B    'ROR.B',0
0000470C= 52 4F 52 2E 57 00       4055  MESSAGERORW DC.B    'ROR.W',0
00004712= 52 4F 52 2E 4C 00       4056  MESSAGERORL DC.B    'ROR.L',0
00004718                          4057  
00004718= 52 4F 4C 2E 42 00       4058  MESSAGEROLB DC.B    'ROL.B',0
0000471E= 52 4F 4C 2E 57 00       4059  MESSAGEROLW DC.B    'ROL.W',0
00004724= 52 4F 4C 2E 4C 00       4060  MESSAGEROLL DC.B    'ROL.L',0
0000472A                          4061  
0000472A= 4C 53 52 2E 42 00       4062  MESSAGELSRB DC.B    'LSR.B',0
00004730= 4C 53 52 2E 57 00       4063  MESSAGELSRW DC.B    'LSR.W',0
00004736= 4C 53 52 2E 4C 00       4064  MESSAGELSRL DC.B    'LSR.L',0
0000473C                          4065  
0000473C= 4C 53 4C 2E 42 00       4066  MESSAGELSLB DC.B    'LSL.B',0
00004742= 4C 53 4C 2E 57 00       4067  MESSAGELSLW DC.B    'LSL.W',0
00004748= 4C 53 4C 2E 4C 00       4068  MESSAGELSLL DC.B    'LSL.L',0
0000474E                          4069  
0000474E= 4F 52 2E 42 00          4070  MESSAGEORB DC.B    'OR.B',0
00004753= 4F 52 2E 57 00          4071  MESSAGEORW DC.B    'OR.W',0
00004758= 4F 52 2E 4C 00          4072  MESSAGEORL DC.B    'OR.L',0
0000475D                          4073  
0000475D= 44 49 56 55 2E 57 00    4074  MESSAGEDIVUW DC.B    'DIVU.W',0
00004764                          4075  
00004764= 42 43 43 00             4076  MESSAGEBCC DC.B    'BCC',0
00004768= 42 47 54 00             4077  MESSAGEBGT DC.B    'BGT',0
0000476C= 42 4C 45 00             4078  MESSAGEBLE DC.B    'BLE',0
00004770                          4079  
00004770= 54 68 61 74 20 69 ...   4080  MESSAGEOPCODE_INVALID DC.B    'That is not an opcode!', 0
00004787                          4081  
00004787                          4082  
00004787                          4083  
00004787                          4084  
00004787                          4085  -------------------- end include --------------------
00004787                          4086      INCLUDE 'EAMessages.X68'
00004787                          4087  
00004787= 00                      4088  EA_MSG_NULL         DC.B    0
00004788= 20 00                   4089  EA_MSG_SPACE        DC.B    ' ',0
0000478A= 2C 20 00                4090  EA_MSG_COMMA        DC.B    ', ',0
0000478D= 28 00                   4091  EA_MSG_OPENPAREN    DC.B    '(',0
0000478F= 29 00                   4092  EA_MSG_CLOSEPAREN   DC.B    ')',0
00004791= 2D 00                   4093  EA_MSG_MIN          DC.B    '-',0
00004793= 2B 00                   4094  EA_MSG_PLUS         DC.B    '+',0
00004795= 23 00                   4095  EA_MSG_HASH         DC.B    '#',0
00004797= 24 00                   4096  EA_MSG_HEX          DC.B    '$',0
00004799                          4097  
00004799= 44 30 00                4098  EA_MSG_D0           DC.B    'D0',0
0000479C= 44 31 00                4099  EA_MSG_D1           DC.B    'D1',0
0000479F= 44 32 00                4100  EA_MSG_D2           DC.B    'D2',0
000047A2= 44 33 00                4101  EA_MSG_D3           DC.B    'D3',0
000047A5= 44 34 00                4102  EA_MSG_D4           DC.B    'D4',0
000047A8= 44 35 00                4103  EA_MSG_D5           DC.B    'D5',0
000047AB= 44 36 00                4104  EA_MSG_D6           DC.B    'D6',0
000047AE= 44 37 00                4105  EA_MSG_D7           DC.B    'D7',0
000047B1                          4106  
000047B1= 41 30 00                4107  EA_MSG_A0           DC.B    'A0',0
000047B4= 41 31 00                4108  EA_MSG_A1           DC.B    'A1',0
000047B7= 41 32 00                4109  EA_MSG_A2           DC.B    'A2',0
000047BA= 41 33 00                4110  EA_MSG_A3           DC.B    'A3',0
000047BD= 41 34 00                4111  EA_MSG_A4           DC.B    'A4',0
000047C0= 41 35 00                4112  EA_MSG_A5           DC.B    'A5',0
000047C3= 41 36 00                4113  EA_MSG_A6           DC.B    'A6',0
000047C6= 41 37 00                4114  EA_MSG_A7           DC.B    'A7',0
000047C9                          4115  
000047C9= 5B 45 41 20 43 4F ...   4116  EA_MSG_UNIMP        DC.B    '[EA CODE NOT IMPLEMENTED]',0
000047E3= 5B 50 52 49 4E 54 ...   4117  EA_MSG_PRINT_DATA   DC.B    '[PRINTING DATA NOT IMPLEMENTED]',0
00004803                          4118  
00004803                          4119  -------------------- end include --------------------
00004803                          4120      INCLUDE 'EPMessages.x68'        ; EndProgram messages
00004803                          4121  
00004803= 57 4F 55 4C 44 20 ...   4122  ENDQUESTION     DC.B 'WOULD YOU LIKE TO RUN THE PROGRAM AGAIN (Y/N)? ',0
00004803= 57 4F 55 4C 44 20 ...   4123  -------------------- end include --------------------
00004833                          4124      INCLUDE 'WBMessages.X68'        ; WriteBuffer messages
00004833                          4125  
00004833= 2D 2D 2D 2D 2D 2D ...   4126  ENTER           DC.B '------------------------- Press Enter ------------------------',0
00004872                          4127  
00004872                          4128  
00004872= 4D 4F 56 45 00          4129  MV              DC.B 'MOVE',0
00004877= 41 44 44 20 00          4130  AD              DC.B 'ADD ',0
0000487C                          4131  
0000487C= 2E 42 20 20 00          4132  BYTE            DC.B '.B  ',0
00004881= 2E 57 20 20 00          4133  WORD            DC.B '.W  ',0
00004886= 2E 4C 20 20 00          4134  LONG            DC.B '.L  ',0
0000488B= 0D 0A 00                4135  ENDL            DC.B CR,LF,0
0000488E                          4136  
0000488E= 44 30 00                4137  DREG0           DC.B 'D0',0
00004891= 44 31 00                4138  DREG1           DC.B 'D1',0
00004894= 44 32 00                4139  DREG2           DC.B 'D2',0
00004897= 44 33 00                4140  DREG3           DC.B 'D3',0
0000489A= 44 34 00                4141  DREG4           DC.B 'D4',0
0000489D= 44 35 00                4142  DREG5           DC.B 'D5',0
000048A0= 44 36 00                4143  DREG6           DC.B 'D6',0
000048A3= 44 37 00                4144  DREG7           DC.B 'D7',0
000048A6= 41 30 00                4145  AREG0           DC.B 'A0',0
000048A9= 41 31 00                4146  AREG1           DC.B 'A1',0
000048AC= 41 32 00                4147  AREG2           DC.B 'A2',0
000048AF= 41 33 00                4148  AREG3           DC.B 'A3',0
000048B2= 41 34 00                4149  AREG4           DC.B 'A4',0
000048B5= 41 35 00                4150  AREG5           DC.B 'A5',0
000048B8= 41 36 00                4151  AREG6           DC.B 'A6',0
000048BB= 41 37 00                4152  AREG7           DC.B 'A7',0
000048BE                          4153  
000048BE= 23 00                   4154  POUND           DC.B '#',0
000048C0= 24 00                   4155  DOLLAR          DC.B '$',0
000048C2= 25 00                   4156  PERCENT         DC.B '%',0
000048C4= 2C 20 00                4157  COMMA           DC.B ', ',0
000048C7= 28 00                   4158  OPAREN          DC.B '(',0
000048C9= 29 00                   4159  CPAREN          DC.B ')',0
000048CB= 2B 00                   4160  PLUS            DC.B '+',0
000048CD= 2D 00                   4161  MINUS           DC.B '-',0
000048CF                          4162  
000048CF= 20 20 20 20 00          4163  TAB             DC.B '    ',0
000048CF= 20 20 20 20 00          4164  -------------------- end include --------------------
000048D4                          4165  
000048D4                          4166  *********** END INCLUDES *****************************************************
000048D4                          4167  
000048D4                          4168  *---------- Reserved Registers -----------------------------
000048D4                          4169  *   A7: stack pointer
000048D4                          4170  *   A6: current address (updated by subroutines)
000048D4                          4171  *   D0: instruction validity flag (reset by main control
000048D4                          4172  *       code, can be set to false by subroutines)
000048D4                          4173  *-----------------------------------------------------------
000048D4                          4174  
000048D4                          4175  *---------- End --------------------------------------------
000048D4                          4176                 END  START          * Last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AD                  4877
ADDA_ABS_L          2F4E
ADDA_ABS_W          2F44
ADDA_END            2F84
ADDA_IMM            2F58
ADDA_MODE           2EB8
ADDA_MODE_000       2EE8
ADDA_MODE_001       2EF2
ADDA_MODE_010       2EFC
ADDA_MODE_011       2F06
ADDA_MODE_100       2F10
ADDA_MODE_101       2F1A
ADDA_MODE_110       2F20
ADDA_MODE_111       2F26
ADDA_MODE_END       2F70
ADDA_MODE_INVALID   2F66
ADDCODE000          1970
ADDCODE001          1978
ADDCODE010          1980
ADDCODE011          1988
ADDCODE100          1990
ADDCODE101          1998
ADDCODE110          19A0
ADDCODE111          19A8
ADDIBCODE00         1DCE
ADDILCODE10         1DDE
ADDILCODE11         1DE6
ADDIWCODE01         1DD6
ADDI_ABS_L          3096
ADDI_ABS_W          308C
ADDI_B              2FBC
ADDI_BORADDI_WORADDI_L  1D98
ADDI_END            30A0
ADDI_GET_DEST       2FEA
ADDI_L              2FE4
ADDI_MODE           2FFC
ADDI_MODE_000       302C
ADDI_MODE_001       3036
ADDI_MODE_010       3040
ADDI_MODE_011       304A
ADDI_MODE_100       3054
ADDI_MODE_101       305E
ADDI_MODE_110       3068
ADDI_MODE_111       3072
ADDI_W              2FD6
ADDQCODE00          1ACA
ADDQCODE01          1AD2
ADDQCODE10          1ADA
ADDQCODE11          1AE2
ADDQ_ABS_L          3194
ADDQ_ABS_W          318A
ADDQ_BORADDQ_WORADDQ_L  1A94
ADDQ_END            319E
ADDQ_MODE           30FA
ADDQ_MODE_000       312A
ADDQ_MODE_001       3134
ADDQ_MODE_010       313E
ADDQ_MODE_011       3148
ADDQ_MODE_100       3152
ADDQ_MODE_101       315C
ADDQ_MODE_110       3166
ADDQ_MODE_111       3170
ADDQ_PRINT_IMM      30CC
ADDRESS_ERR         132A
ADD_ABS_L           2E70
ADD_ABS_W           2E66
ADD_BORADD_WORADD_L  1922
ADD_END             2E94
ADD_EVAL_EA         2DBC
ADD_IMM             2E7A
ADD_MODE            2DCA
ADD_MODE_000        2DFA
ADD_MODE_001        2E0C
ADD_MODE_010        2E1E
ADD_MODE_011        2E28
ADD_MODE_1          2D6C
ADD_MODE_100        2E32
ADD_MODE_101        2E3C
ADD_MODE_110        2E42
ADD_MODE_111        2E48
ADD_MODE_2          2D96
ADD_MODE_END        2E8C
ADD_MODE_INVALID    2E8E
ADD_OPMODE          2CEC
ADD_OPMODE_000      2D1C
ADD_OPMODE_001      2D26
ADD_OPMODE_010      2D30
ADD_OPMODE_011      2D3A
ADD_OPMODE_100      2D44
ADD_OPMODE_101      2D4E
ADD_OPMODE_110      2D58
ADD_OPMODE_111      2D62
ADR_ERR_NOTLT       4546
ANDCODE000          18E2
ANDCODE001          18EA
ANDCODE010          18F2
ANDCODE011          18FA
ANDCODE100          1902
ANDCODE101          190A
ANDCODE110          1912
ANDCODE111          191A
AND_ABS_L           3338
AND_ABS_W           332E
AND_BORAND_WORAND_LORMULS_W  1894
AND_END             335C
AND_EVAL_EA         3290
AND_IMM             3342
AND_MODE            329E
AND_MODE_000        32CE
AND_MODE_001        32E0
AND_MODE_010        32E6
AND_MODE_011        32F0
AND_MODE_1          3240
AND_MODE_100        32FA
AND_MODE_101        3304
AND_MODE_110        330A
AND_MODE_111        3310
AND_MODE_2          326A
AND_MODE_END        3354
AND_MODE_INVALID    3356
AND_OPMODE          31C0
AND_OPMODE_000      31F0
AND_OPMODE_001      31FA
AND_OPMODE_010      3204
AND_OPMODE_011      320E
AND_OPMODE_100      3218
AND_OPMODE_101      3222
AND_OPMODE_110      322C
AND_OPMODE_111      3236
AN_000              29EE
AN_001              29FA
AN_010              2A06
AN_011              2A12
AN_100              2A1E
AN_101              2A2A
AN_110              2A36
AN_111              2A42
AN_JMP              29BE
AREG0               48A6
AREG1               48A9
AREG2               48AC
AREG3               48AF
AREG4               48B2
AREG5               48B5
AREG6               48B8
AREG7               48BB
ASCII_TO_HEX        1172
ASD_END             348C
ASD_MEM             33D6
ASD_MEM_ABS_L       3482
ASD_MEM_ABS_W       3478
ASD_MEM_MODE        33E8
ASD_MEM_MODE_000    3418
ASD_MEM_MODE_001    3422
ASD_MEM_MODE_010    342C
ASD_MEM_MODE_011    3436
ASD_MEM_MODE_100    3440
ASD_MEM_MODE_101    344A
ASD_MEM_MODE_110    3454
ASD_MEM_MODE_111    345E
ASD_REG             337E
ASD_REG_COUNT       33AC
ASD_REG_END         33BC
ASD_REG_REG         33A2
ASLCODE00           162A
ASLCODE01           1632
ASLCODE10           163A
ASLCODE11           1642
ASL_ASR             180E
ASL_ASRCODE0        1838
ASL_ASRCODE1        183E
ASRCODE00           15D4
ASRCODE01           15DC
ASRCODE10           15E4
ASRCODE11           15EC
BCCORBGTORBLE       14BA
BCCORBGTORBLECODE00  14F0
BCCORBGTORBLECODE01  14F8
BCCORBGTORBLECODE10  1500
BCCORBGTORBLECODE11  1508
BCC_B               34C4
BCC_DISPLAY         3518
BCC_L               350A
BCC_W               34E8
BEGINADDR           5000
BMESSAGE            4508
BUFFDONE            442C
BUFFER              2000
BYTE                487C
CHECK_BADDR_IS_LESS_THAN_EADDR  10F2
CLEAN_BUFF          441A
CLEAR               1126
CLEARSCRN           131E
CLRCODE00           1B20
CLRCODE01           1B28
CLRCODE10           1B30
CLRCODE11           1B38
CLR_ABS_L           35D8
CLR_ABS_W           35CE
CLR_END             35E2
CLR_MODE            353E
CLR_MODE_000        356E
CLR_MODE_001        3578
CLR_MODE_010        3582
CLR_MODE_011        358C
CLR_MODE_100        3596
CLR_MODE_101        35A0
CLR_MODE_110        35AA
CLR_MODE_111        35B4
CMPCODE00           1A74
CMPCODE01           1A7C
CMPCODE10           1A84
CMPCODE11           1A8C
CMP_ABS_L           36A0
CMP_ABS_W           3696
CMP_BORCMP_WORCMP_L  1A3E
CMP_END             36BE
CMP_MODE            3606
CMP_MODE_000        3636
CMP_MODE_001        3640
CMP_MODE_010        364A
CMP_MODE_011        3654
CMP_MODE_100        365E
CMP_MODE_101        3668
CMP_MODE_110        3672
CMP_MODE_111        367C
CMP_MODE_END        36AA
CODE0000            140E
CODE0001            1414
CODE0010            1420
CODE0011            1426
CODE0100            142C
CODE0101            1438
CODE0110            1444
CODE0111            1450
CODE1000            145C
CODE1001            1468
CODE1010            1474
CODE1011            147C
CODE1100            1488
CODE1101            1494
CODE1110            14A0
CODE1111            14AC
COMMA               48C4
CPAREN              48C9
CR                  D
DATA                45F1
DIVU_W_ABS_L        3784
DIVU_W_ABS_W        377A
DIVU_W_DEST         379C
DIVU_W_END          37AE
DIVU_W_IMM          378E
DIVU_W_MODE         36E2
DIVU_W_MODE_000     3712
DIVU_W_MODE_001     371C
DIVU_W_MODE_010     3726
DIVU_W_MODE_011     3730
DIVU_W_MODE_100     373A
DIVU_W_MODE_101     3744
DIVU_W_MODE_110     374E
DIVU_W_MODE_111     3758
DN_000              294E
DN_001              295A
DN_010              2966
DN_011              2972
DN_100              297E
DN_101              298A
DN_110              2996
DN_111              29A2
DOLLAR              48C0
DONE                14B4
DREG0               488E
DREG1               4891
DREG2               4894
DREG3               4897
DREG4               489A
DREG5               489D
DREG6               48A0
DREG7               48A3
EA_ADD              2CD2
EA_ADDA             2E9E
EA_ADDI             2F8E
EA_ADDQ             30AA
EA_AND              31A8
EA_ASD              3366
EA_BCC              3496
EA_CLR              3524
EA_CMP              35EC
EA_COPY_PTR         28AE
EA_DEFAULT_COMBO    28B2
EA_DIVU_W           36C8
EA_INVALID          288A
EA_JSR              37B8
EA_LEA              3880
EA_LSD              395C
EA_MOVE             3A8C
EA_MOVEA            3C60
EA_MOVEM            3D86
EA_MOVEQ            3D8C
EA_MSG_A0           47B1
EA_MSG_A1           47B4
EA_MSG_A2           47B7
EA_MSG_A3           47BA
EA_MSG_A4           47BD
EA_MSG_A5           47C0
EA_MSG_A6           47C3
EA_MSG_A7           47C6
EA_MSG_CLOSEPAREN   478F
EA_MSG_COMMA        478A
EA_MSG_D0           4799
EA_MSG_D1           479C
EA_MSG_D2           479F
EA_MSG_D3           47A2
EA_MSG_D4           47A5
EA_MSG_D5           47A8
EA_MSG_D6           47AB
EA_MSG_D7           47AE
EA_MSG_HASH         4795
EA_MSG_HEX          4797
EA_MSG_MIN          4791
EA_MSG_NULL         4787
EA_MSG_OPENPAREN    478D
EA_MSG_PLUS         4793
EA_MSG_PRINT_DATA   47E3
EA_MSG_SPACE        4788
EA_MSG_UNIMP        47C9
EA_MULS_W           3DEC
EA_OPMODE_COMBO     28D8
EA_OR               3EDC
EA_PRINT_ABS_L      2CB2
EA_PRINT_ABS_W      2CC2
EA_PRINT_AN         29B0
EA_PRINT_AN_END     2A4E
EA_PRINT_DATA       2894
EA_PRINT_DN         2910
EA_PRINT_DN_END     29AE
EA_PRINT_DN_JMP     291E
EA_PRINT_IMM        2B08
EA_PRINT_IND        2A50
EA_PRINT_IND_END    2AFA
EA_PRINT_PD_END     2CA4
EA_PRINT_PI_END     2BD4
EA_PRINT_POSTINC    2B2A
EA_PRINT_PREDEC     2BEE
EA_ROD              40A0
EA_SIZE_BITS        28FE
EA_SUB              41D0
EA_UNIMPLEMENTED    287A
EA_UPDATE_POINTER   28A2
EMESSAGE            4527
ENDADDR             5010
ENDL                488B
ENDQUESTION         4803
END_LOOP            103C
ENTER               4833
FINISHED            1110
FOUND               122E
GET_ADDRESSES       104E
GET_FIRST_ADDRESS   105A
GET_HEXSTRING       1140
GET_SECOND_ADDRESS  10A6
HEXA                127E
HEXB                1286
HEXC                128E
HEXD                1296
HEXE                129E
HEXEIGHT            1272
HEXF                12A6
HEXFIVE             1266
HEXFLAG             5021
HEXFOUR             1262
HEXNINE             1276
HEXONE              1256
HEXSEVEN            126E
HEXSIX              126A
HEXSTRING           45A1
HEXTHREE            125E
HEXTWO              125A
HEXVALUE            5030
HEXZERO             124E
IND_000             2A9A
IND_001             2AA6
IND_010             2AB2
IND_011             2ABE
IND_100             2ACA
IND_101             2AD6
IND_110             2AE2
IND_111             2AEE
IND_JMP             2A6A
INITIAL_TABLE       13AE
INTRO               444E
INVALID_DATA        133C
IO_WELCOME          1112
ISADDAL             23A6
ISADDAW             237E
ISADDB              23CE
ISADDIB             2852
ISADDIL             282A
ISADDIW             2802
ISADDL              241E
ISADDQB             2536
ISADDQL             2586
ISADDQW             255E
ISADDW              23F6
ISANDB              2306
ISANDL              2356
ISANDW              232E
ISASLB              20AA
ISASLL              20EE
ISASLW              20D2
ISASRB              2032
ISASRL              2082
ISASRW              205A
ISBCC               1F1A
ISBGT               1F42
ISBLE               1F6A
ISCLR               2706
ISCLRB              25CA
ISCLRL              261A
ISCLRW              25F2
ISCMPB              24BE
ISCMPL              250E
ISCMPW              24E6
ISDIVUW             1F92
ISJSR               26BA
ISLEA               2692
ISLSLB              218E
ISLSLL              21D2
ISLSLW              21AA
ISLSRB              2116
ISLSRL              2166
ISLSRW              213E
ISMOVEAL            27BE
ISMOVEAW            276E
ISMOVEB             27E6
ISMOVEL             2796
ISMOVEML            2642
ISMOVEMW            266A
ISMOVEQL            25A2
ISMOVEW             2746
ISMULSW             22DE
ISNOP               2722
ISORB               1FBA
ISORL               200A
ISORW               1FE2
ISROLB              2266
ISROLL              22B6
ISROLW              228E
ISRORB              21FA
ISRORL              223E
ISRORW              2222
ISRTS               26E2
ISSUBB              2446
ISSUBL              2496
ISSUBW              246E
IS_HEX_EVEN         12CE
IS_LESSTHAN         12AE
JSRORCLRCODE0000    1BE2
JSRORCLRCODE0001    1BEA
JSRORCLRCODE0010    1BF2
JSRORCLRCODE0011    1BF8
JSRORCLRCODE0100    1C00
JSRORCLRCODE0101    1C08
JSRORCLRCODE0110    1C10
JSRORCLRCODE0111    1C18
JSRORCLRCODE1000    1C20
JSRORCLRCODE1001    1C28
JSRORCLRCODE1010    1C30
JSRORCLRCODE1011    1C38
JSRORCLRCODE1100    1C40
JSRORCLRCODE1101    1C48
JSRORCLRCODE1110    1C50
JSRORCLRCODE1111    1C58
JSR_ABS_L           386C
JSR_ABS_W           3862
JSR_END             3876
JSR_MODE            37D2
JSR_MODE_000        3802
JSR_MODE_001        380C
JSR_MODE_010        3816
JSR_MODE_011        3820
JSR_MODE_100        382A
JSR_MODE_101        3834
JSR_MODE_110        383E
JSR_MODE_111        3848
KEEP_RUNNING        4394
LEA_ABS_L           3934
LEA_ABS_W           392A
LEA_DEST            393E
LEA_END             3952
LEA_MODE            389A
LEA_MODE_000        38CA
LEA_MODE_001        38D4
LEA_MODE_010        38DE
LEA_MODE_011        38E8
LEA_MODE_100        38F2
LEA_MODE_101        38FC
LEA_MODE_110        3906
LEA_MODE_111        3910
LF                  A
LONG                4886
LOOP                100E
LOOP_CHECK          1032
LOTSCODE0000        1D1E
LOTSCODE0001        1D26
LOTSCODE0010        1D2E
LOTSCODE0011        1D34
LOTSCODE0100        1D3C
LOTSCODE0101        1D44
LOTSCODE0110        1D4C
LOTSCODE0111        1D54
LOTSCODE1000        1D5C
LOTSCODE1001        1D62
LOTSCODE1010        1D6A
LOTSCODE1011        1D70
LOTSCODE1100        1D78
LOTSCODE1101        1D80
LOTSCODE1110        1D88
LOTSCODE1111        1D90
LOWYES              79
LSD_END             3A82
LSD_MEM             39CC
LSD_MEM_ABS_L       3A78
LSD_MEM_ABS_W       3A6E
LSD_MEM_MODE        39DE
LSD_MEM_MODE_000    3A0E
LSD_MEM_MODE_001    3A18
LSD_MEM_MODE_010    3A22
LSD_MEM_MODE_011    3A2C
LSD_MEM_MODE_100    3A36
LSD_MEM_MODE_101    3A40
LSD_MEM_MODE_110    3A4A
LSD_MEM_MODE_111    3A54
LSD_REG             3974
LSD_REG_COUNT       39A2
LSD_REG_END         39B2
LSD_REG_REG         3998
LSLCODE00           16D6
LSLCODE01           16DE
LSLCODE10           16E6
LSLCODE11           16EE
LSL_LSR             17D8
LSL_LSRCODE0        1802
LSL_LSRCODE1        1808
LSRCODE00           1680
LSRCODE01           1688
LSRCODE10           1690
LSRCODE11           1698
LT                  12C6
MESSAGEADDAL        46BA
MESSAGEADDAW        46B3
MESSAGEADDB         46A1
MESSAGEADDIB        461F
MESSAGEADDIL        4618
MESSAGEADDIW        4611
MESSAGEADDL         46AD
MESSAGEADDQB        4668
MESSAGEADDQL        4676
MESSAGEADDQW        466F
MESSAGEADDW         46A7
MESSAGEANDB         46C9
MESSAGEANDL         46D5
MESSAGEANDW         46CF
MESSAGEASLB         46F4
MESSAGEASLL         4700
MESSAGEASLW         46FA
MESSAGEASRB         46E2
MESSAGEASRL         46EE
MESSAGEASRW         46E8
MESSAGEBCC          4764
MESSAGEBGT          4768
MESSAGEBLE          476C
MESSAGECLR          464A
MESSAGECLRB         4656
MESSAGECLRL         4662
MESSAGECLRW         465C
MESSAGECMPB         467D
MESSAGECMPL         4689
MESSAGECMPW         4683
MESSAGEDIVUW        475D
MESSAGEJSR          4646
MESSAGELEA          4652
MESSAGELSLB         473C
MESSAGELSLL         4748
MESSAGELSLW         4742
MESSAGELSRB         472A
MESSAGELSRL         4736
MESSAGELSRW         4730
MESSAGEMOVEAL       4626
MESSAGEMOVEAW       462E
MESSAGEMOVEB        460A
MESSAGEMOVEL        4603
MESSAGEMOVEML       4636
MESSAGEMOVEMW       463E
MESSAGEMOVEQL       46C1
MESSAGEMOVEW        45FC
MESSAGEMULSW        46DB
MESSAGENOP          45F8
MESSAGEOPCODE_INVALID  4770
MESSAGEORB          474E
MESSAGEORL          4758
MESSAGEORW          4753
MESSAGEROLB         4718
MESSAGEROLL         4724
MESSAGEROLW         471E
MESSAGERORB         4706
MESSAGERORL         4712
MESSAGERORW         470C
MESSAGERTS          464E
MESSAGESPACE        45F6
MESSAGESUBB         468F
MESSAGESUBL         469B
MESSAGESUBW         4695
MINUS               48CD
MOD                 2
MOVEACODE001        1E44
MOVEAWCODE001       1ED2
MOVEA_ADJUST_L      3C96
MOVEA_ADJUST_W      3C8C
MOVEA_DESTINATION   3D68
MOVEA_END           3D7C
MOVEA_LORMOVE_L     1DEE
MOVEA_SOURCE        3CA0
MOVEA_SRC_ABS_L     3D54
MOVEA_SRC_ABS_W     3D4A
MOVEA_SRC_IMM       3D5E
MOVEA_SRC_MODE      3CB2
MOVEA_SRC_MODE_000  3CE2
MOVEA_SRC_MODE_001  3CEC
MOVEA_SRC_MODE_010  3CF6
MOVEA_SRC_MODE_011  3D00
MOVEA_SRC_MODE_100  3D0A
MOVEA_SRC_MODE_101  3D14
MOVEA_SRC_MODE_110  3D1E
MOVEA_SRC_MODE_111  3D28
MOVEA_WORMOVE_W     1E7C
MOVECODE000         1E3C
MOVECODE010         1E4C
MOVECODE011         1E54
MOVECODE100         1E5C
MOVECODE101         1E64
MOVECODE110         1E6C
MOVECODE111         1E74
MOVEMCODE0          1C8A
MOVEMCODE1          1C92
MOVEQ_PRINT_DATA    3DBE
MOVEWCODE000        1ECA
MOVEWCODE010        1EDA
MOVEWCODE011        1EE2
MOVEWCODE100        1EEA
MOVEWCODE101        1EF2
MOVEWCODE110        1EFA
MOVEWCODE111        1F02
MOVE_ADJUST_L       3AC2
MOVE_ADJUST_W       3AB8
MOVE_DESTINATION    3B94
MOVE_DST_ABS_L      3C4C
MOVE_DST_ABS_W      3C42
MOVE_DST_MODE       3BB2
MOVE_DST_MODE_000   3BE2
MOVE_DST_MODE_001   3BEC
MOVE_DST_MODE_010   3BF6
MOVE_DST_MODE_011   3C00
MOVE_DST_MODE_100   3C0A
MOVE_DST_MODE_101   3C14
MOVE_DST_MODE_110   3C1E
MOVE_DST_MODE_111   3C28
MOVE_END            3C56
MOVE_SOURCE         3ACC
MOVE_SRC_ABS_L      3B80
MOVE_SRC_ABS_W      3B76
MOVE_SRC_IMM        3B8A
MOVE_SRC_MODE       3ADE
MOVE_SRC_MODE_000   3B0E
MOVE_SRC_MODE_001   3B18
MOVE_SRC_MODE_010   3B22
MOVE_SRC_MODE_011   3B2C
MOVE_SRC_MODE_100   3B36
MOVE_SRC_MODE_101   3B40
MOVE_SRC_MODE_110   3B4A
MOVE_SRC_MODE_111   3B54
MULS_W_ABS_L        3EA8
MULS_W_ABS_W        3E9E
MULS_W_DEST         3EC0
MULS_W_END          3ED2
MULS_W_IMM          3EB2
MULS_W_MODE         3E06
MULS_W_MODE_000     3E36
MULS_W_MODE_001     3E40
MULS_W_MODE_010     3E4A
MULS_W_MODE_011     3E54
MULS_W_MODE_100     3E5E
MULS_W_MODE_101     3E68
MULS_W_MODE_110     3E72
MULS_W_MODE_111     3E7C
MV                  4872
NEW_LINE            1310
NEW_PAGE            442E
NOPCOMMAND          1BDA
NOPORCLRORRTSORJSR  1B40
NOP_MOVEM_LEA_JSR_CLR_RTS  1C9A
NOTDONE             43C4
NOTEVEN             12F8
OC_PARSE            1392
OPAREN              48C7
OPCODE_INVALID      1F0A
OR_ABS_L            4072
OR_ABS_W            4068
OR_BOROR_WOROR_LORDIVU  1510
OR_DIVUCODE000      155E
OR_DIVUCODE001      1566
OR_DIVUCODE010      156E
OR_DIVUCODE011      1576
OR_DIVUCODE100      157E
OR_DIVUCODE101      1586
OR_DIVUCODE110      158E
OR_DIVUCODE111      1596
OR_END              4096
OR_EVAL_EA          3FC6
OR_IMM              407C
OR_MODE             3FD4
OR_MODE_000         4004
OR_MODE_001         400E
OR_MODE_010         4020
OR_MODE_011         402A
OR_MODE_1           3F76
OR_MODE_100         4034
OR_MODE_101         403E
OR_MODE_110         4044
OR_MODE_111         404A
OR_MODE_2           3FA0
OR_MODE_END         408E
OR_MODE_INVALID     4090
OR_OPMODE           3EF6
OR_OPMODE_000       3F26
OR_OPMODE_001       3F30
OR_OPMODE_010       3F3A
OR_OPMODE_011       3F44
OR_OPMODE_100       3F4E
OR_OPMODE_101       3F58
OR_OPMODE_110       3F62
OR_OPMODE_111       3F6C
PAUSE               4446
PERCENT             48C2
PLUS                48CB
POSTINC_000         2B74
POSTINC_001         2B80
POSTINC_010         2B8C
POSTINC_011         2B98
POSTINC_100         2BA4
POSTINC_101         2BB0
POSTINC_110         2BBC
POSTINC_111         2BC8
POSTINC_JMP         2B44
POUND               48BE
PREDEC_000          2C44
PREDEC_001          2C50
PREDEC_010          2C5C
PREDEC_011          2C68
PREDEC_100          2C74
PREDEC_101          2C80
PREDEC_110          2C8C
PREDEC_111          2C98
PREDEC_JMP          2C14
PRINTLN             440C
PRINT_HEXVALUE      1302
PRINT_IMM_END       2B26
PRINT_IMM_L         2B22
PS1                 4476
PS2                 44C0
QUIT                444E
RCOUNT              1E
REMAINDER           5050
REPEAT              12DA
RERUN               439A
ROD_END             41C6
ROD_LSD_ASD         1844
ROD_LSD_ASDCODE00   187A
ROD_LSD_ASDCODE01   1880
ROD_LSD_ASDCODE10   1886
ROD_LSD_ASDCODE11   188E
ROD_MEM             4110
ROD_MEM_ABS_L       41BC
ROD_MEM_ABS_W       41B2
ROD_MEM_MODE        4122
ROD_MEM_MODE_000    4152
ROD_MEM_MODE_001    415C
ROD_MEM_MODE_010    4166
ROD_MEM_MODE_011    4170
ROD_MEM_MODE_100    417A
ROD_MEM_MODE_101    4184
ROD_MEM_MODE_110    418E
ROD_MEM_MODE_111    4198
ROD_REG             40B8
ROD_REG_COUNT       40E6
ROD_REG_END         40F6
ROD_REG_REG         40DC
ROLCODE00           172C
ROLCODE01           1734
ROLCODE10           173C
ROLCODE11           1744
ROL_ROR             17A2
ROL_RORCODE0        17CC
ROL_RORCODE1        17D2
RORCODE00           1782
RORCODE01           178A
RORCODE10           1792
RORCODE11           179A
RTSCOMMAND          1BD2
RUNAGAIN            6000
SHIFTLEFT           1248
SKIP_WRITE          43F6
SOMEASL             15F4
SOMEASR             159E
SOMECLR             1AEA
SOMELSL             16A0
SOMELSR             164A
SOMEMOVEM           1C60
SOMEROL             16F6
SOMEROR             174C
STACK               7000
START               1000
STR_LEN             5020
SUBCODE000          19FE
SUBCODE001          1A06
SUBCODE010          1A0E
SUBCODE011          1A16
SUBCODE100          1A1E
SUBCODE101          1A26
SUBCODE110          1A2E
SUBCODE111          1A36
SUB_ABS_L           4366
SUB_ABS_W           435C
SUB_BORSUB_WORSUB_L  19B0
SUB_END             438A
SUB_EVAL_EA         42B2
SUB_IMM             4370
SUB_MODE            42C0
SUB_MODE_000        42F0
SUB_MODE_001        4302
SUB_MODE_010        4314
SUB_MODE_011        431E
SUB_MODE_1          4262
SUB_MODE_100        4328
SUB_MODE_101        4332
SUB_MODE_110        4338
SUB_MODE_111        433E
SUB_MODE_2          428C
SUB_MODE_END        4382
SUB_MODE_INVALID    4384
SUB_OPMODE          41E2
SUB_OPMODE_000      4212
SUB_OPMODE_001      421C
SUB_OPMODE_010      4226
SUB_OPMODE_011      4230
SUB_OPMODE_100      423A
SUB_OPMODE_101      4244
SUB_OPMODE_110      424E
SUB_OPMODE_111      4258
TAB                 48CF
TABLEADDI_BORADDI_WORADDI_L  1DB6
TABLEADDQ_BORADDQ_WORADDQ_L  1AB2
TABLEADD_BORADD_WORADD_L  1940
TABLEAND_BORAND_WORAND_LORMULS_W  18B2
TABLEASL_ASR        182C
TABLEBCCORBGTORBLE  14D8
TABLECMP_BORCMP_WORCMP_L  1A5C
TABLELSL_LSR        17F6
TABLEMOVEA_LORMOVE_L  1E0C
TABLEMOVEA_WORMOVE_W  1E9A
TABLENOPORCLRORRTSORJSR  1B72
TABLENOP_MOVEM_LEA_JSR_CLR_RTS  1CBE
TABLEOR_BOROR_WOROR_LORDIVU  152E
TABLEROD_LSD_ASD    1862
TABLEROL_ROR        17C0
TABLESOMEASL        1612
TABLESOMEASR        15BC
TABLESOMECLR        1B08
TABLESOMELSL        16BE
TABLESOMELSR        1668
TABLESOMEMOVEM      1C7E
TABLESOMEROL        1714
TABLESOMEROR        176A
TABLESUB_BORSUB_WORSUB_L  19CE
UPDATE_PTR          28AA
UPYES               59
WORD                4881
WRITE2MEM           43EA
WRITE_ENDL          43FE
WRITE_LINE          43CE
