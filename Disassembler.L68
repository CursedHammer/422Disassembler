00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/2/2016 3:47:33 PM

00000000                             1  ******************************************************************************
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Brandon Authier (Hblkr), Jack S. Eldridge
00000000                             4  *              (JackScottie), Marijn Burger (marijnburger)
00000000                             5  * Date       : 16 May 2016
00000000                             6  * Description: An inverse assembler that will convert a memory
00000000                             7  *              image of instructions and data back to the display.
00000000                             8  *              The following will be decoded:
00000000                             9  *
00000000                            10  *              Addressing Modes
00000000                            11  *
00000000                            12  *                Data Register Direct
00000000                            13  *                Address Register Direct
00000000                            14  *                Address Register Indirect
00000000                            15  *                Immediate Data
00000000                            16  *                Address Register Indirect with Post Increment
00000000                            17  *                Address Register Indirect with Pre Decrement
00000000                            18  *                Absolute Long Address
00000000                            19  *                Absolute Word Address
00000000                            20  *
00000000                            21  *              Instructions
00000000                            22  *
00000000                            23  *                NOP
00000000                            24  *                MOVE
00000000                            25  *                MOVEA
00000000                            26  *                MOVEQ
00000000                            27  *                MOVEM
00000000                            28  *                ADD
00000000                            29  *                ADDA
00000000                            30  *                ADDI
00000000                            31  *                ADDQ
00000000                            32  *                SUB
00000000                            33  *                MULS
00000000                            34  *                DIVU
00000000                            35  *                LEA
00000000                            36  *                CLR
00000000                            37  *                AND
00000000                            38  *                OR
00000000                            39  *                LSL
00000000                            40  *                LSR
00000000                            41  *                ASR
00000000                            42  *                ASL
00000000                            43  *                ROL
00000000                            44  *                ROR
00000000                            45  *                CMP
00000000                            46  *                Bcc (BCC, BGT, BLE)
00000000                            47  *                JSR
00000000                            48  *                RTS
00000000                            49  *
00000000                            50  ******************************************************************************
00000000                            51  
00000000                            52  ******************************************************************************
00000000                            53  *           DEFINITIONS                                                      *
00000000                            54  ******************************************************************************
00000000  =00007000                 55  STACK     EQU   $7000               * Beginning address for stack pointer
00000000                            56  
00000000  =00005000                 57  BEGINADDR EQU   $5000               * Variable to hold beginning address value
00000000  =00005010                 58  ENDADDR   EQU   $5010               * Variable to hold ending address value
00000000                            59  
00000000  =00006000                 60  RUNAGAIN  EQU   $6000               * Value equivalent to 'true'
00000000                            61  
00001000                            62  START     ORG   $1000               * Program begins at address 1000
00001000                            63  
00001000                            64  *********** END DEFINITIONS **************************************************
00001000                            65  
00001000                            66  
00001000                            67  ******************************************************************************
00001000                            68  *           BEGIN CODE                                                       *
00001000                            69  ******************************************************************************
00001000                            70  
00001000                            71  *---------- START ------------------------------------------------------------
00001000                            72  * Begins program's logical flow. Similar to main in C/C++
00001000                            73  *-----------------------------------------------------------------------------
00001000  4FF8 7000                 74      LEA         STACK,SP            * SP is stored in A7
00001004  4EB9 0000104E             75      JSR         GET_ADDRESSES       * Runs GET_ADDRESSES and IO_WELCOME
0000100A  2C78 5000                 76      MOVEA.L     BEGINADDR,A6        * Assign beginning address to A6 for use
0000100E                            77  
0000100E                            78  LOOP
0000100E                            79      * OC_PARSE Command doesn't work due to issues in the Opcode include
0000100E                            80      * many errors need to be fixed. Same with EA include
0000100E                            81  
0000100E  45F9 00002000             82      LEA         BUFFER, A2
00001014  4EB9 0000137C             83      JSR         OC_PARSE            * Determine if there is an initial opcode match
0000101A  4EB9 000043E6             84      JSR         WRITE_ENDL
00001020  4EB9 000043F4             85      JSR         PRINTLN
00001026  45F9 00002000             86      LEA         BUFFER, A2
0000102C  4EB9 00004402             87      JSR         CLEAN_BUFF
00001032                            88  
00001032                            89      * decrement row count
00001032                            90      * if at 0, prompt for next page
00001032                            91      * else, continue
00001032                            92  
00001032                            93      *JSR         INVALID_DATA
00001032                            94      *ADDA.L      #$00000002,A6            * Advance address to test LOOP (test only)
00001032                            95  
00001032                            96  LOOP_CHECK
00001032                            97      * Changed the following code from:
00001032                            98      * CMPA        A6, ENDADDR
00001032                            99      * to:
00001032                           100      * CMPA      (ENDADDR),A6
00001032                           101      * When using the CMPA, destination must be an address so A6
00001032  BDF8 5010                102      CMPA.L      ENDADDR,A6          * Is pointer at end of address range?
00001036                           103  
00001036  6E00 0004                104      BGT         END_LOOP            * If yes, END_LOOP
0000103A                           105      ; in case this resets status register, do another compare TODO
0000103A                           106  
0000103A  66D2                     107      BNE         LOOP                * If not, continue processing addresses
0000103C                           108      ; If at end of address range, check if user wants to continue
0000103C                           109      ; if user wants to continue, restart
0000103C                           110      ; else, end
0000103C                           111  
0000103C                           112  END_LOOP
0000103C  4EB9 00004376            113      JSR         KEEP_RUNNING        * Does the user want to run program again
00001042  0C38 0001 6000           114      CMPI.B      #1,(RUNAGAIN)       * Does RUNAGAIN = TRUE?
00001048  67B6                     115      BEQ         START               * If yes, rerun program
0000104A  4E72 3000                116      STOP        #$3000              * Else, end program
0000104E                           117  
0000104E                           118  *---------- END - START ------------------------------------------------------
0000104E                           119  
0000104E                           120  *********** END BEGIN CODE ***************************************************
0000104E                           121  
0000104E                           122  
0000104E                           123  ******************************************************************************
0000104E                           124  *           VARIABLES AND CONSTANTS                                          *
0000104E                           125  ******************************************************************************
0000104E                           126  
0000104E                           127  ******************************************************************************
0000104E                           128  *           INCLUDES                                                         *
0000104E                           129  ******************************************************************************
0000104E                           130  
0000104E                           131      INCLUDE 'IO.X68'
0000104E                           132  
0000104E                           133  
0000104E                           134  
0000104E  =00005020                135  STR_LEN   EQU   $5020
0000104E  =00005021                136  HEXFLAG   EQU   $5021
0000104E  =00005030                137  HEXVALUE  EQU   $5030
0000104E  =00005050                138  REMAINDER EQU   $5050
0000104E  =00000002                139  MOD       EQU   2
0000104E                           140  
0000104E  =0000000D                141  CR        EQU   $0D
0000104E  =0000000A                142  LF        EQU   $0A
0000104E                           143  
0000104E                           144  
0000104E                           145  GET_ADDRESSES
0000104E  4EB9 00001308            146      JSR         CLEARSCRN
00001054  4EB9 000010C6            147      JSR         IO_WELCOME          * Run welcome subroutine
0000105A                           148  
0000105A                           149  GET_FIRST_ADDRESS
0000105A  43F9 0000445E            150      LEA         PS1,A1              * Loads message into A1
00001060  4EB9 000012BE            151      JSR         MAKE_CHECKS         * Get address and perform checks
00001066  0C38 0001 5021           152      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000106C  66EC                     153      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000106E                           154  
0000106E  21F8 5030 5000           155      MOVE.L      HEXVALUE,BEGINADDR  * Copy hex value to begin
00001074  4EB9 000012FA            156      JSR         NEW_LINE            * Space
0000107A  4EB9 000010DA            157      JSR         CLEAR               * Clear values for next hex
00001080                           158  
00001080                           159  GET_SECOND_ADDRESS
00001080  43F9 000044A8            160      LEA         PS2,A1              * Loads message into A1
00001086  4EB9 000012BE            161      JSR         MAKE_CHECKS         * Get address and perform checks
0000108C  0C38 0001 5021           162      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001092  66EC                     163      BNE         GET_SECOND_ADDRESS  * If no, get hex again
00001094                           164  
00001094  21F8 5030 5010           165      MOVE.L      HEXVALUE,ENDADDR    * Copy hex value to begin
0000109A  4EB9 000012FA            166      JSR         NEW_LINE            * Space
000010A0  4EB9 000010DA            167      JSR         CLEAR               * Clear values for next hex
000010A6                           168  
000010A6                           169  CHECK_BADDR_IS_LESS_THAN_EADDR
000010A6  4EB9 0000126A            170      JSR         IS_LESSTHAN         *
000010AC  0C38 0001 5021           171      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000010B2  6700 0010                172      BEQ         FINISHED            * If yes, finished
000010B6  43F9 0000452E            173      LEA         ADR_ERR_NOTLT,A1    * Else, load error message
000010BC  6100 0256                174      BSR.W       ADDRESS_ERR
000010C0  6100 FF3E                175      BSR.W       START
000010C4                           176  
000010C4                           177  
000010C4                           178  FINISHED
000010C4  4E75                     179      RTS                             * Return to Disassembler
000010C6                           180  
000010C6                           181  
000010C6                           182  
000010C6                           183  
000010C6                           184  
000010C6                           185  IO_WELCOME:
000010C6  43F9 00004436            186      LEA         INTRO,A1            * Loads message into A1
000010CC  103C 000E                187      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010D0  4E4F                     188      TRAP        #15                 * Displays Intro Message
000010D2                           189  
000010D2  4EB9 000012FA            190      JSR         NEW_LINE            * Call Subroutine
000010D8  4E75                     191      RTS                             * Return from subroutine
000010DA                           192  
000010DA                           193  
000010DA                           194  
000010DA                           195  CLEAR
000010DA  4286                     196      CLR.L       D6                   * Clear
000010DC  31FC FFFF 5020           197      MOVE.W      #$FFFF,STR_LEN       * Clear
000010E2  21FC FFFFFFFF 5030       198      MOVE.L      #$FFFFFFFF,HEXVALUE  * Clear
000010EA  21FC FFFFFFFF 5050       199      MOVE.L      #$FFFFFFFF,REMAINDER * Clear
000010F2  4E75                     200      RTS                              * Return to main to get hex
000010F4                           201  
000010F4                           202  
000010F4                           203  
000010F4                           204  GET_HEXSTRING
000010F4  103C 000E                205      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010F8  323C 004A                206      MOVE.W      #(PS2-PS1),D1       * The prompt string length
000010FC  4E4F                     207      TRAP        #15                 * Displays contents of A1
000010FE                           208  
000010FE  43F9 00004589            209      LEA         HEXSTRING,A1        * Pointer to store the sentence
00001104  103C 0002                210      MOVE.B      #2,D0               * Set up readstring function
00001108  4E4F                     211      TRAP        #15                 * Get string from keyboard
0000110A  11C1 5020                212      MOVE.B      D1,STR_LEN          * Save length of input string
0000110E                           213  
0000110E  0C38 0008 5020           214      CMPI.B      #8,(STR_LEN)        * Is length > 8?
00001114  6E00 0010                215      BGT         BAD_LENGTH          * If yes, get hex again
00001118                           216  
00001118  41F9 00004589            217      LEA         HEXSTRING,A0        * Load address for verification
0000111E  11FC 0001 5021           218      MOVE.B      #1,(HEXFLAG)
00001124  4E75                     219      RTS                             * Return from subroutine
00001126                           220  
00001126                           221  BAD_LENGTH
00001126  11FC 0000 5021           222      MOVE.B      #0,(HEXFLAG)        * Bad length set HEXFLAG to false
0000112C  4E75                     223      RTS                             * Return to subroutine
0000112E                           224  
0000112E                           225  
0000112E                           226  
0000112E                           227  ASCII_TO_HEX
0000112E  1618                     228      MOVE.B      (A0)+,D3            * Move first char into D3
00001130  0C03 0030                229      CMPI.B      #'0',D3             * Is Char equal to 0?
00001134  6700 00D4                230      BEQ         HEXZERO
00001138  0C03 0031                231      CMPI.B      #'1',D3             * Is Char equal to 1?
0000113C  6700 00D4                232      BEQ         HEXONE
00001140  0C03 0032                233      CMPI.B      #'2',D3             * Is Char equal to 2?
00001144  6700 00D0                234      BEQ         HEXTWO
00001148  0C03 0033                235      CMPI.B      #'3',D3             * Is Char equal to 3?
0000114C  6700 00CC                236      BEQ         HEXTHREE
00001150  0C03 0034                237      CMPI.B      #'4',D3             * Is Char equal to 4?
00001154  6700 00C8                238      BEQ         HEXFOUR
00001158  0C03 0035                239      CMPI.B      #'5',D3             * Is Char equal to 5?
0000115C  6700 00C4                240      BEQ         HEXFIVE
00001160  0C03 0036                241      CMPI.B      #'6',D3             * Is Char equal to 6?
00001164  6700 00C0                242      BEQ         HEXSIX
00001168  0C03 0037                243      CMPI.B      #'7',D3             * Is Char equal to 7?
0000116C  6700 00BC                244      BEQ         HEXSEVEN
00001170  0C03 0038                245      CMPI.B      #'8',D3             * Is Char equal to 8?
00001174  6700 00B8                246      BEQ         HEXEIGHT
00001178  0C03 0039                247      CMPI.B      #'9',D3             * Is Char equal to 9?
0000117C  6700 00B4                248      BEQ         HEXNINE
00001180  0C03 0041                249      CMPI.B      #'A',D3             * Is Char equal to A?
00001184  6700 00B4                250      BEQ         HEXA
00001188  0C03 0042                251      CMPI.B      #'B',D3             * Is Char equal to B?
0000118C  6700 00B4                252      BEQ         HEXB
00001190  0C03 0043                253      CMPI.B      #'C',D3             * Is Char equal to C?
00001194  6700 00B4                254      BEQ         HEXC
00001198  0C03 0044                255      CMPI.B      #'D',D3             * Is Char equal to D?
0000119C  6700 00B4                256      BEQ         HEXD
000011A0  0C03 0045                257      CMPI.B      #'E',D3             * Is Char equal to E?
000011A4  6700 00B4                258      BEQ         HEXE
000011A8  0C03 0046                259      CMPI.B      #'F',D3             * Is Char equal to F?
000011AC  6700 00B4                260      BEQ         HEXF
000011B0  0C03 0061                261      CMPI.B      #'a',D3             * Is Char equal to a?
000011B4  6700 0084                262      BEQ         HEXA
000011B8  0C03 0062                263      CMPI.B      #'b',D3             * Is Char equal to b?
000011BC  6700 0084                264      BEQ         HEXB
000011C0  0C03 0063                265      CMPI.B      #'c',D3             * Is Char equal to c?
000011C4  6700 0084                266      BEQ         HEXC
000011C8  0C03 0064                267      CMPI.B      #'d',D3             * Is Char equal to d?
000011CC  6700 0084                268      BEQ         HEXD
000011D0  0C03 0065                269      CMPI.B      #'e',D3             * Is Char equal to e?
000011D4  6700 0084                270      BEQ         HEXE
000011D8  0C03 0066                271      CMPI.B      #'f',D3             * Is Char equal to f?
000011DC  6700 0084                272      BEQ         HEXF
000011E0                           273  
000011E0  11FC 0000 5021           274      MOVE.B      #0,HEXFLAG          * Set false
000011E6  6000 FEF2                275      BRA         CLEAR               * Clear some values
000011EA                           276  
000011EA                           277  FOUND
000011EA  5338 5020                278      SUBI.B      #1,STR_LEN          * Decrease string by one
000011EE  0C38 0000 5020           279      CMPI.B      #0,STR_LEN          * Is string = 0?
000011F4  6600 000E                280      BNE         SHIFTLEFT           * If no, shift value left
000011F8  21C6 5030                281      MOVE.L      D6,HEXVALUE         * If yes, save hex value
000011FC  11FC 0001 5021           282      MOVE.B      #1,HEXFLAG          * Set true
00001202  4E75                     283      RTS                             * Then, return to main
00001204                           284  
00001204                           285  SHIFTLEFT
00001204  E98E                     286      LSL.L       #4,D6               * Shift the value left
00001206  6000 FF26                287      BRA         ASCII_TO_HEX        * Check next char
0000120A                           288  
0000120A                           289  HEXZERO
0000120A  0686 00000000            290      ADD.L       #$0,D6              * Add value
00001210  60D8                     291      BRA         FOUND               * found, decrease strlen, shift value left
00001212                           292  HEXONE
00001212  5286                     293      ADD.L       #$1,D6              * Add value
00001214  60D4                     294      BRA         FOUND               * found, decrease strlen, shift value left
00001216                           295  HEXTWO
00001216  5486                     296      ADD.L       #$2,D6              * Add value
00001218  60D0                     297      BRA         FOUND               * found, decrease strlen, shift value left
0000121A                           298  HEXTHREE
0000121A  5686                     299      ADD.L       #$3,D6              * Add value
0000121C  60CC                     300      BRA         FOUND               * found, decrease strlen, shift value left
0000121E                           301  HEXFOUR
0000121E  5886                     302      ADD.L       #$4,D6              * Add value
00001220  60C8                     303      BRA         FOUND               * found, decrease strlen, shift value left
00001222                           304  HEXFIVE
00001222  5A86                     305      ADD.L       #$5,D6              * Add value
00001224  60C4                     306      BRA         FOUND               * found, decrease strlen, shift value left
00001226                           307  HEXSIX
00001226  5C86                     308      ADD.L       #$6,D6              * Add value
00001228  60C0                     309      BRA         FOUND               * found, decrease strlen, shift value left
0000122A                           310  HEXSEVEN
0000122A  5E86                     311      ADD.L       #$7,D6              * Add value
0000122C  60BC                     312      BRA         FOUND               * found, decrease strlen, shift value left
0000122E                           313  HEXEIGHT
0000122E  5086                     314      ADD.L       #$8,D6              * Add value
00001230  60B8                     315      BRA         FOUND               * found, decrease strlen, shift value left
00001232                           316  HEXNINE
00001232  0686 00000009            317      ADD.L       #$9,D6              * Add value
00001238  60B0                     318      BRA         FOUND               * found, decrease strlen, shift value left
0000123A                           319  HEXA
0000123A  0686 0000000A            320      ADD.L       #$A,D6              * Add value
00001240  60A8                     321      BRA         FOUND               * found, decrease strlen, shift value left
00001242                           322  HEXB
00001242  0686 0000000B            323      ADD.L       #$B,D6              * Add value
00001248  60A0                     324      BRA         FOUND               * found, decrease strlen, shift value left
0000124A                           325  HEXC
0000124A  0686 0000000C            326      ADD.L       #$C,D6              * Add value
00001250  6098                     327      BRA         FOUND               * found, decrease strlen, shift value left
00001252                           328  HEXD
00001252  0686 0000000D            329      ADD.L       #$D,D6              * Add value
00001258  6090                     330      BRA         FOUND               * found, decrease strlen, shift value left
0000125A                           331  HEXE
0000125A  0686 0000000E            332      ADD.L       #$E,D6              * Add value
00001260  6088                     333      BRA         FOUND               * found, decrease strlen, shift value left
00001262                           334  HEXF
00001262  0686 0000000F            335      ADD.L       #$F,D6              * Add value
00001268  6080                     336      BRA         FOUND               * found, decrease strlen, shift value left
0000126A                           337  
0000126A                           338  
0000126A                           339  
0000126A                           340  IS_LESSTHAN
0000126A  2838 5000                341      MOVE.L      BEGINADDR,D4        * Store beginning address in D4
0000126E  2C38 5010                342      MOVE.L      ENDADDR,D6          * Store ending address in D6
00001272  B886                     343      CMP.L       D6,D4               * Is D4 < D6
00001274  6D00 000C                344      BLT         LT                  * Yes, mark true return to main
00001278  11FC 0000 5021           345      MOVE.B      #0,HEXFLAG          * No, mark false
0000127E  6000 FE5A                346      BRA         CLEAR               * Clear values, return to main
00001282                           347  
00001282                           348  LT
00001282  11FC 0001 5021           349      MOVE.B      #1,HEXFLAG          * Mark true
00001288  4E75                     350      RTS                             * Return to main
0000128A                           351  
0000128A                           352  
0000128A                           353  
0000128A                           354  IS_HEX_EVEN
0000128A  3606                     355      MOVE.W      D6,D3               * Move value to be modded into D3
0000128C  3A3C 0002                356      MOVE.W      #MOD,D5             * Move mod value into D5
00001290  86C5                     357      DIVU        D5,D3               * Divide D3 by D5
00001292  123C 0003                358      MOVE.B      #3,D1               * Set counter to shift value into word
00001296                           359                                      * position
00001296                           360  REPEAT
00001296  E88B                     361      LSR.L       #4,D3               * Shift remainder to lower word
00001298  57C9 FFFC                362      DBEQ        D1,REPEAT           * UNTIL [D0] = - 1
0000129C  4241                     363      CLR         D1                  * Clear
0000129E                           364  
0000129E  B6BC 00000000            365      CMP.L       #0,D3               * Is hex even?
000012A4  6600 000E                366      BNE         NOTEVEN             * No, clear and go back to get_hex
000012A8  31C3 5050                367      MOVE.W      D3,REMAINDER        * Save remainder
000012AC  11FC 0001 5021           368      MOVE.B      #1,HEXFLAG          * Set true
000012B2  4E75                     369      RTS                             * Return to main
000012B4                           370  
000012B4                           371  NOTEVEN
000012B4  11FC 0000 5021           372      MOVE.B      #0,HEXFLAG          * Set false
000012BA  6000 FE1E                373      BRA         CLEAR               * Clear values
000012BE                           374  
000012BE                           375  
000012BE                           376  
000012BE                           377  MAKE_CHECKS
000012BE  4EB8 10F4                378      JSR         GET_HEXSTRING       * Get string from user
000012C2  0C38 0001 5021           379      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000012C8  6600 0020                380      BNE         BAD_CHECK           * If no, get hex again
000012CC                           381  
000012CC  4EB8 112E                382      JSR         ASCII_TO_HEX        * Convert ascii to hex
000012D0  0C38 0001 5021           383      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000012D6  6600 0012                384      BNE         BAD_CHECK           * If no, get hex again
000012DA                           385  
000012DA  4EB8 128A                386      JSR         IS_HEX_EVEN         * Check that hex value is even
000012DE  0C38 0001 5021           387      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000012E4  6600 0004                388      BNE         BAD_CHECK           * If no, get hex again
000012E8                           389  
000012E8  4E75                     390      RTS                             * Return from subroutine
000012EA                           391  
000012EA                           392  BAD_CHECK
000012EA  4E75                     393      RTS                             * Return from subroutine
000012EC                           394  
000012EC                           395  
000012EC                           396  
000012EC                           397  PRINT_HEXVALUE
000012EC  103C 000E                398      MOVE.B      #14,D0              * Moves the Task 14 into D0
000012F0  4E4F                     399      TRAP        #15                 * Displays contents of A1
000012F2                           400  
000012F2  103C 0003                401      MOVE.B      #3,D0               * Moves the Task 3 into D0
000012F6  4E4F                     402      TRAP        #15                 * Displays contents of D1
000012F8                           403  
000012F8  4E75                     404      RTS                             * Return from subroutine
000012FA                           405  
000012FA                           406  
000012FA                           407  NEW_LINE
000012FA  43F9 00004873            408      LEA         ENDL,A1             * Loads message into A1
00001300  103C 000E                409      MOVE.B      #14,D0              * Moves the TRACK 14 into D0
00001304  4E4F                     410      TRAP        #15                 * Displays New line
00001306  4E75                     411      RTS                             * Return from subroutine
00001308                           412  
00001308                           413  
00001308                           414  CLEARSCRN
00001308  103C 000B                415      MOVE.B      #11,D0              * Task 11 for clearing screen
0000130C  323C FF00                416      MOVE.W      #$FF00,D1           * FF00, Clear screen
00001310  4E4F                     417      TRAP        #15                 * Wait for keystroke
00001312  4E75                     418      RTS                             * Return from subroutine
00001314                           419  
00001314                           420  
00001314                           421  
00001314                           422  
00001314                           423  ADDRESS_ERR
00001314  6100 FFF2                424      BSR.W       CLEARSCRN           * Clear output before displaying error
00001318  103C 000D                425      MOVE.B      #13,D0              * Moves the Task 13 into D0
0000131C  4E4F                     426      TRAP        #15                 * Displays contents of A1
0000131E  103C 0005                427      MOVE.B      #5,D0               * Read single character from
00001322  4E4F                     428      TRAP        #15                 * The keyboard into D1.B
00001324  4E75                     429      RTS                             * Return from subroutine
00001326                           430  
00001326                           431  
00001326                           432  
00001326                           433  INVALID_DATA
00001326  220E                     434      MOVE.L      A6,D1               * Move the address location to D1
00001328  143C 0010                435      MOVE.B      #16,D2              * Move base 16 to D2
0000132C  103C 000F                436      MOVE.B      #15,D0              * Moves Task 15 into D0
00001330  4E4F                     437      TRAP        #15                 * Displays contents of D1
00001332                           438  
00001332  43F9 000048B7            439      LEA         TAB,A1              * Load TAB to A1
00001338  103C 000E                440      MOVE.B      #14,D0              * Moves the Task 14 into D0
0000133C  4E4F                     441      TRAP        #15                 * Displays a tab of A1
0000133E                           442  
0000133E  43F9 000045D9            443      LEA         DATA,A1             * Load address location to A1
00001344  103C 000E                444      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001348  4E4F                     445      TRAP        #15                 * Displays location of A1
0000134A                           446  
0000134A  43F9 000048B7            447      LEA         TAB,A1              * Load TAB to A1
00001350  103C 000E                448      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001354  4E4F                     449      TRAP        #15                 * Displays a tab of A1
00001356                           450  
00001356  43F9 000048A8            451      LEA         DOLLAR,A1           * Load TAB to A1
0000135C  103C 000E                452      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001360  4E4F                     453      TRAP        #15                 * Displays a tab of A1
00001362                           454  
00001362  3216                     455      MOVE.W      (A6),D1             * Move the address value to D1
00001364  143C 0010                456      MOVE.B      #16,D2              * Move base 16 to D2
00001368  103C 000F                457      MOVE.B      #15,D0              * Moves Task 15 into D0
0000136C  4E4F                     458      TRAP        #15                 * Displays value of D1
0000136E                           459  
0000136E  43F9 00004873            460      LEA         ENDL,A1             * Load TAB to A1
00001374  103C 000E                461      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001378  4E4F                     462      TRAP        #15                 * Displays a tab of A1
0000137A                           463  
0000137A  4E75                     464      RTS                             * Return from subroutine
0000137C                           465  
0000137C                           466  
0000137C                           467  
0000137C                           468  
0000137C                           469  
0000137C                           470  
0000137C                           471  
0000137C                           472  
0000137C                           473  
0000137C                           474  
0000137C                           475  
0000137C                           476  -------------------- end include --------------------
0000137C                           477      INCLUDE 'OpCodes.X68'
0000137C                           478  
0000137C                           479  
0000137C                           480  OC_PARSE:
0000137C  48E7 FFFE                481          MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001380  41F9 00001398            482          LEA         initial_table,A0 ; Index into the table
00001386  4280                     483          CLR.L       D0              ; Zero it
00001388  3012                     484          MOVE.W      (A2),D0         ; We'll play with it here
0000138A  123C 000C                485          MOVE.B      #12,D1          ; Shift 12 bits to the right
0000138E  E268                     486          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001390                           487                                      ; and the rest are zeroed out)
00001390  C0FC 0006                488          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001394  4EF0 0000                489          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001398                           490  
00001398                           491  initial_table:
00001398  4EF9 000013F8            492          JMP         code0000        ; ADDI.B, ADDI.W, or ADDI.L
0000139E  4EF9 000013FE            493          JMP         code0001        ; MOVE.B
000013A4  4EF9 0000140A            494          JMP         code0010        ; MOVEA.L or MOVE.L
000013AA  4EF9 00001410            495          JMP         code0011        ; MOVEA.W or MOVE.W
000013B0  4EF9 00001416            496          JMP         code0100        ; NOP or MOVEM.W or MOVEM.L or LEA or CLR.B or CLR.W or CLR.L or JSR or RTS or MULS.W
000013B6  4EF9 00001422            497          JMP         code0101        ; ADDQ.B or ADDQ.W or ADDQ.L
000013BC  4EF9 0000142E            498          JMP         code0110        ; BCC or BGT or BLE
000013C2  4EF9 0000143A            499          JMP         code0111        ; MOVEQ.L
000013C8  4EF9 00001446            500          JMP         code1000        ; OR.B or OR.W or OR.L or DIVU (DIVU is either word or long depending on ea)
000013CE  4EF9 00001452            501          JMP         code1001        ; SUB.B or SUB.W or SUB.L
000013D4  4EF9 0000145E            502          JMP         code1010
000013DA  4EF9 00001466            503          JMP         code1011        ; CMP.B or CMP.W or CMP.L
000013E0  4EF9 00001472            504          JMP         code1100        ; AND_BorAND_WorAND_LorMULS_W
000013E6  4EF9 0000147E            505          JMP         code1101        ; ADD.B or ADD.W or ADD.L
000013EC  4EF9 0000148A            506          JMP         code1110        ; ROd_LSd_ASd
000013F2  4EF9 00001496            507          JMP         code1111
000013F8                           508  
000013F8  4EB9 00001D82            509  code0000 JSR        ADDI_BorADDI_WorADDI_L
000013FE  4EB9 000027D0            510  code0001 JSR        ISMOVEB
00001404  4EF9 0000149E            511           JMP        DONE
0000140A  4EB9 00001DD8            512  code0010 JSR        MOVEA_LorMOVE_L
00001410  4EB9 00001E66            513  code0011 JSR        MOVEA_WorMOVE_W
00001416  4EB9 00001C84            514  code0100 JSR        NOP_MOVEM_LEA_JSR_CLR_RTS
0000141C  4EF9 0000149E            515           JMP        DONE
00001422  4EB9 00001A7E            516  code0101 JSR        ADDQ_BorADDQ_WorADDQ_L
00001428  4EF9 0000149E            517           JMP        DONE
0000142E  4EB9 000014A4            518  code0110 JSR        BCCorBGTorBLE
00001434  4EF9 0000149E            519           JMP        DONE
0000143A  4EB9 0000258C            520  code0111 JSR        ISMOVEQL
00001440  4EF9 0000149E            521           JMP        DONE
00001446  4EB9 000014FA            522  code1000 JSR        OR_BorOR_WorOR_LorDIVU
0000144C  4EF9 0000149E            523           JMP        DONE
00001452  4EB9 0000199A            524  code1001 JSR        SUB_BorSUB_WorSUB_L
00001458  4EF9 0000149E            525           JMP        DONE
0000145E  4EB9 00001EF4            526  code1010 JSR    OPCODE_INVALID              ;INVALID
00001464  4E75                     527           RTS
00001466  4EB9 00001A28            528  code1011 JSR        CMP_BorCMP_WorCMP_L
0000146C  4EF9 0000149E            529           JMP        DONE
00001472  4EB9 0000187E            530  code1100 JSR        AND_BorAND_WorAND_LorMULS_W
00001478  4EF9 0000149E            531           JMP        DONE
0000147E  4EB9 0000190C            532  code1101 JSR        ADD_BorADD_WorADD_L
00001484  4EF9 0000149E            533           JMP        DONE
0000148A  4EB9 0000182E            534  code1110 JSR        ROd_LSd_ASd
00001490  4EF9 0000149E            535           JMP        DONE
00001496  4EB9 00001EF4            536  code1111 JSR    OPCODE_INVALID              ;INVALID
0000149C  4E75                     537           RTS
0000149E  4CDF 7FFF                538  DONE    MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000014A2  4E75                     539          RTS
000014A4                           540  
000014A4  41F9 000014C2            541  BCCorBGTorBLE       LEA     tableBCCorBGTorBLE, A0            ; Index into the table
000014AA  4280                     542                      CLR.L   D0                  ; Zero it
000014AC  3016                     543                      MOVE.W  (A6),D0         ; We'll play with it here
000014AE  123C 0006                544                      MOVE.B  #6,D1           ; Shift 6 bits left
000014B2  E360                     545                      ASL.W   D1,D0
000014B4  123C 000E                546                      MOVE.B  #14,D1           ; Shift 14 bits to the right
000014B8  E268                     547                      LSR.W   D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
000014BA                           548                                      ; and the rest are zeroed out)
000014BA  C0FC 0006                549                      MULU    #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
000014BE  4EF0 0000                550                      JMP     0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
000014C2                           551  
000014C2  4EF9 000014DA            552  tableBCCorBGTorBLE   JMP    BCCorBGTorBLEcode00   ; BCC
000014C8  4EF9 000014E2            553                       JMP    BCCorBGTorBLEcode01   ;
000014CE  4EF9 000014EA            554                       JMP    BCCorBGTorBLEcode10   ; BGT
000014D4  4EF9 000014F2            555                       JMP    BCCorBGTorBLEcode11   ; BLE
000014DA                           556  
000014DA                           557  
000014DA                           558  
000014DA  4EB9 00001F04            559  BCCorBGTorBLEcode00    JSR     ISBCC
000014E0  4E75                     560                         RTS
000014E2  4EB9 00001EF4            561  BCCorBGTorBLEcode01    JSR    OPCODE_INVALID              ;INVALID
000014E8  4E75                     562                         RTS
000014EA  4EB9 00001F2C            563  BCCorBGTorBLEcode10    JSR     ISBGT
000014F0  4E75                     564                         RTS
000014F2  4EB9 00001F54            565  BCCorBGTorBLEcode11    JSR     ISBLE
000014F8  4E75                     566                         RTS
000014FA                           567  
000014FA                           568  
000014FA                           569  OR_BorOR_WorOR_LorDIVU:
000014FA  41F9 00001518            570          LEA         tableOR_BorOR_WorOR_LorDIVU, A0 ; Index into the table
00001500  4280                     571          CLR.L       D0              ; Zero it
00001502  3016                     572          MOVE.W      (A6),D0     ; We'll play with it here
00001504  123C 0007                573          MOVE.B      #7,D1           ; Shift 7 bits left
00001508  E360                     574          ASL.W       D1,D0
0000150A  123C 000D                575          MOVE.B      #13,D1          ; Shift 13 bits to the right
0000150E  E268                     576          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001510                           577                                      ; and the rest are zeroed out)
00001510  C0FC 0006                578          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001514  4EF0 0000                579          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001518                           580  
00001518                           581  tableOR_BorOR_WorOR_LorDIVU
00001518  4EF9 00001548            582          JMP         OR_DIVUcode000  ; OR.B
0000151E  4EF9 00001550            583          JMP         OR_DIVUcode001  ; OR.W
00001524  4EF9 00001558            584          JMP         OR_DIVUcode010  ; OR.L
0000152A  4EF9 00001560            585          JMP         OR_DIVUcode011  ; DIVU.W
00001530  4EF9 00001568            586          JMP         OR_DIVUcode100  ; OR.B
00001536  4EF9 00001570            587          JMP         OR_DIVUcode101  ; OR.W
0000153C  4EF9 00001578            588          JMP         OR_DIVUcode110  ; OR.L
00001542  4EF9 00001580            589          JMP         OR_DIVUcode111  ; INVALID
00001548                           590  
00001548                           591  
00001548  4EB9 00001FA4            592  OR_DIVUcode000 JSR  ISORB
0000154E  4E75                     593                 RTS
00001550  4EB9 00001FCC            594  OR_DIVUcode001 JSR  ISORW
00001556  4E75                     595                 RTS
00001558  4EB9 00001FF4            596  OR_DIVUcode010 JSR  ISORL
0000155E  4E75                     597                 RTS
00001560  4EB9 00001F7C            598  OR_DIVUcode011 JSR  ISDIVUW
00001566  4E75                     599                 RTS
00001568  4EB9 00001FA4            600  OR_DIVUcode100 JSR  ISORB
0000156E  4E75                     601                 RTS
00001570  4EB9 00001FCC            602  OR_DIVUcode101 JSR  ISORW
00001576  4E75                     603                 RTS
00001578  4EB9 00001FF4            604  OR_DIVUcode110 JSR  ISORL
0000157E  4E75                     605                 RTS
00001580  4EB9 00001EF4            606  OR_DIVUcode111 JSR    OPCODE_INVALID              ;INVALID
00001586  4E75                     607                 RTS
00001588                           608  
00001588                           609  
00001588                           610  someASR:
00001588  41F9 000015A6            611          LEA         tableSomeASR, A0 ; Index into the table
0000158E  4280                     612          CLR.L       D0              ; Zero it
00001590  3016                     613          MOVE.W      (A6),D0         ; We'll play with it here
00001592  123C 0008                614          MOVE.B      #8,D1           ; Shift 8 bits left
00001596  E360                     615          ASL.W       D1,D0
00001598  123C 000E                616          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000159C  E268                     617          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000159E                           618                                      ; and the rest are zeroed out)
0000159E  C0FC 0006                619          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000015A2  4EF0 0000                620          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000015A6                           621  
000015A6                           622  tableSomeASR:
000015A6  4EF9 000015BE            623          JMP         ASRcode00       *ASR.B
000015AC  4EF9 000015C6            624          JMP         ASRcode01       *ASR.W
000015B2  4EF9 000015CE            625          JMP         ASRcode10       *ASR.L
000015B8  4EF9 000015D6            626          JMP         ASRcode11       *ASR.W
000015BE                           627  
000015BE  4EB9 0000201C            628  ASRcode00 JSR       ISASRB
000015C4  4E75                     629            RTS
000015C6  4EB9 00002044            630  ASRcode01 JSR       ISASRW
000015CC  4E75                     631            RTS
000015CE  4EB9 0000206C            632  ASRcode10 JSR       ISASRL
000015D4  4E75                     633            RTS
000015D6  4EB9 00002044            634  ASRcode11 JSR       ISASRW
000015DC  4E75                     635            RTS
000015DE                           636  
000015DE                           637  someASL:
000015DE  41F9 000015FC            638          LEA         tableSomeASL, A0 ; Index into the table
000015E4  4280                     639          CLR.L       D0              ; Zero it
000015E6  3016                     640          MOVE.W      (A6),D0     ; We'll play with it here
000015E8  123C 0008                641          MOVE.B      #8,D1           ; Shift 8 bits left
000015EC  E360                     642          ASL.W       D1,D0
000015EE  123C 000E                643          MOVE.B      #14,D1          ; Shift 14 bits to the right
000015F2  E268                     644          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000015F4                           645                                      ; and the rest are zeroed out)
000015F4  C0FC 0006                646          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000015F8  4EF0 0000                647          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000015FC                           648  
000015FC                           649  tableSomeASL:
000015FC  4EF9 00001614            650          JMP         ASLcode00       *ASL.B
00001602  4EF9 0000161C            651          JMP         ASLcode01       *ASL.W
00001608  4EF9 00001624            652          JMP         ASLcode10       *ASL.L
0000160E  4EF9 0000162C            653          JMP         ASLcode11       *ASL.W
00001614                           654  
00001614  4EB9 00002094            655  ASLcode00 JSR       ISASLB
0000161A  4E75                     656            RTS
0000161C  4EB9 000020BC            657  ASLcode01 JSR       ISASLW
00001622  4E75                     658            RTS
00001624  4EB9 000020D8            659  ASLcode10 JSR       ISASLL
0000162A  4E75                     660            RTS
0000162C  4EB9 000020BC            661  ASLcode11 JSR       ISASLW
00001632  4E75                     662            RTS
00001634                           663  
00001634                           664  someLSR:
00001634  41F9 00001652            665          LEA         tableSomeLSR, A0 ; Index into the table
0000163A  4280                     666          CLR.L       D0              ; Zero it
0000163C  3016                     667          MOVE.W      (A6),D0     ; We'll play with it here
0000163E  123C 0008                668          MOVE.B      #8,D1           ; Shift 8 bits left
00001642  E360                     669          ASL.W       D1,D0
00001644  123C 000E                670          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001648  E268                     671          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000164A                           672                                      ; and the rest are zeroed out)
0000164A  C0FC 0006                673          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000164E  4EF0 0000                674          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001652                           675  
00001652                           676  tableSomeLSR:
00001652  4EF9 0000166A            677          JMP         LSRcode00       *LSR.B
00001658  4EF9 00001672            678          JMP         LSRcode01       *LSR.W
0000165E  4EF9 0000167A            679          JMP         LSRcode10       *LSR.L
00001664  4EF9 00001682            680          JMP         LSRcode11       *LSR.W
0000166A  4EB9 00002100            681  LSRcode00 JSR       ISLSRB
00001670  4E75                     682            RTS
00001672  4EB9 00002128            683  LSRcode01 JSR       ISLSRW
00001678  4E75                     684            RTS
0000167A  4EB9 00002150            685  LSRcode10 JSR       ISLSRL
00001680  4E75                     686            RTS
00001682  4EB9 00002128            687  LSRcode11 JSR       ISLSRW
00001688  4E75                     688            RTS
0000168A                           689  
0000168A                           690  someLSL:
0000168A  41F9 000016A8            691          LEA         tableSomeLSL, A0 ; Index into the table
00001690  4280                     692          CLR.L       D0              ; Zero it
00001692  3016                     693          MOVE.W      (A6),D0     ; We'll play with it here
00001694  123C 0008                694          MOVE.B      #8,D1           ; Shift 8 bits left
00001698  E360                     695          ASL.W       D1,D0
0000169A  123C 000E                696          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000169E  E268                     697          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000016A0                           698                                      ; and the rest are zeroed out)
000016A0  C0FC 0006                699          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000016A4  4EF0 0000                700          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000016A8                           701  
000016A8                           702  tableSomeLSL:
000016A8  4EF9 000016C0            703          JMP         LSLcode00       *LSL.B
000016AE  4EF9 000016C8            704          JMP         LSLcode01       *LSL.W
000016B4  4EF9 000016D0            705          JMP         LSLcode10       *LSL.L
000016BA  4EF9 000016D8            706          JMP         LSLcode11       *LSL.W
000016C0                           707  
000016C0  4EB9 00002178            708  LSLcode00 JSR       ISLSLB
000016C6  4E75                     709            RTS
000016C8  4EB9 00002194            710  LSLcode01 JSR       ISLSLW
000016CE  4E75                     711            RTS
000016D0  4EB9 000021BC            712  LSLcode10 JSR       ISLSLL
000016D6  4E75                     713            RTS
000016D8  4EB9 00002194            714  LSLcode11 JSR       ISLSLW
000016DE  4E75                     715            RTS
000016E0                           716  
000016E0                           717  someROL:
000016E0  41F9 000016FE            718          LEA         tableSomeROL, A0 ; Index into the table
000016E6  4280                     719          CLR.L       D0              ; Zero it
000016E8  3016                     720          MOVE.W      (A6),D0     ; We'll play with it here
000016EA  123C 0008                721          MOVE.B      #8,D1           ; Shift 8 bits left
000016EE  E360                     722          ASL.W       D1,D0
000016F0  123C 000E                723          MOVE.B      #14,D1          ; Shift 14 bits to the right
000016F4  E268                     724          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000016F6                           725                                      ; and the rest are zeroed out)
000016F6  C0FC 0006                726          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000016FA  4EF0 0000                727          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000016FE                           728  
000016FE                           729  tableSomeROL:
000016FE  4EF9 00001716            730          JMP         ROLcode00       *ROL.B
00001704  4EF9 0000171E            731          JMP         ROLcode01       *ROL.W
0000170A  4EF9 00001726            732          JMP         ROLcode10       *ROL.L
00001710  4EF9 0000172E            733          JMP         ROLcode11       *ROL.W
00001716                           734  
00001716  4EB9 00002250            735  ROLcode00 JSR       ISROLB
0000171C  4E75                     736            RTS
0000171E  4EB9 00002278            737  ROLcode01 JSR       ISROLW
00001724  4E75                     738            RTS
00001726  4EB9 000022A0            739  ROLcode10 JSR       ISROLL
0000172C  4E75                     740            RTS
0000172E  4EB9 00002278            741  ROLcode11 JSR       ISROLW
00001734  4E75                     742            RTS
00001736                           743  
00001736                           744  
00001736                           745  someROR:
00001736  41F9 00001754            746          LEA         tableSomeROR, A0 ; Index into the table
0000173C  4280                     747          CLR.L       D0              ; Zero it
0000173E  3016                     748          MOVE.W      (A6),D0     ; We'll play with it here
00001740  123C 0008                749          MOVE.B      #8,D1           ; Shift 8 bits left
00001744  E360                     750          ASL.W       D1,D0
00001746  123C 000E                751          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000174A  E268                     752          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000174C                           753                                      ; and the rest are zeroed out)
0000174C  C0FC 0006                754          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001750  4EF0 0000                755          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001754                           756  
00001754                           757  tableSomeROR:
00001754  4EF9 0000176C            758          JMP         RORcode00       *ROR.B
0000175A  4EF9 00001774            759          JMP         RORcode01       *ROR.W
00001760  4EF9 0000177C            760          JMP         RORcode10       *ROR.L
00001766  4EF9 00001784            761          JMP         RORcode11       *ROR.W
0000176C                           762  
0000176C  4EB9 000021E4            763  RORcode00 JSR       ISRORB
00001772  4E75                     764            RTS
00001774  4EB9 0000220C            765  RORcode01 JSR       ISRORW
0000177A  4E75                     766            RTS
0000177C  4EB9 00002228            767  RORcode10 JSR       ISRORL
00001782  4E75                     768            RTS
00001784  4EB9 0000220C            769  RORcode11 JSR       ISRORW
0000178A  4E75                     770            RTS
0000178C                           771  
0000178C                           772  ROL_ROR:
0000178C  41F9 000017AA            773          LEA         tableROL_ROR, A0 ; Index into the table
00001792  4280                     774          CLR.L       D0              ; Zero it
00001794  3016                     775          MOVE.W      (A6),D0     ; We'll play with it here
00001796  123C 0007                776          MOVE.B      #7,D1           ; Shift 7 bits left
0000179A  E360                     777          ASL.W       D1,D0
0000179C  123C 000F                778          MOVE.B      #15,D1          ; Shift 15 bits to the right
000017A0  E268                     779          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000017A2                           780                                      ; and the rest are zeroed out)
000017A2  C0FC 0006                781          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000017A6  4EF0 0000                782          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000017AA                           783  
000017AA                           784  tableROL_ROR:
000017AA  4EF9 000017B6            785          JMP         ROL_RORcode0    ; ROR
000017B0  4EF9 000017BC            786          JMP         ROL_RORcode1    ; ROL
000017B6                           787  
000017B6  4EB8 1736                788  ROL_RORcode0 JSR    someROR
000017BA  4E75                     789               RTS
000017BC  4EB8 16E0                790  ROL_RORcode1 JSR    someROL
000017C0  4E75                     791               RTS
000017C2                           792  
000017C2                           793  LSL_LSR:
000017C2  41F9 000017E0            794          LEA         tableLSL_LSR, A0 ; Index into the table
000017C8  4280                     795          CLR.L       D0              ; Zero it
000017CA  3016                     796          MOVE.W      (A6),D0     ; We'll play with it here
000017CC  123C 0007                797          MOVE.B      #7,D1           ; Shift 7 bits left
000017D0  E360                     798          ASL.W       D1,D0
000017D2  123C 000F                799          MOVE.B      #15,D1          ; Shift 15 bits to the right
000017D6  E268                     800          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000017D8                           801                                      ; and the rest are zeroed out)
000017D8  C0FC 0006                802          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000017DC  4EF0 0000                803          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000017E0                           804  
000017E0                           805  tableLSL_LSR:
000017E0  4EF9 000017EC            806          JMP         LSL_LSRcode0    ; LSR
000017E6  4EF9 000017F2            807          JMP         LSL_LSRcode1    ; LSL
000017EC                           808  
000017EC  4EB8 1634                809  LSL_LSRcode0 JSR    someLSR
000017F0  4E75                     810               RTS
000017F2  4EB8 168A                811  LSL_LSRcode1 JSR    someLSL
000017F6  4E75                     812               RTS
000017F8                           813  
000017F8                           814  ASL_ASR:
000017F8  41F9 00001816            815          LEA         tableASL_ASR, A0 ; Index into the table
000017FE  4280                     816          CLR.L       D0              ; Zero it
00001800  3016                     817          MOVE.W      (A6),D0     ; We'll play with it here
00001802  123C 0007                818          MOVE.B      #7,D1           ; Shift 7 bits left
00001806  E360                     819          ASL.W       D1,D0
00001808  123C 000F                820          MOVE.B      #15,D1          ; Shift 15 bits to the right
0000180C  E268                     821          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000180E                           822                                      ; and the rest are zeroed out)
0000180E  C0FC 0006                823          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001812  4EF0 0000                824          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001816                           825  
00001816                           826  tableASL_ASR:
00001816  4EF9 00001822            827          JMP         ASL_ASRcode0    ; ASR
0000181C  4EF9 00001828            828          JMP         ASL_ASRcode1    ; ASL
00001822                           829  
00001822  4EB8 1588                830  ASL_ASRcode0 JSR    someASR
00001826  4E75                     831               RTS
00001828  4EB8 15DE                832  ASL_ASRcode1 JSR    someASL
0000182C  4E75                     833               RTS
0000182E                           834  
0000182E                           835  ROd_LSd_ASd:
0000182E  41F9 0000184C            836          LEA         tableROd_LSd_ASd, A0 ; Index into the table
00001834  4280                     837          CLR.L       D0              ; Zero it
00001836  3016                     838          MOVE.W      (A6),D0     ; We'll play with it here
00001838  123C 000B                839          MOVE.B      #11,D1          ; Shift 11 bits left
0000183C  E360                     840          ASL.W       D1,D0
0000183E  123C 000F                841          MOVE.B      #15,D1          ; Shift 12 bits to the right
00001842  E268                     842          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001844                           843                                      ; and the rest are zeroed out)
00001844  C0FC 0006                844          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001848  4EF0 0000                845          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000184C                           846  
0000184C                           847  tableROd_LSd_ASd:
0000184C  4EF9 00001864            848          JMP         ROd_LSd_ASdcode00 ; ASL_ASR
00001852  4EF9 0000186A            849          JMP         ROd_LSd_ASdcode01 ; LSL_LSR
00001858  4EF9 00001870            850          JMP         ROd_LSd_ASdcode10
0000185E  4EF9 00001878            851          JMP         ROd_LSd_ASdcode11 ; ROL_ROR
00001864                           852  
00001864  4EB8 17F8                853  ROd_LSd_ASdcode00 JSR ASL_ASR
00001868  4E75                     854                    RTS
0000186A  4EB8 17C2                855  ROd_LSd_ASdcode01 JSR LSL_LSR
0000186E  4E75                     856                    RTS
00001870  4EB9 00001EF4            857  ROd_LSd_ASdcode10 JSR    OPCODE_INVALID              ;INVALID
00001876  4E75                     858                    RTS
00001878  4EB8 178C                859  ROd_LSd_ASdcode11 JSR ROL_ROR
0000187C  4E75                     860                    RTS
0000187E                           861  
0000187E                           862  AND_BorAND_WorAND_LorMULS_W:
0000187E  41F9 0000189C            863          LEA         tableAND_BorAND_WorAND_LorMULS_W, A0            ; Index into the table
00001884  4280                     864          CLR.L       D0                  ; Zero it
00001886  3016                     865          MOVE.W      (A6),D0         ; We'll play with it here
00001888  123C 0007                866          MOVE.B      #7,D1           ; Shift 7 bits left
0000188C  E360                     867          ASL.W       D1,D0
0000188E  123C 000D                868          MOVE.B      #13,D1              ; Shift 13 bits to the right
00001892  E268                     869          LSR.W       D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001894                           870                                  ; and the rest are zeroed out)
00001894  C0FC 0006                871          MULU        #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001898  4EF0 0000                872          JMP         0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
0000189C                           873  
0000189C                           874  tableAND_BorAND_WorAND_LorMULS_W:
0000189C  4EF9 000018CC            875          JMP         ANDcode000   ; AND.B
000018A2  4EF9 000018D4            876          JMP         ANDcode001   ; AND.W
000018A8  4EF9 000018DC            877          JMP         ANDcode010   ; AND.L
000018AE  4EF9 000018E4            878          JMP         ANDcode011
000018B4  4EF9 000018EC            879          JMP         ANDcode100   ; AND.B
000018BA  4EF9 000018F4            880          JMP         ANDcode101   ; AND.W
000018C0  4EF9 000018FC            881          JMP         ANDcode110   ; AND.L
000018C6  4EF9 00001904            882          JMP         ANDcode111   ; MULS.W
000018CC                           883  
000018CC  4EB9 000022F0            884  ANDcode000 JSR      ISANDB
000018D2  4E75                     885             RTS
000018D4  4EB9 00002318            886  ANDcode001 JSR      ISANDW
000018DA  4E75                     887             RTS
000018DC  4EB9 00002340            888  ANDcode010 JSR      ISANDL
000018E2  4E75                     889             RTS
000018E4  4EB9 00001EF4            890  ANDcode011 JSR    OPCODE_INVALID              ;INVALID
000018EA  4E75                     891             RTS
000018EC  4EB9 000022F0            892  ANDcode100 JSR      ISANDB
000018F2  4E75                     893             RTS
000018F4  4EB9 00002318            894  ANDcode101 JSR      ISANDW
000018FA  4E75                     895             RTS
000018FC  4EB9 00002340            896  ANDcode110 JSR      ISANDL
00001902  4E75                     897             RTS
00001904  4EB9 000022C8            898  ANDcode111 JSR      ISMULSW
0000190A  4E75                     899             RTS
0000190C                           900  
0000190C                           901  ADD_BorADD_WorADD_L:
0000190C  41F9 0000192A            902          LEA         tableADD_BorADD_WorADD_L, A0 ; Index into the table
00001912  4280                     903          CLR.L       D0              ; Zero it
00001914  3016                     904          MOVE.W      (A6),D0     ; We'll play with it here
00001916  123C 0007                905          MOVE.B      #7,D1           ; Shift 7 bits left
0000191A  E360                     906          ASL.W       D1,D0
0000191C  123C 000D                907          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001920  E268                     908          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001922                           909                                      ; and the rest are zeroed out)
00001922  C0FC 0006                910          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001926  4EF0 0000                911          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000192A                           912  
0000192A                           913  tableADD_BorADD_WorADD_L:
0000192A  4EF9 0000195A            914          JMP         ADDcode000      *ADD.B
00001930  4EF9 00001962            915          JMP         ADDcode001      *ADD.W
00001936  4EF9 0000196A            916          JMP         ADDcode010      *ADD.L
0000193C  4EF9 00001972            917          JMP         ADDcode011      *ADDA.W
00001942  4EF9 0000197A            918          JMP         ADDcode100      *ADD.B
00001948  4EF9 00001982            919          JMP         ADDcode101      *ADD.W
0000194E  4EF9 0000198A            920          JMP         ADDcode110      *ADD.L
00001954  4EF9 00001992            921          JMP         ADDcode111      *ADDA.L
0000195A                           922  
0000195A  4EB9 000023B8            923  ADDcode000 JSR      ISADDB
00001960  4E75                     924             RTS
00001962  4EB9 000023E0            925  ADDcode001 JSR      ISADDW
00001968  4E75                     926             RTS
0000196A  4EB9 00002408            927  ADDcode010 JSR      ISADDL
00001970  4E75                     928             RTS
00001972  4EB9 00002368            929  ADDcode011 JSR      ISADDAW
00001978  4E75                     930             RTS
0000197A  4EB9 000023B8            931  ADDcode100 JSR      ISADDB
00001980  4E75                     932             RTS
00001982  4EB9 000023E0            933  ADDcode101 JSR      ISADDW
00001988  4E75                     934             RTS
0000198A  4EB9 00002408            935  ADDcode110 JSR      ISADDL
00001990  4E75                     936             RTS
00001992  4EB9 00002390            937  ADDcode111 JSR      ISADDAL
00001998  4E75                     938             RTS
0000199A                           939  
0000199A                           940  SUB_BorSUB_WorSUB_L:
0000199A  41F9 000019B8            941          LEA         tableSUB_BorSUB_WorSUB_L, A0 ; Index into the table
000019A0  4280                     942          CLR.L       D0              ; Zero it
000019A2  3016                     943          MOVE.W      (A6),D0     ; We'll play with it here
000019A4  123C 0007                944          MOVE.B      #7,D1           ; Shift 7 bits left
000019A8  E360                     945          ASL.W       D1,D0
000019AA  123C 000D                946          MOVE.B      #13,D1          ; Shift 13 bits to the right
000019AE  E268                     947          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000019B0                           948                                      ; and the rest are zeroed out)
000019B0  C0FC 0006                949          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000019B4  4EF0 0000                950          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000019B8                           951  
000019B8                           952  tableSUB_BorSUB_WorSUB_L:
000019B8  4EF9 000019E8            953          JMP         SUBcode000      *SUB.B
000019BE  4EF9 000019F0            954          JMP         SUBcode001      *SUB.W
000019C4  4EF9 000019F8            955          JMP         SUBcode010      *SUB.L
000019CA  4EF9 00001A00            956          JMP         SUBcode011
000019D0  4EF9 00001A08            957          JMP         SUBcode100      *SUB.B
000019D6  4EF9 00001A10            958          JMP         SUBcode101      *SUB.W
000019DC  4EF9 00001A18            959          JMP         SUBcode110      *SUB.L
000019E2  4EF9 00001A20            960          JMP         SUBcode111      ; INVALID
000019E8                           961  
000019E8  4EB9 00002430            962  SUBcode000 JSR      ISSUBB
000019EE  4E75                     963             RTS
000019F0  4EB9 00002458            964  SUBcode001 JSR      ISSUBW
000019F6  4E75                     965             RTS
000019F8  4EB9 00002480            966  SUBcode010 JSR      ISSUBL
000019FE  4E75                     967             RTS
00001A00  4EB9 00001EF4            968  SUBcode011 JSR      OPCODE_INVALID              ;INVALID
00001A06  4E75                     969             RTS
00001A08  4EB9 00002430            970  SUBcode100 JSR      ISSUBB
00001A0E  4E75                     971             RTS
00001A10  4EB9 00002458            972  SUBcode101 JSR      ISSUBW
00001A16  4E75                     973             RTS
00001A18  4EB9 00002480            974  SUBcode110 JSR      ISSUBL
00001A1E  4E75                     975             RTS
00001A20  4EB9 00001EF4            976  SUBcode111 JSR      OPCODE_INVALID              ;INVALID
00001A26  4E75                     977             RTS
00001A28                           978  
00001A28                           979  CMP_BorCMP_WorCMP_L:
00001A28  41F9 00001A46            980          LEA         tableCMP_BorCMP_WorCMP_L, A0 ; Index into the table
00001A2E  4280                     981          CLR.L       D0              ; Zero it
00001A30  3016                     982          MOVE.W      (A6),D0     ; We'll play with it here
00001A32  123C 0008                983          MOVE.B      #8,D1           ; Shift 8 bits left
00001A36  E360                     984          ASL.W       D1,D0
00001A38  123C 000E                985          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001A3C  E268                     986          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001A3E                           987                                      ; and the rest are zeroed out)
00001A3E  C0FC 0006                988          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001A42  4EF0 0000                989          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A46                           990  
00001A46                           991  tableCMP_BorCMP_WorCMP_L:
00001A46  4EF9 00001A5E            992          JMP         CMPcode00       *CMP.B
00001A4C  4EF9 00001A66            993          JMP         CMPcode01       *CMP.W
00001A52  4EF9 00001A6E            994          JMP         CMPcode10       *CMP.L
00001A58  4EF9 00001A76            995          JMP         CMPcode11       ; INVALID
00001A5E                           996  
00001A5E  4EB9 000024A8            997  CMPcode00   JSR      ISCMPB
00001A64  4E75                     998              RTS
00001A66  4EB9 000024D0            999  CMPcode01   JSR      ISCMPW
00001A6C  4E75                    1000              RTS
00001A6E  4EB9 000024F8           1001  CMPcode10   JSR      ISCMPL
00001A74  4E75                    1002              RTS
00001A76  4EB9 00001EF4           1003  CMPcode11   JSR    OPCODE_INVALID              ;INVALID
00001A7C  4E75                    1004              RTS
00001A7E                          1005  
00001A7E                          1006  ADDQ_BorADDQ_WorADDQ_L:
00001A7E  41F9 00001A9C           1007          LEA         tableADDQ_BorADDQ_WorADDQ_L, A0 ; Index into the table
00001A84  4280                    1008          CLR.L       D0              ; Zero it
00001A86  3016                    1009          MOVE.W      (A6),D0     ; We'll play with it here
00001A88  123C 0008               1010          MOVE.B      #8,D1           ; Shift 8 bits left
00001A8C  E360                    1011          ASL.W       D1,D0
00001A8E  123C 000E               1012          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001A92  E268                    1013          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001A94                          1014                                      ; and the rest are zeroed out)
00001A94  C0FC 0006               1015          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001A98  4EF0 0000               1016          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A9C                          1017  
00001A9C                          1018  tableADDQ_BorADDQ_WorADDQ_L:
00001A9C  4EF9 00001AB4           1019          JMP         ADDQcode00      *ADDQ.B
00001AA2  4EF9 00001ABC           1020          JMP         ADDQcode01      *ADDQ.W
00001AA8  4EF9 00001AC4           1021          JMP         ADDQcode10      *ADDQ.L
00001AAE  4EF9 00001ACC           1022          JMP         ADDQcode11      ; INVALID
00001AB4                          1023  
00001AB4  4EB9 00002520           1024  ADDQcode00 JSR      ISADDQB
00001ABA  4E75                    1025             RTS
00001ABC  4EB9 00002548           1026  ADDQcode01 JSR      ISADDQW
00001AC2  4E75                    1027             RTS
00001AC4  4EB9 00002570           1028  ADDQcode10 JSR      ISADDQL
00001ACA  4E75                    1029             RTS
00001ACC  4EB9 00001EF4           1030  ADDQcode11   JSR    OPCODE_INVALID              ;INVALID
00001AD2  4E75                    1031              RTS
00001AD4                          1032  
00001AD4                          1033  someCLR:
00001AD4  41F9 00001AF2           1034          LEA         tableSomeCLR, A0 ; Index into the table
00001ADA  4280                    1035          CLR.L       D0              ; Zero it
00001ADC  3016                    1036          MOVE.W      (A6),D0     ; We'll play with it here
00001ADE  123C 0008               1037          MOVE.B      #8,D1           ; Shift 8 bits left
00001AE2  E360                    1038          ASL.W       D1,D0
00001AE4  123C 000E               1039          MOVE.B      #14,D1       ; Shift 12 bits to the right
00001AE8  E268                    1040          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001AEA                          1041                                      ; and the rest are zeroed out)
00001AEA  C0FC 0006               1042          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001AEE  4EF0 0000               1043          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001AF2                          1044  
00001AF2                          1045  tableSomeCLR:
00001AF2  4EF9 00001B0A           1046          JMP         CLRcode00       *CLR.B
00001AF8  4EF9 00001B12           1047          JMP         CLRcode01       *CLR.W
00001AFE  4EF9 00001B1A           1048          JMP         CLRcode10       *CLR.L
00001B04  4EF9 00001B22           1049          JMP         CLRcode11       ; INVALID
00001B0A                          1050  
00001B0A  4EB9 000025B4           1051  CLRcode00 JSR       ISCLRB
00001B10  4E75                    1052            RTS
00001B12  4EB9 000025DC           1053  CLRcode01 JSR       ISCLRW
00001B18  4E75                    1054            RTS
00001B1A  4EB9 00002604           1055  CLRcode10 JSR       ISCLRL
00001B20  4E75                    1056            RTS
00001B22  4EB9 00001EF4           1057  CLRcode11 JSR    OPCODE_INVALID              ;INVALID
00001B28  4E75                    1058            RTS
00001B2A                          1059  
00001B2A                          1060  NOPorCLRorRTSorJSR:
00001B2A  41F9 00001B5C           1061          LEA         tableNOPorCLRorRTSorJSR, A0 ; Index into the table
00001B30  4280                    1062          CLR.L       D0              ; Zero it
00001B32  3016                    1063          MOVE.W      (A6),D0     ; We'll play with it here
00001B34                          1064  
00001B34  323C 4E71               1065          MOVE.W      #%0100111001110001, D1 ; 0100111001110001 = NOP
00001B38  B240                    1066          CMP.W       D0, D1
00001B3A  6700 0088               1067          BEQ         NOPcommand
00001B3E                          1068  
00001B3E  323C 4E75               1069          MOVE.W      #%0100111001110101, D1 ; 0100111001110101 = RTS
00001B42  B240                    1070          CMP.W       D0, D1
00001B44  6700 0076               1071          BEQ         RTScommand
00001B48                          1072  
00001B48  123C 0004               1073          MOVE.B      #4,D1           ; Shift 4 bits left
00001B4C  E360                    1074          ASL.W       D1,D0
00001B4E  123C 000C               1075          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001B52  E268                    1076          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B54                          1077                                      ; and the rest are zeroed out)
00001B54  C0FC 0006               1078          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B58  4EF0 0000               1079          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B5C                          1080  
00001B5C                          1081  tableNOPorCLRorRTSorJSR:
00001B5C  4EF9 00001BCC           1082          JMP         JSRorCLRcode0000
00001B62  4EF9 00001BD4           1083          JMP         JSRorCLRcode0001
00001B68  4EF9 00001BDC           1084          JMP         JSRorCLRcode0010
00001B6E  4EF9 00001BE2           1085          JMP         JSRorCLRcode0011
00001B74  4EF9 00001BEA           1086          JMP         JSRorCLRcode0100
00001B7A  4EF9 00001BF2           1087          JMP         JSRorCLRcode0101
00001B80  4EF9 00001BFA           1088          JMP         JSRorCLRcode0110
00001B86  4EF9 00001C02           1089          JMP         JSRorCLRcode0111
00001B8C  4EF9 00001C0A           1090          JMP         JSRorCLRcode1000
00001B92  4EF9 00001C12           1091          JMP         JSRorCLRcode1001
00001B98  4EF9 00001C1A           1092          JMP         JSRorCLRcode1010
00001B9E  4EF9 00001C22           1093          JMP         JSRorCLRcode1011
00001BA4  4EF9 00001C2A           1094          JMP         JSRorCLRcode1100
00001BAA  4EF9 00001C32           1095          JMP         JSRorCLRcode1101
00001BB0  4EF9 00001C3A           1096          JMP         JSRorCLRcode1110
00001BB6  4EF9 00001C42           1097          JMP         JSRorCLRcode1111
00001BBC                          1098  
00001BBC  4EB9 000026CC           1099  RTScommand JSR      ISRTS
00001BC2  4E75                    1100             RTS
00001BC4  4EB9 0000270C           1101  NOPcommand JSR      ISNOP
00001BCA  4E75                    1102             RTS
00001BCC  4EB9 00001EF4           1103  JSRorCLRcode0000 JSR    OPCODE_INVALID              ;INVALID
00001BD2  4E75                    1104                   RTS
00001BD4  4EB9 00001EF4           1105  JSRorCLRcode0001 JSR    OPCODE_INVALID              ;INVALID
00001BDA  4E75                    1106                   RTS
00001BDC  4EB8 1AD4               1107  JSRorCLRcode0010 JSR someCLR
00001BE0  4E75                    1108                   RTS
00001BE2  4EB9 00001EF4           1109  JSRorCLRcode0011 JSR    OPCODE_INVALID              ;INVALID
00001BE8  4E75                    1110                   RTS
00001BEA  4EB9 00001EF4           1111  JSRorCLRcode0100 JSR    OPCODE_INVALID              ;INVALID
00001BF0  4E75                    1112                   RTS
00001BF2  4EB9 00001EF4           1113  JSRorCLRcode0101 JSR    OPCODE_INVALID              ;INVALID
00001BF8  4E75                    1114                   RTS
00001BFA  4EB9 00001EF4           1115  JSRorCLRcode0110 JSR    OPCODE_INVALID              ;INVALID
00001C00  4E75                    1116                   RTS
00001C02  4EB9 00001EF4           1117  JSRorCLRcode0111 JSR    OPCODE_INVALID              ;INVALID
00001C08  4E75                    1118                   RTS
00001C0A  4EB9 00001EF4           1119  JSRorCLRcode1000 JSR    OPCODE_INVALID              ;INVALID
00001C10  4E75                    1120                   RTS
00001C12  4EB9 00001EF4           1121  JSRorCLRcode1001 JSR    OPCODE_INVALID              ;INVALID
00001C18  4E75                    1122                   RTS
00001C1A  4EB9 00001EF4           1123  JSRorCLRcode1010 JSR    OPCODE_INVALID              ;INVALID
00001C20  4E75                    1124                   RTS
00001C22  4EB9 00001EF4           1125  JSRorCLRcode1011 JSR    OPCODE_INVALID              ;INVALID
00001C28  4E75                    1126                   RTS
00001C2A  4EB9 00001EF4           1127  JSRorCLRcode1100 JSR    OPCODE_INVALID              ;INVALID
00001C30  4E75                    1128                   RTS
00001C32  4EB9 00001EF4           1129  JSRorCLRcode1101 JSR    OPCODE_INVALID              ;INVALID
00001C38  4E75                    1130                   RTS
00001C3A  4EB9 000026A4           1131  JSRorCLRcode1110 JSR ISJSR
00001C40  4E75                    1132                   RTS
00001C42  4EB9 00001EF4           1133  JSRorCLRcode1111 JSR    OPCODE_INVALID              ;INVALID
00001C48  4E75                    1134                   RTS
00001C4A                          1135  
00001C4A                          1136  someMOVEM:
00001C4A  41F9 00001C68           1137          LEA         tableSomeMOVEM, A0 ; Index into the table
00001C50  4280                    1138          CLR.L       D0              ; Zero it
00001C52  3016                    1139          MOVE.W      (A6),D0     ; We'll play with it here
00001C54  123C 0009               1140          MOVE.B      #9,D1           ; Shift 9 bits left
00001C58  E360                    1141          ASL.W       D1,D0
00001C5A  123C 000F               1142          MOVE.B      #15,D1       ; Shift 12 bits to the right
00001C5E  E268                    1143          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001C60                          1144                                      ; and the rest are zeroed out)
00001C60  C0FC 0006               1145          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001C64  4EF0 0000               1146          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001C68                          1147  
00001C68                          1148  tableSomeMOVEM:
00001C68  4EF9 00001C74           1149          JMP         MOVEMcode0      ; MOVEM.W
00001C6E  4EF9 00001C7C           1150          JMP         MOVEMcode1      ; MOVEM.L
00001C74                          1151  
00001C74  4EB9 00002654           1152  MOVEMcode0 JSR      ISMOVEMW
00001C7A  4E75                    1153             RTS
00001C7C  4EB9 0000262C           1154  MOVEMcode1 JSR      ISMOVEML
00001C82  4E75                    1155             RTS
00001C84                          1156  
00001C84                          1157  NOP_MOVEM_LEA_JSR_CLR_RTS:
00001C84  41F9 00001CA8           1158          LEA         tableNOP_MOVEM_LEA_JSR_CLR_RTS, A0 ; Index into the table
00001C8A  4280                    1159          CLR.L       D0              ; Zero it
00001C8C  3016                    1160          MOVE.W      (A6),D0     ; We'll play with it here
00001C8E  123C 0007               1161          MOVE.B      #7,D1           ; Shift 7 bits right
00001C92  E260                    1162          ASR.W       D1,D0
00001C94  123C 000D               1163          MOVE.B      #13,D1          ; Shift 13 bits left
00001C98  E360                    1164          ASL.W       D1,D0
00001C9A  123C 000C               1165          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001C9E  E268                    1166          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001CA0                          1167                                      ; and the rest are zeroed out)
00001CA0  C0FC 0006               1168          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001CA4  4EF0 0000               1169          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001CA8                          1170  
00001CA8                          1171  tableNOP_MOVEM_LEA_JSR_CLR_RTS:
00001CA8  4EF9 00001D08           1172          JMP         LOTScode0000
00001CAE  4EF9 00001D10           1173          JMP         LOTScode0001
00001CB4  4EF9 00001D18           1174          JMP         LOTScode0010
00001CBA  4EF9 00001D1E           1175          JMP         LOTScode0011
00001CC0  4EF9 00001D26           1176          JMP         LOTScode0100
00001CC6  4EF9 00001D2E           1177          JMP         LOTScode0101
00001CCC  4EF9 00001D36           1178          JMP         LOTScode0110
00001CD2  4EF9 00001D3E           1179          JMP         LOTScode0111
00001CD8  4EF9 00001D46           1180          JMP         LOTScode1000
00001CDE  4EF9 00001D4C           1181          JMP         LOTScode1001
00001CE4  4EF9 00001D54           1182          JMP         LOTScode1010
00001CEA  4EF9 00001D5A           1183          JMP         LOTScode1011
00001CF0  4EF9 00001D62           1184          JMP         LOTScode1100
00001CF6  4EF9 00001D6A           1185          JMP         LOTScode1101
00001CFC  4EF9 00001D72           1186          JMP         LOTScode1110
00001D02  4EF9 00001D7A           1187          JMP         LOTScode1111
00001D08                          1188  
00001D08  4EB9 00001EF4           1189  LOTScode0000 JSR    OPCODE_INVALID              ; MULS.L and DIVU.L are not supported for 68000 Disassember
00001D0E  4E75                    1190               RTS
00001D10  4EB9 00001EF4           1191  LOTScode0001 JSR    OPCODE_INVALID              ;INVALID
00001D16  4E75                    1192               RTS
00001D18  4EB8 1C4A               1193  LOTScode0010 JSR    someMOVEM
00001D1C  4E75                    1194               RTS
00001D1E  4EB9 00001EF4           1195  LOTScode0011 JSR    OPCODE_INVALID              ;INVALID
00001D24  4E75                    1196               RTS
00001D26  4EB9 00001EF4           1197  LOTScode0100 JSR    OPCODE_INVALID              ;INVALID
00001D2C  4E75                    1198               RTS
00001D2E  4EB9 00001EF4           1199  LOTScode0101 JSR    OPCODE_INVALID              ;INVALID
00001D34  4E75                    1200               RTS
00001D36  4EB9 0000267C           1201  LOTScode0110 JSR    ISLEA
00001D3C  4E75                    1202               RTS
00001D3E  4EB9 00001EF4           1203  LOTScode0111 JSR    OPCODE_INVALID              ;INVALID
00001D44  4E75                    1204               RTS
00001D46  4EB8 1B2A               1205  LOTScode1000 JSR    NOPorCLRorRTSorJSR
00001D4A  4E75                    1206               RTS
00001D4C  4EB9 00001EF4           1207  LOTScode1001 JSR    OPCODE_INVALID              ;INVALID
00001D52  4E75                    1208               RTS
00001D54  4EB8 1B2A               1209  LOTScode1010 JSR    NOPorCLRorRTSorJSR
00001D58  4E75                    1210               RTS
00001D5A  4EB9 00001EF4           1211  LOTScode1011 JSR    OPCODE_INVALID              ;INVALID
00001D60  4E75                    1212               RTS
00001D62  4EB9 00001EF4           1213  LOTScode1100 JSR    OPCODE_INVALID              ;INVALID
00001D68  4E75                    1214               RTS
00001D6A  4EB9 00001EF4           1215  LOTScode1101 JSR    OPCODE_INVALID              ;INVALID
00001D70  4E75                    1216               RTS
00001D72  4EB9 0000267C           1217  LOTScode1110 JSR    ISLEA
00001D78  4E75                    1218               RTS
00001D7A  4EB9 00001EF4           1219  LOTScode1111 JSR    OPCODE_INVALID              ;INVALID
00001D80  4E75                    1220               RTS
00001D82                          1221  
00001D82                          1222  ADDI_BorADDI_WorADDI_L:
00001D82  41F9 00001DA0           1223          LEA         tableADDI_BorADDI_WorADDI_L,A0 ; Index into the table
00001D88  4280                    1224          CLR.L       D0              ; Zero it
00001D8A  3016                    1225          MOVE.W      (A6),D0     ; We'll play with it here
00001D8C  123C 0007               1226          MOVE.B      #7,D1           ; Shift 7 bits left
00001D90  E360                    1227          ASL.W       D1,D0
00001D92  123C 000D               1228          MOVE.B      #13,D1          ; Shift 13 bits right
00001D96  E260                    1229          ASR.W       D1,D0
00001D98  C0FC 0006               1230          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001D9C  4EF0 0000               1231          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001DA0                          1232  
00001DA0                          1233  tableADDI_BorADDI_WorADDI_L:
00001DA0  4EF9 00001DB8           1234          JMP         ADDIBcode00
00001DA6  4EF9 00001DC0           1235          JMP         ADDIWcode01
00001DAC  4EF9 00001DC8           1236          JMP         ADDILcode10
00001DB2  4EF9 00001DD0           1237          JMP         ADDILcode11
00001DB8                          1238  
00001DB8  4EB9 0000283C           1239  ADDIBcode00 JSR     ISADDIB
00001DBE  4E75                    1240              RTS
00001DC0  4EB9 000027EC           1241  ADDIWcode01 JSR     ISADDIW
00001DC6  4E75                    1242              RTS
00001DC8  4EB9 00002814           1243  ADDILcode10 JSR     ISADDIL
00001DCE  4E75                    1244              RTS
00001DD0  4EB9 00001EF4           1245  ADDILcode11 JSR    OPCODE_INVALID              ;INVALID
00001DD6  4E75                    1246              RTS
00001DD8                          1247  
00001DD8                          1248  MOVEA_LorMOVE_L:
00001DD8  41F9 00001DF6           1249          LEA         tableMOVEA_LorMOVE_L,A0 ; Index into the table
00001DDE  4280                    1250          CLR.L       D0              ; Zero it
00001DE0  3016                    1251          MOVE.W      (A6),D0         ; We'll play with it here
00001DE2  123C 0007               1252          MOVE.B      #7,D1           ; Shift 7 bits left
00001DE6  E360                    1253          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
00001DE8  123C 000D               1254          MOVE.B      #13,D1          ; Shift 13 bits right
00001DEC  E260                    1255          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
00001DEE  C0FC 0006               1256          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001DF2  4EF0 0000               1257          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001DF6                          1258  
00001DF6                          1259  tableMOVEA_LorMOVE_L:
00001DF6  4EF9 00001E26           1260          JMP         MOVEcode000
00001DFC  4EF9 00001E2E           1261          JMP         MOVEAcode001
00001E02  4EF9 00001E36           1262          JMP         MOVEcode010
00001E08  4EF9 00001E3E           1263          JMP         MOVEcode011
00001E0E  4EF9 00001E46           1264          JMP         MOVEcode100
00001E14  4EF9 00001E4E           1265          JMP         MOVEcode101
00001E1A  4EF9 00001E56           1266          JMP         MOVEcode110
00001E20  4EF9 00001E5E           1267          JMP         MOVEcode111
00001E26                          1268  
00001E26  4EB9 00002780           1269  MOVEcode000 JSR     ISMOVEL
00001E2C  4E75                    1270              RTS
00001E2E  4EB9 000027A8           1271  MOVEAcode001 JSR    ISMOVEAL
00001E34  4E75                    1272               RTS
00001E36  4EB9 00002780           1273  MOVEcode010 JSR     ISMOVEL
00001E3C  4E75                    1274              RTS
00001E3E  4EB9 00002780           1275  MOVEcode011 JSR     ISMOVEL
00001E44  4E75                    1276              RTS
00001E46  4EB9 00002780           1277  MOVEcode100 JSR     ISMOVEL
00001E4C  4E75                    1278              RTS
00001E4E  4EB9 00002780           1279  MOVEcode101 JSR     ISMOVEL
00001E54  4E75                    1280              RTS
00001E56  4EB9 00002780           1281  MOVEcode110 JSR     ISMOVEL
00001E5C  4E75                    1282              RTS
00001E5E  4EB9 00002780           1283  MOVEcode111 JSR     ISMOVEL
00001E64  4E75                    1284              RTS
00001E66                          1285  
00001E66                          1286  MOVEA_WorMOVE_W:
00001E66  41F9 00001E84           1287          LEA         tableMOVEA_WorMOVE_W,A0 ; Index into the table
00001E6C  4280                    1288          CLR.L       D0              ; Zero it
00001E6E  3016                    1289          MOVE.W      (A6),D0     ; We'll play with it here
00001E70  123C 0007               1290          MOVE.B      #7,D1           ; Shift 7 bits left
00001E74  E360                    1291          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
00001E76  123C 000D               1292          MOVE.B      #13,D1          ; Shift 13 bits right
00001E7A  E260                    1293          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
00001E7C  C0FC 0006               1294          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001E80  4EF0 0000               1295          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001E84                          1296  
00001E84                          1297  tableMOVEA_WorMOVE_W:
00001E84  4EF9 00001EB4           1298          JMP         MOVEWcode000
00001E8A  4EF9 00001EBC           1299          JMP         MOVEAWcode001
00001E90  4EF9 00001EC4           1300          JMP         MOVEWcode010
00001E96  4EF9 00001ECC           1301          JMP         MOVEWcode011
00001E9C  4EF9 00001ED4           1302          JMP         MOVEWcode100
00001EA2  4EF9 00001EDC           1303          JMP         MOVEWcode101
00001EA8  4EF9 00001EE4           1304          JMP         MOVEWcode110
00001EAE  4EF9 00001EEC           1305          JMP         MOVEWcode111
00001EB4                          1306  
00001EB4  4EB9 00002730           1307  MOVEWcode000 JSR    ISMOVEW
00001EBA  4E75                    1308               RTS
00001EBC  4EB9 00002758           1309  MOVEAWcode001 JSR   ISMOVEAW
00001EC2  4E75                    1310                RTS
00001EC4  4EB9 00002730           1311  MOVEWcode010 JSR    ISMOVEW
00001ECA  4E75                    1312               RTS
00001ECC  4EB9 00002730           1313  MOVEWcode011 JSR    ISMOVEW
00001ED2  4E75                    1314               RTS
00001ED4  4EB9 00002730           1315  MOVEWcode100 JSR    ISMOVEW
00001EDA  4E75                    1316               RTS
00001EDC  4EB9 00002730           1317  MOVEWcode101 JSR    ISMOVEW
00001EE2  4E75                    1318               RTS
00001EE4  4EB9 00002730           1319  MOVEWcode110 JSR    ISMOVEW
00001EEA  4E75                    1320               RTS
00001EEC  4EB9 00002730           1321  MOVEWcode111 JSR    ISMOVEW
00001EF2  4E75                    1322               RTS
00001EF4                          1323  
00001EF4                          1324  ; TODO: adjust workflow to:
00001EF4                          1325  ;   1) save message address to buffer pointer
00001EF4  48E7 FFFE               1326  OPCODE_INVALID  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001EF8  4EB8 1326               1327              JSR     INVALID_DATA
00001EFC  548E                    1328              ADDA.L      #$00000002, A6          ; Increment past current opcode word
00001EFE  4CDF 7FFF               1329              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001F02  4E75                    1330              RTS
00001F04                          1331  
00001F04  48E7 FFFE               1332  ISBCC  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001F08  49F9 0000474C           1333              LEA    MESSAGEBCC, A4
00001F0E  4EB9 000043D2           1334              JSR    WRITE2MEM
00001F14  49F9 000045DE           1335              LEA    MESSAGESPACE, A4
00001F1A  4EB9 000043D2           1336              JSR    WRITE2MEM
00001F20  4EB9 0000347C           1337              JSR     EA_Bcc
00001F26  4CDF 7FFF               1338              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001F2A  4E75                    1339              RTS
00001F2C  48E7 FFFE               1340  ISBGT  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001F30  49F9 00004750           1341              LEA MESSAGEBGT, A4
00001F36  4EB9 000043D2           1342              JSR    WRITE2MEM
00001F3C  49F9 000045DE           1343              LEA    MESSAGESPACE, A4
00001F42  4EB9 000043D2           1344              JSR    WRITE2MEM
00001F48  4EB9 0000347C           1345              JSR     EA_Bcc
00001F4E  4CDF 7FFF               1346              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001F52  4E75                    1347              RTS
00001F54                          1348  
00001F54  48E7 FFFE               1349  ISBLE  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001F58  49F9 00004754           1350              LEA MESSAGEBLE, A4
00001F5E  4EB9 000043D2           1351              JSR    WRITE2MEM
00001F64  49F9 000045DE           1352              LEA    MESSAGESPACE, A4
00001F6A  4EB9 000043D2           1353              JSR    WRITE2MEM
00001F70  4EB9 0000347C           1354              JSR     EA_Bcc
00001F76  4CDF 7FFF               1355              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001F7A  4E75                    1356              RTS
00001F7C                          1357  
00001F7C  48E7 FFFE               1358  ISDIVUW     MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001F80  49F9 00004745           1359              LEA MESSAGEDIVUW, A4
00001F86  4EB9 000043D2           1360              JSR    WRITE2MEM
00001F8C  49F9 000045DE           1361              LEA    MESSAGESPACE, A4
00001F92  4EB9 000043D2           1362              JSR    WRITE2MEM
00001F98  4EB9 000036AE           1363              JSR     EA_DIVU_W
00001F9E  4CDF 7FFF               1364              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001FA2  4E75                    1365              RTS
00001FA4                          1366  
00001FA4  48E7 FFFE               1367  ISORB   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001FA8  49F9 00004736           1368          LEA         MESSAGEORB, A4
00001FAE  4EB9 000043D2           1369          JSR    WRITE2MEM
00001FB4  49F9 000045DE           1370          LEA    MESSAGESPACE, A4
00001FBA  4EB9 000043D2           1371          JSR    WRITE2MEM
00001FC0  4EB9 00003EC2           1372          JSR         EA_OR
00001FC6  4CDF 7FFF               1373          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00001FCA  4E75                    1374          RTS
00001FCC                          1375  
00001FCC  48E7 FFFE               1376  ISORW   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001FD0  49F9 0000473B           1377          LEA         MESSAGEORW, A4
00001FD6  4EB9 000043D2           1378          JSR    WRITE2MEM
00001FDC  49F9 000045DE           1379          LEA    MESSAGESPACE, A4
00001FE2  4EB9 000043D2           1380          JSR    WRITE2MEM
00001FE8  4EB9 00003EC2           1381          JSR         EA_OR
00001FEE  4CDF 7FFF               1382          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00001FF2  4E75                    1383          RTS
00001FF4                          1384  
00001FF4  48E7 FFFE               1385  ISORL   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001FF8  49F9 00004740           1386          LEA         MESSAGEORL, A4
00001FFE  4EB9 000043D2           1387          JSR    WRITE2MEM
00002004  49F9 000045DE           1388          LEA    MESSAGESPACE, A4
0000200A  4EB9 000043D2           1389          JSR    WRITE2MEM
00002010  4EB9 00003EC2           1390          JSR         EA_OR
00002016  4CDF 7FFF               1391          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000201A  4E75                    1392          RTS
0000201C                          1393  
0000201C  48E7 FFFE               1394  ISASRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002020  49F9 000046CA           1395          LEA         MESSAGEASRB, A4
00002026  4EB9 000043D2           1396          JSR    WRITE2MEM
0000202C  49F9 000045DE           1397          LEA    MESSAGESPACE, A4
00002032  4EB9 000043D2           1398          JSR    WRITE2MEM
00002038  4EB9 0000334C           1399          JSR         EA_ASd
0000203E  4CDF 7FFF               1400          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002042  4E75                    1401          RTS
00002044                          1402  
00002044  48E7 FFFE               1403  ISASRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002048  49F9 000046D0           1404          LEA         MESSAGEASRW, A4
0000204E  4EB9 000043D2           1405          JSR    WRITE2MEM
00002054  49F9 000045DE           1406          LEA    MESSAGESPACE, A4
0000205A  4EB9 000043D2           1407          JSR    WRITE2MEM
00002060  4EB9 0000334C           1408          JSR         EA_ASd
00002066  4CDF 7FFF               1409          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000206A  4E75                    1410          RTS
0000206C                          1411  
0000206C  48E7 FFFE               1412  ISASRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002070  49F9 000046D6           1413          LEA         MESSAGEASRL, A4
00002076  4EB9 000043D2           1414          JSR    WRITE2MEM
0000207C  49F9 000045DE           1415          LEA    MESSAGESPACE, A4
00002082  4EB9 000043D2           1416          JSR    WRITE2MEM
00002088  4EB9 0000334C           1417          JSR         EA_ASd
0000208E  4CDF 7FFF               1418          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002092  4E75                    1419          RTS
00002094                          1420  
00002094  48E7 FFFE               1421  ISASLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002098  49F9 000046DC           1422          LEA         MESSAGEASLB, A4
0000209E  4EB9 000043D2           1423          JSR    WRITE2MEM
000020A4  49F9 000045DE           1424          LEA    MESSAGESPACE, A4
000020AA  4EB9 000043D2           1425          JSR    WRITE2MEM
000020B0  4EB9 0000334C           1426          JSR         EA_ASd
000020B6  4CDF 7FFF               1427          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000020BA  4E75                    1428          RTS
000020BC                          1429  
000020BC  48E7 FFFE               1430  ISASLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000020C0  43F9 000046E2           1431          LEA         MESSAGEASLW, A1
000020C6  103C 000E               1432          MOVE.B      #14, D0
000020CA  4E4F                    1433          TRAP        #15
000020CC  4EB9 0000334C           1434          JSR         EA_ASd
000020D2  4CDF 7FFF               1435          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000020D6  4E75                    1436          RTS
000020D8                          1437  
000020D8  48E7 FFFE               1438  ISASLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000020DC  49F9 000046E8           1439          LEA         MESSAGEASLL, A4
000020E2  4EB9 000043D2           1440          JSR    WRITE2MEM
000020E8  49F9 000045DE           1441          LEA    MESSAGESPACE, A4
000020EE  4EB9 000043D2           1442          JSR    WRITE2MEM
000020F4  4EB9 0000334C           1443          JSR         EA_ASd
000020FA  4CDF 7FFF               1444          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000020FE  4E75                    1445          RTS
00002100                          1446  
00002100  48E7 FFFE               1447  ISLSRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002104  49F9 00004712           1448          LEA         MESSAGELSRB, A4
0000210A  4EB9 000043D2           1449          JSR    WRITE2MEM
00002110  49F9 000045DE           1450          LEA    MESSAGESPACE, A4
00002116  4EB9 000043D2           1451          JSR    WRITE2MEM
0000211C  4EB9 00003942           1452          JSR         EA_LSd
00002122  4CDF 7FFF               1453          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002126  4E75                    1454          RTS
00002128                          1455  
00002128  48E7 FFFE               1456  ISLSRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000212C  49F9 00004718           1457          LEA         MESSAGELSRW, A4
00002132  4EB9 000043D2           1458          JSR    WRITE2MEM
00002138  49F9 000045DE           1459          LEA    MESSAGESPACE, A4
0000213E  4EB9 000043D2           1460          JSR    WRITE2MEM
00002144  4EB9 00003942           1461          JSR         EA_LSd
0000214A  4CDF 7FFF               1462          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000214E  4E75                    1463          RTS
00002150                          1464  
00002150  48E7 FFFE               1465  ISLSRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002154  49F9 0000471E           1466          LEA         MESSAGELSRL, A4
0000215A  4EB9 000043D2           1467          JSR    WRITE2MEM
00002160  49F9 000045DE           1468          LEA    MESSAGESPACE, A4
00002166  4EB9 000043D2           1469          JSR    WRITE2MEM
0000216C  4EB9 00003942           1470          JSR         EA_LSd
00002172  4CDF 7FFF               1471          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002176  4E75                    1472          RTS
00002178                          1473  
00002178  48E7 FFFE               1474  ISLSLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000217C  43F9 00004724           1475          LEA         MESSAGELSLB, A1
00002182  103C 000E               1476          MOVE.B      #14, D0
00002186  4E4F                    1477          TRAP        #15
00002188  4EB9 00003942           1478          JSR         EA_LSd
0000218E  4CDF 7FFF               1479          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002192  4E75                    1480          RTS
00002194                          1481  
00002194  48E7 FFFE               1482  ISLSLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002198  49F9 0000472A           1483          LEA         MESSAGELSLW, A4
0000219E  4EB9 000043D2           1484          JSR    WRITE2MEM
000021A4  49F9 000045DE           1485          LEA    MESSAGESPACE, A4
000021AA  4EB9 000043D2           1486          JSR    WRITE2MEM
000021B0  4EB9 00003942           1487          JSR         EA_LSd
000021B6  4CDF 7FFF               1488          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000021BA  4E75                    1489          RTS
000021BC                          1490  
000021BC  48E7 FFFE               1491  ISLSLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000021C0  49F9 00004730           1492          LEA         MESSAGELSLL, A4
000021C6  4EB9 000043D2           1493          JSR    WRITE2MEM
000021CC  49F9 000045DE           1494          LEA    MESSAGESPACE, A4
000021D2  4EB9 000043D2           1495          JSR    WRITE2MEM
000021D8  4EB9 00003942           1496          JSR         EA_LSd
000021DE  4CDF 7FFF               1497          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000021E2  4E75                    1498          RTS
000021E4                          1499  
000021E4  48E7 FFFE               1500  ISRORB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000021E8  49F9 000046EE           1501          LEA         MESSAGERORB, A4
000021EE  4EB9 000043D2           1502          JSR    WRITE2MEM
000021F4  49F9 000045DE           1503          LEA    MESSAGESPACE, A4
000021FA  4EB9 000043D2           1504          JSR    WRITE2MEM
00002200  4EB9 00004084           1505          JSR         EA_ROd
00002206  4CDF 7FFF               1506          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000220A  4E75                    1507          RTS
0000220C                          1508  
0000220C  48E7 FFFE               1509  ISRORW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002210  43F9 000046F4           1510          LEA         MESSAGERORW, A1
00002216  103C 000E               1511          MOVE.B      #14, D0
0000221A  4E4F                    1512          TRAP        #15
0000221C  4EB9 00004084           1513          JSR         EA_ROd
00002222  4CDF 7FFF               1514          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002226  4E75                    1515          RTS
00002228                          1516  
00002228  48E7 FFFE               1517  ISRORL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000222C  49F9 000046FA           1518          LEA         MESSAGERORL, A4
00002232  4EB9 000043D2           1519          JSR    WRITE2MEM
00002238  49F9 000045DE           1520          LEA    MESSAGESPACE, A4
0000223E  4EB9 000043D2           1521          JSR    WRITE2MEM
00002244  4EB9 00004084           1522          JSR         EA_ROd
0000224A  4CDF 7FFF               1523          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000224E  4E75                    1524          RTS
00002250                          1525  
00002250  48E7 FFFE               1526  ISROLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002254  49F9 00004700           1527          LEA         MESSAGEROLB, A4
0000225A  4EB9 000043D2           1528          JSR    WRITE2MEM
00002260  49F9 000045DE           1529          LEA    MESSAGESPACE, A4
00002266  4EB9 000043D2           1530          JSR    WRITE2MEM
0000226C  4EB9 00004084           1531          JSR         EA_ROd
00002272  4CDF 7FFF               1532          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002276  4E75                    1533          RTS
00002278                          1534  
00002278  48E7 FFFE               1535  ISROLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000227C  49F9 00004706           1536          LEA         MESSAGEROLW, A4
00002282  4EB9 000043D2           1537          JSR    WRITE2MEM
00002288  49F9 000045DE           1538          LEA    MESSAGESPACE, A4
0000228E  4EB9 000043D2           1539          JSR    WRITE2MEM
00002294  4EB9 00004084           1540          JSR         EA_ROd
0000229A  4CDF 7FFF               1541          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000229E  4E75                    1542          RTS
000022A0                          1543  
000022A0  48E7 FFFE               1544  ISROLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022A4  49F9 0000470C           1545          LEA         MESSAGEROLL, A4
000022AA  4EB9 000043D2           1546          JSR    WRITE2MEM
000022B0  49F9 000045DE           1547          LEA    MESSAGESPACE, A4
000022B6  4EB9 000043D2           1548          JSR    WRITE2MEM
000022BC  4EB9 00004084           1549          JSR         EA_ROd
000022C2  4CDF 7FFF               1550          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022C6  4E75                    1551          RTS
000022C8                          1552  
000022C8  48E7 FFFE               1553  ISMULSW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022CC  49F9 000046C3           1554          LEA         MESSAGEMULSW, A4
000022D2  4EB9 000043D2           1555          JSR    WRITE2MEM
000022D8  49F9 000045DE           1556          LEA    MESSAGESPACE, A4
000022DE  4EB9 000043D2           1557          JSR    WRITE2MEM
000022E4  4EB9 00003DD2           1558          JSR         EA_MULS_W
000022EA  4CDF 7FFF               1559          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022EE  4E75                    1560          RTS
000022F0                          1561  
000022F0  48E7 FFFE               1562  ISANDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022F4  49F9 000046B1           1563          LEA         MESSAGEANDB, A4
000022FA  4EB9 000043D2           1564          JSR    WRITE2MEM
00002300  49F9 000045DE           1565          LEA    MESSAGESPACE, A4
00002306  4EB9 000043D2           1566          JSR    WRITE2MEM
0000230C  4EB9 00003190           1567          JSR         EA_AND
00002312  4CDF 7FFF               1568          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002316  4E75                    1569          RTS
00002318                          1570  
00002318  48E7 FFFE               1571  ISANDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000231C  49F9 000046B7           1572          LEA         MESSAGEANDW, A4
00002322  4EB9 000043D2           1573          JSR    WRITE2MEM
00002328  49F9 000045DE           1574          LEA    MESSAGESPACE, A4
0000232E  4EB9 000043D2           1575          JSR    WRITE2MEM
00002334  4EB9 00003190           1576          JSR         EA_AND
0000233A  4CDF 7FFF               1577          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000233E  4E75                    1578          RTS
00002340                          1579  
00002340  48E7 FFFE               1580  ISANDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002344  49F9 000046BD           1581          LEA         MESSAGEANDL, A4
0000234A  4EB9 000043D2           1582          JSR    WRITE2MEM
00002350  49F9 000045DE           1583          LEA    MESSAGESPACE, A4
00002356  4EB9 000043D2           1584          JSR    WRITE2MEM
0000235C  4EB9 00003190           1585          JSR         EA_AND
00002362  4CDF 7FFF               1586          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002366  4E75                    1587          RTS
00002368                          1588  
00002368  48E7 FFFE               1589  ISADDAW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000236C  49F9 0000469B           1590          LEA         MESSAGEADDAW, A4
00002372  4EB9 000043D2           1591          JSR    WRITE2MEM
00002378  49F9 000045DE           1592          LEA    MESSAGESPACE, A4
0000237E  4EB9 000043D2           1593          JSR    WRITE2MEM
00002384  4EB9 00002E86           1594          JSR         EA_ADDA
0000238A  4CDF 7FFF               1595          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000238E  4E75                    1596          RTS
00002390                          1597  
00002390  48E7 FFFE               1598  ISADDAL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002394  49F9 000046A2           1599          LEA         MESSAGEADDAL, A4
0000239A  4EB9 000043D2           1600          JSR    WRITE2MEM
000023A0  49F9 000045DE           1601          LEA    MESSAGESPACE, A4
000023A6  4EB9 000043D2           1602          JSR    WRITE2MEM
000023AC  4EB9 00002E86           1603          JSR         EA_ADDA
000023B2  4CDF 7FFF               1604          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023B6  4E75                    1605          RTS
000023B8                          1606  
000023B8  48E7 FFFE               1607  ISADDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023BC  49F9 00004689           1608          LEA         MESSAGEADDB, A4
000023C2  4EB9 000043D2           1609          JSR    WRITE2MEM
000023C8  49F9 000045DE           1610          LEA    MESSAGESPACE, A4
000023CE  4EB9 000043D2           1611          JSR    WRITE2MEM
000023D4  4EB9 00002CBC           1612          JSR         EA_ADD
000023DA  4CDF 7FFF               1613          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023DE  4E75                    1614          RTS
000023E0                          1615  
000023E0  48E7 FFFE               1616  ISADDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023E4  49F9 0000468F           1617          LEA         MESSAGEADDW, A4
000023EA  4EB9 000043D2           1618          JSR    WRITE2MEM
000023F0  49F9 000045DE           1619          LEA    MESSAGESPACE, A4
000023F6  4EB9 000043D2           1620          JSR    WRITE2MEM
000023FC  4EB9 00002CBC           1621          JSR         EA_ADD
00002402  4CDF 7FFF               1622          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002406  4E75                    1623          RTS
00002408                          1624  
00002408  48E7 FFFE               1625  ISADDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000240C  49F9 00004695           1626          LEA         MESSAGEADDL, A4
00002412  4EB9 000043D2           1627          JSR    WRITE2MEM
00002418  49F9 000045DE           1628          LEA    MESSAGESPACE, A4
0000241E  4EB9 000043D2           1629          JSR    WRITE2MEM
00002424  4EB9 00002CBC           1630          JSR         EA_ADD
0000242A  4CDF 7FFF               1631          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000242E  4E75                    1632          RTS
00002430                          1633  
00002430  48E7 FFFE               1634  ISSUBB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002434  49F9 00004677           1635          LEA         MESSAGESUBB, A4
0000243A  4EB9 000043D2           1636          JSR    WRITE2MEM
00002440  49F9 000045DE           1637          LEA    MESSAGESPACE, A4
00002446  4EB9 000043D2           1638          JSR    WRITE2MEM
0000244C  4EB9 000041B4           1639          JSR         EA_SUB
00002452  4CDF 7FFF               1640          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002456  4E75                    1641          RTS
00002458                          1642  
00002458  48E7 FFFE               1643  ISSUBW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000245C  49F9 0000467D           1644          LEA         MESSAGESUBW, A4
00002462  4EB9 000043D2           1645          JSR    WRITE2MEM
00002468  49F9 000045DE           1646          LEA    MESSAGESPACE, A4
0000246E  4EB9 000043D2           1647          JSR    WRITE2MEM
00002474  4EB9 000041B4           1648          JSR         EA_SUB
0000247A  4CDF 7FFF               1649          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000247E  4E75                    1650          RTS
00002480                          1651  
00002480  48E7 FFFE               1652  ISSUBL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002484  49F9 00004683           1653          LEA         MESSAGESUBL, A4
0000248A  4EB9 000043D2           1654          JSR    WRITE2MEM
00002490  49F9 000045DE           1655          LEA    MESSAGESPACE, A4
00002496  4EB9 000043D2           1656          JSR    WRITE2MEM
0000249C  4EB9 000041B4           1657          JSR         EA_SUB
000024A2  4CDF 7FFF               1658          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024A6  4E75                    1659          RTS
000024A8                          1660  
000024A8  48E7 FFFE               1661  ISCMPB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024AC  49F9 00004665           1662          LEA         MESSAGECMPB, A4
000024B2  4EB9 000043D2           1663          JSR    WRITE2MEM
000024B8  49F9 000045DE           1664          LEA    MESSAGESPACE, A4
000024BE  4EB9 000043D2           1665          JSR    WRITE2MEM
000024C4  4EB9 000035D2           1666          JSR         EA_CMP
000024CA  4CDF 7FFF               1667          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024CE  4E75                    1668          RTS
000024D0                          1669  
000024D0  48E7 FFFE               1670  ISCMPW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024D4  49F9 0000466B           1671          LEA         MESSAGECMPW, A4
000024DA  4EB9 000043D2           1672          JSR    WRITE2MEM
000024E0  49F9 000045DE           1673          LEA    MESSAGESPACE, A4
000024E6  4EB9 000043D2           1674          JSR    WRITE2MEM
000024EC  4EB9 000035D2           1675          JSR         EA_CMP
000024F2  4CDF 7FFF               1676          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024F6  4E75                    1677          RTS
000024F8                          1678  
000024F8  48E7 FFFE               1679  ISCMPL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024FC  49F9 00004671           1680          LEA         MESSAGECMPL, A4
00002502  4EB9 000043D2           1681          JSR    WRITE2MEM
00002508  49F9 000045DE           1682          LEA    MESSAGESPACE, A4
0000250E  4EB9 000043D2           1683          JSR    WRITE2MEM
00002514  4EB9 000035D2           1684          JSR         EA_CMP
0000251A  4CDF 7FFF               1685          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000251E  4E75                    1686          RTS
00002520                          1687  
00002520  48E7 FFFE               1688  ISADDQB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002524  49F9 00004650           1689          LEA         MESSAGEADDQB, A4
0000252A  4EB9 000043D2           1690          JSR    WRITE2MEM
00002530  49F9 000045DE           1691          LEA    MESSAGESPACE, A4
00002536  4EB9 000043D2           1692          JSR    WRITE2MEM
0000253C  4EB9 00003092           1693          JSR         EA_ADDQ
00002542  4CDF 7FFF               1694          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002546  4E75                    1695          RTS
00002548                          1696  
00002548  48E7 FFFE               1697  ISADDQW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000254C  49F9 00004657           1698          LEA         MESSAGEADDQW, A4
00002552  4EB9 000043D2           1699          JSR    WRITE2MEM
00002558  49F9 000045DE           1700          LEA    MESSAGESPACE, A4
0000255E  4EB9 000043D2           1701          JSR    WRITE2MEM
00002564  4EB9 00003092           1702          JSR         EA_ADDQ
0000256A  4CDF 7FFF               1703          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000256E  4E75                    1704          RTS
00002570                          1705  
00002570  48E7 FFFE               1706  ISADDQL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002574  43F9 0000465E           1707          LEA         MESSAGEADDQL, A1 *OPCODE is ADDQ.L
0000257A  103C 000E               1708          MOVE.B      #14, D0
0000257E  4E4F                    1709          TRAP        #15
00002580  4EB9 00003092           1710          JSR         EA_ADDQ
00002586  4CDF 7FFF               1711          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000258A  4E75                    1712          RTS
0000258C                          1713  
0000258C  48E7 FFFE               1714  ISMOVEQL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
00002590  49F9 000046A9           1715          LEA         MESSAGEMOVEQL, A4
00002596  4EB9 000043D2           1716          JSR    WRITE2MEM
0000259C  49F9 000045DE           1717          LEA    MESSAGESPACE, A4
000025A2  4EB9 000043D2           1718          JSR    WRITE2MEM
000025A8  4EB9 00003D72           1719          JSR         EA_MOVEQ
000025AE  4CDF 7FFF               1720          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025B2  4E75                    1721          RTS
000025B4                          1722  
000025B4  48E7 FFFE               1723  ISCLRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025B8  49F9 0000463E           1724          LEA         MESSAGECLRB, A4
000025BE  4EB9 000043D2           1725          JSR    WRITE2MEM
000025C4  49F9 000045DE           1726          LEA    MESSAGESPACE, A4
000025CA  4EB9 000043D2           1727          JSR    WRITE2MEM
000025D0  4EB9 00003D72           1728          JSR         EA_MOVEQ
000025D6  4CDF 7FFF               1729          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025DA  4E75                    1730          RTS
000025DC                          1731  
000025DC  48E7 FFFE               1732  ISCLRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025E0  49F9 00004644           1733          LEA         MESSAGECLRW, A4
000025E6  4EB9 000043D2           1734          JSR    WRITE2MEM
000025EC  49F9 000045DE           1735          LEA    MESSAGESPACE, A4
000025F2  4EB9 000043D2           1736          JSR    WRITE2MEM
000025F8  4EB9 0000350A           1737          JSR         EA_CLR
000025FE  4CDF 7FFF               1738          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002602  4E75                    1739          RTS
00002604                          1740  
00002604  48E7 FFFE               1741  ISCLRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002608  49F9 0000464A           1742          LEA         MESSAGECLRL, A4
0000260E  4EB9 000043D2           1743          JSR    WRITE2MEM
00002614  49F9 000045DE           1744          LEA    MESSAGESPACE, A4
0000261A  4EB9 000043D2           1745          JSR    WRITE2MEM
00002620  4EB9 0000350A           1746          JSR         EA_CLR
00002626  4CDF 7FFF               1747          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000262A  4E75                    1748          RTS
0000262C                          1749  
0000262C  48E7 FFFE               1750  ISMOVEML MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
00002630  49F9 0000461E           1751          LEA         MESSAGEMOVEML, A4
00002636  4EB9 000043D2           1752          JSR    WRITE2MEM
0000263C  49F9 000045DE           1753          LEA    MESSAGESPACE, A4
00002642  4EB9 000043D2           1754          JSR    WRITE2MEM
00002648  4EB9 00003D6C           1755          JSR         EA_MOVEM
0000264E  4CDF 7FFF               1756          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002652  4E75                    1757          RTS
00002654                          1758  
00002654  48E7 FFFE               1759  ISMOVEMW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
00002658  49F9 00004626           1760          LEA         MESSAGEMOVEMW, A4
0000265E  4EB9 000043D2           1761          JSR    WRITE2MEM
00002664  49F9 000045DE           1762          LEA    MESSAGESPACE, A4
0000266A  4EB9 000043D2           1763          JSR    WRITE2MEM
00002670  4EB9 00003D6C           1764          JSR         EA_MOVEM
00002676  4CDF 7FFF               1765          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000267A  4E75                    1766          RTS
0000267C                          1767  
0000267C  48E7 FFFE               1768  ISLEA   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002680  49F9 0000463A           1769          LEA         MESSAGELEA, A4
00002686  4EB9 000043D2           1770          JSR    WRITE2MEM
0000268C  49F9 000045DE           1771          LEA    MESSAGESPACE, A4
00002692  4EB9 000043D2           1772          JSR    WRITE2MEM
00002698  4EB9 00003866           1773          JSR         EA_LEA
0000269E  4CDF 7FFF               1774          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026A2  4E75                    1775          RTS                         ; Exit subroutine
000026A4                          1776  
000026A4  48E7 FFFE               1777  ISJSR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026A8  49F9 0000462E           1778          LEA         MESSAGEJSR, A4
000026AE  4EB9 000043D2           1779          JSR    WRITE2MEM
000026B4  49F9 000045DE           1780          LEA    MESSAGESPACE, A4
000026BA  4EB9 000043D2           1781          JSR    WRITE2MEM
000026C0  4EB9 0000379E           1782          JSR         EA_JSR
000026C6  4CDF 7FFF               1783          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026CA  4E75                    1784          RTS                         ; Exit subroutine
000026CC                          1785  
000026CC  48E7 FFFE               1786  ISRTS   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026D0  49F9 00004636           1787          LEA         MESSAGERTS, A4
000026D6  4EB9 000043D2           1788          JSR    WRITE2MEM
000026DC  49F9 000045DE           1789          LEA    MESSAGESPACE, A4
000026E2  4EB9 000043D2           1790          JSR    WRITE2MEM
000026E8  548E                    1791          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
000026EA  4CDF 7FFF               1792          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026EE  4E75                    1793          RTS
000026F0                          1794  
000026F0  48E7 FFFE               1795  ISCLR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026F4  43F9 00004632           1796          LEA         MESSAGECLR, A1  *OPCODE is CLR
000026FA  103C 000E               1797          MOVE.B      #14, D0
000026FE  4E4F                    1798          TRAP        #15
00002700  4EB9 0000350A           1799          JSR         EA_CLR
00002706  4CDF 7FFF               1800          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000270A  4E75                    1801          RTS
0000270C                          1802  
0000270C  48E7 FFFE               1803  ISNOP   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002710  49F9 000045E0           1804          LEA         MESSAGENOP, A4
00002716  4EB9 000043D2           1805          JSR    WRITE2MEM
0000271C  49F9 000045DE           1806          LEA    MESSAGESPACE, A4
00002722  4EB9 000043D2           1807          JSR    WRITE2MEM
00002728  548E                    1808          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
0000272A  4CDF 7FFF               1809          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000272E  4E75                    1810          RTS                         ; Exit subroutine
00002730                          1811  
00002730  48E7 FFFE               1812  ISMOVEW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002734  49F9 000045E4           1813          LEA         MESSAGEMOVEW, A4
0000273A  4EB9 000043D2           1814          JSR    WRITE2MEM
00002740  49F9 000045DE           1815          LEA    MESSAGESPACE, A4
00002746  4EB9 000043D2           1816          JSR    WRITE2MEM
0000274C  4EB9 00003A72           1817          JSR         EA_MOVE
00002752  4CDF 7FFF               1818          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002756  4E75                    1819          RTS                         ; Exit subroutine
00002758                          1820  
00002758  48E7 FFFE               1821  ISMOVEAW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
0000275C  49F9 00004616           1822          LEA         MESSAGEMOVEAW, A4
00002762  4EB9 000043D2           1823          JSR    WRITE2MEM
00002768  49F9 000045DE           1824          LEA    MESSAGESPACE, A4
0000276E  4EB9 000043D2           1825          JSR    WRITE2MEM
00002774  4EB9 00003C46           1826          JSR         EA_MOVEA
0000277A  4CDF 7FFF               1827          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000277E  4E75                    1828          RTS                         ; Exit subroutine
00002780                          1829  
00002780  48E7 FFFE               1830  ISMOVEL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002784  49F9 000045EB           1831          LEA         MESSAGEMOVEL, A4
0000278A  4EB9 000043D2           1832          JSR    WRITE2MEM
00002790  49F9 000045DE           1833          LEA    MESSAGESPACE, A4
00002796  4EB9 000043D2           1834          JSR    WRITE2MEM
0000279C  4EB9 00003A72           1835          JSR         EA_MOVE
000027A2  4CDF 7FFF               1836          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027A6  4E75                    1837          RTS                         ; Exit subroutine
000027A8                          1838  
000027A8  48E7 FFFE               1839  ISMOVEAL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000027AC  49F9 0000460E           1840          LEA         MESSAGEMOVEAL, A4
000027B2  4EB9 000043D2           1841          JSR    WRITE2MEM
000027B8  49F9 000045DE           1842          LEA    MESSAGESPACE, A4
000027BE  4EB9 000043D2           1843          JSR    WRITE2MEM
000027C4  4EB9 00003C46           1844          JSR         EA_MOVEA
000027CA  4CDF 7FFF               1845          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027CE  4E75                    1846          RTS                         ; Exit subroutine
000027D0                          1847  
000027D0  48E7 FFFE               1848  ISMOVEB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027D4  43F9 000045F2           1849          LEA         MESSAGEMOVEB, A1 *OPCODE is MOVE.B so display MOVEB message
000027DA  103C 000E               1850          MOVE.B      #14, D0
000027DE  4E4F                    1851          TRAP        #15
000027E0  4EB9 00003A72           1852          JSR         EA_MOVE
000027E6  4CDF 7FFF               1853          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027EA  4E75                    1854          RTS                         ; Exit subroutine
000027EC                          1855  
000027EC  48E7 FFFE               1856  ISADDIW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027F0  49F9 000045F9           1857          LEA         MESSAGEADDIW, A4
000027F6  4EB9 000043D2           1858          JSR    WRITE2MEM
000027FC  49F9 000045DE           1859          LEA    MESSAGESPACE, A4
00002802  4EB9 000043D2           1860          JSR    WRITE2MEM
00002808  4EB9 00002F76           1861          JSR         EA_ADDI
0000280E  4CDF 7FFF               1862          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002812  4E75                    1863          RTS                         ; Exit subroutine
00002814                          1864  
00002814  48E7 FFFE               1865  ISADDIL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002818  49F9 00004600           1866          LEA         MESSAGEADDIL, A4
0000281E  4EB9 000043D2           1867          JSR    WRITE2MEM
00002824  49F9 000045DE           1868          LEA    MESSAGESPACE, A4
0000282A  4EB9 000043D2           1869          JSR    WRITE2MEM
00002830  4EB9 00002F76           1870          JSR         EA_ADDI
00002836  4CDF 7FFF               1871          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000283A  4E75                    1872          RTS                         ; Exit subroutine
0000283C                          1873  
0000283C  48E7 FFFE               1874  ISADDIB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002840  49F9 00004607           1875          LEA         MESSAGEADDIB, A4
00002846  4EB9 000043D2           1876          JSR    WRITE2MEM
0000284C  49F9 000045DE           1877          LEA    MESSAGESPACE, A4
00002852  4EB9 000043D2           1878          JSR    WRITE2MEM
00002858  4EB9 00002F76           1879          JSR         EA_ADDI
0000285E  4CDF 7FFF               1880          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002862  4E75                    1881          RTS                         ; Exit subroutine
00002864                          1882  
00002864                          1883  
00002864                          1884  
00002864                          1885  
00002864                          1886  
00002864                          1887  
00002864                          1888  
00002864                          1889  
00002864                          1890  -------------------- end include --------------------
00002864                          1891      INCLUDE 'EA.X68'
00002864                          1892  
00002864                          1893      INCLUDE 'EA_UTIL.X68'
00002864                          1894  
00002864                          1895  
00002864                          1896  EA_UNIMPLEMENTED:
00002864  548E                    1897      ADDA.L      #$00000002, A6      ; Increment past current opcode word
00002866  49F9 000047B1           1898      LEA         EA_MSG_UNIMP, A4
0000286C  4EB9 000043D2           1899      JSR         WRITE2MEM
00002872  4E75                    1900      RTS
00002874                          1901  
00002874                          1902  EA_INVALID:
00002874  2A4E                    1903      MOVEA.L     A6, A5              ; Copy global pointer
00002876  548D                    1904      ADDA.L      #$00000002, A5      ; Increment past current opcode word
00002878  4EB8 1326               1905      JSR         INVALID_DATA        ; Print data error message
0000287C  4E75                    1906      RTS
0000287E                          1907  
0000287E                          1908  EA_PRINT_DATA:
0000287E  49F9 000047CB           1909      LEA         EA_MSG_PRINT_DATA, A4
00002884  4EB9 000043D2           1910      JSR         WRITE2MEM
0000288A  4E75                    1911      RTS
0000288C                          1912  
0000288C                          1913  
0000288C                          1914  EA_UPDATE_POINTER:
0000288C  BDCD                    1915      CMP.L       A5, A6              ; Check if A5==A6
0000288E  6600 0004               1916      BNE         UPDATE_PTR          ; If NOT equal (a.k.a if any extra operands
00002892                          1917                                      ; were read, and is already up to date),
00002892                          1918                                      ; update global with current
00002892  548D                    1919      ADDA.L      #$00000002, A5      ; Else, increment past current opcode word, then update
00002894                          1920  UPDATE_PTR:
00002894  2C4D                    1921      MOVEA.L     A5, A6              ; Update global pointer
00002896  4E75                    1922      RTS
00002898                          1923  
00002898                          1924  EA_COPY_PTR:
00002898  2A4E                    1925      MOVEA.L     A6, A5              ; Save global pointer
0000289A  4E75                    1926      RTS
0000289C                          1927  
0000289C                          1928  EA_DEFAULT_COMBO:
0000289C  4286                    1929      CLR.L       D6                  ; Clear space for mode bits
0000289E  4287                    1930      CLR.L       D7                  ; Clear space for register bits
000028A0  2216                    1931      MOVE.L      (A6), D1            ; Load opcode to data register 1
000028A2  143C 000A               1932      MOVE.B      #10, D2             ; Clear upper 10 bits of opcode word
000028A6  E569                    1933      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000028A8  143C 000D               1934      MOVE.B      #13, D2             ; 'Right-align' bits 3-5 to determine mode bits
000028AC  E469                    1935      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000028AE  1C01                    1936      MOVE.B      D1, D6              ; Save mode bits to D6
000028B0  2216                    1937      MOVE.L      (A6), D1            ; Reload opcode to data register 1
000028B2  143C 000D               1938      MOVE.B      #13, D2             ; Clear upper 13 bits of opcode word
000028B6  E569                    1939      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000028B8  143C 000D               1940      MOVE.B      #13, D2             ; 'Right-align' bits 0-2 to determine register bits
000028BC  E469                    1941      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000028BE  1E01                    1942      MOVE.B      D1, D7              ; Save register bits to D7
000028C0  4E75                    1943      RTS                             ; Return from subroutine
000028C2                          1944  
000028C2                          1945  EA_OPMODE_COMBO:
000028C2  4286                    1946      CLR.L       D6                  ; Clear space for mode bits
000028C4  4287                    1947      CLR.L       D7                  ; Clear space for register bits
000028C6  2216                    1948      MOVE.L      (A6), D1            ; Load opcode to data register 1
000028C8  143C 0007               1949      MOVE.B      #7, D2              ; Clear upper 7 bits of opcode word
000028CC  E569                    1950      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000028CE  143C 000D               1951      MOVE.B      #13, D2             ; 'Right-align' bits 6-8 to determine opmode bits
000028D2  E469                    1952      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000028D4  1C01                    1953      MOVE.B      D1, D6              ; Save opmode bits to D6
000028D6  2216                    1954      MOVE.L      (A6), D1            ; Reload opcode to data register 1
000028D8  143C 0004               1955      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
000028DC  E569                    1956      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000028DE  143C 000D               1957      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register bits
000028E2  E469                    1958      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000028E4  1E01                    1959      MOVE.B      D1, D7              ; Save register bits to D7
000028E6  4E75                    1960      RTS                             ; Return from subroutine
000028E8                          1961  
000028E8                          1962  EA_SIZE_BITS:
000028E8  4287                    1963      CLR.L       D7
000028EA  2E16                    1964      MOVE.L      (A6), D7            ; Load opcode to data register 1
000028EC  143C 0008               1965      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
000028F0  E56F                    1966      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000028F2  143C 000E               1967      MOVE.B      #14, D2             ; 'Right-align' bits 6-7 to determine size bits
000028F6  E46F                    1968      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000028F8  4E75                    1969      RTS
000028FA                          1970  
000028FA                          1971  
000028FA                          1972  EA_PRINT_DN:
000028FA  41F9 00002908           1973      LEA         EA_PRINT_DN_JMP, A0 ; Set index '0' for jump table
00002900  CEFC 0006               1974      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002904  4EF0 7000               1975      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002908                          1976  EA_PRINT_DN_JMP:
00002908  4EF9 00002938           1977      JMP         DN_000 ; D0
0000290E  4EF9 00002944           1978      JMP         DN_001 ; D1
00002914  4EF9 00002950           1979      JMP         DN_010 ; D2
0000291A  4EF9 0000295C           1980      JMP         DN_011 ; D3
00002920  4EF9 00002968           1981      JMP         DN_100 ; D4
00002926  4EF9 00002974           1982      JMP         DN_101 ; D5
0000292C  4EF9 00002980           1983      JMP         DN_110 ; D6
00002932  4EF9 0000298C           1984      JMP         DN_111 ; D7
00002938                          1985  DN_000: ; D0
00002938  49F9 00004781           1986      LEA         EA_MSG_D0, A4
0000293E  4EB9 000043D2           1987      JSR         WRITE2MEM
00002944                          1988  DN_001: ; D1
00002944  49F9 00004784           1989      LEA         EA_MSG_D1, A4
0000294A  4EB9 000043D2           1990      JSR         WRITE2MEM
00002950                          1991  DN_010: ; D2
00002950  49F9 00004787           1992      LEA         EA_MSG_D2, A4
00002956  4EB9 000043D2           1993      JSR         WRITE2MEM
0000295C                          1994  DN_011: ; D3
0000295C  49F9 0000478A           1995      LEA         EA_MSG_D3, A4
00002962  4EB9 000043D2           1996      JSR         WRITE2MEM
00002968                          1997  DN_100: ; D4
00002968  49F9 0000478D           1998      LEA         EA_MSG_D4, A4
0000296E  4EB9 000043D2           1999      JSR         WRITE2MEM
00002974                          2000  DN_101: ; D5
00002974  49F9 00004790           2001      LEA         EA_MSG_D5, A4
0000297A  4EB9 000043D2           2002      JSR         WRITE2MEM
00002980                          2003  DN_110: ; D6
00002980  49F9 00004793           2004      LEA         EA_MSG_D6, A4
00002986  4EB9 000043D2           2005      JSR         WRITE2MEM
0000298C                          2006  DN_111: ; D7
0000298C  49F9 00004796           2007      LEA         EA_MSG_D7, A4
00002992  4EB9 000043D2           2008      JSR         WRITE2MEM
00002998                          2009  
00002998                          2010  EA_PRINT_DN_END:
00002998  4E75                    2011      RTS
0000299A                          2012  
0000299A                          2013  EA_PRINT_AN:
0000299A  41F9 000029A8           2014      LEA         AN_JMP, A0          ; Set index '0' for jump table
000029A0  CEFC 0006               2015      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000029A4  4EF0 7000               2016      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000029A8                          2017  AN_JMP:
000029A8  4EF9 000029D8           2018      JMP         AN_000 ; A0
000029AE  4EF9 000029E4           2019      JMP         AN_001 ; A1
000029B4  4EF9 000029F0           2020      JMP         AN_010 ; A2
000029BA  4EF9 000029FC           2021      JMP         AN_011 ; A3
000029C0  4EF9 00002A08           2022      JMP         AN_100 ; A4
000029C6  4EF9 00002A14           2023      JMP         AN_101 ; A5
000029CC  4EF9 00002A20           2024      JMP         AN_110 ; A6
000029D2  4EF9 00002A2C           2025      JMP         AN_111 ; A7
000029D8                          2026  AN_000: ; A0
000029D8  49F9 00004799           2027      LEA         EA_MSG_A0, A4
000029DE  4EB9 000043D2           2028      JSR         WRITE2MEM
000029E4                          2029  AN_001: ; A1
000029E4  49F9 0000479C           2030      LEA         EA_MSG_A1, A4
000029EA  4EB9 000043D2           2031      JSR         WRITE2MEM
000029F0                          2032  AN_010: ; A2
000029F0  49F9 0000479F           2033      LEA         EA_MSG_A2, A4
000029F6  4EB9 000043D2           2034      JSR         WRITE2MEM
000029FC                          2035  AN_011: ; A3
000029FC  49F9 000047A2           2036      LEA         EA_MSG_A3, A4
00002A02  4EB9 000043D2           2037      JSR         WRITE2MEM
00002A08                          2038  AN_100: ; A4
00002A08  49F9 000047A5           2039      LEA         EA_MSG_A4, A4
00002A0E  4EB9 000043D2           2040      JSR         WRITE2MEM
00002A14                          2041  AN_101: ; A5
00002A14  49F9 000047A8           2042      LEA         EA_MSG_A5, A4
00002A1A  4EB9 000043D2           2043      JSR         WRITE2MEM
00002A20                          2044  AN_110: ; A6
00002A20  49F9 000047AB           2045      LEA         EA_MSG_A6, A4
00002A26  4EB9 000043D2           2046      JSR         WRITE2MEM
00002A2C                          2047  AN_111: ; A7
00002A2C  49F9 000047AE           2048      LEA         EA_MSG_A7, A4
00002A32  4EB9 000043D2           2049      JSR         WRITE2MEM
00002A38                          2050  
00002A38                          2051  EA_PRINT_AN_END:
00002A38  4E75                    2052      RTS
00002A3A                          2053  EA_PRINT_IND:
00002A3A  49F9 000048AF           2054      LEA         OPAREN, A4    ; Print open parentheses
00002A40  4EB9 000043D2           2055      JSR         WRITE2MEM
00002A46  41F9 00002A54           2056      LEA         IND_JMP, A0         ; Set index '0' for jump table
00002A4C  CEFC 0006               2057      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002A50  4EF0 7000               2058      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002A54                          2059  IND_JMP:
00002A54  4EF9 00002A84           2060      JMP         IND_000 ; (A0)
00002A5A  4EF9 00002A90           2061      JMP         IND_001 ; (A1)
00002A60  4EF9 00002A9C           2062      JMP         IND_010 ; (A2)
00002A66  4EF9 00002AA8           2063      JMP         IND_011 ; (A3)
00002A6C  4EF9 00002AB4           2064      JMP         IND_100 ; (A4)
00002A72  4EF9 00002AC0           2065      JMP         IND_101 ; (A5)
00002A78  4EF9 00002ACC           2066      JMP         IND_110 ; (A6)
00002A7E  4EF9 00002AD8           2067      JMP         IND_111 ; (A7)
00002A84                          2068  IND_000: ; (A0)
00002A84  49F9 00004799           2069      LEA         EA_MSG_A0, A4
00002A8A  4EB9 000043D2           2070      JSR         WRITE2MEM
00002A90                          2071  IND_001: ; (A1)
00002A90  49F9 0000479C           2072      LEA         EA_MSG_A1, A4
00002A96  4EB9 000043D2           2073      JSR         WRITE2MEM
00002A9C                          2074  IND_010: ; (A2)
00002A9C  49F9 0000479F           2075      LEA         EA_MSG_A2, A4
00002AA2  4EB9 000043D2           2076      JSR         WRITE2MEM
00002AA8                          2077  IND_011: ; (A3)
00002AA8  49F9 000047A2           2078      LEA         EA_MSG_A3, A4
00002AAE  4EB9 000043D2           2079      JSR         WRITE2MEM
00002AB4                          2080  IND_100: ; (A4)
00002AB4  49F9 000047A5           2081      LEA         EA_MSG_A4, A4
00002ABA  4EB9 000043D2           2082      JSR         WRITE2MEM
00002AC0                          2083  IND_101: ; (A5)
00002AC0  49F9 000047A8           2084      LEA         EA_MSG_A5, A4
00002AC6  4EB9 000043D2           2085      JSR         WRITE2MEM
00002ACC                          2086  IND_110: ; (A6)
00002ACC  49F9 000047AB           2087      LEA         EA_MSG_A6, A4
00002AD2  4EB9 000043D2           2088      JSR         WRITE2MEM
00002AD8                          2089  IND_111: ; (A7)
00002AD8  49F9 000047AE           2090      LEA         EA_MSG_A7, A4
00002ADE  4EB9 000043D2           2091      JSR         WRITE2MEM
00002AE4                          2092  EA_PRINT_IND_END:
00002AE4  49F9 000048B1           2093      LEA         CPAREN, A4   ; Print close parentheses
00002AEA  4EB9 000043D2           2094      JSR         WRITE2MEM
00002AF0  4E75                    2095      RTS
00002AF2                          2096  EA_PRINT_IMM:
00002AF2  224D                    2097      MOVEA.L     A5, A1              ; copy pointer to temp
00002AF4  5489                    2098      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002AF6  BA7C 0003               2099      CMP         #3, D5
00002AFA  6700 0010               2100      BEQ         PRINT_IMM_L         ; if L, branch
00002AFE  3011                    2101      MOVE.W      (A1), D0            ; store value in a register (todo, register tbd)
00002B00  4EB8 287E               2102      JSR         EA_PRINT_DATA *print value TODO
00002B04  5489                    2103      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002B06  4EF9 00002B10           2104      JMP         PRINT_IMM_END
00002B0C                          2105  PRINT_IMM_L:
00002B0C  2011                    2106      MOVE.L      (A1), D0            ; store value in a register (todo, register tbd)
00002B0E                          2107      *print value TODO
00002B0E  5889                    2108      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002B10                          2109  PRINT_IMM_END:
00002B10  2A49                    2110      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002B12  4E75                    2111      RTS
00002B14                          2112  EA_PRINT_POSTINC:
00002B14  49F9 000048AF           2113      LEA         OPAREN, A4    ; Print open parentheses
00002B1A  4EB9 000043D2           2114      JSR         WRITE2MEM
00002B20  41F9 00002B2E           2115      LEA         POSTINC_JMP, A0     ; Set index '0' for jump table
00002B26  CEFC 0006               2116      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002B2A  4EF0 7000               2117      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002B2E                          2118  POSTINC_JMP:
00002B2E  4EF9 00002B5E           2119      JMP         POSTINC_000 ; (A0)+
00002B34  4EF9 00002B6A           2120      JMP         POSTINC_001 ; (A1)+
00002B3A  4EF9 00002B76           2121      JMP         POSTINC_010 ; (A2)+
00002B40  4EF9 00002B82           2122      JMP         POSTINC_011 ; (A3)+
00002B46  4EF9 00002B8E           2123      JMP         POSTINC_100 ; (A4)+
00002B4C  4EF9 00002B9A           2124      JMP         POSTINC_101 ; (A5)+
00002B52  4EF9 00002BA6           2125      JMP         POSTINC_110 ; (A6)+
00002B58  4EF9 00002BB2           2126      JMP         POSTINC_111 ; (A7)+
00002B5E                          2127  POSTINC_000: ; (A0)+
00002B5E  49F9 00004799           2128      LEA         EA_MSG_A0, A4
00002B64  4EB9 000043D2           2129      JSR         WRITE2MEM
00002B6A                          2130  POSTINC_001: ; (A1)+
00002B6A  49F9 0000479C           2131      LEA         EA_MSG_A1, A4
00002B70  4EB9 000043D2           2132      JSR         WRITE2MEM
00002B76                          2133  POSTINC_010: ; (A2)+
00002B76  49F9 0000479F           2134      LEA         EA_MSG_A2, A4
00002B7C  4EB9 000043D2           2135      JSR         WRITE2MEM
00002B82                          2136  POSTINC_011: ; (A3)+
00002B82  49F9 000047A2           2137      LEA         EA_MSG_A3, A4
00002B88  4EB9 000043D2           2138      JSR         WRITE2MEM
00002B8E                          2139  POSTINC_100: ; (A4)+
00002B8E  49F9 000047A5           2140      LEA         EA_MSG_A4, A4
00002B94  4EB9 000043D2           2141      JSR         WRITE2MEM
00002B9A                          2142  POSTINC_101: ; (A5)+
00002B9A  49F9 000047A8           2143      LEA         EA_MSG_A5, A4
00002BA0  4EB9 000043D2           2144      JSR         WRITE2MEM
00002BA6                          2145  POSTINC_110: ; (A6)+
00002BA6  49F9 000047AB           2146      LEA         EA_MSG_A6, A4
00002BAC  4EB9 000043D2           2147      JSR         WRITE2MEM
00002BB2                          2148  POSTINC_111: ; (A7)+
00002BB2  49F9 000047AE           2149      LEA         EA_MSG_A7, A4
00002BB8  4EB9 000043D2           2150      JSR         WRITE2MEM
00002BBE                          2151  EA_PRINT_PI_END:
00002BBE  49F9 000048B1           2152      LEA         CPAREN, A4   ; Print close parentheses
00002BC4  4EB9 000043D2           2153      JSR         WRITE2MEM
00002BCA  49F9 000048B3           2154      LEA         PLUS, A4         ; Print plus sign
00002BD0  4EB9 000043D2           2155      JSR         WRITE2MEM
00002BD6  4E75                    2156      RTS
00002BD8                          2157  EA_PRINT_PREDEC:
00002BD8  49F9 000048B5           2158      LEA         MINUS, A4               ; Print minus sign
00002BDE  4EB9 000043D2           2159      JSR         WRITE2MEM
00002BE4  49F9 000048AF           2160      LEA         OPAREN, A4              ; Print open parentheses
00002BEA  4EB9 000043D2           2161      JSR         WRITE2MEM
00002BF0  41F9 00002BFE           2162      LEA         PREDEC_JMP, A0      ; Set index '0' for jump table
00002BF6  CEFC 0006               2163      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002BFA  4EF0 7000               2164      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002BFE                          2165  PREDEC_JMP:
00002BFE  4EF9 00002C2E           2166      JMP         PREDEC_000 ; -(A0)
00002C04  4EF9 00002C3A           2167      JMP         PREDEC_001 ; -(A1)
00002C0A  4EF9 00002C46           2168      JMP         PREDEC_010 ; -(A2)
00002C10  4EF9 00002C52           2169      JMP         PREDEC_011 ; -(A3)
00002C16  4EF9 00002C5E           2170      JMP         PREDEC_100 ; -(A4)
00002C1C  4EF9 00002C6A           2171      JMP         PREDEC_101 ; -(A5)
00002C22  4EF9 00002C76           2172      JMP         PREDEC_110 ; -(A6)
00002C28  4EF9 00002C82           2173      JMP         PREDEC_111 ; -(A7)
00002C2E                          2174  
00002C2E                          2175  PREDEC_000: ; -(A0)
00002C2E  49F9 00004799           2176      LEA         EA_MSG_A0, A4
00002C34  4EB9 000043D2           2177      JSR         WRITE2MEM
00002C3A                          2178  PREDEC_001: ; -(A1)
00002C3A  49F9 0000479C           2179      LEA         EA_MSG_A1, A4
00002C40  4EB9 000043D2           2180      JSR         WRITE2MEM
00002C46                          2181  PREDEC_010: ; -(A2)
00002C46  49F9 0000479F           2182      LEA         EA_MSG_A2, A4
00002C4C  4EB9 000043D2           2183      JSR         WRITE2MEM
00002C52                          2184  PREDEC_011: ; -(A3)
00002C52  49F9 000047A2           2185      LEA         EA_MSG_A3, A4
00002C58  4EB9 000043D2           2186      JSR         WRITE2MEM
00002C5E                          2187  PREDEC_100: ; -(A4)
00002C5E  49F9 000047A5           2188      LEA         EA_MSG_A4, A4
00002C64  4EB9 000043D2           2189      JSR         WRITE2MEM
00002C6A                          2190  PREDEC_101: ; -(A5)
00002C6A  49F9 000047A8           2191      LEA         EA_MSG_A5, A4
00002C70  4EB9 000043D2           2192      JSR         WRITE2MEM
00002C76                          2193  PREDEC_110: ; -(A6)
00002C76  49F9 000047AB           2194      LEA         EA_MSG_A6, A4
00002C7C  4EB9 000043D2           2195      JSR         WRITE2MEM
00002C82                          2196  PREDEC_111: ; -(A7)
00002C82  49F9 000047AE           2197      LEA         EA_MSG_A7, A4
00002C88  4EB9 000043D2           2198      JSR         WRITE2MEM
00002C8E                          2199  
00002C8E                          2200  EA_PRINT_PD_END:
00002C8E  49F9 000048B1           2201      LEA         CPAREN, A4   ; Print close parentheses
00002C94  4EB9 000043D2           2202      JSR         WRITE2MEM
00002C9A  4E75                    2203      RTS
00002C9C                          2204  EA_PRINT_ABS_L:
00002C9C  224D                    2205      MOVEA.L     A5, A1              ; copy pointer to temp
00002C9E  5489                    2206      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002CA0  2011                    2207      MOVE.L      (A1), D0            ; store longword address to print TODO
00002CA2  4EB8 287E               2208      JSR         EA_PRINT_DATA *print value TODO
00002CA6  5889                    2209      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002CA8  2A49                    2210      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002CAA  4E75                    2211      RTS
00002CAC                          2212  EA_PRINT_ABS_W:
00002CAC  224D                    2213      MOVEA.L     A5, A1              ; copy pointer to temp
00002CAE  5489                    2214      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002CB0  2011                    2215      MOVE.L      (A1), D0            ; store word address to print in TODO
00002CB2  4EB8 287E               2216      JSR         EA_PRINT_DATA *print value TODO
00002CB6  5489                    2217      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002CB8  2A49                    2218      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002CBA  4E75                    2219      RTS
00002CBC                          2220  
00002CBC                          2221  
00002CBC                          2222  -------------------- end include --------------------
00002CBC                          2223  
00002CBC                          2224  EA_ADD:
00002CBC  48E7 FFFC               2225      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002CC0  4EB8 2898               2226      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002CC4  4EB8 28C2               2227      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00002CC8  41F9 00002CD6           2228      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
00002CCE  CCFC 0006               2229      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002CD2  4EF0 6000               2230      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002CD6                          2231  ADD_OPMODE:
00002CD6  4EF9 00002D06           2232      JMP         ADD_OPMODE_000      ; mode 1, byte
00002CDC  4EF9 00002D10           2233      JMP         ADD_OPMODE_001      ; mode 1, word
00002CE2  4EF9 00002D1A           2234      JMP         ADD_OPMODE_010      ; mode 1, long
00002CE8  4EF9 00002D24           2235      JMP         ADD_OPMODE_011      ; Invalid value
00002CEE  4EF9 00002D2E           2236      JMP         ADD_OPMODE_100      ; mode 2, byte
00002CF4  4EF9 00002D38           2237      JMP         ADD_OPMODE_101      ; mode 2, word
00002CFA  4EF9 00002D42           2238      JMP         ADD_OPMODE_110      ; mode 2, long
00002D00  4EF9 00002D4C           2239      JMP         ADD_OPMODE_111      ; Invalid value
00002D06                          2240  ADD_OPMODE_000: ; mode 1, byte
00002D06  1A3C 0001               2241      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002D0A  4EF9 00002D56           2242      JMP         ADD_MODE_1
00002D10                          2243  ADD_OPMODE_001: ; mode 1, word
00002D10  1A3C 0002               2244      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00002D14  4EF9 00002D56           2245      JMP         ADD_MODE_1
00002D1A                          2246  ADD_OPMODE_010: ; mode 1, long
00002D1A  1A3C 0003               2247      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00002D1E  4EF9 00002D56           2248      JMP         ADD_MODE_1
00002D24                          2249  ADD_OPMODE_011: ; Invalid value
00002D24  4EB8 2874               2250      JSR         EA_INVALID
00002D28  4EF9 00002E7C           2251      JMP         ADD_END
00002D2E                          2252  ADD_OPMODE_100: ; mode 2, byte
00002D2E  1A3C 0001               2253      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002D32  4EF9 00002D80           2254      JMP         ADD_MODE_2
00002D38                          2255  ADD_OPMODE_101: ; mode 2, word
00002D38  1A3C 0001               2256      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002D3C  4EF9 00002D80           2257      JMP         ADD_MODE_2
00002D42                          2258  ADD_OPMODE_110: ; mode 2, long
00002D42  1A3C 0001               2259      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002D46  4EF9 00002D80           2260      JMP         ADD_MODE_2
00002D4C                          2261  ADD_OPMODE_111: ; Invalid value
00002D4C  4EB8 2874               2262      JSR         EA_INVALID
00002D50  4EF9 00002E7C           2263      JMP         ADD_END
00002D56                          2264  ADD_MODE_1:
00002D56  4280                    2265      CLR.L       D0                  ; Clear data register 0
00002D58  103C 0001               2266      MOVE.B      #1, D0              ; Save mode number to D0
00002D5C  3207                    2267      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00002D5E  4EB8 289C               2268      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002D62  4EB9 00002DA6           2269      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002D68  49F9 000048AC           2270      LEA         COMMA, A4        ; Print comma
00002D6E  4EB9 000043D2           2271      JSR         WRITE2MEM
00002D74  3E01                    2272      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00002D76  4EB8 28FA               2273      JSR         EA_PRINT_DN         ; Print data register
00002D7A  4EF9 00002E7C           2274      JMP         ADD_END
00002D80                          2275  ADD_MODE_2:
00002D80  4280                    2276      CLR.L       D0                  ; Clear data register 0
00002D82  103C 0002               2277      MOVE.B      #2, D0              ; Save mode number to D0
00002D86  4EB8 28FA               2278      JSR         EA_PRINT_DN         ; Print data register
00002D8A  49F9 000048AC           2279      LEA         COMMA, A4        ; Print comma
00002D90  4EB9 000043D2           2280      JSR         WRITE2MEM
00002D96  4EB8 289C               2281      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002D9A  4EB9 00002DA6           2282      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002DA0  4EF9 00002E7C           2283      JMP         ADD_END
00002DA6                          2284  ADD_EVAL_EA:
00002DA6  41F9 00002DB4           2285      LEA         ADD_MODE, A0        ; Set index '0' for jump table
00002DAC  CCFC 0006               2286      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002DB0  4EF0 6000               2287      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002DB4                          2288  ADD_MODE:
00002DB4  4EF9 00002DE4           2289      JMP         ADD_MODE_000        ; Dn (invalid if opmode 2)
00002DBA  4EF9 00002DF6           2290      JMP         ADD_MODE_001        ; An (invalid if opmode 2)
00002DC0  4EF9 00002E08           2291      JMP         ADD_MODE_010        ; (An)
00002DC6  4EF9 00002E12           2292      JMP         ADD_MODE_011        ; (An)+
00002DCC  4EF9 00002E1C           2293      JMP         ADD_MODE_100        ; -(An)
00002DD2  4EF9 00002E26           2294      JMP         ADD_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00002DD8  4EF9 00002E2C           2295      JMP         ADD_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002DDE  4EF9 00002E32           2296      JMP         ADD_MODE_111        ; The rest (not all valid, validated by register number)
00002DE4                          2297  ADD_MODE_000: ; Dn (invalid if opmode 2)
00002DE4  B07C 0002               2298      CMP         #2, D0
00002DE8  6700 008E               2299      BEQ         ADD_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00002DEC  4EB8 28FA               2300      JSR         EA_PRINT_DN         ; Print data register direct operand
00002DF0  4EF9 00002E76           2301      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002DF6                          2302  ADD_MODE_001: ; An (invalid if opmode 2)
00002DF6  B07C 0002               2303      CMP         #2, D0
00002DFA  6700 007C               2304      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002DFE  4EB8 299A               2305      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002E02  4EF9 00002E76           2306      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E08                          2307  ADD_MODE_010: ; (An)
00002E08  4EB8 2A3A               2308      JSR         EA_PRINT_IND         ; Print address register indirect
00002E0C  4EF9 00002E76           2309      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E12                          2310  ADD_MODE_011: ; (An)+
00002E12  4EB8 2B14               2311      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002E16  4EF9 00002E76           2312      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E1C                          2313  ADD_MODE_100: ; -(An)
00002E1C  4EB8 2BD8               2314      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002E20  4EF9 00002E76           2315      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E26                          2316  ADD_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002E26  4EF9 00002E78           2317      JMP         ADD_MODE_INVALID
00002E2C                          2318  ADD_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002E2C  4EF9 00002E78           2319      JMP         ADD_MODE_INVALID
00002E32                          2320  ADD_MODE_111: ; The rest (not all valid, validated by register number)
00002E32  BE3C 0000               2321      CMP.B       #$00, D7            ; Test for absolute word address
00002E36  6700 0018               2322      BEQ         ADD_ABS_W
00002E3A  BE3C 0001               2323      CMP.B       #$01, D7            ; Test for absolute long address
00002E3E  6700 001A               2324      BEQ         ADD_ABS_L
00002E42  BE3C 0004               2325      CMP.B       #$04, D7            ; Test for immediate data
00002E46  6700 001C               2326      BEQ         ADD_IMM
00002E4A  4EF9 00002E78           2327      JMP         ADD_MODE_INVALID    ; else, invalid
00002E50                          2328  ADD_ABS_W:
00002E50  4EB8 2CAC               2329      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002E54  4EF9 00002E76           2330      JMP         ADD_MODE_END
00002E5A                          2331  ADD_ABS_L:
00002E5A  4EB8 2C9C               2332      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002E5E  4EF9 00002E76           2333      JMP         ADD_MODE_END
00002E64                          2334  ADD_IMM: ; invalid if opmode is 2
00002E64  B07C 0002               2335      CMP         #2, D0
00002E68  6700 000E               2336      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002E6C  4EB8 2AF2               2337      JSR         EA_PRINT_IMM        ; Print immediate data
00002E70  4EF9 00002E76           2338      JMP         ADD_MODE_END
00002E76                          2339  ADD_MODE_END:
00002E76  4E75                    2340      RTS                             ; Finish evaluating EA bits
00002E78                          2341  ADD_MODE_INVALID:
00002E78  4EB8 2874               2342      JSR         EA_INVALID          ; Opcode word is Invalid, then end
00002E7C                          2343  ADD_END:
00002E7C  4EB8 288C               2344      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00002E80  4CDF 3FFF               2345      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002E84  4E75                    2346      RTS
00002E86                          2347  
00002E86                          2348  EA_ADDA:
00002E86  48E7 FFFC               2349      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002E8A  4EB8 2898               2350      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002E8E  4EB8 289C               2351      JSR         EA_DEFAULT_COMBO    ; Mode: D6, register: D7
00002E92  41F9 00002EA0           2352      LEA         ADDA_MODE, A0       ; Set index '0' for jump table
00002E98  CCFC 0006               2353      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002E9C  4EF0 6000               2354      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002EA0                          2355  ADDA_MODE:
00002EA0  4EF9 00002ED0           2356      JMP         ADDA_MODE_000       ; Dn
00002EA6  4EF9 00002EDA           2357      JMP         ADDA_MODE_001       ; An
00002EAC  4EF9 00002EE4           2358      JMP         ADDA_MODE_010       ; (An)
00002EB2  4EF9 00002EEE           2359      JMP         ADDA_MODE_011       ; (An)+
00002EB8  4EF9 00002EF8           2360      JMP         ADDA_MODE_100       ; -(An)
00002EBE  4EF9 00002F02           2361      JMP         ADDA_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00002EC4  4EF9 00002F08           2362      JMP         ADDA_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002ECA  4EF9 00002F0E           2363      JMP         ADDA_MODE_111       ; The rest (not all valid, validated by register number)
00002ED0                          2364  ADDA_MODE_000: ; Dn
00002ED0  4EB8 28FA               2365      JSR         EA_PRINT_DN         ; Print data register direct operand
00002ED4  4EF9 00002F58           2366      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002EDA                          2367  ADDA_MODE_001: ; An
00002EDA  4EB8 299A               2368      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002EDE  4EF9 00002F58           2369      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002EE4                          2370  ADDA_MODE_010: ; (An)
00002EE4  4EB8 2A3A               2371      JSR         EA_PRINT_IND         ; Print address register indirect
00002EE8  4EF9 00002F58           2372      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002EEE                          2373  ADDA_MODE_011: ; (An)+
00002EEE  4EB8 2B14               2374      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002EF2  4EF9 00002F58           2375      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002EF8                          2376  ADDA_MODE_100: ; -(An)
00002EF8  4EB8 2BD8               2377      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002EFC  4EF9 00002F58           2378      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002F02                          2379  ADDA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002F02  4EF9 00002F4E           2380      JMP         ADDA_MODE_INVALID
00002F08                          2381  ADDA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002F08  4EF9 00002F4E           2382      JMP         ADDA_MODE_INVALID
00002F0E                          2383  ADDA_MODE_111: ; The rest (not all valid, validated by register number)
00002F0E  BE3C 0000               2384      CMP.B       #$00, D7            ; Test for absolute word address
00002F12  6700 0018               2385      BEQ         ADDA_ABS_W
00002F16  BE3C 0001               2386      CMP.B       #$01, D7            ; Test for absolute long address
00002F1A  6700 001A               2387      BEQ         ADDA_ABS_L
00002F1E  BE3C 0004               2388      CMP.B       #$04, D7            ; Test for immediate data
00002F22  6700 001C               2389      BEQ         ADDA_IMM
00002F26  4EF9 00002F4E           2390      JMP         ADDA_MODE_INVALID   ; Else, invalid
00002F2C                          2391  ADDA_ABS_W:
00002F2C  4EB8 2CAC               2392      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002F30  4EF9 00002F58           2393      JMP         ADDA_MODE_END
00002F36                          2394  ADDA_ABS_L:
00002F36  4EB8 2C9C               2395      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002F3A  4EF9 00002F58           2396      JMP         ADDA_MODE_END
00002F40                          2397  ADDA_IMM:
00002F40  4EB8 28C2               2398      JSR         EA_OPMODE_COMBO     ; Get opmode bits in
00002F44  4EB8 2AF2               2399      JSR         EA_PRINT_IMM        ; Print immediate data
00002F48  4EF9 00002F58           2400      JMP         ADDA_MODE_END
00002F4E                          2401  ADDA_MODE_INVALID:
00002F4E  4EB8 2874               2402      JSR         EA_INVALID          ; Opcode word is Invalid
00002F52  4EF9 00002F6C           2403      JMP         ADDA_END
00002F58                          2404  ADDA_MODE_END:
00002F58  49F9 000048AC           2405      LEA         COMMA, A4        ; Print comma
00002F5E  4EB9 000043D2           2406      JSR         WRITE2MEM
00002F64  4EB8 28C2               2407      JSR         EA_OPMODE_COMBO     ; Opmode: D6, register: D7
00002F68  4EB8 299A               2408      JSR         EA_PRINT_AN         ; Print address register
00002F6C                          2409  ADDA_END:
00002F6C  4EB8 288C               2410      JSR         EA_UPDATE_POINTER   ; Update global pointer
00002F70  4CDF 3FFF               2411      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002F74  4E75                    2412      RTS
00002F76                          2413  
00002F76                          2414  EA_ADDI:
00002F76  48E7 FFFC               2415      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002F7A  4EB8 2898               2416      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002F7E  4EB8 28E8               2417      JSR         EA_SIZE_BITS        ; get size bits in D7
00002F82  BE3C 0000               2418      CMP.B       #$00, D7            ; Test if size: byte
00002F86  6700 001C               2419      BEQ         ADDI_B
00002F8A  BE3C 0001               2420      CMP.B       #$01, D7            ; Test if size: word
00002F8E  6700 002E               2421      BEQ         ADDI_W
00002F92  BE3C 0002               2422      CMP.B       #$02, D7            ; Test if size: long
00002F96  6700 0034               2423      BEQ         ADDI_L
00002F9A  4EB8 2874               2424      JSR         EA_INVALID          ; Else, invalid
00002F9E  4EF9 00003088           2425      JMP         ADDI_END
00002FA4                          2426  ADDI_B:
00002FA4  548D                    2427      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002FA6  4280                    2428      CLR.L       D0
00002FA8  3015                    2429      MOVE.W      (A5), D0            ; read next word in memory and save
00002FAA  143C 0008               2430      MOVE.B      #8, D2              ; Clear upper 8 bits of operand word
00002FAE  E568                    2431      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00002FB0  143C 0008               2432      MOVE.B      #8, D2             ; 'Right-align' bits 0-7 to get value
00002FB4  E468                    2433      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00002FB6                          2434      *print data
00002FB6  548D                    2435      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
00002FB8  4EF9 00002FD2           2436      JMP         ADDI_GET_DEST
00002FBE                          2437  ADDI_W:
00002FBE  548D                    2438      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002FC0  4280                    2439      CLR.L       D0
00002FC2  3015                    2440      MOVE.W      (A5), D0            ; read next word in memory and save
00002FC4                          2441      *print data
00002FC4  548D                    2442      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
00002FC6  4EF9 00002FD2           2443      JMP         ADDI_GET_DEST
00002FCC                          2444  ADDI_L:
00002FCC  548D                    2445      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002FCE  2015                    2446      MOVE.L      (A5), D0            ; read next two words in memory and save
00002FD0  588D                    2447      ADDA.L      #$00000004, A5      ; Increment A5 past operand longword
00002FD2                          2448  ADDI_GET_DEST:
00002FD2                          2449      *PRINT COMMA
00002FD2  4EB8 289C               2450      JSR         EA_DEFAULT_COMBO    ; get mode bits in D6, register bits in D7
00002FD6  41F9 00002FE4           2451      LEA         ADDI_MODE, A0       ; Set index '0' for jump table
00002FDC  CCFC 0006               2452      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002FE0  4EF0 6000               2453      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002FE4                          2454  ADDI_MODE:
00002FE4  4EF9 00003014           2455      JMP         ADDI_MODE_000       ; Dn
00002FEA  4EF9 0000301E           2456      JMP         ADDI_MODE_001       ; Invalid: An
00002FF0  4EF9 00003028           2457      JMP         ADDI_MODE_010       ; (An)
00002FF6  4EF9 00003032           2458      JMP         ADDI_MODE_011       ; (An)+
00002FFC  4EF9 0000303C           2459      JMP         ADDI_MODE_100       ; -(An)
00003002  4EF9 00003046           2460      JMP         ADDI_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00003008  4EF9 00003050           2461      JMP         ADDI_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000300E  4EF9 0000305A           2462      JMP         ADDI_MODE_111       ; The rest (not all valid, validated by register number)
00003014                          2463  ADDI_MODE_000: ; Dn
00003014  4EB8 28FA               2464      JSR         EA_PRINT_DN         ; Print data register direct operand
00003018  4EF9 00003088           2465      JMP         ADDI_END
0000301E                          2466  ADDI_MODE_001: ; Invalid: An
0000301E  4EB8 2874               2467      JSR         EA_INVALID          ; Opcode word is Invalid
00003022  4EF9 00003088           2468      JMP         ADDI_END
00003028                          2469  ADDI_MODE_010: ; (An)
00003028  4EB8 2A3A               2470      JSR         EA_PRINT_IND         ; Print address register indirect
0000302C  4EF9 00003088           2471      JMP         ADDI_END            ; End evaluation of ea mode
00003032                          2472  ADDI_MODE_011: ; (An)+
00003032  4EB8 2B14               2473      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003036  4EF9 00003088           2474      JMP         ADDI_END            ; End evaluation of ea mode
0000303C                          2475  ADDI_MODE_100: ; -(An)
0000303C  4EB8 2BD8               2476      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003040  4EF9 00003088           2477      JMP         ADDI_END            ; End evaluation of ea mode
00003046                          2478  ADDI_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003046  4EB8 2874               2479      JSR         EA_INVALID          ; Opcode word is Invalid
0000304A  4EF9 00003088           2480      JMP         ADDI_END
00003050                          2481  ADDI_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003050  4EB8 2874               2482      JSR         EA_INVALID          ; Opcode word is Invalid
00003054  4EF9 00003088           2483      JMP         ADDI_END
0000305A                          2484  ADDI_MODE_111: ; The rest (not all valid, validated by register number)
0000305A  BE3C 0000               2485      CMP.B       #$00, D7            ; Test for absolute word address
0000305E  6700 0014               2486      BEQ         ADDI_ABS_W
00003062  BE3C 0001               2487      CMP.B       #$01, D7            ; Test for absolute long address
00003066  6700 0016               2488      BEQ         ADDI_ABS_L
0000306A  4EB8 2874               2489      JSR         EA_INVALID          ; else, invalid
0000306E  4EF9 00003088           2490      JMP         ADDI_END
00003074                          2491  ADDI_ABS_W:
00003074  4EB8 2CAC               2492      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003078  4EF9 00003088           2493      JMP         ADDI_END
0000307E                          2494  ADDI_ABS_L:
0000307E  4EB8 2C9C               2495      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003082  4EF9 00003088           2496      JMP         ADDI_END
00003088                          2497  ADDI_END:
00003088  4EB8 288C               2498      JSR         EA_UPDATE_POINTER   ; Update global pointer
0000308C  4CDF 3FFF               2499      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003090  4E75                    2500      RTS
00003092                          2501  EA_ADDQ:
00003092  48E7 FFFC               2502      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003096  4EB8 2898               2503      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000309A  2216                    2504      MOVE.L      (A6), D1            ; Load opcode to data register 1
0000309C  143C 0004               2505      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
000030A0  E569                    2506      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000030A2  143C 000D               2507      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine mode bits
000030A6  E469                    2508      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000030A8  B23C 0000               2509      CMP.B       #$00, D1            ; Check for special case (if imm. data is 0, value is actually 8)
000030AC  6600 0006               2510      BNE         ADDQ_PRINT_IMM      ; If any value other than 0, print the data
000030B0  123C 0008               2511      MOVE.B      #$08, D1            ; Else, the value is 0 and therefore symbolic of the value 8, so replace with the value 8
000030B4                          2512  ADDQ_PRINT_IMM:
000030B4  49F9 000048A6           2513      LEA         POUND, A4         ; Print '#'
000030BA  4EB9 000043D2           2514      JSR         WRITE2MEM
000030C0  4EB8 287E               2515      JSR         EA_PRINT_DATA
000030C4  49F9 000048AC           2516      LEA         COMMA, A4        ; Print comma
000030CA  4EB9 000043D2           2517      JSR         WRITE2MEM
000030D0  4EB8 289C               2518      JSR         EA_DEFAULT_COMBO
000030D4  41F9 000030E2           2519      LEA         ADDQ_MODE, A0       ; Set index '0' for jump table
000030DA  CCFC 0006               2520      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000030DE  4EF0 6000               2521      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000030E2                          2522  ADDQ_MODE:
000030E2  4EF9 00003112           2523      JMP         ADDQ_MODE_000       ; Dn
000030E8  4EF9 0000311C           2524      JMP         ADDQ_MODE_001       ; An
000030EE  4EF9 00003126           2525      JMP         ADDQ_MODE_010       ; (An)
000030F4  4EF9 00003130           2526      JMP         ADDQ_MODE_011       ; (An)+
000030FA  4EF9 0000313A           2527      JMP         ADDQ_MODE_100       ; -(An)
00003100  4EF9 00003144           2528      JMP         ADDQ_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00003106  4EF9 0000314E           2529      JMP         ADDQ_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000310C  4EF9 00003158           2530      JMP         ADDQ_MODE_111       ; The rest (not all valid, validated by register number)
00003112                          2531  ADDQ_MODE_000: ; Dn
00003112  4EB8 28FA               2532      JSR         EA_PRINT_DN         ; Print data register direct operand
00003116  4EF9 00003186           2533      JMP         ADDQ_END            ; End evaluation of ea mode
0000311C                          2534  ADDQ_MODE_001: ; An
0000311C  4EB8 299A               2535      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00003120  4EF9 00003186           2536      JMP         ADDQ_END            ; End evaluation of ea mode
00003126                          2537  ADDQ_MODE_010: ; (An)
00003126  4EB8 2A3A               2538      JSR         EA_PRINT_IND         ; Print address register indirect
0000312A  4EF9 00003186           2539      JMP         ADDQ_END            ; End evaluation of ea mode
00003130                          2540  ADDQ_MODE_011: ; (An)+
00003130  4EB8 2B14               2541      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003134  4EF9 00003186           2542      JMP         ADDQ_END            ; End evaluation of ea mode
0000313A                          2543  ADDQ_MODE_100: ; -(An)
0000313A  4EB8 2BD8               2544      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000313E  4EF9 00003186           2545      JMP         ADDQ_END            ; End evaluation of ea mode
00003144                          2546  ADDQ_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003144  4EB8 2874               2547      JSR         EA_INVALID          ; Opcode word is Invalid
00003148  4EF9 00003186           2548      JMP         ADDQ_END
0000314E                          2549  ADDQ_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000314E  4EB8 2874               2550      JSR         EA_INVALID          ; Opcode word is Invalid
00003152  4EF9 00003186           2551      JMP         ADDQ_END
00003158                          2552  ADDQ_MODE_111: ; The rest (not all valid, validated by register number)
00003158  BE3C 0000               2553      CMP.B       #$00, D7            ; Test for absolute word address
0000315C  6700 0014               2554      BEQ         ADDQ_ABS_W
00003160  BE3C 0001               2555      CMP.B       #$01, D7            ; Test for absolute long address
00003164  6700 0016               2556      BEQ         ADDQ_ABS_L
00003168  4EB8 2874               2557      JSR         EA_INVALID          ; Opcode word is Invalid
0000316C  4EF9 00003186           2558      JMP         ADDQ_END
00003172                          2559  ADDQ_ABS_W:
00003172  4EB8 2CAC               2560      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003176  4EF9 00003186           2561      JMP         ADDQ_END
0000317C                          2562  ADDQ_ABS_L:
0000317C  4EB8 2C9C               2563      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003180  4EF9 00003186           2564      JMP         ADDQ_END
00003186                          2565  
00003186                          2566  ADDQ_END:
00003186  4EB8 288C               2567      JSR         EA_UPDATE_POINTER   ; Update global pointer
0000318A  4CDF 3FFF               2568      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000318E  4E75                    2569      RTS
00003190                          2570  EA_AND:
00003190  48E7 FFFC               2571      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003194  4EB8 2898               2572      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003198  4EB8 28C2               2573      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
0000319C  41F8 2CD6               2574      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
000031A0  CCFC 0006               2575      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000031A4  4EF0 6000               2576      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000031A8                          2577  AND_OPMODE:
000031A8  4EF9 000031D8           2578      JMP         AND_OPMODE_000      ; mode 1, byte
000031AE  4EF9 000031E2           2579      JMP         AND_OPMODE_001      ; mode 1, word
000031B4  4EF9 000031EC           2580      JMP         AND_OPMODE_010      ; mode 1, long
000031BA  4EF9 000031F6           2581      JMP         AND_OPMODE_011      ; Invalid value
000031C0  4EF9 00003200           2582      JMP         AND_OPMODE_100      ; mode 2, byte
000031C6  4EF9 0000320A           2583      JMP         AND_OPMODE_101      ; mode 2, word
000031CC  4EF9 00003214           2584      JMP         AND_OPMODE_110      ; mode 2, long
000031D2  4EF9 0000321E           2585      JMP         AND_OPMODE_111      ; Invalid value
000031D8                          2586  AND_OPMODE_000: ; mode 1, byte
000031D8  1A3C 0001               2587      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
000031DC  4EF9 00003228           2588      JMP         AND_MODE_1
000031E2                          2589  AND_OPMODE_001: ; mode 1, word
000031E2  1A3C 0002               2590      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
000031E6  4EF9 00003228           2591      JMP         AND_MODE_1
000031EC                          2592  AND_OPMODE_010: ; mode 1, long
000031EC  1A3C 0003               2593      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
000031F0  4EF9 00003228           2594      JMP         AND_MODE_1
000031F6                          2595  AND_OPMODE_011: ; Invalid value
000031F6  4EB8 2874               2596      JSR         EA_INVALID
000031FA  4EF9 00003342           2597      JMP         AND_END
00003200                          2598  AND_OPMODE_100: ; mode 2, byte
00003200  1A3C 0001               2599      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003204  4EF9 00003252           2600      JMP         AND_MODE_2
0000320A                          2601  AND_OPMODE_101: ; mode 2, word
0000320A  1A3C 0001               2602      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000320E  4EF9 00003252           2603      JMP         AND_MODE_2
00003214                          2604  AND_OPMODE_110: ; mode 2, long
00003214  1A3C 0001               2605      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003218  4EF9 00003252           2606      JMP         AND_MODE_2
0000321E                          2607  AND_OPMODE_111: ; Invalid value
0000321E  4EB8 2874               2608      JSR         EA_INVALID
00003222  4EF9 00003342           2609      JMP         AND_END
00003228                          2610  AND_MODE_1:
00003228  4280                    2611      CLR.L       D0                  ; Clear data register 0
0000322A  103C 0001               2612      MOVE.B      #1, D0              ; Save mode number to D0
0000322E  3207                    2613      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003230  4EB8 289C               2614      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003234  4EB9 00003278           2615      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
0000323A  49F9 000048AC           2616      LEA         COMMA, A4        ; Print comma
00003240  4EB9 000043D2           2617      JSR         WRITE2MEM
00003246  3E01                    2618      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003248  4EB8 28FA               2619      JSR         EA_PRINT_DN         ; Print data register
0000324C  4EF9 00003342           2620      JMP         AND_END
00003252                          2621  AND_MODE_2:
00003252  4280                    2622      CLR.L       D0                  ; Clear data register 0
00003254  103C 0002               2623      MOVE.B      #2, D0              ; Save mode number to D0
00003258  4EB8 28FA               2624      JSR         EA_PRINT_DN         ; Print data register
0000325C  49F9 000048AC           2625      LEA         COMMA, A4        ; Print comma
00003262  4EB9 000043D2           2626      JSR         WRITE2MEM
00003268  4EB8 289C               2627      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
0000326C  4EB9 00003278           2628      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
00003272  4EF9 00003342           2629      JMP         AND_END
00003278                          2630  AND_EVAL_EA:
00003278  41F9 00003286           2631      LEA         AND_MODE, A0        ; Set index '0' for jump table
0000327E  CCFC 0006               2632      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003282  4EF0 6000               2633      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003286                          2634  AND_MODE:
00003286  4EF9 000032B6           2635      JMP         AND_MODE_000        ; Dn (invalid if opmode 2)
0000328C  4EF9 000032C8           2636      JMP         AND_MODE_001        ; Invalid: An
00003292  4EF9 000032CE           2637      JMP         AND_MODE_010        ; (An)
00003298  4EF9 000032D8           2638      JMP         AND_MODE_011        ; (An)+
0000329E  4EF9 000032E2           2639      JMP         AND_MODE_100        ; -(An)
000032A4  4EF9 000032EC           2640      JMP         AND_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000032AA  4EF9 000032F2           2641      JMP         AND_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000032B0  4EF9 000032F8           2642      JMP         AND_MODE_111        ; The rest (not all valid, validated by register number)
000032B6                          2643  AND_MODE_000: ; Dn (invalid if opmode 2)
000032B6  B07C 0002               2644      CMP         #2, D0
000032BA  6700 0082               2645      BEQ         AND_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
000032BE  4EB8 28FA               2646      JSR         EA_PRINT_DN         ; Print data register direct operand
000032C2  4EF9 0000333C           2647      JMP         AND_MODE_END        ; End evaluation of ea mode
000032C8                          2648  AND_MODE_001: ; Invalid: An
000032C8  4EF9 0000333E           2649      JMP         AND_MODE_INVALID
000032CE                          2650  AND_MODE_010: ; (An)
000032CE  4EB8 2A3A               2651      JSR         EA_PRINT_IND         ; Print address register indirect
000032D2  4EF9 0000333C           2652      JMP         AND_MODE_END        ; End evaluation of ea mode
000032D8                          2653  AND_MODE_011: ; (An)+
000032D8  4EB8 2B14               2654      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000032DC  4EF9 0000333C           2655      JMP         AND_MODE_END        ; End evaluation of ea mode
000032E2                          2656  AND_MODE_100: ; -(An)
000032E2  4EB8 2BD8               2657      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000032E6  4EF9 0000333C           2658      JMP         AND_MODE_END        ; End evaluation of ea mode
000032EC                          2659  AND_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000032EC  4EF9 0000333E           2660      JMP         AND_MODE_INVALID
000032F2                          2661  AND_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000032F2  4EF9 0000333E           2662      JMP         AND_MODE_INVALID
000032F8                          2663  AND_MODE_111: ; The rest (not all valid, validated by register number)
000032F8  BE3C 0000               2664      CMP.B       #$00, D7            ; Test for absolute word address
000032FC  6700 0018               2665      BEQ         AND_ABS_W
00003300  BE3C 0001               2666      CMP.B       #$01, D7            ; Test for absolute long address
00003304  6700 001A               2667      BEQ         AND_ABS_L
00003308  BE3C 0004               2668      CMP.B       #$04, D7            ; Test for immediate data
0000330C  6700 001C               2669      BEQ         AND_IMM
00003310  4EF9 0000333E           2670      JMP         AND_MODE_INVALID    ; else, invalid
00003316                          2671  AND_ABS_W:
00003316  4EB8 2CAC               2672      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000331A  4EF9 0000333C           2673      JMP         AND_MODE_END
00003320                          2674  AND_ABS_L:
00003320  4EB8 2C9C               2675      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003324  4EF9 0000333C           2676      JMP         AND_MODE_END
0000332A                          2677  AND_IMM: ; invalid if opmode is 2
0000332A  B07C 0002               2678      CMP         #2, D0
0000332E  6700 000E               2679      BEQ         AND_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00003332  4EB8 2AF2               2680      JSR         EA_PRINT_IMM        ; Print immediate data
00003336  4EF9 0000333C           2681      JMP         AND_MODE_END
0000333C                          2682  AND_MODE_END:
0000333C  4E75                    2683      RTS                             ; Finish evaluating EA bits
0000333E                          2684  AND_MODE_INVALID:
0000333E  4EB8 2874               2685      JSR         EA_INVALID          ; Opcode word is Invalid, continue to end
00003342                          2686  AND_END:
00003342  4EB8 288C               2687      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003346  4CDF 3FFF               2688      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000334A  4E75                    2689      RTS
0000334C                          2690  EA_ASd:
0000334C  48E7 FFFC               2691      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003350  4EB8 2898               2692      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003354  4EB8 28E8               2693      JSR         EA_SIZE_BITS        ; get size bits in D7
00003358  BE3C 0003               2694      CMP.B       #$03, D7            ; test if memory shift
0000335C  6700 005E               2695      BEQ         ASd_MEM
00003360  6000 0002               2696      BRA         ASd_REG             ; else, register shfit
00003364                          2697  ASd_REG:
00003364  3E16                    2698      MOVE.W      (A6), D7            ; read opcode word in memory and save,
00003366                          2699                                      ; (using D7 because EA_PRINT_DN uses D7)
00003366  143C 0004               2700      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
0000336A  E56F                    2701      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
0000336C  143C 000D               2702      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
00003370  E46F                    2703      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003372  3016                    2704      MOVE.W      (A6), D0            ; read opcode word in memory and save
00003374  143C 000A               2705      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
00003378  E568                    2706      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
0000337A  143C 000F               2707      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
0000337E  E468                    2708      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00003380  B03C 0000               2709      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
00003384  6700 000C               2710      BEQ         ASd_REG_COUNT
00003388                          2711  ASd_REG_REG:                        ; Else, count/register field contains register number
00003388  4EB8 28FA               2712      JSR         EA_PRINT_DN         ; Print register value, stored in D7
0000338C  4EF9 000033A2           2713      JMP         ASd_REG_END         ; Jump to end of ASd_REG
00003392                          2714  ASd_REG_COUNT:
00003392  49F9 000048A6           2715      LEA         POUND, A4        ; Print '#'
00003398  4EB9 000043D2           2716      JSR         WRITE2MEM
0000339E  4EB8 287E               2717      JSR         EA_PRINT_DATA *print hex value in D7 as byte todo, continue on to ASd_REG_END
000033A2                          2718  ASd_REG_END:
000033A2  49F9 000048AC           2719      LEA         COMMA, A4        ; Print comma
000033A8  4EB9 000043D2           2720      JSR         WRITE2MEM
000033AE  4EB8 289C               2721      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
000033B2  4EB8 28FA               2722      JSR         EA_PRINT_DN         ; Print register value in D7
000033B6  4EF9 00003472           2723      JMP         ASd_END
000033BC                          2724  ASd_MEM:
000033BC  4EB8 289C               2725      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000033C0  41F9 000033CE           2726      LEA         ASd_MEM_MODE, A0    ; Set index '0' for jump table
000033C6  CCFC 0006               2727      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000033CA  4EF0 6000               2728      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000033CE                          2729  ASd_MEM_MODE:
000033CE  4EF9 000033FE           2730      JMP         ASd_MEM_MODE_000     ; Invalid: Dn
000033D4  4EF9 00003408           2731      JMP         ASd_MEM_MODE_001     ; Invalid: An
000033DA  4EF9 00003412           2732      JMP         ASd_MEM_MODE_010     ; (An)
000033E0  4EF9 0000341C           2733      JMP         ASd_MEM_MODE_011     ; (An)+
000033E6  4EF9 00003426           2734      JMP         ASd_MEM_MODE_100     ; -(An)
000033EC  4EF9 00003430           2735      JMP         ASd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
000033F2  4EF9 0000343A           2736      JMP         ASd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000033F8  4EF9 00003444           2737      JMP         ASd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
000033FE                          2738  ASd_MEM_MODE_000: ; Invalid: Dn
000033FE  4EB8 2874               2739      JSR         EA_INVALID          ; Data register direct is invalid mode
00003402  4EF9 00003472           2740      JMP         ASd_END
00003408                          2741  ASd_MEM_MODE_001: ; Invalid: An
00003408  4EB8 2874               2742      JSR         EA_INVALID          ; Address register direct is invalid mode
0000340C  4EF9 00003472           2743      JMP         ASd_END
00003412                          2744  ASd_MEM_MODE_010: ; (An)
00003412  4EB8 2A3A               2745      JSR         EA_PRINT_IND         ; Print address register indirect
00003416  4EF9 00003472           2746      JMP         ASd_END
0000341C                          2747  ASd_MEM_MODE_011: ; (An)+
0000341C  4EB8 2B14               2748      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003420  4EF9 00003472           2749      JMP         ASd_END
00003426                          2750  ASd_MEM_MODE_100: ; -(An)
00003426  4EB8 2BD8               2751      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000342A  4EF9 00003472           2752      JMP         ASd_END         ; Continue with parsing destination operand
00003430                          2753  ASd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003430  4EB8 2874               2754      JSR         EA_INVALID          ; Opcode word is Invalid
00003434  4EF9 00003472           2755      JMP         ASd_END
0000343A                          2756  ASd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000343A  4EB8 2874               2757      JSR         EA_INVALID          ; Opcode word is Invalid
0000343E  4EF9 00003472           2758      JMP         ASd_END
00003444                          2759  ASd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
00003444  BE3C 0000               2760      CMP.B       #$00, D7            ; Test for absolute word address
00003448  6700 0014               2761      BEQ         ASd_MEM_ABS_W
0000344C  BE3C 0001               2762      CMP.B       #$01, D7            ; Test for absolute long address
00003450  6700 0016               2763      BEQ         ASd_MEM_ABS_L
00003454  4EB8 2874               2764      JSR         EA_INVALID          ; Else: invalid
00003458  4EF9 00003472           2765      JMP         ASd_END
0000345E                          2766  ASd_MEM_ABS_W:
0000345E  4EB8 2CAC               2767      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003462  4EF9 00003472           2768      JMP         ASd_END
00003468                          2769  ASd_MEM_ABS_L:
00003468  4EB8 2C9C               2770      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000346C  4EF9 00003472           2771      JMP         ASd_END
00003472                          2772  ASd_END:
00003472  4EB8 288C               2773      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003476  4CDF 3FFF               2774      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000347A  4E75                    2775      RTS
0000347C                          2776  EA_Bcc:
0000347C  48E7 FFFC               2777      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003480  4EB8 2898               2778      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003484  2216                    2779      MOVE.L      (A6), D1            ; Load opcode to data register 1
00003486  143C 0008               2780      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
0000348A  E569                    2781      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
0000348C  143C 0008               2782      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine condition
00003490  E469                    2783      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00003492                          2784      *save ultimate address to be printed
00003492  284E                    2785      MOVEA.L     A6, A4              ; Copy global pointer for dislay
00003494  B23C 0000               2786      CMP.B       #$00, D1            ; If value is zero, real value is next word in memory
00003498  6700 0034               2787      BEQ         BCC_W
0000349C  B23C 00FF               2788      CMP.B       #$FF, D1            ; If value is FF, real value is next longword
000034A0  6700 004E               2789      BEQ         BCC_L
000034A4  4EF9 000034AA           2790      JMP         BCC_B               ; Else, parse lower-order byte of opcode word
000034AA                          2791  BCC_B:
000034AA  548C                    2792      ADDA.L      #$00000002, A4      ; Increment display pointer past opcode word
000034AC  3616                    2793      MOVE.W      (A6), D3            ; Save opcode word
000034AE  143C 0008               2794      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
000034B2  E56B                    2795      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
000034B4  143C 000F               2796      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
000034B8  E46B                    2797      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
000034BA  B63C 0000               2798      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
000034BE  6700 003E               2799      BEQ         BCC_DISPLAY
000034C2  0681 FFFFFF00           2800      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
000034C8  4EF9 000034FE           2801      JMP         BCC_DISPLAY
000034CE                          2802  BCC_W:
000034CE  588C                    2803      ADDA.L      #$00000004, A4      ; Increment display pointer past opcode word
000034D0                          2804                                      ; and displacement word in memory
000034D0  548D                    2805      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
000034D2  3615                    2806      MOVE.W      (A5), D3            ; Read word displacement from memory
000034D4  548D                    2807      ADDA.L      #$00000002, A5      ; Increment A5 past word read
000034D6  143C 000F               2808      MOVE.B      #15, D2             ; 'Right-align' bit 15 to determine MSB
000034DA  E46B                    2809      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
000034DC  B63C 0000               2810      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
000034E0  6700 001C               2811      BEQ         BCC_DISPLAY
000034E4  0681 FFFF0000           2812      ADD.L       #$FFFF0000, D1      ; Else, sign extend data with F
000034EA  4EF9 000034FE           2813      JMP         BCC_DISPLAY
000034F0                          2814  BCC_L:
000034F0  5C8C                    2815      ADDA.L      #$00000006, A4      ; Increment display pointer past opcode word
000034F2                          2816                                      ; and displacement longword in memory
000034F2  548D                    2817      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
000034F4  2215                    2818      MOVE.L      (A5), D1            ; Read longword displacement from memory
000034F6  588D                    2819      ADDA.L      #$00000004, A5      ; Increment A5 past longword read
000034F8  4EF9 000034FE           2820      JMP         BCC_DISPLAY
000034FE                          2821  BCC_DISPLAY:
000034FE  D9C1                    2822      ADDA.L      D1, A4              ; add displacement to current addressing
00003500                          2823      *print address in A4
00003500  4EB8 288C               2824      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003504  4CDF 3FFF               2825      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003508  4E75                    2826      RTS
0000350A                          2827  EA_CLR:
0000350A  48E7 FFFC               2828      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000350E  4EB8 2898               2829      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003512  4EB8 289C               2830      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003516  41F9 00003524           2831      LEA         CLR_MODE, A0        ; Set index '0' for jump table
0000351C  CCFC 0006               2832      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003520  4EF0 6000               2833      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003524                          2834  CLR_MODE:
00003524  4EF9 00003554           2835      JMP         CLR_MODE_000        ; Dn
0000352A  4EF9 0000355E           2836      JMP         CLR_MODE_001        ; Invalid: An
00003530  4EF9 00003568           2837      JMP         CLR_MODE_010        ; (An)
00003536  4EF9 00003572           2838      JMP         CLR_MODE_011        ; (An)+
0000353C  4EF9 0000357C           2839      JMP         CLR_MODE_100        ; -(An)
00003542  4EF9 00003586           2840      JMP         CLR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003548  4EF9 00003590           2841      JMP         CLR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000354E  4EF9 0000359A           2842      JMP         CLR_MODE_111        ; The rest (not all valid, validated by register number)
00003554                          2843  CLR_MODE_000: ; Dn
00003554  4EB8 28FA               2844      JSR         EA_PRINT_DN
00003558  4EF9 000035C8           2845      JMP         CLR_END
0000355E                          2846  CLR_MODE_001: ; Invalid: An
0000355E  4EB8 2874               2847      JSR         EA_INVALID          ; Address register direct is invalid mode
00003562  4EF9 000035C8           2848      JMP         CLR_END
00003568                          2849  CLR_MODE_010: ; (An)
00003568  4EB8 2A3A               2850      JSR         EA_PRINT_IND         ; Print address register indirect
0000356C  4EF9 000035C8           2851      JMP         CLR_END
00003572                          2852  CLR_MODE_011: ; (An)+
00003572  4EB8 2B14               2853      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003576  4EF9 000035C8           2854      JMP         CLR_END
0000357C                          2855  CLR_MODE_100: ; -(An)
0000357C  4EB8 2BD8               2856      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003580  4EF9 000035C8           2857      JMP         CLR_END             ; Continue with parsing destination operand
00003586                          2858  CLR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003586  4EB8 2874               2859      JSR         EA_INVALID          ; Opcode word is Invalid
0000358A  4EF9 000035C8           2860      JMP         CLR_END
00003590                          2861  CLR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003590  4EB8 2874               2862      JSR         EA_INVALID          ; Opcode word is Invalid
00003594  4EF9 000035C8           2863      JMP         CLR_END
0000359A                          2864  CLR_MODE_111: ; The rest (not all valid, validated by register number)
0000359A  BE3C 0000               2865      CMP.B       #$00, D7            ; Test for absolute word address
0000359E  6700 0014               2866      BEQ         CLR_ABS_W
000035A2  BE3C 0001               2867      CMP.B       #$01, D7            ; Test for absolute long address
000035A6  6700 0016               2868      BEQ         CLR_ABS_L
000035AA  4EB8 2874               2869      JSR         EA_INVALID          ; Else: invalid
000035AE  4EF9 000035C8           2870      JMP         CLR_END
000035B4                          2871  CLR_ABS_W:
000035B4  4EB8 2CAC               2872      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000035B8  4EF9 000035C8           2873      JMP         CLR_END
000035BE                          2874  CLR_ABS_L:
000035BE  4EB8 2C9C               2875      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000035C2  4EF9 000035C8           2876      JMP         CLR_END
000035C8                          2877  CLR_END:
000035C8  4EB8 288C               2878      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000035CC  4CDF 3FFF               2879      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000035D0  4E75                    2880      RTS
000035D2                          2881  EA_CMP:
000035D2  48E7 FFFC               2882      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000035D6  4EB8 2898               2883      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000035DA  4EB8 289C               2884      JSR         EA_DEFAULT_COMBO
000035DE  41F9 000035EC           2885      LEA         CMP_MODE, A0       ; Set index '0' for jump table
000035E4  CCFC 0006               2886      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000035E8  4EF0 6000               2887      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000035EC                          2888  CMP_MODE:
000035EC  4EF9 0000361C           2889      JMP         CMP_MODE_000       ; Dn
000035F2  4EF9 00003626           2890      JMP         CMP_MODE_001       ; An
000035F8  4EF9 00003630           2891      JMP         CMP_MODE_010       ; (An)
000035FE  4EF9 0000363A           2892      JMP         CMP_MODE_011       ; (An)+
00003604  4EF9 00003644           2893      JMP         CMP_MODE_100       ; -(An)
0000360A  4EF9 0000364E           2894      JMP         CMP_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00003610  4EF9 00003658           2895      JMP         CMP_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003616  4EF9 00003662           2896      JMP         CMP_MODE_111       ; The rest (not all valid, validated by register number)
0000361C                          2897  CMP_MODE_000: ; Dn
0000361C  4EB8 28FA               2898      JSR         EA_PRINT_DN         ; Print data register direct operand
00003620  4EF9 00003690           2899      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003626                          2900  CMP_MODE_001: ; An
00003626  4EB8 299A               2901      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
0000362A  4EF9 00003690           2902      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003630                          2903  CMP_MODE_010: ; (An)
00003630  4EB8 2A3A               2904      JSR         EA_PRINT_IND        ; Print address register indirect
00003634  4EF9 00003690           2905      JMP         CMP_MODE_END        ; End evaluation of ea mode
0000363A                          2906  CMP_MODE_011: ; (An)+
0000363A  4EB8 2B14               2907      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000363E  4EF9 00003690           2908      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003644                          2909  CMP_MODE_100: ; -(An)
00003644  4EB8 2BD8               2910      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003648  4EF9 00003690           2911      JMP         CMP_MODE_END        ; End evaluation of ea mode
0000364E                          2912  CMP_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000364E  4EB8 2874               2913      JSR         EA_INVALID          ; Opcode word is Invalid
00003652  4EF9 000036A4           2914      JMP         CMP_END
00003658                          2915  CMP_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003658  4EB8 2874               2916      JSR         EA_INVALID          ; Opcode word is Invalid
0000365C  4EF9 000036A4           2917      JMP         CMP_END
00003662                          2918  CMP_MODE_111: ; The rest (not all valid, validated by register number)
00003662  BE3C 0000               2919      CMP.B       #$00, D7            ; Test for absolute word address
00003666  6700 0014               2920      BEQ         CMP_ABS_W
0000366A  BE3C 0001               2921      CMP.B       #$01, D7            ; Test for absolute long address
0000366E  6700 0016               2922      BEQ         CMP_ABS_L
00003672  4EB8 2874               2923      JSR         EA_INVALID          ; Opcode word is Invalid
00003676  4EF9 000036A4           2924      JMP         CMP_END
0000367C                          2925  CMP_ABS_W:
0000367C  4EB8 2CAC               2926      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003680  4EF9 00003690           2927      JMP         CMP_MODE_END
00003686                          2928  CMP_ABS_L:
00003686  4EB8 2C9C               2929      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000368A  4EF9 00003690           2930      JMP         CMP_MODE_END
00003690                          2931  CMP_MODE_END:
00003690  49F9 000048AC           2932      LEA         COMMA, A4        ; Print comma
00003696  4EB9 000043D2           2933      JSR         WRITE2MEM
0000369C  4EB8 28C2               2934      JSR         EA_OPMODE_COMBO     ; get register bits in D7, opmode bits not used
000036A0  4EB8 28FA               2935      JSR         EA_PRINT_DN         ; print register
000036A4                          2936  CMP_END:
000036A4  4EB8 288C               2937      JSR         EA_UPDATE_POINTER   ; Update global pointer
000036A8  4CDF 3FFF               2938      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000036AC  4E75                    2939      RTS
000036AE                          2940  EA_DIVU_W:
000036AE  48E7 FFFC               2941      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000036B2  4EB8 2898               2942      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000036B6  4EB8 289C               2943      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000036BA  41F9 000036C8           2944      LEA         DIVU_W_MODE, A0       ; Set index '0' for jump table
000036C0  CCFC 0006               2945      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000036C4  4EF0 6000               2946      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000036C8                          2947  DIVU_W_MODE:
000036C8  4EF9 000036F8           2948      JMP         DIVU_W_MODE_000     ; Dn
000036CE  4EF9 00003702           2949      JMP         DIVU_W_MODE_001     ; Invalid: An
000036D4  4EF9 0000370C           2950      JMP         DIVU_W_MODE_010     ; (An)
000036DA  4EF9 00003716           2951      JMP         DIVU_W_MODE_011     ; (An)+
000036E0  4EF9 00003720           2952      JMP         DIVU_W_MODE_100     ; -(An)
000036E6  4EF9 0000372A           2953      JMP         DIVU_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
000036EC  4EF9 00003734           2954      JMP         DIVU_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000036F2  4EF9 0000373E           2955      JMP         DIVU_W_MODE_111     ; The rest (not all valid, validated by register number)
000036F8                          2956  DIVU_W_MODE_000: ; Dn
000036F8  4EB8 28FA               2957      JSR         EA_PRINT_DN         ; Print data register direct operand
000036FC  4EF9 00003782           2958      JMP         DIVU_W_DEST         ; Go to: print destination operand
00003702                          2959  DIVU_W_MODE_001: ; Invalid: An
00003702  4EB8 2874               2960      JSR         EA_INVALID          ; Address register direct is invalid mode
00003706  4EF9 00003794           2961      JMP         DIVU_W_END
0000370C                          2962  DIVU_W_MODE_010: ; (An)
0000370C  4EB8 2A3A               2963      JSR         EA_PRINT_IND         ; Print address register indirect
00003710  4EF9 00003782           2964      JMP         DIVU_W_DEST
00003716                          2965  DIVU_W_MODE_011: ; (An)+
00003716  4EB8 2B14               2966      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000371A  4EF9 00003782           2967      JMP         DIVU_W_DEST
00003720                          2968  DIVU_W_MODE_100: ; -(An)
00003720  4EB8 2BD8               2969      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003724  4EF9 00003782           2970      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
0000372A                          2971  DIVU_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000372A  4EB8 2874               2972      JSR         EA_INVALID          ; Opcode word is Invalid
0000372E  4EF9 00003794           2973      JMP         DIVU_W_END
00003734                          2974  DIVU_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003734  4EB8 2874               2975      JSR         EA_INVALID          ; Opcode word is Invalid
00003738  4EF9 00003794           2976      JMP         DIVU_W_END
0000373E                          2977  DIVU_W_MODE_111: ; The rest (not all valid, validated by register number)
0000373E  BE3C 0000               2978      CMP.B       #$00, D7            ; Test for absolute word address
00003742  6700 001C               2979      BEQ         DIVU_W_ABS_W
00003746  BE3C 0001               2980      CMP.B       #$01, D7            ; Test for absolute long address
0000374A  6700 001E               2981      BEQ         DIVU_W_ABS_L
0000374E  BE3C 0004               2982      CMP.B       #$04, D7            ; Test for immediate data
00003752  6700 0020               2983      BEQ         DIVU_W_IMM
00003756  4EB8 2874               2984      JSR         EA_INVALID          ; Else: invalid
0000375A  4EF9 00003794           2985      JMP         DIVU_W_END
00003760                          2986  DIVU_W_ABS_W:
00003760  4EB8 2CAC               2987      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003764  4EF9 00003782           2988      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
0000376A                          2989  DIVU_W_ABS_L:
0000376A  4EB8 2C9C               2990      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000376E  4EF9 00003782           2991      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
00003774                          2992  DIVU_W_IMM:
00003774  1A3C 0002               2993      MOVE.B      #2, D5              ; Size is word
00003778  4EB8 2AF2               2994      JSR         EA_PRINT_IMM        ; Print immediate data
0000377C  4EF9 00003782           2995      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
00003782                          2996  DIVU_W_DEST:
00003782                          2997      *print COMMA
00003782                          2998      *Get destination register
00003782  3E16                    2999      MOVE.W      (A6), D7            ; Load word at current pointer to D1
00003784  143C 0004               3000      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00003788  E56F                    3001      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
0000378A  143C 000D               3002      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
0000378E  E46F                    3003      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003790  4EB8 28FA               3004      JSR         EA_PRINT_DN         ; Print data register direct operand
00003794                          3005  DIVU_W_END:
00003794  4EB8 288C               3006      JSR         EA_UPDATE_POINTER   ; Update global pointer
00003798  4CDF 3FFF               3007      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000379C  4E75                    3008      RTS
0000379E                          3009  EA_JSR:
0000379E  48E7 FFFC               3010      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000037A2  4EB8 2898               3011      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000037A6  4EB8 289C               3012      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000037AA  41F9 000037B8           3013      LEA         JSR_MODE, A0        ; Set index '0' for jump table
000037B0  CCFC 0006               3014      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000037B4  4EF0 6000               3015      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000037B8                          3016  JSR_MODE:
000037B8  4EF9 000037E8           3017      JMP         JSR_MODE_000        ; Invalid: Dn
000037BE  4EF9 000037F2           3018      JMP         JSR_MODE_001        ; Invalid: An
000037C4  4EF9 000037FC           3019      JMP         JSR_MODE_010        ; (An)
000037CA  4EF9 00003806           3020      JMP         JSR_MODE_011        ; Invalid: (An)+
000037D0  4EF9 00003810           3021      JMP         JSR_MODE_100        ; Invalid: -(An)
000037D6  4EF9 0000381A           3022      JMP         JSR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000037DC  4EF9 00003824           3023      JMP         JSR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000037E2  4EF9 0000382E           3024      JMP         JSR_MODE_111        ; The rest (not all valid, validated by register number)
000037E8                          3025  JSR_MODE_000: ; Invalid: Dn
000037E8  4EB8 2874               3026      JSR         EA_INVALID          ; Data register direct is invalid mode
000037EC  4EF9 0000385C           3027      JMP         JSR_END
000037F2                          3028  JSR_MODE_001: ; Invalid: An
000037F2  4EB8 2874               3029      JSR         EA_INVALID          ; Address register direct is invalid mode
000037F6  4EF9 0000385C           3030      JMP         JSR_END
000037FC                          3031  JSR_MODE_010: ; (An)
000037FC  4EB8 2A3A               3032      JSR         EA_PRINT_IND         ; Print address register indirect
00003800  4EF9 0000385C           3033      JMP         JSR_END
00003806                          3034  JSR_MODE_011: ; (An)+
00003806  4EB8 2874               3035      JSR         EA_INVALID          ; Address register indirect w/ post increment is invalid mode
0000380A  4EF9 0000385C           3036      JMP         JSR_END
00003810                          3037  JSR_MODE_100: ; -(An)
00003810  4EB8 2874               3038      JSR         EA_INVALID          ; Address register indirect w/ pre decrement is invalid mode
00003814  4EF9 0000385C           3039      JMP         JSR_END
0000381A                          3040  JSR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000381A  4EB8 2874               3041      JSR         EA_INVALID          ; Opcode word is Invalid
0000381E  4EF9 0000385C           3042      JMP         JSR_END
00003824                          3043  JSR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003824  4EB8 2874               3044      JSR         EA_INVALID          ; Opcode word is Invalid
00003828  4EF9 0000385C           3045      JMP         JSR_END
0000382E                          3046  JSR_MODE_111: ; The rest (not all valid, validated by register number)
0000382E  BE3C 0000               3047      CMP.B       #$00, D7            ; Test for absolute word address
00003832  6700 0014               3048      BEQ         JSR_ABS_W
00003836  BE3C 0001               3049      CMP.B       #$01, D7            ; Test for absolute long address
0000383A  6700 0016               3050      BEQ         JSR_ABS_L
0000383E  4EB8 2874               3051      JSR         EA_INVALID          ; Else: invalid
00003842  4EF9 0000385C           3052      JMP         JSR_END
00003848                          3053  JSR_ABS_W:
00003848  4EB8 2CAC               3054      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000384C  4EF9 0000385C           3055      JMP         JSR_END
00003852                          3056  JSR_ABS_L:
00003852  4EB8 2C9C               3057      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003856  4EF9 0000385C           3058      JMP         JSR_END
0000385C                          3059  JSR_END:
0000385C  4EB8 288C               3060      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003860  4CDF 3FFF               3061      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003864  4E75                    3062      RTS
00003866                          3063  EA_LEA:
00003866  48E7 FFFC               3064      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000386A  4EB8 2898               3065      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
0000386E  4EB8 289C               3066      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003872  41F9 00003880           3067      LEA         LEA_MODE, A0        ; Set index '0' for jump table
00003878  CCFC 0006               3068      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000387C  4EF0 6000               3069      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003880                          3070  LEA_MODE:
00003880  4EF9 000038B0           3071      JMP         LEA_MODE_000        ; Dn
00003886  4EF9 000038BA           3072      JMP         LEA_MODE_001        ; Invalid: An
0000388C  4EF9 000038C4           3073      JMP         LEA_MODE_010        ; (An)
00003892  4EF9 000038CE           3074      JMP         LEA_MODE_011        ; (An)+
00003898  4EF9 000038D8           3075      JMP         LEA_MODE_100        ; -(An)
0000389E  4EF9 000038E2           3076      JMP         LEA_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000038A4  4EF9 000038EC           3077      JMP         LEA_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000038AA  4EF9 000038F6           3078      JMP         LEA_MODE_111        ; The rest (not all valid, validated by register number)
000038B0                          3079  LEA_MODE_000: ; Invalid: Dn
000038B0  4EB8 2874               3080      JSR         EA_INVALID          ; Data register direct is invalid mode
000038B4  4EF9 00003938           3081      JMP         LEA_END
000038BA                          3082  LEA_MODE_001: ; Invalid: An
000038BA  4EB8 2874               3083      JSR         EA_INVALID          ; Address register direct is invalid mode
000038BE  4EF9 00003938           3084      JMP         LEA_END
000038C4                          3085  LEA_MODE_010: ; (An)
000038C4  4EB8 2A3A               3086      JSR         EA_PRINT_IND         ; Print address register indirect
000038C8  4EF9 00003924           3087      JMP         LEA_DEST
000038CE                          3088  LEA_MODE_011: ; (An)+
000038CE  4EB8 2874               3089      JSR         EA_INVALID          ; Address register indirect with post increment is invalid
000038D2  4EF9 00003938           3090      JMP         LEA_END
000038D8                          3091  LEA_MODE_100: ; -(An)
000038D8  4EB8 2874               3092      JSR         EA_INVALID          ; Adress register indirect with pre decrement is invalid
000038DC  4EF9 00003938           3093      JMP         LEA_END             ; Continue with parsing destination operand
000038E2                          3094  LEA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000038E2  4EB8 2874               3095      JSR         EA_INVALID          ; Opcode word is Invalid
000038E6  4EF9 00003938           3096      JMP         LEA_END
000038EC                          3097  LEA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000038EC  4EB8 2874               3098      JSR         EA_INVALID          ; Opcode word is Invalid
000038F0  4EF9 00003938           3099      JMP         LEA_END
000038F6                          3100  LEA_MODE_111: ; The rest (not all valid, validated by register number)
000038F6  BE3C 0000               3101      CMP.B       #$00, D7            ; Test for absolute word address
000038FA  6700 0014               3102      BEQ         LEA_ABS_W
000038FE  BE3C 0001               3103      CMP.B       #$01, D7            ; Test for absolute long address
00003902  6700 0016               3104      BEQ         LEA_ABS_L
00003906  4EB8 2874               3105      JSR         EA_INVALID          ; Else: invalid
0000390A  4EF9 00003924           3106      JMP         LEA_DEST
00003910                          3107  LEA_ABS_W:
00003910  4EB8 2CAC               3108      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003914  4EF9 00003924           3109      JMP         LEA_DEST
0000391A                          3110  LEA_ABS_L:
0000391A  4EB8 2C9C               3111      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000391E  4EF9 00003924           3112      JMP         LEA_DEST
00003924                          3113  LEA_DEST:
00003924  49F9 000048AC           3114      LEA         COMMA, A4        ; Print comma
0000392A  4EB9 000043D2           3115      JSR         WRITE2MEM
00003930  4EB8 28C2               3116      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, opmode bits unused
00003934  4EB8 299A               3117      JSR         EA_PRINT_AN         ; Print address register
00003938                          3118  LEA_END:
00003938  4EB8 288C               3119      JSR         EA_UPDATE_POINTER   ; Updates global pointer
0000393C  4CDF 3FFF               3120      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003940  4E75                    3121      RTS
00003942                          3122  EA_LSd:
00003942  48E7 FFFC               3123      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003946  4EB8 2898               3124      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000394A  4EB8 28E8               3125      JSR         EA_SIZE_BITS        ; get size bits in D7
0000394E  BE3C 0003               3126      CMP.B       #$03, D7            ; test if memory shift
00003952  6700 005E               3127      BEQ         LSd_MEM
00003956  6000 0002               3128      BRA         LSd_REG             ; else, register shfit
0000395A                          3129  LSd_REG:
0000395A  3E16                    3130      MOVE.W      (A6), D7            ; read opcode word in memory and save,
0000395C                          3131                                      ; (using D7 because EA_PRINT_DN uses D7)
0000395C  143C 0004               3132      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
00003960  E56F                    3133      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003962  143C 000D               3134      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
00003966  E46F                    3135      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003968  3016                    3136      MOVE.W      (A6), D0            ; read opcode word in memory and save
0000396A  143C 000A               3137      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
0000396E  E568                    3138      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00003970  143C 000F               3139      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
00003974  E468                    3140      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00003976  B03C 0000               3141      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
0000397A  6700 000C               3142      BEQ         LSd_REG_COUNT
0000397E                          3143  LSd_REG_REG:                        ; Else, count/register field contains register number
0000397E  4EB8 28FA               3144      JSR         EA_PRINT_DN         ; Print register value, stored in D7
00003982  4EF9 00003998           3145      JMP         LSd_REG_END         ; Jump to end of LSd_REG
00003988                          3146  LSd_REG_COUNT:
00003988  49F9 000048A6           3147      LEA         POUND, A4         ; Print '#'
0000398E  4EB9 000043D2           3148      JSR         WRITE2MEM
00003994  4EB8 287E               3149      JSR         EA_PRINT_DATA  *print hex value in D7 as byte todo, continue on to LSd_REG_END
00003998                          3150  LSd_REG_END:
00003998  49F9 000048AC           3151      LEA         COMMA, A4        ; Print comma
0000399E  4EB9 000043D2           3152      JSR         WRITE2MEM
000039A4  4EB8 289C               3153      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
000039A8  4EB8 28FA               3154      JSR         EA_PRINT_DN         ; Print register value in D7
000039AC  4EF9 00003A68           3155      JMP         LSd_END
000039B2                          3156  LSd_MEM:
000039B2  4EB8 289C               3157      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000039B6  41F9 000039C4           3158      LEA         LSd_MEM_MODE, A0    ; Set index '0' for jump table
000039BC  CCFC 0006               3159      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000039C0  4EF0 6000               3160      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000039C4                          3161  LSd_MEM_MODE:
000039C4  4EF9 000039F4           3162      JMP         LSd_MEM_MODE_000     ; Invalid: Dn
000039CA  4EF9 000039FE           3163      JMP         LSd_MEM_MODE_001     ; Invalid: An
000039D0  4EF9 00003A08           3164      JMP         LSd_MEM_MODE_010     ; (An)
000039D6  4EF9 00003A12           3165      JMP         LSd_MEM_MODE_011     ; (An)+
000039DC  4EF9 00003A1C           3166      JMP         LSd_MEM_MODE_100     ; -(An)
000039E2  4EF9 00003A26           3167      JMP         LSd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
000039E8  4EF9 00003A30           3168      JMP         LSd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000039EE  4EF9 00003A3A           3169      JMP         LSd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
000039F4                          3170  LSd_MEM_MODE_000: ; Invalid: Dn
000039F4  4EB8 2874               3171      JSR         EA_INVALID          ; Data register direct is invalid mode
000039F8  4EF9 00003A68           3172      JMP         LSd_END
000039FE                          3173  LSd_MEM_MODE_001: ; Invalid: An
000039FE  4EB8 2874               3174      JSR         EA_INVALID          ; Address register direct is invalid mode
00003A02  4EF9 00003A68           3175      JMP         LSd_END
00003A08                          3176  LSd_MEM_MODE_010: ; (An)
00003A08  4EB8 2A3A               3177      JSR         EA_PRINT_IND         ; Print address register indirect
00003A0C  4EF9 00003A68           3178      JMP         LSd_END
00003A12                          3179  LSd_MEM_MODE_011: ; (An)+
00003A12  4EB8 2B14               3180      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003A16  4EF9 00003A68           3181      JMP         LSd_END
00003A1C                          3182  LSd_MEM_MODE_100: ; -(An)
00003A1C  4EB8 2BD8               3183      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003A20  4EF9 00003A68           3184      JMP         LSd_END         ; Continue with parsing destination operand
00003A26                          3185  LSd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003A26  4EB8 2874               3186      JSR         EA_INVALID          ; Opcode word is Invalid
00003A2A  4EF9 00003A68           3187      JMP         LSd_END
00003A30                          3188  LSd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A30  4EB8 2874               3189      JSR         EA_INVALID          ; Opcode word is Invalid
00003A34  4EF9 00003A68           3190      JMP         LSd_END
00003A3A                          3191  LSd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
00003A3A  BE3C 0000               3192      CMP.B       #$00, D7            ; Test for absolute word address
00003A3E  6700 0014               3193      BEQ         LSd_MEM_ABS_W
00003A42  BE3C 0001               3194      CMP.B       #$01, D7            ; Test for absolute long address
00003A46  6700 0016               3195      BEQ         LSd_MEM_ABS_L
00003A4A  4EB8 2874               3196      JSR         EA_INVALID          ; Else: invalid
00003A4E  4EF9 00003A68           3197      JMP         LSd_END
00003A54                          3198  LSd_MEM_ABS_W:
00003A54  4EB8 2CAC               3199      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003A58  4EF9 00003A68           3200      JMP         LSd_END
00003A5E                          3201  LSd_MEM_ABS_L:
00003A5E  4EB8 2C9C               3202      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003A62  4EF9 00003A68           3203      JMP         LSd_END
00003A68                          3204  LSd_END:
00003A68  4EB8 288C               3205      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003A6C  4CDF 3FFF               3206      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003A70  4E75                    3207      RTS
00003A72                          3208  EA_MOVE:
00003A72  48E7 FFFC               3209      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003A76  4EB8 2898               3210      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003A7A  2A16                    3211      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
00003A7C  143C 0002               3212      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
00003A80  E56D                    3213      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
00003A82  143C 000E               3214      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
00003A86  E46D                    3215      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
00003A88  BA3C 0003               3216      CMP.B       #$03, D5            ; if size bits are 11, correct D5
00003A8C                          3217                                      ; to 10 for use with immediate data subroutine
00003A8C  6700 0010               3218      BEQ         MOVE_ADJUST_W
00003A90  BA3C 0002               3219      CMP.B       #$02, D5            ; if size bits are 10, correct D5
00003A94                          3220                                      ; to 11 for use with immediate data subroutine
00003A94  6700 0012               3221      BEQ         MOVE_ADJUST_L
00003A98  4EF9 00003AB2           3222      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003A9E                          3223  MOVE_ADJUST_W:
00003A9E  1A3C 0002               3224      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
00003AA2  4EF9 00003AB2           3225      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003AA8                          3226  MOVE_ADJUST_L:
00003AA8  1A3C 0003               3227      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
00003AAC  4EF9 00003AB2           3228      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003AB2                          3229  MOVE_SOURCE:
00003AB2  4EB8 289C               3230      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003AB6  41F9 00003AC4           3231      LEA         MOVE_SRC_MODE, A0   ; Set index '0' for jump table
00003ABC  CCFC 0006               3232      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003AC0  4EF0 6000               3233      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003AC4                          3234  MOVE_SRC_MODE:
00003AC4  4EF9 00003AF4           3235      JMP         MOVE_SRC_MODE_000   ; Dn
00003ACA  4EF9 00003AFE           3236      JMP         MOVE_SRC_MODE_001   ; An
00003AD0  4EF9 00003B08           3237      JMP         MOVE_SRC_MODE_010   ; (An)
00003AD6  4EF9 00003B12           3238      JMP         MOVE_SRC_MODE_011   ; (An)+
00003ADC  4EF9 00003B1C           3239      JMP         MOVE_SRC_MODE_100   ; -(An)
00003AE2  4EF9 00003B26           3240      JMP         MOVE_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003AE8  4EF9 00003B30           3241      JMP         MOVE_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003AEE  4EF9 00003B3A           3242      JMP         MOVE_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003AF4                          3243  MOVE_SRC_MODE_000: ; Dn
00003AF4  4EB8 28FA               3244      JSR         EA_PRINT_DN         ; Print data register in D7
00003AF8  4EF9 00003B7A           3245      JMP         MOVE_DESTINATION
00003AFE                          3246  MOVE_SRC_MODE_001: ; Invalid: An
00003AFE  4EB8 299A               3247      JSR         EA_PRINT_AN         ; Print address register in D7
00003B02  4EF9 00003B7A           3248      JMP         MOVE_DESTINATION
00003B08                          3249  MOVE_SRC_MODE_010: ; (An)
00003B08  4EB8 2A3A               3250      JSR         EA_PRINT_IND         ; Print address register indirect
00003B0C  4EF9 00003B7A           3251      JMP         MOVE_DESTINATION
00003B12                          3252  MOVE_SRC_MODE_011: ; (An)+
00003B12  4EB8 2B14               3253      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003B16  4EF9 00003B7A           3254      JMP         MOVE_DESTINATION
00003B1C                          3255  MOVE_SRC_MODE_100: ; -(An)
00003B1C  4EB8 2BD8               3256      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003B20  4EF9 00003B7A           3257      JMP         MOVE_DESTINATION    ; Continue with parsing destination operand
00003B26                          3258  MOVE_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003B26  4EB8 2874               3259      JSR         EA_INVALID          ; Opcode word is Invalid
00003B2A  4EF9 00003C3C           3260      JMP         MOVE_END
00003B30                          3261  MOVE_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003B30  4EB8 2874               3262      JSR         EA_INVALID          ; Opcode word is Invalid
00003B34  4EF9 00003C3C           3263      JMP         MOVE_END
00003B3A                          3264  MOVE_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003B3A  BE3C 0000               3265      CMP.B       #$00, D7            ; Test for absolute word address
00003B3E  6700 001C               3266      BEQ         MOVE_SRC_ABS_W
00003B42  BE3C 0001               3267      CMP.B       #$01, D7            ; Test for absolute long address
00003B46  6700 001E               3268      BEQ         MOVE_SRC_ABS_L
00003B4A  BE3C 0004               3269      CMP.B       #$04, D7            ; Test for immediate data
00003B4E  6700 0020               3270      BEQ         MOVE_SRC_IMM
00003B52  4EB8 2874               3271      JSR         EA_INVALID          ; Else: invalid
00003B56  4EF9 00003C3C           3272      JMP         MOVE_END
00003B5C                          3273  MOVE_SRC_ABS_W:
00003B5C  4EB8 2CAC               3274      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003B60  4EF9 00003B7A           3275      JMP         MOVE_DESTINATION
00003B66                          3276  MOVE_SRC_ABS_L:
00003B66  4EB8 2C9C               3277      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003B6A  4EF9 00003B7A           3278      JMP         MOVE_DESTINATION
00003B70                          3279  MOVE_SRC_IMM:
00003B70  4EB8 2AF2               3280      JSR         EA_PRINT_IMM        ; Print immediate data
00003B74  4EF9 00003B7A           3281      JMP         MOVE_DESTINATION
00003B7A                          3282  MOVE_DESTINATION:
00003B7A  49F9 000048AC           3283      LEA         COMMA, A4        ; Print comma
00003B80  4EB9 000043D2           3284      JSR         WRITE2MEM
00003B86  4EB8 28C2               3285      JSR         EA_OPMODE_COMBO     ; mode: D6, register: D7 (destination bits)
00003B8A  41F9 00003B98           3286      LEA         MOVE_DST_MODE, A0   ; Set index '0' for jump table
00003B90  CCFC 0006               3287      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003B94  4EF0 6000               3288      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003B98                          3289  MOVE_DST_MODE:
00003B98  4EF9 00003BC8           3290      JMP         MOVE_DST_MODE_000   ; Dn
00003B9E  4EF9 00003BD2           3291      JMP         MOVE_DST_MODE_001   ; Invalid: An
00003BA4  4EF9 00003BDC           3292      JMP         MOVE_DST_MODE_010   ; (An)
00003BAA  4EF9 00003BE6           3293      JMP         MOVE_DST_MODE_011   ; (An)+
00003BB0  4EF9 00003BF0           3294      JMP         MOVE_DST_MODE_100   ; -(An)
00003BB6  4EF9 00003BFA           3295      JMP         MOVE_DST_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003BBC  4EF9 00003C04           3296      JMP         MOVE_DST_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003BC2  4EF9 00003C0E           3297      JMP         MOVE_DST_MODE_111   ; The rest (not all valid, validated by register number)
00003BC8                          3298  MOVE_DST_MODE_000: ; Dn
00003BC8  4EB8 28FA               3299      JSR         EA_PRINT_DN         ; Print data register in D7
00003BCC  4EF9 00003C3C           3300      JMP         MOVE_END
00003BD2                          3301  MOVE_DST_MODE_001: ; Invalid: An
00003BD2  4EB8 2874               3302      JSR         EA_INVALID          ; Print address register in D7
00003BD6  4EF9 00003C3C           3303      JMP         MOVE_END
00003BDC                          3304  MOVE_DST_MODE_010: ; (An)
00003BDC  4EB8 2A3A               3305      JSR         EA_PRINT_IND         ; Print address register indirect
00003BE0  4EF9 00003C3C           3306      JMP         MOVE_END
00003BE6                          3307  MOVE_DST_MODE_011: ; (An)+
00003BE6  4EB8 2B14               3308      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003BEA  4EF9 00003C3C           3309      JMP         MOVE_END
00003BF0                          3310  MOVE_DST_MODE_100: ; -(An)
00003BF0  4EB8 2BD8               3311      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003BF4  4EF9 00003C3C           3312      JMP         MOVE_END    ; Continue with parsing destination operand
00003BFA                          3313  MOVE_DST_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003BFA  4EB8 2874               3314      JSR         EA_INVALID          ; Opcode word is Invalid
00003BFE  4EF9 00003C3C           3315      JMP         MOVE_END
00003C04                          3316  MOVE_DST_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003C04  4EB8 2874               3317      JSR         EA_INVALID          ; Opcode word is Invalid
00003C08  4EF9 00003C3C           3318      JMP         MOVE_END
00003C0E                          3319  MOVE_DST_MODE_111: ; The rest (not all valid, validated by register number)
00003C0E  BE3C 0000               3320      CMP.B       #$00, D7            ; Test for absolute word address
00003C12  6700 0014               3321      BEQ         MOVE_DST_ABS_W
00003C16  BE3C 0001               3322      CMP.B       #$01, D7            ; Test for absolute long address
00003C1A  6700 0016               3323      BEQ         MOVE_DST_ABS_L
00003C1E  4EB8 2874               3324      JSR         EA_INVALID          ; Else: invalid
00003C22  4EF9 00003C3C           3325      JMP         MOVE_END
00003C28                          3326  MOVE_DST_ABS_W:
00003C28  4EB8 2CAC               3327      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003C2C  4EF9 00003C3C           3328      JMP         MOVE_END
00003C32                          3329  MOVE_DST_ABS_L:
00003C32  4EB8 2C9C               3330      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003C36  4EF9 00003C3C           3331      JMP         MOVE_END
00003C3C                          3332  MOVE_END:
00003C3C  4EB8 288C               3333      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003C40  4CDF 3FFF               3334      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003C44  4E75                    3335      RTS
00003C46                          3336  EA_MOVEA:
00003C46  48E7 FFFC               3337      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003C4A  4EB8 2898               3338      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003C4E  2A16                    3339      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
00003C50  143C 0002               3340      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
00003C54  E56D                    3341      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
00003C56  143C 000E               3342      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
00003C5A  E46D                    3343      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
00003C5C  BA3C 0003               3344      CMP.B       #$03, D5            ; if size bits are 11, correct D5
00003C60                          3345                                      ; to 10 for use with immediate data subroutine
00003C60  6700 0010               3346      BEQ         MOVEA_ADJUST_W
00003C64  BA3C 0002               3347      CMP.B       #$02, D5            ; if size bits are 10, correct D5
00003C68                          3348                                      ; to 11 for use with immediate data subroutine
00003C68  6700 0012               3349      BEQ         MOVEA_ADJUST_L
00003C6C  4EF9 00003C86           3350      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003C72                          3351  MOVEA_ADJUST_W:
00003C72  1A3C 0002               3352      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
00003C76  4EF9 00003C86           3353      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003C7C                          3354  MOVEA_ADJUST_L:
00003C7C  1A3C 0003               3355      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
00003C80  4EF9 00003C86           3356      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003C86                          3357  MOVEA_SOURCE:
00003C86  4EB8 289C               3358      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003C8A  41F9 00003C98           3359      LEA         MOVEA_SRC_MODE, A0   ; Set index '0' for jump table
00003C90  CCFC 0006               3360      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003C94  4EF0 6000               3361      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003C98                          3362  MOVEA_SRC_MODE:
00003C98  4EF9 00003CC8           3363      JMP         MOVEA_SRC_MODE_000   ; Dn
00003C9E  4EF9 00003CD2           3364      JMP         MOVEA_SRC_MODE_001   ; An
00003CA4  4EF9 00003CDC           3365      JMP         MOVEA_SRC_MODE_010   ; (An)
00003CAA  4EF9 00003CE6           3366      JMP         MOVEA_SRC_MODE_011   ; (An)+
00003CB0  4EF9 00003CF0           3367      JMP         MOVEA_SRC_MODE_100   ; -(An)
00003CB6  4EF9 00003CFA           3368      JMP         MOVEA_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003CBC  4EF9 00003D04           3369      JMP         MOVEA_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003CC2  4EF9 00003D0E           3370      JMP         MOVEA_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003CC8                          3371  MOVEA_SRC_MODE_000: ; Dn
00003CC8  4EB8 28FA               3372      JSR         EA_PRINT_DN         ; Print data register in D7
00003CCC  4EF9 00003D4E           3373      JMP         MOVEA_DESTINATION
00003CD2                          3374  MOVEA_SRC_MODE_001: ; Invalid: An
00003CD2  4EB8 299A               3375      JSR         EA_PRINT_AN         ; Print address register in D7
00003CD6  4EF9 00003D4E           3376      JMP         MOVEA_DESTINATION
00003CDC                          3377  MOVEA_SRC_MODE_010: ; (An)
00003CDC  4EB8 2A3A               3378      JSR         EA_PRINT_IND         ; Print address register indirect
00003CE0  4EF9 00003D4E           3379      JMP         MOVEA_DESTINATION
00003CE6                          3380  MOVEA_SRC_MODE_011: ; (An)+
00003CE6  4EB8 2B14               3381      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003CEA  4EF9 00003D4E           3382      JMP         MOVEA_DESTINATION
00003CF0                          3383  MOVEA_SRC_MODE_100: ; -(An)
00003CF0  4EB8 2BD8               3384      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003CF4  4EF9 00003D4E           3385      JMP         MOVEA_DESTINATION    ; Continue with parsing destination operand
00003CFA                          3386  MOVEA_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003CFA  4EB8 2874               3387      JSR         EA_INVALID          ; Opcode word is Invalid
00003CFE  4EF9 00003D62           3388      JMP         MOVEA_END
00003D04                          3389  MOVEA_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003D04  4EB8 2874               3390      JSR         EA_INVALID          ; Opcode word is Invalid
00003D08  4EF9 00003D62           3391      JMP         MOVEA_END
00003D0E                          3392  MOVEA_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003D0E  BE3C 0000               3393      CMP.B       #$00, D7            ; Test for absolute word address
00003D12  6700 001C               3394      BEQ         MOVEA_SRC_ABS_W
00003D16  BE3C 0001               3395      CMP.B       #$01, D7            ; Test for absolute long address
00003D1A  6700 001E               3396      BEQ         MOVEA_SRC_ABS_L
00003D1E  BE3C 0004               3397      CMP.B       #$04, D7            ; Test for immediate data
00003D22  6700 0020               3398      BEQ         MOVEA_SRC_IMM
00003D26  4EB8 2874               3399      JSR         EA_INVALID          ; Else: invalid
00003D2A  4EF9 00003D62           3400      JMP         MOVEA_END
00003D30                          3401  MOVEA_SRC_ABS_W:
00003D30  4EB8 2CAC               3402      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003D34  4EF9 00003D4E           3403      JMP         MOVEA_DESTINATION
00003D3A                          3404  MOVEA_SRC_ABS_L:
00003D3A  4EB8 2C9C               3405      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003D3E  4EF9 00003D4E           3406      JMP         MOVEA_DESTINATION
00003D44                          3407  MOVEA_SRC_IMM:
00003D44  4EB8 2AF2               3408      JSR         EA_PRINT_IMM        ; Print immediate data
00003D48  4EF9 00003D4E           3409      JMP         MOVEA_DESTINATION
00003D4E                          3410  MOVEA_DESTINATION:
00003D4E  49F9 000048AC           3411      LEA         COMMA, A4        ; Print comma
00003D54  4EB9 000043D2           3412      JSR         WRITE2MEM
00003D5A  4EB8 28C2               3413      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003D5E  4EB8 299A               3414      JSR         EA_PRINT_AN         ; Print address register, continue to end
00003D62                          3415  MOVEA_END:
00003D62  4EB8 288C               3416      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003D66  4CDF 3FFF               3417      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003D6A  4E75                    3418      RTS
00003D6C                          3419  EA_MOVEM:
00003D6C                          3420      *seems complicated, todo
00003D6C  4EB8 2864               3421      JSR         EA_UNIMPLEMENTED
00003D70  4E75                    3422      RTS
00003D72                          3423  EA_MOVEQ:
00003D72  48E7 FFFC               3424      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003D76  4EB8 2898               3425      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003D7A  2216                    3426      MOVE.L      (A6), D1            ; Load opcode to data register 1
00003D7C  143C 0008               3427      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003D80  E569                    3428      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00003D82  143C 0008               3429      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine data bits
00003D86  E469                    3430      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00003D88  2616                    3431      MOVE.L      (A6), D3            ; Save mode bits to D6
00003D8A  143C 0008               3432      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003D8E  E56B                    3433      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
00003D90  143C 000F               3434      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
00003D94  E46B                    3435      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003D96  B63C 0000               3436      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003D9A  6700 0008               3437      BEQ         MOVEQ_PRINT_DATA
00003D9E  0681 FFFFFF00           3438      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
00003DA4                          3439  MOVEQ_PRINT_DATA:
00003DA4  49F9 000048A6           3440      LEA         POUND, A4         ; Print '#'
00003DAA  4EB9 000043D2           3441      JSR         WRITE2MEM
00003DB0  4EB8 287E               3442      JSR         EA_PRINT_DATA *print data todo
00003DB4  49F9 000048AC           3443      LEA         COMMA, A4        ; Print comma
00003DBA  4EB9 000043D2           3444      JSR         WRITE2MEM
00003DC0  4EB8 28C2               3445      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003DC4  4EB8 28FA               3446      JSR         EA_PRINT_DN         ; Print data register
00003DC8  4EB8 288C               3447      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003DCC  4CDF 3FFF               3448      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003DD0  4E75                    3449      RTS
00003DD2                          3450  EA_MULS_W:
00003DD2  48E7 FFFC               3451      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003DD6  4EB8 2898               3452      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003DDA  4EB8 289C               3453      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003DDE  41F9 00003DEC           3454      LEA         MULS_W_MODE, A0     ; Set index '0' for jump table
00003DE4  CCFC 0006               3455      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003DE8  4EF0 6000               3456      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003DEC                          3457  MULS_W_MODE:
00003DEC  4EF9 00003E1C           3458      JMP         MULS_W_MODE_000     ; Dn
00003DF2  4EF9 00003E26           3459      JMP         MULS_W_MODE_001     ; Invalid: An
00003DF8  4EF9 00003E30           3460      JMP         MULS_W_MODE_010     ; (An)
00003DFE  4EF9 00003E3A           3461      JMP         MULS_W_MODE_011     ; (An)+
00003E04  4EF9 00003E44           3462      JMP         MULS_W_MODE_100     ; -(An)
00003E0A  4EF9 00003E4E           3463      JMP         MULS_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003E10  4EF9 00003E58           3464      JMP         MULS_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E16  4EF9 00003E62           3465      JMP         MULS_W_MODE_111     ; The rest (not all valid, validated by register number)
00003E1C                          3466  MULS_W_MODE_000: ; Dn
00003E1C  4EB8 28FA               3467      JSR         EA_PRINT_DN         ; Print data register direct operand
00003E20  4EF9 00003EA6           3468      JMP         MULS_W_DEST         ; Go to: print destination operand
00003E26                          3469  MULS_W_MODE_001: ; Invalid: An
00003E26  4EB8 2874               3470      JSR         EA_INVALID          ; Address register direct is invalid mode
00003E2A  4EF9 00003EB8           3471      JMP         MULS_W_END
00003E30                          3472  MULS_W_MODE_010: ; (An)
00003E30  4EB8 2A3A               3473      JSR         EA_PRINT_IND         ; Print address register indirect
00003E34  4EF9 00003EA6           3474      JMP         MULS_W_DEST
00003E3A                          3475  MULS_W_MODE_011: ; (An)+
00003E3A  4EB8 2B14               3476      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003E3E  4EF9 00003EA6           3477      JMP         MULS_W_DEST
00003E44                          3478  MULS_W_MODE_100: ; -(An)
00003E44  4EB8 2BD8               3479      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003E48  4EF9 00003EA6           3480      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003E4E                          3481  MULS_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003E4E  4EB8 2874               3482      JSR         EA_INVALID          ; Opcode word is Invalid
00003E52  4EF9 00003EB8           3483      JMP         MULS_W_END
00003E58                          3484  MULS_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E58  4EB8 2874               3485      JSR         EA_INVALID          ; Opcode word is Invalid
00003E5C  4EF9 00003EB8           3486      JMP         MULS_W_END
00003E62                          3487  MULS_W_MODE_111: ; The rest (not all valid, validated by register number)
00003E62  BE3C 0000               3488      CMP.B       #$00, D7            ; Test for absolute word address
00003E66  6700 001C               3489      BEQ         MULS_W_ABS_W
00003E6A  BE3C 0001               3490      CMP.B       #$01, D7            ; Test for absolute long address
00003E6E  6700 001E               3491      BEQ         MULS_W_ABS_L
00003E72  BE3C 0004               3492      CMP.B       #$04, D7            ; Test for immediate data
00003E76  6700 0020               3493      BEQ         MULS_W_IMM
00003E7A  4EB8 2874               3494      JSR         EA_INVALID          ; Else: invalid
00003E7E  4EF9 00003EB8           3495      JMP         MULS_W_END
00003E84                          3496  MULS_W_ABS_W:
00003E84  4EB8 2CAC               3497      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003E88  4EF9 00003EA6           3498      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003E8E                          3499  MULS_W_ABS_L:
00003E8E  4EB8 2C9C               3500      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003E92  4EF9 00003EA6           3501      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003E98                          3502  MULS_W_IMM:
00003E98  1A3C 0002               3503      MOVE.B      #2, D5              ; Size is word
00003E9C  4EB8 2AF2               3504      JSR         EA_PRINT_IMM        ; Print immediate data
00003EA0  4EF9 00003EA6           3505      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003EA6                          3506  MULS_W_DEST:
00003EA6                          3507      *print COMMA
00003EA6                          3508      *Get destination register
00003EA6  3E16                    3509      MOVE.W      (A6), D7            ; Load word at current pointer to D1
00003EA8  143C 0004               3510      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00003EAC  E56F                    3511      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003EAE  143C 000D               3512      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
00003EB2  E46F                    3513      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003EB4  4EB8 28FA               3514      JSR         EA_PRINT_DN         ; Print data register direct operand
00003EB8                          3515  MULS_W_END:
00003EB8  4EB8 288C               3516      JSR         EA_UPDATE_POINTER   ; Update global pointer
00003EBC  4CDF 3FFF               3517      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003EC0  4E75                    3518      RTS
00003EC2                          3519  
00003EC2                          3520  EA_OR:
00003EC2  48E7 FFFC               3521      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003EC6  4EB8 2898               3522      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003ECA  4EB8 28C2               3523      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00003ECE  41F9 00003EDC           3524      LEA         OR_OPMODE, A0       ; Set index '0' for jump table
00003ED4  CCFC 0006               3525      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003ED8  4EF0 6000               3526      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003EDC                          3527  OR_OPMODE:
00003EDC  4EF9 00003F0C           3528      JMP         OR_OPMODE_000       ; mode 1, byte
00003EE2  4EF9 00003F16           3529      JMP         OR_OPMODE_001       ; mode 1, word
00003EE8  4EF9 00003F20           3530      JMP         OR_OPMODE_010       ; mode 1, long
00003EEE  4EF9 00003F2A           3531      JMP         OR_OPMODE_011       ; Invalid value
00003EF4  4EF9 00003F34           3532      JMP         OR_OPMODE_100       ; mode 2, byte
00003EFA  4EF9 00003F3E           3533      JMP         OR_OPMODE_101       ; mode 2, word
00003F00  4EF9 00003F48           3534      JMP         OR_OPMODE_110       ; mode 2, long
00003F06  4EF9 00003F52           3535      JMP         OR_OPMODE_111       ; Invalid value
00003F0C                          3536  OR_OPMODE_000: ; mode 1, byte
00003F0C  1A3C 0001               3537      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F10  4EF9 00003F5C           3538      JMP         OR_MODE_1
00003F16                          3539  OR_OPMODE_001: ; mode 1, word
00003F16  1A3C 0002               3540      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00003F1A  4EF9 00003F5C           3541      JMP         OR_MODE_1
00003F20                          3542  OR_OPMODE_010: ; mode 1, long
00003F20  1A3C 0003               3543      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00003F24  4EF9 00003F5C           3544      JMP         OR_MODE_1
00003F2A                          3545  OR_OPMODE_011: ; Invalid value
00003F2A  4EB8 2874               3546      JSR         EA_INVALID
00003F2E  4EF9 0000407A           3547      JMP         OR_END
00003F34                          3548  OR_OPMODE_100: ; mode 2, byte
00003F34  1A3C 0001               3549      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F38  4EF9 00003F86           3550      JMP         OR_MODE_2
00003F3E                          3551  OR_OPMODE_101: ; mode 2, word
00003F3E  1A3C 0001               3552      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F42  4EF9 00003F86           3553      JMP         OR_MODE_2
00003F48                          3554  OR_OPMODE_110: ; mode 2, long
00003F48  1A3C 0001               3555      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F4C  4EF9 00003F86           3556      JMP         OR_MODE_2
00003F52                          3557  OR_OPMODE_111: ; Invalid value
00003F52  4EB8 2874               3558      JSR         EA_INVALID
00003F56  4EF9 0000407A           3559      JMP         OR_END
00003F5C                          3560  OR_MODE_1:
00003F5C  4280                    3561      CLR.L       D0                  ; Clear data register 0
00003F5E  103C 0001               3562      MOVE.B      #1, D0              ; Save mode number to D0
00003F62  3207                    3563      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003F64  4EB8 289C               3564      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003F68  4EB9 00003FAC           3565      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
00003F6E  49F9 000048AC           3566      LEA         COMMA, A4        ; Print comma
00003F74  4EB9 000043D2           3567      JSR         WRITE2MEM
00003F7A  3E01                    3568      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003F7C  4EB8 28FA               3569      JSR         EA_PRINT_DN         ; Print data register
00003F80  4EF9 0000407A           3570      JMP         OR_END
00003F86                          3571  OR_MODE_2:
00003F86  4280                    3572      CLR.L       D0                  ; Clear data register 0
00003F88  103C 0002               3573      MOVE.B      #2, D0              ; Save mode number to D0
00003F8C  4EB8 28FA               3574      JSR         EA_PRINT_DN         ; Print data register
00003F90  49F9 000048AC           3575      LEA         COMMA, A4        ; Print comma
00003F96  4EB9 000043D2           3576      JSR         WRITE2MEM
00003F9C  4EB8 289C               3577      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003FA0  4EB9 00003FAC           3578      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
00003FA6  4EF9 0000407A           3579      JMP         OR_END
00003FAC                          3580  OR_EVAL_EA:
00003FAC  41F9 00003FBA           3581      LEA         OR_MODE, A0         ; Set index '0' for jump table
00003FB2  CCFC 0006               3582      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003FB6  4EF0 6000               3583      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003FBA                          3584  OR_MODE:
00003FBA  4EF9 00003FEA           3585      JMP         OR_MODE_000         ; Invalid: Dn
00003FC0  4EF9 00003FF4           3586      JMP         OR_MODE_001         ; An (invalid if opmode 2)
00003FC6  4EF9 00004006           3587      JMP         OR_MODE_010         ; (An)
00003FCC  4EF9 00004010           3588      JMP         OR_MODE_011         ; (An)+
00003FD2  4EF9 0000401A           3589      JMP         OR_MODE_100         ; -(An)
00003FD8  4EF9 00004024           3590      JMP         OR_MODE_101         ; Invalid: Address Register Indirect with Displacement Mode
00003FDE  4EF9 0000402A           3591      JMP         OR_MODE_110         ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003FE4  4EF9 00004030           3592      JMP         OR_MODE_111         ; The rest (not all valid, validated by register number)
00003FEA                          3593  OR_MODE_000: ; Invalid: Dn
00003FEA  4EB8 2874               3594      JSR         EA_INVALID          ; Invalid for both opmodes
00003FEE  4EF9 00004074           3595      JMP         OR_MODE_END         ; End evaluation of ea mode
00003FF4                          3596  OR_MODE_001: ; An (invalid if opmode 2)
00003FF4  B07C 0002               3597      CMP         #2, D0
00003FF8  6700 007C               3598      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
00003FFC  4EB8 299A               3599      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00004000  4EF9 00004074           3600      JMP         OR_MODE_END         ; End evaluation of ea mode
00004006                          3601  OR_MODE_010: ; (An)
00004006  4EB8 2A3A               3602      JSR         EA_PRINT_IND         ; Print address register indirect
0000400A  4EF9 00004074           3603      JMP         OR_MODE_END         ; End evaluation of ea mode
00004010                          3604  OR_MODE_011: ; (An)+
00004010  4EB8 2B14               3605      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00004014  4EF9 00004074           3606      JMP         OR_MODE_END         ; End evaluation of ea mode
0000401A                          3607  OR_MODE_100: ; -(An)
0000401A  4EB8 2BD8               3608      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000401E  4EF9 00004074           3609      JMP         OR_MODE_END         ; End evaluation of ea mode
00004024                          3610  OR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00004024  4EF9 00004076           3611      JMP         OR_MODE_INVALID
0000402A                          3612  OR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000402A  4EF9 00004076           3613      JMP         OR_MODE_INVALID
00004030                          3614  OR_MODE_111: ; The rest (not all valid, validated by register number)
00004030  BE3C 0000               3615      CMP.B       #$00, D7            ; Test for absolute word address
00004034  6700 0018               3616      BEQ         OR_ABS_W
00004038  BE3C 0001               3617      CMP.B       #$01, D7            ; Test for absolute long address
0000403C  6700 001A               3618      BEQ         OR_ABS_L
00004040  BE3C 0004               3619      CMP.B       #$04, D7            ; Test for immediate data
00004044  6700 001C               3620      BEQ         OR_IMM
00004048  4EF9 00004076           3621      JMP         OR_MODE_INVALID     ; else, invalid
0000404E                          3622  OR_ABS_W:
0000404E  4EB8 2CAC               3623      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00004052  4EF9 00004074           3624      JMP         OR_MODE_END
00004058                          3625  OR_ABS_L:
00004058  4EB8 2C9C               3626      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000405C  4EF9 00004074           3627      JMP         OR_MODE_END
00004062                          3628  OR_IMM: ; invalid if opmode is 2
00004062  B07C 0002               3629      CMP         #2, D0
00004066  6700 000E               3630      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
0000406A  4EB8 2AF2               3631      JSR         EA_PRINT_IMM        ; Print immediate data
0000406E  4EF9 00004074           3632      JMP         OR_MODE_END
00004074                          3633  OR_MODE_END:
00004074  4E75                    3634      RTS                             ; Finish evaluating EA bits
00004076                          3635  OR_MODE_INVALID:
00004076  4EB8 2874               3636      JSR         EA_INVALID          ; Opcode word is Invalid, continue to end
0000407A                          3637  OR_END:
0000407A  4EB8 288C               3638      JSR         EA_UPDATE_POINTER   ; Updates global pointer
0000407E  4CDF 3FFF               3639      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00004082  4E75                    3640      RTS
00004084                          3641  EA_ROd:
00004084  48E7 FFFC               3642      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00004088  4EB8 2898               3643      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000408C  4EB8 28E8               3644      JSR         EA_SIZE_BITS        ; get size bits in D7
00004090  BE3C 0003               3645      CMP.B       #$03, D7            ; test if memory shift
00004094  6700 005E               3646      BEQ         ROd_MEM
00004098  6000 0002               3647      BRA         ROd_REG             ; else, register shfit
0000409C                          3648  ROd_REG:
0000409C  3E16                    3649      MOVE.W      (A6), D7            ; read opcode word in memory and save,
0000409E                          3650                                      ; (using D7 because EA_PRINT_DN uses D7)
0000409E  143C 0004               3651      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
000040A2  E56F                    3652      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000040A4  143C 000D               3653      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
000040A8  E46F                    3654      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000040AA  3016                    3655      MOVE.W      (A6), D0            ; read opcode word in memory and save
000040AC  143C 000A               3656      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
000040B0  E568                    3657      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
000040B2  143C 000F               3658      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
000040B6  E468                    3659      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
000040B8  B03C 0000               3660      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
000040BC  6700 000C               3661      BEQ         ROd_REG_COUNT
000040C0                          3662  ROd_REG_REG:                        ; Else, count/register field contains register number
000040C0  4EB8 28FA               3663      JSR         EA_PRINT_DN         ; Print register value, stored in D7
000040C4  4EF9 000040DA           3664      JMP         ROd_REG_END         ; Jump to end of ROd_REG
000040CA                          3665  ROd_REG_COUNT:
000040CA  49F9 000048A6           3666      LEA         POUND, A4         ; Print '#'''
000040D0  4EB9 000043D2           3667      JSR         WRITE2MEM
000040D6  4EB8 287E               3668      JSR         EA_PRINT_DATA       *print hex value in D7 as byte todo, continue on to ROd_REG_END
000040DA                          3669  ROd_REG_END:
000040DA  49F9 000048AC           3670      LEA         COMMA, A4        ; Print comma
000040E0  4EB9 000043D2           3671      JSR         WRITE2MEM
000040E6  4EB8 289C               3672      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
000040EA  4EB8 28FA               3673      JSR         EA_PRINT_DN         ; Print register value in D7
000040EE  4EF9 000041AA           3674      JMP         ROd_END
000040F4                          3675  ROd_MEM:
000040F4  4EB8 289C               3676      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000040F8  41F9 00004106           3677      LEA         ROd_MEM_MODE, A0    ; Set index '0' for jump table
000040FE  CCFC 0006               3678      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00004102  4EF0 6000               3679      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00004106                          3680  ROd_MEM_MODE:
00004106  4EF9 00004136           3681      JMP         ROd_MEM_MODE_000     ; Invalid: Dn
0000410C  4EF9 00004140           3682      JMP         ROd_MEM_MODE_001     ; Invalid: An
00004112  4EF9 0000414A           3683      JMP         ROd_MEM_MODE_010     ; (An)
00004118  4EF9 00004154           3684      JMP         ROd_MEM_MODE_011     ; (An)+
0000411E  4EF9 0000415E           3685      JMP         ROd_MEM_MODE_100     ; -(An)
00004124  4EF9 00004168           3686      JMP         ROd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
0000412A  4EF9 00004172           3687      JMP         ROd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004130  4EF9 0000417C           3688      JMP         ROd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00004136                          3689  ROd_MEM_MODE_000: ; Invalid: Dn
00004136  4EB8 2874               3690      JSR         EA_INVALID          ; Data register direct is invalid mode
0000413A  4EF9 000041AA           3691      JMP         ROd_END
00004140                          3692  ROd_MEM_MODE_001: ; Invalid: An
00004140  4EB8 2874               3693      JSR         EA_INVALID          ; Address register direct is invalid mode
00004144  4EF9 000041AA           3694      JMP         ROd_END
0000414A                          3695  ROd_MEM_MODE_010: ; (An)
0000414A  4EB8 2A3A               3696      JSR         EA_PRINT_IND         ; Print address register indirect
0000414E  4EF9 000041AA           3697      JMP         ROd_END
00004154                          3698  ROd_MEM_MODE_011: ; (An)+
00004154  4EB8 2B14               3699      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00004158  4EF9 000041AA           3700      JMP         ROd_END
0000415E                          3701  ROd_MEM_MODE_100: ; -(An)
0000415E  4EB8 2BD8               3702      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00004162  4EF9 000041AA           3703      JMP         ROd_END         ; Continue with parsing destination operand
00004168                          3704  ROd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00004168  4EB8 2874               3705      JSR         EA_INVALID          ; Opcode word is Invalid
0000416C  4EF9 000041AA           3706      JMP         ROd_END
00004172                          3707  ROd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004172  4EB8 2874               3708      JSR         EA_INVALID          ; Opcode word is Invalid
00004176  4EF9 000041AA           3709      JMP         ROd_END
0000417C                          3710  ROd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
0000417C  BE3C 0000               3711      CMP.B       #$00, D7            ; Test for absolute word address
00004180  6700 0014               3712      BEQ         ROd_MEM_ABS_W
00004184  BE3C 0001               3713      CMP.B       #$01, D7            ; Test for absolute long address
00004188  6700 0016               3714      BEQ         ROd_MEM_ABS_L
0000418C  4EB8 2874               3715      JSR         EA_INVALID          ; Else: invalid
00004190  4EF9 000041AA           3716      JMP         ROd_END
00004196                          3717  ROd_MEM_ABS_W:
00004196  4EB8 2CAC               3718      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000419A  4EF9 000041AA           3719      JMP         ROd_END
000041A0                          3720  ROd_MEM_ABS_L:
000041A0  4EB8 2C9C               3721      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000041A4  4EF9 000041AA           3722      JMP         ROd_END
000041AA                          3723  ROd_END:
000041AA  4EB8 288C               3724      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000041AE  4CDF 3FFF               3725      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000041B2  4E75                    3726      RTS
000041B4                          3727  EA_SUB:
000041B4  4EB8 28C2               3728      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
000041B8  41F9 000041C6           3729      LEA         SUB_OPMODE, A0      ; Set index '0' for jump table
000041BE  CCFC 0006               3730      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000041C2  4EF0 6000               3731      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000041C6                          3732  SUB_OPMODE:
000041C6  4EF9 000041F6           3733      JMP         SUB_OPMODE_000      ; mode 1, byte
000041CC  4EF9 00004200           3734      JMP         SUB_OPMODE_001      ; mode 1, word
000041D2  4EF9 0000420A           3735      JMP         SUB_OPMODE_010      ; mode 1, long
000041D8  4EF9 00004214           3736      JMP         SUB_OPMODE_011      ; Invalid value
000041DE  4EF9 0000421E           3737      JMP         SUB_OPMODE_100      ; mode 2, byte
000041E4  4EF9 00004228           3738      JMP         SUB_OPMODE_101      ; mode 2, word
000041EA  4EF9 00004232           3739      JMP         SUB_OPMODE_110      ; mode 2, long
000041F0  4EF9 0000423C           3740      JMP         SUB_OPMODE_111      ; Invalid value
000041F6                          3741  SUB_OPMODE_000: ; mode 1, byte
000041F6  1A3C 0001               3742      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
000041FA  4EF9 00004246           3743      JMP         SUB_MODE_1
00004200                          3744  SUB_OPMODE_001: ; mode 1, word
00004200  1A3C 0002               3745      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00004204  4EF9 00004246           3746      JMP         SUB_MODE_1
0000420A                          3747  SUB_OPMODE_010: ; mode 1, long
0000420A  1A3C 0003               3748      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
0000420E  4EF9 00004246           3749      JMP         SUB_MODE_1
00004214                          3750  SUB_OPMODE_011: ; Invalid value
00004214  4EB8 2874               3751      JSR         EA_INVALID
00004218  4EF9 0000436C           3752      JMP         SUB_END
0000421E                          3753  SUB_OPMODE_100: ; mode 2, byte
0000421E  1A3C 0001               3754      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004222  4EF9 00004270           3755      JMP         SUB_MODE_2
00004228                          3756  SUB_OPMODE_101: ; mode 2, word
00004228  1A3C 0001               3757      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000422C  4EF9 00004270           3758      JMP         SUB_MODE_2
00004232                          3759  SUB_OPMODE_110: ; mode 2, long
00004232  1A3C 0001               3760      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004236  4EF9 00004270           3761      JMP         SUB_MODE_2
0000423C                          3762  SUB_OPMODE_111: ; Invalid value
0000423C  4EB8 2874               3763      JSR         EA_INVALID
00004240  4EF9 0000436C           3764      JMP         SUB_END
00004246                          3765  SUB_MODE_1:
00004246  4280                    3766      CLR.L       D0                  ; Clear data register 0
00004248  103C 0001               3767      MOVE.B      #1, D0              ; Save mode number to D0
0000424C  3207                    3768      MOVE.W      D7, D1              ; Save register value for printing dest. operand
0000424E  4EB8 289C               3769      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00004252  4EB9 00004296           3770      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
00004258  49F9 000048AC           3771      LEA         COMMA, A4        ; Print comma
0000425E  4EB9 000043D2           3772      JSR         WRITE2MEM
00004264  3E01                    3773      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00004266  4EB8 28FA               3774      JSR         EA_PRINT_DN         ; Print data register
0000426A  4EF9 0000436C           3775      JMP         SUB_END
00004270                          3776  SUB_MODE_2:
00004270  4280                    3777      CLR.L       D0                  ; Clear data register 0
00004272  103C 0002               3778      MOVE.B      #2, D0              ; Save mode number to D0
00004276  4EB8 28FA               3779      JSR         EA_PRINT_DN         ; Print data register
0000427A  49F9 000048AC           3780      LEA         COMMA, A4        ; Print comma
00004280  4EB9 000043D2           3781      JSR         WRITE2MEM
00004286  4EB8 289C               3782      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
0000428A  4EB9 00004296           3783      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
00004290  4EF9 0000436C           3784      JMP         SUB_END
00004296                          3785  SUB_EVAL_EA:
00004296  41F9 000042A4           3786      LEA         SUB_MODE, A0        ; Set index '0' for jump table
0000429C  CCFC 0006               3787      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000042A0  4EF0 6000               3788      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000042A4                          3789  SUB_MODE:
000042A4  4EF9 000042D4           3790      JMP         SUB_MODE_000        ; Dn (invalid if opmode 2)
000042AA  4EF9 000042E6           3791      JMP         SUB_MODE_001        ; An (invalid if opmode 2)
000042B0  4EF9 000042F8           3792      JMP         SUB_MODE_010        ; (An)
000042B6  4EF9 00004302           3793      JMP         SUB_MODE_011        ; (An)+
000042BC  4EF9 0000430C           3794      JMP         SUB_MODE_100        ; -(An)
000042C2  4EF9 00004316           3795      JMP         SUB_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000042C8  4EF9 0000431C           3796      JMP         SUB_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000042CE  4EF9 00004322           3797      JMP         SUB_MODE_111        ; The rest (not all valid, validated by register number)
000042D4                          3798  SUB_MODE_000: ; Dn (invalid if opmode 2)
000042D4  B07C 0002               3799      CMP         #2, D0
000042D8  6700 008E               3800      BEQ         SUB_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
000042DC  4EB8 28FA               3801      JSR         EA_PRINT_DN         ; Print data register direct operand
000042E0  4EF9 00004366           3802      JMP         SUB_MODE_END        ; End evaluation of ea mode
000042E6                          3803  SUB_MODE_001: ; An (invalid if opmode 2)
000042E6  B07C 0002               3804      CMP         #2, D0
000042EA  6700 007C               3805      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
000042EE  4EB8 299A               3806      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
000042F2  4EF9 00004366           3807      JMP         SUB_MODE_END        ; End evaluation of ea mode
000042F8                          3808  SUB_MODE_010: ; (An)
000042F8  4EB8 2A3A               3809      JSR         EA_PRINT_IND         ; Print address register indirect
000042FC  4EF9 00004366           3810      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004302                          3811  SUB_MODE_011: ; (An)+
00004302  4EB8 2B14               3812      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00004306  4EF9 00004366           3813      JMP         SUB_MODE_END        ; End evaluation of ea mode
0000430C                          3814  SUB_MODE_100: ; -(An)
0000430C  4EB8 2BD8               3815      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00004310  4EF9 00004366           3816      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004316                          3817  SUB_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00004316  4EF9 00004368           3818      JMP         SUB_MODE_INVALID
0000431C                          3819  SUB_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000431C  4EF9 00004368           3820      JMP         SUB_MODE_INVALID
00004322                          3821  SUB_MODE_111: ; The rest (not all valid, validated by register number)
00004322  BE3C 0000               3822      CMP.B       #$00, D7            ; Test for absolute word address
00004326  6700 0018               3823      BEQ         SUB_ABS_W
0000432A  BE3C 0001               3824      CMP.B       #$01, D7            ; Test for absolute long address
0000432E  6700 001A               3825      BEQ         SUB_ABS_L
00004332  BE3C 0004               3826      CMP.B       #$04, D7            ; Test for immediate data
00004336  6700 001C               3827      BEQ         SUB_IMM
0000433A  4EF9 00004368           3828      JMP         SUB_MODE_INVALID    ; else, invalid
00004340                          3829  SUB_ABS_W:
00004340  4EB8 2CAC               3830      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00004344  4EF9 00004366           3831      JMP         SUB_MODE_END
0000434A                          3832  SUB_ABS_L:
0000434A  4EB8 2C9C               3833      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000434E  4EF9 00004366           3834      JMP         SUB_MODE_END
00004354                          3835  SUB_IMM: ; invalid if opmode is 2
00004354  B07C 0002               3836      CMP         #2, D0
00004358  6700 000E               3837      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
0000435C  4EB8 2AF2               3838      JSR         EA_PRINT_IMM        ; Print immediate data
00004360  4EF9 00004366           3839      JMP         SUB_MODE_END
00004366                          3840  SUB_MODE_END:
00004366  4E75                    3841      RTS                             ; Finish evaluating EA bits
00004368                          3842  SUB_MODE_INVALID:
00004368  4EB8 2874               3843      JSR         EA_INVALID          ; Opcode word is Invalid, continue to end
0000436C                          3844  SUB_END:
0000436C  4EB8 288C               3845      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00004370  4CDF 3FFF               3846      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00004374  4E75                    3847      RTS
00004376                          3848  
00004376                          3849  
00004376                          3850  
00004376                          3851  -------------------- end include --------------------
00004376                          3852      INCLUDE 'EndProgram.X68'
00004376                          3853  
00004376                          3854  
00004376                          3855  
00004376  =00000059               3856  UPYES     EQU   'Y'
00004376  =00000079               3857  LOWYES    EQU   'y'
00004376                          3858  
00004376                          3859  
00004376                          3860  
00004376                          3861  KEEP_RUNNING
00004376  6100 0004               3862      BSR.W       RERUN               * Run welcome subroutine
0000437A  4E75                    3863      RTS                             * Return to Disassembler
0000437C                          3864  
0000437C                          3865  
0000437C                          3866  
0000437C                          3867  
0000437C                          3868  
0000437C                          3869  RERUN
0000437C  43F9 000047EB           3870      LEA         ENDQUESTION,A1      * Loads message into A1
00004382  103C 000E               3871      MOVE.B      #14,D0              * Moves the Task 14 into D0
00004386  4E4F                    3872      TRAP        #15                 * Displays Intro Message
00004388                          3873  
00004388  103C 0005               3874      MOVE.B      #5,D0               * Move task 5 to read one char
0000438C  4E4F                    3875      TRAP        #15                 * Trap 15 for IO
0000438E                          3876  
0000438E  0C01 0059               3877      CMPI.B      #UPYES,D1           * Is char = Y
00004392  6700 0012               3878      BEQ         NOTDONE             * If yes, notdone
00004396  0C01 0079               3879      CMPI.B      #LOWYES,D1          * Is char = y
0000439A  6700 000A               3880      BEQ         NOTDONE             * If yes, notdone
0000439E  11FC 0000 6000          3881      MOVE.B      #0,(RUNAGAIN)       * 0 for false to end program
000043A4  4E75                    3882      RTS
000043A6                          3883  
000043A6                          3884  NOTDONE
000043A6  11FC 0001 6000          3885      MOVE.B      #1,(RUNAGAIN)       * 1 for true to rerun program
000043AC  6100 CD2C               3886      BSR.W       CLEAR               * Clear all values
000043B0  6100 CF56               3887      BSR.W       CLEARSCRN           * Clear screen and return from subroutine
000043B4  4E75                    3888      RTS
000043B6                          3889  
000043B6                          3890  
000043B6                          3891  
000043B6                          3892  
000043B6                          3893  
000043B6                          3894  
000043B6                          3895  
000043B6                          3896  
000043B6                          3897  -------------------- end include --------------------
000043B6                          3898      INCLUDE 'WriteBuffer.X68'
000043B6                          3899  
000043B6  =0000000D               3900  CR      EQU     $0D                 * Carriage return
000043B6  =0000000A               3901  LF      EQU     $0A                 * Line feed
000043B6                          3902  
000043B6  =00002000               3903  BUFFER  EQU     $2000               * Buffer address for string
000043B6  =0000001E               3904  RCOUNT  EQU     30                  * Counters
000043B6                          3905  
000043B6                          3906  WRITE_LINE
000043B6  163C 001E               3907      MOVE.B      #RCOUNT,D3          * Move row counter to D3
000043BA  45F8 2000               3908      LEA         BUFFER,A2           * Load BUFFER address to A2 for use
000043BE                          3909  
000043BE  6112                    3910      BSR.S       WRITE2MEM
000043C0  4E75                    3911      RTS
000043C2                          3912  
000043C2                          3913  
000043C2                          3914  
000043C2                          3915      *BSR.S       PRINTLN             * Subroutine to print buffer
000043C2                          3916  
000043C2                          3917      *LEA         BUFFER,A2           * Reset A2 for buffer cleaning
000043C2                          3918      *BSR.S       CLEAN_BUFF          * Subroutine to reset buffer to all F's
000043C2                          3919  
000043C2  5303                    3920      SUBI.B      #1,D3               * Decrement RCOUNT by 1
000043C4  0C03 0000               3921      CMPI.B      #0,D3               * Is RCOUNT = 0
000043C8  6700 004C               3922      BEQ         NEW_PAGE            * If yes, prompt user and make new page
000043CC  61E8                    3923      BSR.S       WRITE_LINE          * If no, keep writing lines
000043CE                          3924  
000043CE  6000 005E               3925      BRA         PAUSE               * Pause program (SIMHALT)
000043D2                          3926  
000043D2                          3927  WRITE2MEM
000043D2  0C14 0000               3928      CMP.B       #$00,(A4)           * Check if byte is string terminator
000043D6  6700 0006               3929      BEQ         SKIP_WRITE          * If yes, skip write and return
000043DA  14DC                    3930      MOVE.B      (A4)+,(A2)+         * If no, write byte to memory
000043DC  60F4                    3931      BRA         WRITE2MEM           * Keep writing, not end of string
000043DE                          3932  SKIP_WRITE
000043DE  287C 00000000           3933      MOVEA.L     #$00000000,A4       * Clean up A4
000043E4  4E75                    3934      RTS                             * Return to main
000043E6                          3935  
000043E6                          3936  WRITE_ENDL
000043E6  14FC 000D               3937      MOVE.B      #CR,(A2)+           * Move carriage return into memory
000043EA  14FC 000A               3938      MOVE.B      #LF,(A2)+           * Move line feed into memory
000043EE  14FC 0000               3939      MOVE.B      #$00,(A2)+          * Move string terminator into memory
000043F2  4E75                    3940      RTS
000043F4                          3941  
000043F4                          3942  PRINTLN
000043F4  45F8 2000               3943      LEA         BUFFER,A2           * Reset A2 to BUFFER address beginning
000043F8  43D2                    3944      LEA         (A2),A1             * Load BUFFER address into A1
000043FA  103C 000E               3945      MOVE.B      #14,D0              * Task 14, no CR or LF
000043FE  4E4F                    3946      TRAP        #15                 * Display string held in BUFFER
00004400  4E75                    3947      RTS                             * Return to main
00004402                          3948  
00004402                          3949  CLEAN_BUFF
00004402  0C92 FFFFFFFF           3950      CMPI.L      #$FFFFFFFF,(A2)     *
00004408  6700 000A               3951      BEQ         BUFFDONE            * Buffer has been cleaned
0000440C  24FC FFFFFFFF           3952      MOVE.L      #$FFFFFFFF,(A2)+    * Fill with F's
00004412  60EE                    3953      BRA         CLEAN_BUFF          * Continue cleaning buffer
00004414                          3954  BUFFDONE
00004414  4E75                    3955      RTS                             * Return to main
00004416                          3956  
00004416                          3957  NEW_PAGE
00004416  4283                    3958      CLR.L       D3                  * Clear counter
00004418  43F9 0000481B           3959      LEA         ENTER,A1            * Load enter message into A1
0000441E  103C 000E               3960      MOVE.B      #14,D0              * Moves the Task 14 into D0
00004422  4E4F                    3961      TRAP        #15                 * Displays contents of A1
00004424  103C 0005               3962      MOVE.B      #5,D0               * Read single character from
00004428  4E4F                    3963      TRAP        #15                 * The keyboard into D1.B
0000442A  6000 CEDC               3964      BRA.W       CLEARSCRN           * Clear the screen.
0000442E                          3965  
0000442E                          3966  PAUSE
0000442E  FFFF FFFF               3967          SIMHALT                     * Halt simulator
00004432  6000 0002               3968          BRA     QUIT                * End program
00004436                          3969  
00004436                          3970  QUIT
00004436                          3971          *END     START        ; last line of source
00004436                          3972  
00004436                          3973  
00004436                          3974  -------------------- end include --------------------
00004436                          3975  
00004436                          3976      INCLUDE 'IOMessages.X68'
00004436                          3977  
00004436= 57 45 4C 43 4F 4D ...   3978  INTRO           DC.B 'WELCOME!',CR,LF,'THIS IS A 68K DISASSEMBLER.',CR,LF,0
0000445E= 50 4C 45 41 53 45 ...   3979  PS1             DC.B 'PLEASE ENTER THE STARTING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000044A8= 50 4C 45 41 53 45 ...   3980  PS2             DC.B 'PLEASE ENTER THE ENDING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000044F0= 0D 0A 42 45 47 49 ...   3981  BMESSAGE        DC.B CR,LF,'BEGINNING ADDRESS GIVEN IS: ',0
0000450F= 0D 0A 45 4E 44 49 ...   3982  EMESSAGE        DC.B CR,LF,'ENDING ADDRESS GIVEN IS   : ',0
0000452E                          3983  
0000452E= 54 48 45 20 42 45 ...   3984  ADR_ERR_NOTLT   DC.B 'THE BEGINNING ADDRESS MUST BE LESS THAN THE ENDING ADDRESS.',CR,LF,'PRESS ANY KEY TO TRY AGAIN...',0
00004589                          3985  
00004589                          3986  HEXSTRING       DS.B 80             * Var for hex string
000045D9                          3987  
000045D9= 44 41 54 41 00          3988  DATA            DC.B 'DATA',0
000045D9= 44 41 54 41 00          3989  -------------------- end include --------------------
000045DE                          3990      INCLUDE 'OCMessages.X68'
000045DE                          3991  
000045DE                          3992  
000045DE  =0000000D               3993  CR      EQU     $0D
000045DE  =0000000A               3994  LF      EQU     $0A
000045DE= 20 00                   3995  MESSAGESPACE DC.B  ' ',0
000045E0= 4E 4F 50 00             3996  MESSAGENOP DC.B    'NOP',0
000045E4                          3997  
000045E4= 4D 4F 56 45 2E 57 00    3998  MESSAGEMOVEW DC.B    'MOVE.W',0
000045EB= 4D 4F 56 45 2E 4C 00    3999  MESSAGEMOVEL DC.B    'MOVE.L',0
000045F2= 4D 4F 56 45 2E 42 00    4000  MESSAGEMOVEB DC.B    'MOVE.B',0
000045F9                          4001  
000045F9= 41 44 44 49 2E 57 00    4002  MESSAGEADDIW DC.B    'ADDI.W',0
00004600= 41 44 44 49 2E 4C 00    4003  MESSAGEADDIL DC.B    'ADDI.L',0
00004607= 41 44 44 49 2E 42 00    4004  MESSAGEADDIB DC.B    'ADDI.B',0
0000460E                          4005  
0000460E= 4D 4F 56 45 41 2E ...   4006  MESSAGEMOVEAL DC.B    'MOVEA.L',0
00004616= 4D 4F 56 45 41 2E ...   4007  MESSAGEMOVEAW DC.B    'MOVEA.W',0
0000461E                          4008  
0000461E= 4D 4F 56 45 4D 2E ...   4009  MESSAGEMOVEML DC.B    'MOVEM.L',0
00004626= 4D 4F 56 45 4D 2E ...   4010  MESSAGEMOVEMW DC.B    'MOVEM.W',0
0000462E                          4011  
0000462E= 4A 53 52 00             4012  MESSAGEJSR DC.B    'JSR',0
00004632                          4013  
00004632= 43 4C 52 00             4014  MESSAGECLR DC.B    'CLR',0
00004636                          4015  
00004636= 52 54 53 00             4016  MESSAGERTS DC.B    'RTS',0
0000463A                          4017  
0000463A= 4C 45 41 00             4018  MESSAGELEA DC.B    'LEA',0
0000463E                          4019  
0000463E= 43 4C 52 2E 42 00       4020  MESSAGECLRB DC.B    'CLR.B',0
00004644= 43 4C 52 2E 57 00       4021  MESSAGECLRW DC.B    'CLR.W',0
0000464A= 43 4C 52 2E 4C 00       4022  MESSAGECLRL DC.B    'CLR.L',0
00004650                          4023  
00004650= 41 44 44 51 2E 42 00    4024  MESSAGEADDQB DC.B    'ADDQ.B',0
00004657= 41 44 44 51 2E 57 00    4025  MESSAGEADDQW DC.B    'ADDQ.W',0
0000465E= 41 44 44 51 2E 4C 00    4026  MESSAGEADDQL DC.B    'ADDQ.L',0
00004665                          4027  
00004665= 43 4D 50 2E 42 00       4028  MESSAGECMPB DC.B    'CMP.B',0
0000466B= 43 4D 50 2E 57 00       4029  MESSAGECMPW DC.B    'CMP.W',0
00004671= 43 4D 50 2E 4C 00       4030  MESSAGECMPL DC.B    'CMP.L',0
00004677                          4031  
00004677= 53 55 42 2E 42 00       4032  MESSAGESUBB DC.B    'SUB.B',0
0000467D= 53 55 42 2E 57 00       4033  MESSAGESUBW DC.B    'SUB.W',0
00004683= 53 55 42 2E 4C 00       4034  MESSAGESUBL DC.B    'SUB.L',0
00004689                          4035  
00004689= 41 44 44 2E 42 00       4036  MESSAGEADDB DC.B    'ADD.B',0
0000468F= 41 44 44 2E 57 00       4037  MESSAGEADDW DC.B    'ADD.W',0
00004695= 41 44 44 2E 4C 00       4038  MESSAGEADDL DC.B    'ADD.L',0
0000469B                          4039  
0000469B= 41 44 44 41 2E 57 00    4040  MESSAGEADDAW DC.B    'ADDA.W',0
000046A2= 41 44 44 41 2E 4C 00    4041  MESSAGEADDAL DC.B    'ADDA.L',0
000046A9                          4042  
000046A9= 4D 4F 56 45 51 2E ...   4043  MESSAGEMOVEQL DC.B    'MOVEQ.L',0
000046B1                          4044  
000046B1= 41 4E 44 2E 42 00       4045  MESSAGEANDB DC.B    'AND.B',0
000046B7= 41 4E 44 2E 57 00       4046  MESSAGEANDW DC.B    'AND.W',0
000046BD= 41 4E 44 2E 4C 00       4047  MESSAGEANDL DC.B    'AND.L',0
000046C3                          4048  
000046C3= 4D 55 4C 53 2E 57 00    4049  MESSAGEMULSW DC.B    'MULS.W',0
000046CA                          4050  
000046CA= 41 53 52 2E 42 00       4051  MESSAGEASRB DC.B    'ASR.B',0
000046D0= 41 53 52 2E 57 00       4052  MESSAGEASRW DC.B    'ASR.W',0
000046D6= 41 53 52 2E 4C 00       4053  MESSAGEASRL DC.B    'ASR.L',0
000046DC                          4054  
000046DC= 41 53 4C 2E 42 00       4055  MESSAGEASLB DC.B    'ASL.B',0
000046E2= 41 53 4C 2E 57 00       4056  MESSAGEASLW DC.B    'ASL.W',0
000046E8= 41 53 4C 2E 4C 00       4057  MESSAGEASLL DC.B    'ASL.L',0
000046EE                          4058  
000046EE= 52 4F 52 2E 42 00       4059  MESSAGERORB DC.B    'ROR.B',0
000046F4= 52 4F 52 2E 57 00       4060  MESSAGERORW DC.B    'ROR.W',0
000046FA= 52 4F 52 2E 4C 00       4061  MESSAGERORL DC.B    'ROR.L',0
00004700                          4062  
00004700= 52 4F 4C 2E 42 00       4063  MESSAGEROLB DC.B    'ROL.B',0
00004706= 52 4F 4C 2E 57 00       4064  MESSAGEROLW DC.B    'ROL.W',0
0000470C= 52 4F 4C 2E 4C 00       4065  MESSAGEROLL DC.B    'ROL.L',0
00004712                          4066  
00004712= 4C 53 52 2E 42 00       4067  MESSAGELSRB DC.B    'LSR.B',0
00004718= 4C 53 52 2E 57 00       4068  MESSAGELSRW DC.B    'LSR.W',0
0000471E= 4C 53 52 2E 4C 00       4069  MESSAGELSRL DC.B    'LSR.L',0
00004724                          4070  
00004724= 4C 53 4C 2E 42 00       4071  MESSAGELSLB DC.B    'LSL.B',0
0000472A= 4C 53 4C 2E 57 00       4072  MESSAGELSLW DC.B    'LSL.W',0
00004730= 4C 53 4C 2E 4C 00       4073  MESSAGELSLL DC.B    'LSL.L',0
00004736                          4074  
00004736= 4F 52 2E 42 00          4075  MESSAGEORB DC.B    'OR.B',0
0000473B= 4F 52 2E 57 00          4076  MESSAGEORW DC.B    'OR.W',0
00004740= 4F 52 2E 4C 00          4077  MESSAGEORL DC.B    'OR.L',0
00004745                          4078  
00004745= 44 49 56 55 2E 57 00    4079  MESSAGEDIVUW DC.B    'DIVU.W',0
0000474C                          4080  
0000474C= 42 43 43 00             4081  MESSAGEBCC DC.B    'BCC',0
00004750= 42 47 54 00             4082  MESSAGEBGT DC.B    'BGT',0
00004754= 42 4C 45 00             4083  MESSAGEBLE DC.B    'BLE',0
00004758                          4084  
00004758= 54 68 61 74 20 69 ...   4085  MESSAGEOPCODE_INVALID DC.B    'That is not an opcode!', 0
0000476F                          4086  
0000476F                          4087  
0000476F                          4088  
0000476F                          4089  
0000476F                          4090  -------------------- end include --------------------
0000476F                          4091      INCLUDE 'EAMessages.X68'
0000476F                          4092  
0000476F= 00                      4093  EA_MSG_NULL         DC.B    0
00004770= 20 00                   4094  EA_MSG_SPACE        DC.B    ' ',0
00004772= 2C 20 00                4095  EA_MSG_COMMA        DC.B    ', ',0
00004775= 28 00                   4096  EA_MSG_OPENPAREN    DC.B    '(',0
00004777= 29 00                   4097  EA_MSG_CLOSEPAREN   DC.B    ')',0
00004779= 2D 00                   4098  EA_MSG_MIN          DC.B    '-',0
0000477B= 2B 00                   4099  EA_MSG_PLUS         DC.B    '+',0
0000477D= 23 00                   4100  EA_MSG_HASH         DC.B    '#',0
0000477F= 24 00                   4101  EA_MSG_HEX          DC.B    '$',0
00004781                          4102  
00004781= 44 30 00                4103  EA_MSG_D0           DC.B    'D0',0
00004784= 44 31 00                4104  EA_MSG_D1           DC.B    'D1',0
00004787= 44 32 00                4105  EA_MSG_D2           DC.B    'D2',0
0000478A= 44 33 00                4106  EA_MSG_D3           DC.B    'D3',0
0000478D= 44 34 00                4107  EA_MSG_D4           DC.B    'D4',0
00004790= 44 35 00                4108  EA_MSG_D5           DC.B    'D5',0
00004793= 44 36 00                4109  EA_MSG_D6           DC.B    'D6',0
00004796= 44 37 00                4110  EA_MSG_D7           DC.B    'D7',0
00004799                          4111  
00004799= 41 30 00                4112  EA_MSG_A0           DC.B    'A0',0
0000479C= 41 31 00                4113  EA_MSG_A1           DC.B    'A1',0
0000479F= 41 32 00                4114  EA_MSG_A2           DC.B    'A2',0
000047A2= 41 33 00                4115  EA_MSG_A3           DC.B    'A3',0
000047A5= 41 34 00                4116  EA_MSG_A4           DC.B    'A4',0
000047A8= 41 35 00                4117  EA_MSG_A5           DC.B    'A5',0
000047AB= 41 36 00                4118  EA_MSG_A6           DC.B    'A6',0
000047AE= 41 37 00                4119  EA_MSG_A7           DC.B    'A7',0
000047B1                          4120  
000047B1= 5B 45 41 20 43 4F ...   4121  EA_MSG_UNIMP        DC.B    '[EA CODE NOT IMPLEMENTED]',0
000047CB= 5B 50 52 49 4E 54 ...   4122  EA_MSG_PRINT_DATA   DC.B    '[PRINTING DATA NOT IMPLEMENTED]',0
000047EB                          4123  
000047EB                          4124  -------------------- end include --------------------
000047EB                          4125      INCLUDE 'EPMessages.X68'        ; EndProgram messages
000047EB                          4126  
000047EB= 57 4F 55 4C 44 20 ...   4127  ENDQUESTION     DC.B 'WOULD YOU LIKE TO RUN THE PROGRAM AGAIN (Y/N)? ',0
000047EB= 57 4F 55 4C 44 20 ...   4128  -------------------- end include --------------------
0000481B                          4129      INCLUDE 'WBMessages.X68'        ; WriteBuffer messages
0000481B                          4130  
0000481B= 2D 2D 2D 2D 2D 2D ...   4131  ENTER           DC.B '------------------------- Press Enter ------------------------',0
0000485A                          4132  
0000485A                          4133  
0000485A= 4D 4F 56 45 00          4134  MV              DC.B 'MOVE',0
0000485F= 41 44 44 20 00          4135  AD              DC.B 'ADD ',0
00004864                          4136  
00004864= 2E 42 20 20 00          4137  BYTE            DC.B '.B  ',0
00004869= 2E 57 20 20 00          4138  WORD            DC.B '.W  ',0
0000486E= 2E 4C 20 20 00          4139  LONG            DC.B '.L  ',0
00004873= 0D 0A 00                4140  ENDL            DC.B CR,LF,0
00004876                          4141  
00004876= 44 30 00                4142  DREG0           DC.B 'D0',0
00004879= 44 31 00                4143  DREG1           DC.B 'D1',0
0000487C= 44 32 00                4144  DREG2           DC.B 'D2',0
0000487F= 44 33 00                4145  DREG3           DC.B 'D3',0
00004882= 44 34 00                4146  DREG4           DC.B 'D4',0
00004885= 44 35 00                4147  DREG5           DC.B 'D5',0
00004888= 44 36 00                4148  DREG6           DC.B 'D6',0
0000488B= 44 37 00                4149  DREG7           DC.B 'D7',0
0000488E= 41 30 00                4150  AREG0           DC.B 'A0',0
00004891= 41 31 00                4151  AREG1           DC.B 'A1',0
00004894= 41 32 00                4152  AREG2           DC.B 'A2',0
00004897= 41 33 00                4153  AREG3           DC.B 'A3',0
0000489A= 41 34 00                4154  AREG4           DC.B 'A4',0
0000489D= 41 35 00                4155  AREG5           DC.B 'A5',0
000048A0= 41 36 00                4156  AREG6           DC.B 'A6',0
000048A3= 41 37 00                4157  AREG7           DC.B 'A7',0
000048A6                          4158  
000048A6= 23 00                   4159  POUND           DC.B '#',0
000048A8= 24 00                   4160  DOLLAR          DC.B '$',0
000048AA= 25 00                   4161  PERCENT         DC.B '%',0
000048AC= 2C 20 00                4162  COMMA           DC.B ', ',0
000048AF= 28 00                   4163  OPAREN          DC.B '(',0
000048B1= 29 00                   4164  CPAREN          DC.B ')',0
000048B3= 2B 00                   4165  PLUS            DC.B '+',0
000048B5= 2D 00                   4166  MINUS           DC.B '-',0
000048B7                          4167  
000048B7= 20 20 20 20 00          4168  TAB             DC.B '    ',0
000048B7= 20 20 20 20 00          4169  -------------------- end include --------------------
000048BC                          4170  
000048BC                          4171  *********** END INCLUDES *****************************************************
000048BC                          4172  
000048BC                          4173  *---------- Reserved Registers -----------------------------
000048BC                          4174  *   A7: stack pointer
000048BC                          4175  *   A6: current address (updated by subroutines)
000048BC                          4176  *   D0: instruction validity flag (reset by main control
000048BC                          4177  *       code, can be set to false by subroutines)
000048BC                          4178  *-----------------------------------------------------------
000048BC                          4179  
000048BC                          4180  *---------- End --------------------------------------------
000048BC                          4181                 END  START          * Last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AD                  485F
ADDA_ABS_L          2F36
ADDA_ABS_W          2F2C
ADDA_END            2F6C
ADDA_IMM            2F40
ADDA_MODE           2EA0
ADDA_MODE_000       2ED0
ADDA_MODE_001       2EDA
ADDA_MODE_010       2EE4
ADDA_MODE_011       2EEE
ADDA_MODE_100       2EF8
ADDA_MODE_101       2F02
ADDA_MODE_110       2F08
ADDA_MODE_111       2F0E
ADDA_MODE_END       2F58
ADDA_MODE_INVALID   2F4E
ADDCODE000          195A
ADDCODE001          1962
ADDCODE010          196A
ADDCODE011          1972
ADDCODE100          197A
ADDCODE101          1982
ADDCODE110          198A
ADDCODE111          1992
ADDIBCODE00         1DB8
ADDILCODE10         1DC8
ADDILCODE11         1DD0
ADDIWCODE01         1DC0
ADDI_ABS_L          307E
ADDI_ABS_W          3074
ADDI_B              2FA4
ADDI_BORADDI_WORADDI_L  1D82
ADDI_END            3088
ADDI_GET_DEST       2FD2
ADDI_L              2FCC
ADDI_MODE           2FE4
ADDI_MODE_000       3014
ADDI_MODE_001       301E
ADDI_MODE_010       3028
ADDI_MODE_011       3032
ADDI_MODE_100       303C
ADDI_MODE_101       3046
ADDI_MODE_110       3050
ADDI_MODE_111       305A
ADDI_W              2FBE
ADDQCODE00          1AB4
ADDQCODE01          1ABC
ADDQCODE10          1AC4
ADDQCODE11          1ACC
ADDQ_ABS_L          317C
ADDQ_ABS_W          3172
ADDQ_BORADDQ_WORADDQ_L  1A7E
ADDQ_END            3186
ADDQ_MODE           30E2
ADDQ_MODE_000       3112
ADDQ_MODE_001       311C
ADDQ_MODE_010       3126
ADDQ_MODE_011       3130
ADDQ_MODE_100       313A
ADDQ_MODE_101       3144
ADDQ_MODE_110       314E
ADDQ_MODE_111       3158
ADDQ_PRINT_IMM      30B4
ADDRESS_ERR         1314
ADD_ABS_L           2E5A
ADD_ABS_W           2E50
ADD_BORADD_WORADD_L  190C
ADD_END             2E7C
ADD_EVAL_EA         2DA6
ADD_IMM             2E64
ADD_MODE            2DB4
ADD_MODE_000        2DE4
ADD_MODE_001        2DF6
ADD_MODE_010        2E08
ADD_MODE_011        2E12
ADD_MODE_1          2D56
ADD_MODE_100        2E1C
ADD_MODE_101        2E26
ADD_MODE_110        2E2C
ADD_MODE_111        2E32
ADD_MODE_2          2D80
ADD_MODE_END        2E76
ADD_MODE_INVALID    2E78
ADD_OPMODE          2CD6
ADD_OPMODE_000      2D06
ADD_OPMODE_001      2D10
ADD_OPMODE_010      2D1A
ADD_OPMODE_011      2D24
ADD_OPMODE_100      2D2E
ADD_OPMODE_101      2D38
ADD_OPMODE_110      2D42
ADD_OPMODE_111      2D4C
ADR_ERR_NOTLT       452E
ANDCODE000          18CC
ANDCODE001          18D4
ANDCODE010          18DC
ANDCODE011          18E4
ANDCODE100          18EC
ANDCODE101          18F4
ANDCODE110          18FC
ANDCODE111          1904
AND_ABS_L           3320
AND_ABS_W           3316
AND_BORAND_WORAND_LORMULS_W  187E
AND_END             3342
AND_EVAL_EA         3278
AND_IMM             332A
AND_MODE            3286
AND_MODE_000        32B6
AND_MODE_001        32C8
AND_MODE_010        32CE
AND_MODE_011        32D8
AND_MODE_1          3228
AND_MODE_100        32E2
AND_MODE_101        32EC
AND_MODE_110        32F2
AND_MODE_111        32F8
AND_MODE_2          3252
AND_MODE_END        333C
AND_MODE_INVALID    333E
AND_OPMODE          31A8
AND_OPMODE_000      31D8
AND_OPMODE_001      31E2
AND_OPMODE_010      31EC
AND_OPMODE_011      31F6
AND_OPMODE_100      3200
AND_OPMODE_101      320A
AND_OPMODE_110      3214
AND_OPMODE_111      321E
AN_000              29D8
AN_001              29E4
AN_010              29F0
AN_011              29FC
AN_100              2A08
AN_101              2A14
AN_110              2A20
AN_111              2A2C
AN_JMP              29A8
AREG0               488E
AREG1               4891
AREG2               4894
AREG3               4897
AREG4               489A
AREG5               489D
AREG6               48A0
AREG7               48A3
ASCII_TO_HEX        112E
ASD_END             3472
ASD_MEM             33BC
ASD_MEM_ABS_L       3468
ASD_MEM_ABS_W       345E
ASD_MEM_MODE        33CE
ASD_MEM_MODE_000    33FE
ASD_MEM_MODE_001    3408
ASD_MEM_MODE_010    3412
ASD_MEM_MODE_011    341C
ASD_MEM_MODE_100    3426
ASD_MEM_MODE_101    3430
ASD_MEM_MODE_110    343A
ASD_MEM_MODE_111    3444
ASD_REG             3364
ASD_REG_COUNT       3392
ASD_REG_END         33A2
ASD_REG_REG         3388
ASLCODE00           1614
ASLCODE01           161C
ASLCODE10           1624
ASLCODE11           162C
ASL_ASR             17F8
ASL_ASRCODE0        1822
ASL_ASRCODE1        1828
ASRCODE00           15BE
ASRCODE01           15C6
ASRCODE10           15CE
ASRCODE11           15D6
BAD_CHECK           12EA
BAD_LENGTH          1126
BCCORBGTORBLE       14A4
BCCORBGTORBLECODE00  14DA
BCCORBGTORBLECODE01  14E2
BCCORBGTORBLECODE10  14EA
BCCORBGTORBLECODE11  14F2
BCC_B               34AA
BCC_DISPLAY         34FE
BCC_L               34F0
BCC_W               34CE
BEGINADDR           5000
BMESSAGE            44F0
BUFFDONE            4414
BUFFER              2000
BYTE                4864
CHECK_BADDR_IS_LESS_THAN_EADDR  10A6
CLEAN_BUFF          4402
CLEAR               10DA
CLEARSCRN           1308
CLRCODE00           1B0A
CLRCODE01           1B12
CLRCODE10           1B1A
CLRCODE11           1B22
CLR_ABS_L           35BE
CLR_ABS_W           35B4
CLR_END             35C8
CLR_MODE            3524
CLR_MODE_000        3554
CLR_MODE_001        355E
CLR_MODE_010        3568
CLR_MODE_011        3572
CLR_MODE_100        357C
CLR_MODE_101        3586
CLR_MODE_110        3590
CLR_MODE_111        359A
CMPCODE00           1A5E
CMPCODE01           1A66
CMPCODE10           1A6E
CMPCODE11           1A76
CMP_ABS_L           3686
CMP_ABS_W           367C
CMP_BORCMP_WORCMP_L  1A28
CMP_END             36A4
CMP_MODE            35EC
CMP_MODE_000        361C
CMP_MODE_001        3626
CMP_MODE_010        3630
CMP_MODE_011        363A
CMP_MODE_100        3644
CMP_MODE_101        364E
CMP_MODE_110        3658
CMP_MODE_111        3662
CMP_MODE_END        3690
CODE0000            13F8
CODE0001            13FE
CODE0010            140A
CODE0011            1410
CODE0100            1416
CODE0101            1422
CODE0110            142E
CODE0111            143A
CODE1000            1446
CODE1001            1452
CODE1010            145E
CODE1011            1466
CODE1100            1472
CODE1101            147E
CODE1110            148A
CODE1111            1496
COMMA               48AC
CPAREN              48B1
CR                  D
DATA                45D9
DIVU_W_ABS_L        376A
DIVU_W_ABS_W        3760
DIVU_W_DEST         3782
DIVU_W_END          3794
DIVU_W_IMM          3774
DIVU_W_MODE         36C8
DIVU_W_MODE_000     36F8
DIVU_W_MODE_001     3702
DIVU_W_MODE_010     370C
DIVU_W_MODE_011     3716
DIVU_W_MODE_100     3720
DIVU_W_MODE_101     372A
DIVU_W_MODE_110     3734
DIVU_W_MODE_111     373E
DN_000              2938
DN_001              2944
DN_010              2950
DN_011              295C
DN_100              2968
DN_101              2974
DN_110              2980
DN_111              298C
DOLLAR              48A8
DONE                149E
DREG0               4876
DREG1               4879
DREG2               487C
DREG3               487F
DREG4               4882
DREG5               4885
DREG6               4888
DREG7               488B
EA_ADD              2CBC
EA_ADDA             2E86
EA_ADDI             2F76
EA_ADDQ             3092
EA_AND              3190
EA_ASD              334C
EA_BCC              347C
EA_CLR              350A
EA_CMP              35D2
EA_COPY_PTR         2898
EA_DEFAULT_COMBO    289C
EA_DIVU_W           36AE
EA_INVALID          2874
EA_JSR              379E
EA_LEA              3866
EA_LSD              3942
EA_MOVE             3A72
EA_MOVEA            3C46
EA_MOVEM            3D6C
EA_MOVEQ            3D72
EA_MSG_A0           4799
EA_MSG_A1           479C
EA_MSG_A2           479F
EA_MSG_A3           47A2
EA_MSG_A4           47A5
EA_MSG_A5           47A8
EA_MSG_A6           47AB
EA_MSG_A7           47AE
EA_MSG_CLOSEPAREN   4777
EA_MSG_COMMA        4772
EA_MSG_D0           4781
EA_MSG_D1           4784
EA_MSG_D2           4787
EA_MSG_D3           478A
EA_MSG_D4           478D
EA_MSG_D5           4790
EA_MSG_D6           4793
EA_MSG_D7           4796
EA_MSG_HASH         477D
EA_MSG_HEX          477F
EA_MSG_MIN          4779
EA_MSG_NULL         476F
EA_MSG_OPENPAREN    4775
EA_MSG_PLUS         477B
EA_MSG_PRINT_DATA   47CB
EA_MSG_SPACE        4770
EA_MSG_UNIMP        47B1
EA_MULS_W           3DD2
EA_OPMODE_COMBO     28C2
EA_OR               3EC2
EA_PRINT_ABS_L      2C9C
EA_PRINT_ABS_W      2CAC
EA_PRINT_AN         299A
EA_PRINT_AN_END     2A38
EA_PRINT_DATA       287E
EA_PRINT_DN         28FA
EA_PRINT_DN_END     2998
EA_PRINT_DN_JMP     2908
EA_PRINT_IMM        2AF2
EA_PRINT_IND        2A3A
EA_PRINT_IND_END    2AE4
EA_PRINT_PD_END     2C8E
EA_PRINT_PI_END     2BBE
EA_PRINT_POSTINC    2B14
EA_PRINT_PREDEC     2BD8
EA_ROD              4084
EA_SIZE_BITS        28E8
EA_SUB              41B4
EA_UNIMPLEMENTED    2864
EA_UPDATE_POINTER   288C
EMESSAGE            450F
ENDADDR             5010
ENDL                4873
ENDQUESTION         47EB
END_LOOP            103C
ENTER               481B
FINISHED            10C4
FOUND               11EA
GET_ADDRESSES       104E
GET_FIRST_ADDRESS   105A
GET_HEXSTRING       10F4
GET_SECOND_ADDRESS  1080
HEXA                123A
HEXB                1242
HEXC                124A
HEXD                1252
HEXE                125A
HEXEIGHT            122E
HEXF                1262
HEXFIVE             1222
HEXFLAG             5021
HEXFOUR             121E
HEXNINE             1232
HEXONE              1212
HEXSEVEN            122A
HEXSIX              1226
HEXSTRING           4589
HEXTHREE            121A
HEXTWO              1216
HEXVALUE            5030
HEXZERO             120A
IND_000             2A84
IND_001             2A90
IND_010             2A9C
IND_011             2AA8
IND_100             2AB4
IND_101             2AC0
IND_110             2ACC
IND_111             2AD8
IND_JMP             2A54
INITIAL_TABLE       1398
INTRO               4436
INVALID_DATA        1326
IO_WELCOME          10C6
ISADDAL             2390
ISADDAW             2368
ISADDB              23B8
ISADDIB             283C
ISADDIL             2814
ISADDIW             27EC
ISADDL              2408
ISADDQB             2520
ISADDQL             2570
ISADDQW             2548
ISADDW              23E0
ISANDB              22F0
ISANDL              2340
ISANDW              2318
ISASLB              2094
ISASLL              20D8
ISASLW              20BC
ISASRB              201C
ISASRL              206C
ISASRW              2044
ISBCC               1F04
ISBGT               1F2C
ISBLE               1F54
ISCLR               26F0
ISCLRB              25B4
ISCLRL              2604
ISCLRW              25DC
ISCMPB              24A8
ISCMPL              24F8
ISCMPW              24D0
ISDIVUW             1F7C
ISJSR               26A4
ISLEA               267C
ISLSLB              2178
ISLSLL              21BC
ISLSLW              2194
ISLSRB              2100
ISLSRL              2150
ISLSRW              2128
ISMOVEAL            27A8
ISMOVEAW            2758
ISMOVEB             27D0
ISMOVEL             2780
ISMOVEML            262C
ISMOVEMW            2654
ISMOVEQL            258C
ISMOVEW             2730
ISMULSW             22C8
ISNOP               270C
ISORB               1FA4
ISORL               1FF4
ISORW               1FCC
ISROLB              2250
ISROLL              22A0
ISROLW              2278
ISRORB              21E4
ISRORL              2228
ISRORW              220C
ISRTS               26CC
ISSUBB              2430
ISSUBL              2480
ISSUBW              2458
IS_HEX_EVEN         128A
IS_LESSTHAN         126A
JSRORCLRCODE0000    1BCC
JSRORCLRCODE0001    1BD4
JSRORCLRCODE0010    1BDC
JSRORCLRCODE0011    1BE2
JSRORCLRCODE0100    1BEA
JSRORCLRCODE0101    1BF2
JSRORCLRCODE0110    1BFA
JSRORCLRCODE0111    1C02
JSRORCLRCODE1000    1C0A
JSRORCLRCODE1001    1C12
JSRORCLRCODE1010    1C1A
JSRORCLRCODE1011    1C22
JSRORCLRCODE1100    1C2A
JSRORCLRCODE1101    1C32
JSRORCLRCODE1110    1C3A
JSRORCLRCODE1111    1C42
JSR_ABS_L           3852
JSR_ABS_W           3848
JSR_END             385C
JSR_MODE            37B8
JSR_MODE_000        37E8
JSR_MODE_001        37F2
JSR_MODE_010        37FC
JSR_MODE_011        3806
JSR_MODE_100        3810
JSR_MODE_101        381A
JSR_MODE_110        3824
JSR_MODE_111        382E
KEEP_RUNNING        4376
LEA_ABS_L           391A
LEA_ABS_W           3910
LEA_DEST            3924
LEA_END             3938
LEA_MODE            3880
LEA_MODE_000        38B0
LEA_MODE_001        38BA
LEA_MODE_010        38C4
LEA_MODE_011        38CE
LEA_MODE_100        38D8
LEA_MODE_101        38E2
LEA_MODE_110        38EC
LEA_MODE_111        38F6
LF                  A
LONG                486E
LOOP                100E
LOOP_CHECK          1032
LOTSCODE0000        1D08
LOTSCODE0001        1D10
LOTSCODE0010        1D18
LOTSCODE0011        1D1E
LOTSCODE0100        1D26
LOTSCODE0101        1D2E
LOTSCODE0110        1D36
LOTSCODE0111        1D3E
LOTSCODE1000        1D46
LOTSCODE1001        1D4C
LOTSCODE1010        1D54
LOTSCODE1011        1D5A
LOTSCODE1100        1D62
LOTSCODE1101        1D6A
LOTSCODE1110        1D72
LOTSCODE1111        1D7A
LOWYES              79
LSD_END             3A68
LSD_MEM             39B2
LSD_MEM_ABS_L       3A5E
LSD_MEM_ABS_W       3A54
LSD_MEM_MODE        39C4
LSD_MEM_MODE_000    39F4
LSD_MEM_MODE_001    39FE
LSD_MEM_MODE_010    3A08
LSD_MEM_MODE_011    3A12
LSD_MEM_MODE_100    3A1C
LSD_MEM_MODE_101    3A26
LSD_MEM_MODE_110    3A30
LSD_MEM_MODE_111    3A3A
LSD_REG             395A
LSD_REG_COUNT       3988
LSD_REG_END         3998
LSD_REG_REG         397E
LSLCODE00           16C0
LSLCODE01           16C8
LSLCODE10           16D0
LSLCODE11           16D8
LSL_LSR             17C2
LSL_LSRCODE0        17EC
LSL_LSRCODE1        17F2
LSRCODE00           166A
LSRCODE01           1672
LSRCODE10           167A
LSRCODE11           1682
LT                  1282
MAKE_CHECKS         12BE
MESSAGEADDAL        46A2
MESSAGEADDAW        469B
MESSAGEADDB         4689
MESSAGEADDIB        4607
MESSAGEADDIL        4600
MESSAGEADDIW        45F9
MESSAGEADDL         4695
MESSAGEADDQB        4650
MESSAGEADDQL        465E
MESSAGEADDQW        4657
MESSAGEADDW         468F
MESSAGEANDB         46B1
MESSAGEANDL         46BD
MESSAGEANDW         46B7
MESSAGEASLB         46DC
MESSAGEASLL         46E8
MESSAGEASLW         46E2
MESSAGEASRB         46CA
MESSAGEASRL         46D6
MESSAGEASRW         46D0
MESSAGEBCC          474C
MESSAGEBGT          4750
MESSAGEBLE          4754
MESSAGECLR          4632
MESSAGECLRB         463E
MESSAGECLRL         464A
MESSAGECLRW         4644
MESSAGECMPB         4665
MESSAGECMPL         4671
MESSAGECMPW         466B
MESSAGEDIVUW        4745
MESSAGEJSR          462E
MESSAGELEA          463A
MESSAGELSLB         4724
MESSAGELSLL         4730
MESSAGELSLW         472A
MESSAGELSRB         4712
MESSAGELSRL         471E
MESSAGELSRW         4718
MESSAGEMOVEAL       460E
MESSAGEMOVEAW       4616
MESSAGEMOVEB        45F2
MESSAGEMOVEL        45EB
MESSAGEMOVEML       461E
MESSAGEMOVEMW       4626
MESSAGEMOVEQL       46A9
MESSAGEMOVEW        45E4
MESSAGEMULSW        46C3
MESSAGENOP          45E0
MESSAGEOPCODE_INVALID  4758
MESSAGEORB          4736
MESSAGEORL          4740
MESSAGEORW          473B
MESSAGEROLB         4700
MESSAGEROLL         470C
MESSAGEROLW         4706
MESSAGERORB         46EE
MESSAGERORL         46FA
MESSAGERORW         46F4
MESSAGERTS          4636
MESSAGESPACE        45DE
MESSAGESUBB         4677
MESSAGESUBL         4683
MESSAGESUBW         467D
MINUS               48B5
MOD                 2
MOVEACODE001        1E2E
MOVEAWCODE001       1EBC
MOVEA_ADJUST_L      3C7C
MOVEA_ADJUST_W      3C72
MOVEA_DESTINATION   3D4E
MOVEA_END           3D62
MOVEA_LORMOVE_L     1DD8
MOVEA_SOURCE        3C86
MOVEA_SRC_ABS_L     3D3A
MOVEA_SRC_ABS_W     3D30
MOVEA_SRC_IMM       3D44
MOVEA_SRC_MODE      3C98
MOVEA_SRC_MODE_000  3CC8
MOVEA_SRC_MODE_001  3CD2
MOVEA_SRC_MODE_010  3CDC
MOVEA_SRC_MODE_011  3CE6
MOVEA_SRC_MODE_100  3CF0
MOVEA_SRC_MODE_101  3CFA
MOVEA_SRC_MODE_110  3D04
MOVEA_SRC_MODE_111  3D0E
MOVEA_WORMOVE_W     1E66
MOVECODE000         1E26
MOVECODE010         1E36
MOVECODE011         1E3E
MOVECODE100         1E46
MOVECODE101         1E4E
MOVECODE110         1E56
MOVECODE111         1E5E
MOVEMCODE0          1C74
MOVEMCODE1          1C7C
MOVEQ_PRINT_DATA    3DA4
MOVEWCODE000        1EB4
MOVEWCODE010        1EC4
MOVEWCODE011        1ECC
MOVEWCODE100        1ED4
MOVEWCODE101        1EDC
MOVEWCODE110        1EE4
MOVEWCODE111        1EEC
MOVE_ADJUST_L       3AA8
MOVE_ADJUST_W       3A9E
MOVE_DESTINATION    3B7A
MOVE_DST_ABS_L      3C32
MOVE_DST_ABS_W      3C28
MOVE_DST_MODE       3B98
MOVE_DST_MODE_000   3BC8
MOVE_DST_MODE_001   3BD2
MOVE_DST_MODE_010   3BDC
MOVE_DST_MODE_011   3BE6
MOVE_DST_MODE_100   3BF0
MOVE_DST_MODE_101   3BFA
MOVE_DST_MODE_110   3C04
MOVE_DST_MODE_111   3C0E
MOVE_END            3C3C
MOVE_SOURCE         3AB2
MOVE_SRC_ABS_L      3B66
MOVE_SRC_ABS_W      3B5C
MOVE_SRC_IMM        3B70
MOVE_SRC_MODE       3AC4
MOVE_SRC_MODE_000   3AF4
MOVE_SRC_MODE_001   3AFE
MOVE_SRC_MODE_010   3B08
MOVE_SRC_MODE_011   3B12
MOVE_SRC_MODE_100   3B1C
MOVE_SRC_MODE_101   3B26
MOVE_SRC_MODE_110   3B30
MOVE_SRC_MODE_111   3B3A
MULS_W_ABS_L        3E8E
MULS_W_ABS_W        3E84
MULS_W_DEST         3EA6
MULS_W_END          3EB8
MULS_W_IMM          3E98
MULS_W_MODE         3DEC
MULS_W_MODE_000     3E1C
MULS_W_MODE_001     3E26
MULS_W_MODE_010     3E30
MULS_W_MODE_011     3E3A
MULS_W_MODE_100     3E44
MULS_W_MODE_101     3E4E
MULS_W_MODE_110     3E58
MULS_W_MODE_111     3E62
MV                  485A
NEW_LINE            12FA
NEW_PAGE            4416
NOPCOMMAND          1BC4
NOPORCLRORRTSORJSR  1B2A
NOP_MOVEM_LEA_JSR_CLR_RTS  1C84
NOTDONE             43A6
NOTEVEN             12B4
OC_PARSE            137C
OPAREN              48AF
OPCODE_INVALID      1EF4
OR_ABS_L            4058
OR_ABS_W            404E
OR_BOROR_WOROR_LORDIVU  14FA
OR_DIVUCODE000      1548
OR_DIVUCODE001      1550
OR_DIVUCODE010      1558
OR_DIVUCODE011      1560
OR_DIVUCODE100      1568
OR_DIVUCODE101      1570
OR_DIVUCODE110      1578
OR_DIVUCODE111      1580
OR_END              407A
OR_EVAL_EA          3FAC
OR_IMM              4062
OR_MODE             3FBA
OR_MODE_000         3FEA
OR_MODE_001         3FF4
OR_MODE_010         4006
OR_MODE_011         4010
OR_MODE_1           3F5C
OR_MODE_100         401A
OR_MODE_101         4024
OR_MODE_110         402A
OR_MODE_111         4030
OR_MODE_2           3F86
OR_MODE_END         4074
OR_MODE_INVALID     4076
OR_OPMODE           3EDC
OR_OPMODE_000       3F0C
OR_OPMODE_001       3F16
OR_OPMODE_010       3F20
OR_OPMODE_011       3F2A
OR_OPMODE_100       3F34
OR_OPMODE_101       3F3E
OR_OPMODE_110       3F48
OR_OPMODE_111       3F52
PAUSE               442E
PERCENT             48AA
PLUS                48B3
POSTINC_000         2B5E
POSTINC_001         2B6A
POSTINC_010         2B76
POSTINC_011         2B82
POSTINC_100         2B8E
POSTINC_101         2B9A
POSTINC_110         2BA6
POSTINC_111         2BB2
POSTINC_JMP         2B2E
POUND               48A6
PREDEC_000          2C2E
PREDEC_001          2C3A
PREDEC_010          2C46
PREDEC_011          2C52
PREDEC_100          2C5E
PREDEC_101          2C6A
PREDEC_110          2C76
PREDEC_111          2C82
PREDEC_JMP          2BFE
PRINTLN             43F4
PRINT_HEXVALUE      12EC
PRINT_IMM_END       2B10
PRINT_IMM_L         2B0C
PS1                 445E
PS2                 44A8
QUIT                4436
RCOUNT              1E
REMAINDER           5050
REPEAT              1296
RERUN               437C
ROD_END             41AA
ROD_LSD_ASD         182E
ROD_LSD_ASDCODE00   1864
ROD_LSD_ASDCODE01   186A
ROD_LSD_ASDCODE10   1870
ROD_LSD_ASDCODE11   1878
ROD_MEM             40F4
ROD_MEM_ABS_L       41A0
ROD_MEM_ABS_W       4196
ROD_MEM_MODE        4106
ROD_MEM_MODE_000    4136
ROD_MEM_MODE_001    4140
ROD_MEM_MODE_010    414A
ROD_MEM_MODE_011    4154
ROD_MEM_MODE_100    415E
ROD_MEM_MODE_101    4168
ROD_MEM_MODE_110    4172
ROD_MEM_MODE_111    417C
ROD_REG             409C
ROD_REG_COUNT       40CA
ROD_REG_END         40DA
ROD_REG_REG         40C0
ROLCODE00           1716
ROLCODE01           171E
ROLCODE10           1726
ROLCODE11           172E
ROL_ROR             178C
ROL_RORCODE0        17B6
ROL_RORCODE1        17BC
RORCODE00           176C
RORCODE01           1774
RORCODE10           177C
RORCODE11           1784
RTSCOMMAND          1BBC
RUNAGAIN            6000
SHIFTLEFT           1204
SKIP_WRITE          43DE
SOMEASL             15DE
SOMEASR             1588
SOMECLR             1AD4
SOMELSL             168A
SOMELSR             1634
SOMEMOVEM           1C4A
SOMEROL             16E0
SOMEROR             1736
STACK               7000
START               1000
STR_LEN             5020
SUBCODE000          19E8
SUBCODE001          19F0
SUBCODE010          19F8
SUBCODE011          1A00
SUBCODE100          1A08
SUBCODE101          1A10
SUBCODE110          1A18
SUBCODE111          1A20
SUB_ABS_L           434A
SUB_ABS_W           4340
SUB_BORSUB_WORSUB_L  199A
SUB_END             436C
SUB_EVAL_EA         4296
SUB_IMM             4354
SUB_MODE            42A4
SUB_MODE_000        42D4
SUB_MODE_001        42E6
SUB_MODE_010        42F8
SUB_MODE_011        4302
SUB_MODE_1          4246
SUB_MODE_100        430C
SUB_MODE_101        4316
SUB_MODE_110        431C
SUB_MODE_111        4322
SUB_MODE_2          4270
SUB_MODE_END        4366
SUB_MODE_INVALID    4368
SUB_OPMODE          41C6
SUB_OPMODE_000      41F6
SUB_OPMODE_001      4200
SUB_OPMODE_010      420A
SUB_OPMODE_011      4214
SUB_OPMODE_100      421E
SUB_OPMODE_101      4228
SUB_OPMODE_110      4232
SUB_OPMODE_111      423C
TAB                 48B7
TABLEADDI_BORADDI_WORADDI_L  1DA0
TABLEADDQ_BORADDQ_WORADDQ_L  1A9C
TABLEADD_BORADD_WORADD_L  192A
TABLEAND_BORAND_WORAND_LORMULS_W  189C
TABLEASL_ASR        1816
TABLEBCCORBGTORBLE  14C2
TABLECMP_BORCMP_WORCMP_L  1A46
TABLELSL_LSR        17E0
TABLEMOVEA_LORMOVE_L  1DF6
TABLEMOVEA_WORMOVE_W  1E84
TABLENOPORCLRORRTSORJSR  1B5C
TABLENOP_MOVEM_LEA_JSR_CLR_RTS  1CA8
TABLEOR_BOROR_WOROR_LORDIVU  1518
TABLEROD_LSD_ASD    184C
TABLEROL_ROR        17AA
TABLESOMEASL        15FC
TABLESOMEASR        15A6
TABLESOMECLR        1AF2
TABLESOMELSL        16A8
TABLESOMELSR        1652
TABLESOMEMOVEM      1C68
TABLESOMEROL        16FE
TABLESOMEROR        1754
TABLESUB_BORSUB_WORSUB_L  19B8
UPDATE_PTR          2894
UPYES               59
WORD                4869
WRITE2MEM           43D2
WRITE_ENDL          43E6
WRITE_LINE          43B6
