00004100 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/2/2016 2:54:16 PM

00000000                             1  ******************************************************************************
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Brandon Authier (Hblkr), Jack S. Eldridge
00000000                             4  *              (JackScottie), Marijn Burger (marijnburger)
00000000                             5  * Date       : 16 May 2016
00000000                             6  * Description: An inverse assembler that will convert a memory
00000000                             7  *              image of instructions and data back to the display.
00000000                             8  *              The following will be decoded:
00000000                             9  *
00000000                            10  *              Addressing Modes
00000000                            11  *
00000000                            12  *                Data Register Direct
00000000                            13  *                Address Register Direct
00000000                            14  *                Address Register Indirect
00000000                            15  *                Immediate Data
00000000                            16  *                Address Register Indirect with Post Increment
00000000                            17  *                Address Register Indirect with Pre Decrement
00000000                            18  *                Absolute Long Address
00000000                            19  *                Absolute Word Address
00000000                            20  *
00000000                            21  *              Instructions
00000000                            22  *
00000000                            23  *                NOP
00000000                            24  *                MOVE
00000000                            25  *                MOVEA
00000000                            26  *                MOVEQ
00000000                            27  *                MOVEM
00000000                            28  *                ADD
00000000                            29  *                ADDA
00000000                            30  *                ADDI
00000000                            31  *                ADDQ
00000000                            32  *                SUB
00000000                            33  *                MULS
00000000                            34  *                DIVU
00000000                            35  *                LEA
00000000                            36  *                CLR
00000000                            37  *                AND
00000000                            38  *                OR
00000000                            39  *                LSL
00000000                            40  *                LSR
00000000                            41  *                ASR
00000000                            42  *                ASL
00000000                            43  *                ROL
00000000                            44  *                ROR
00000000                            45  *                CMP
00000000                            46  *                Bcc (BCC, BGT, BLE)
00000000                            47  *                JSR
00000000                            48  *                RTS
00000000                            49  *
00000000                            50  ******************************************************************************
00000000                            51  
00000000                            52  ******************************************************************************
00000000                            53  *           DEFINITIONS                                                      *
00000000                            54  ******************************************************************************
00000000  =00007000                 55  STACK     EQU   $7000               * Beginning address for stack pointer
00000000                            56  
00000000  =00005000                 57  BEGINADDR EQU   $5000               * Variable to hold beginning address value
00000000  =00005010                 58  ENDADDR   EQU   $5010               * Variable to hold ending address value
00000000                            59  
00000000  =00006000                 60  RUNAGAIN  EQU   $6000               * Value equivalent to 'true'
00000000                            61  
00001000                            62            ORG   $1000               * Program begins at address 1000
00001000                            63  
00001000                            64  *********** END DEFINITIONS **************************************************
00001000                            65  
00001000                            66  
00001000                            67  ******************************************************************************
00001000                            68  *           INCLUDES                                                         *
00001000                            69  ******************************************************************************
00001000                            70  
00001000                            71      INCLUDE 'IO.X68'
00001000                            72  
00001000                            73  
00001000                            74  
00001000  =00005020                 75  STR_LEN   EQU   $5020
00001000  =00005021                 76  HEXFLAG   EQU   $5021
00001000  =00005030                 77  HEXVALUE  EQU   $5030
00001000  =00005050                 78  REMAINDER EQU   $5050
00001000  =00000002                 79  MOD       EQU   2
00001000                            80  
00001000  =0000000D                 81  CR        EQU   $0D
00001000  =0000000A                 82  LF        EQU   $0A 
00001000                            83  
00001000                            84  
00001000                            85  GET_ADDRESSES
00001000  4EB9 000012BA             86      JSR         CLEARSCRN
00001006  4EB9 00001078             87      JSR         IO_WELCOME          * Run welcome subroutine
0000100C                            88              
0000100C                            89  GET_FIRST_ADDRESS
0000100C  43F9 00001356             90      LEA         PS1,A1              * Loads message into A1
00001012  4EB9 00001270             91      JSR         MAKE_CHECKS         * Get address and perform checks
00001018  0C38 0001 5021            92      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000101E  66EC                      93      BNE         GET_FIRST_ADDRESS   * If no, get hex again
00001020                            94     
00001020  21F8 5030 5000            95      MOVE.L      HEXVALUE,BEGINADDR  * Copy hex value to begin
00001026  4EB9 000012AC             96      JSR         NEW_LINE            * Space    
0000102C  4EB9 0000108C             97      JSR         CLEAR               * Clear values for next hex
00001032                            98      
00001032                            99  GET_SECOND_ADDRESS
00001032  43F9 000013A0            100      LEA         PS2,A1              * Loads message into A1
00001038  4EB9 00001270            101      JSR         MAKE_CHECKS         * Get address and perform checks
0000103E  0C38 0001 5021           102      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001044  66EC                     103      BNE         GET_SECOND_ADDRESS  * If no, get hex again
00001046                           104     
00001046  21F8 5030 5010           105      MOVE.L      HEXVALUE,ENDADDR    * Copy hex value to begin
0000104C  4EB9 000012AC            106      JSR         NEW_LINE            * Space    
00001052  4EB9 0000108C            107      JSR         CLEAR               * Clear values for next hex
00001058                           108      
00001058                           109  CHECK_BADDR_IS_LESS_THAN_EADDR
00001058  4EB9 0000121C            110      JSR         IS_LESSTHAN         *
0000105E  0C38 0001 5021           111      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001064  6700 0010                112      BEQ         FINISHED            * If yes, finished
00001068  43F9 00001430            113      LEA         ADR_ERR_NOTLT,A1    * Else, load error message
0000106E  6100 0256                114      BSR.W       ADDRESS_ERR
00001072  6100 308C                115      BSR.W       START      
00001076                           116  
00001076                           117  
00001076                           118  FINISHED
00001076  4E75                     119      RTS                             * Return to Disassembler
00001078                           120      
00001078                           121         
00001078                           122             
00001078                           123             
00001078                           124  
00001078                           125  IO_WELCOME: 
00001078  43F9 0000132E            126      LEA         INTRO,A1            * Loads message into A1
0000107E  103C 000E                127      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001082  4E4F                     128      TRAP        #15                 * Displays Intro Message 
00001084                           129        
00001084  4EB9 000012AC            130      JSR         NEW_LINE            * Call Subroutine        
0000108A  4E75                     131      RTS                             * Return from subroutine
0000108C                           132          
0000108C                           133  
0000108C                           134  
0000108C                           135  CLEAR
0000108C  4286                     136      CLR.L       D6                   * Clear
0000108E  31FC FFFF 5020           137      MOVE.W      #$FFFF,STR_LEN       * Clear   
00001094  21FC FFFFFFFF 5030       138      MOVE.L      #$FFFFFFFF,HEXVALUE  * Clear  
0000109C  21FC FFFFFFFF 5050       139      MOVE.L      #$FFFFFFFF,REMAINDER * Clear
000010A4  4E75                     140      RTS                              * Return to main to get hex
000010A6                           141  
000010A6                           142  
000010A6                           143          
000010A6                           144  GET_HEXSTRING
000010A6  103C 000E                145      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010AA  323C 004A                146      MOVE.W      #(PS2-PS1),D1       * The prompt string length
000010AE  4E4F                     147      TRAP        #15                 * Displays contents of A1
000010B0                           148   
000010B0  43F9 0000148B            149      LEA         HEXSTRING,A1        * Pointer to store the sentence
000010B6  103C 0002                150      MOVE.B      #2,D0               * Set up readstring function
000010BA  4E4F                     151      TRAP        #15                 * Get string from keyboard
000010BC  11C1 5020                152      MOVE.B      D1,STR_LEN          * Save length of input string
000010C0                           153      
000010C0  0C38 0008 5020           154      CMPI.B      #8,(STR_LEN)        * Is length > 8?
000010C6  6E00 0010                155      BGT         BAD_LENGTH          * If yes, get hex again
000010CA                           156         
000010CA  41F9 0000148B            157      LEA         HEXSTRING,A0        * Load address for verification     
000010D0  11FC 0001 5021           158      MOVE.B      #1,(HEXFLAG)   
000010D6  4E75                     159      RTS                             * Return from subroutine
000010D8                           160      
000010D8                           161  BAD_LENGTH
000010D8  11FC 0000 5021           162      MOVE.B      #0,(HEXFLAG)        * Bad length set HEXFLAG to false
000010DE  4E75                     163      RTS                             * Return to subroutine
000010E0                           164          
000010E0                           165  
000010E0                           166  
000010E0                           167  ASCII_TO_HEX      
000010E0  1618                     168      MOVE.B      (A0)+,D3            * Move first char into D3    
000010E2  0C03 0030                169      CMPI.B      #'0',D3             * Is Char equal to 0?
000010E6  6700 00D4                170      BEQ         HEXZERO            
000010EA  0C03 0031                171      CMPI.B      #'1',D3             * Is Char equal to 1?
000010EE  6700 00D4                172      BEQ         HEXONE                   
000010F2  0C03 0032                173      CMPI.B      #'2',D3             * Is Char equal to 2?
000010F6  6700 00D0                174      BEQ         HEXTWO    
000010FA  0C03 0033                175      CMPI.B      #'3',D3             * Is Char equal to 3?
000010FE  6700 00CC                176      BEQ         HEXTHREE    
00001102  0C03 0034                177      CMPI.B      #'4',D3             * Is Char equal to 4?
00001106  6700 00C8                178      BEQ         HEXFOUR    
0000110A  0C03 0035                179      CMPI.B      #'5',D3             * Is Char equal to 5?
0000110E  6700 00C4                180      BEQ         HEXFIVE    
00001112  0C03 0036                181      CMPI.B      #'6',D3             * Is Char equal to 6?
00001116  6700 00C0                182      BEQ         HEXSIX
0000111A  0C03 0037                183      CMPI.B      #'7',D3             * Is Char equal to 7?
0000111E  6700 00BC                184      BEQ         HEXSEVEN
00001122  0C03 0038                185      CMPI.B      #'8',D3             * Is Char equal to 8?
00001126  6700 00B8                186      BEQ         HEXEIGHT
0000112A  0C03 0039                187      CMPI.B      #'9',D3             * Is Char equal to 9?
0000112E  6700 00B4                188      BEQ         HEXNINE
00001132  0C03 0041                189      CMPI.B      #'A',D3             * Is Char equal to A?
00001136  6700 00B4                190      BEQ         HEXA                      
0000113A  0C03 0042                191      CMPI.B      #'B',D3             * Is Char equal to B?
0000113E  6700 00B4                192      BEQ         HEXB
00001142  0C03 0043                193      CMPI.B      #'C',D3             * Is Char equal to C?
00001146  6700 00B4                194      BEQ         HEXC
0000114A  0C03 0044                195      CMPI.B      #'D',D3             * Is Char equal to D?
0000114E  6700 00B4                196      BEQ         HEXD
00001152  0C03 0045                197      CMPI.B      #'E',D3             * Is Char equal to E?
00001156  6700 00B4                198      BEQ         HEXE
0000115A  0C03 0046                199      CMPI.B      #'F',D3             * Is Char equal to F?
0000115E  6700 00B4                200      BEQ         HEXF
00001162  0C03 0061                201      CMPI.B      #'a',D3             * Is Char equal to a?
00001166  6700 0084                202      BEQ         HEXA
0000116A  0C03 0062                203      CMPI.B      #'b',D3             * Is Char equal to b?
0000116E  6700 0084                204      BEQ         HEXB
00001172  0C03 0063                205      CMPI.B      #'c',D3             * Is Char equal to c?
00001176  6700 0084                206      BEQ         HEXC
0000117A  0C03 0064                207      CMPI.B      #'d',D3             * Is Char equal to d?
0000117E  6700 0084                208      BEQ         HEXD
00001182  0C03 0065                209      CMPI.B      #'e',D3             * Is Char equal to e?
00001186  6700 0084                210      BEQ         HEXE
0000118A  0C03 0066                211      CMPI.B      #'f',D3             * Is Char equal to f?
0000118E  6700 0084                212      BEQ         HEXF
00001192                           213      
00001192  11FC 0000 5021           214      MOVE.B      #0,HEXFLAG          * Set false    
00001198  6000 FEF2                215      BRA         CLEAR               * Clear some values
0000119C                           216      
0000119C                           217  FOUND  
0000119C  5338 5020                218      SUBI.B      #1,STR_LEN          * Decrease string by one
000011A0  0C38 0000 5020           219      CMPI.B      #0,STR_LEN          * Is string = 0?
000011A6  6600 000E                220      BNE         SHIFTLEFT           * If no, shift value left 
000011AA  21C6 5030                221      MOVE.L      D6,HEXVALUE         * If yes, save hex value
000011AE  11FC 0001 5021           222      MOVE.B      #1,HEXFLAG          * Set true
000011B4  4E75                     223      RTS                             * Then, return to main
000011B6                           224  
000011B6                           225  SHIFTLEFT
000011B6  E98E                     226      LSL.L       #4,D6               * Shift the value left
000011B8  6000 FF26                227      BRA         ASCII_TO_HEX        * Check next char
000011BC                           228  
000011BC                           229  HEXZERO
000011BC  0686 00000000            230      ADD.L       #$0,D6              * Add value
000011C2  60D8                     231      BRA         FOUND               * found, decrease strlen, shift value left    
000011C4                           232  HEXONE
000011C4  5286                     233      ADD.L       #$1,D6              * Add value
000011C6  60D4                     234      BRA         FOUND               * found, decrease strlen, shift value left
000011C8                           235  HEXTWO
000011C8  5486                     236      ADD.L       #$2,D6              * Add value
000011CA  60D0                     237      BRA         FOUND               * found, decrease strlen, shift value left
000011CC                           238  HEXTHREE
000011CC  5686                     239      ADD.L       #$3,D6              * Add value
000011CE  60CC                     240      BRA         FOUND               * found, decrease strlen, shift value left
000011D0                           241  HEXFOUR
000011D0  5886                     242      ADD.L       #$4,D6              * Add value
000011D2  60C8                     243      BRA         FOUND               * found, decrease strlen, shift value left
000011D4                           244  HEXFIVE
000011D4  5A86                     245      ADD.L       #$5,D6              * Add value
000011D6  60C4                     246      BRA         FOUND               * found, decrease strlen, shift value left
000011D8                           247  HEXSIX
000011D8  5C86                     248      ADD.L       #$6,D6              * Add value
000011DA  60C0                     249      BRA         FOUND               * found, decrease strlen, shift value left
000011DC                           250  HEXSEVEN
000011DC  5E86                     251      ADD.L       #$7,D6              * Add value
000011DE  60BC                     252      BRA         FOUND               * found, decrease strlen, shift value left
000011E0                           253  HEXEIGHT
000011E0  5086                     254      ADD.L       #$8,D6              * Add value
000011E2  60B8                     255      BRA         FOUND               * found, decrease strlen, shift value left
000011E4                           256  HEXNINE
000011E4  0686 00000009            257      ADD.L       #$9,D6              * Add value
000011EA  60B0                     258      BRA         FOUND               * found, decrease strlen, shift value left
000011EC                           259  HEXA
000011EC  0686 0000000A            260      ADD.L       #$A,D6              * Add value
000011F2  60A8                     261      BRA         FOUND               * found, decrease strlen, shift value left    
000011F4                           262  HEXB
000011F4  0686 0000000B            263      ADD.L       #$B,D6              * Add value
000011FA  60A0                     264      BRA         FOUND               * found, decrease strlen, shift value left
000011FC                           265  HEXC
000011FC  0686 0000000C            266      ADD.L       #$C,D6              * Add value
00001202  6098                     267      BRA         FOUND               * found, decrease strlen, shift value left
00001204                           268  HEXD
00001204  0686 0000000D            269      ADD.L       #$D,D6              * Add value
0000120A  6090                     270      BRA         FOUND               * found, decrease strlen, shift value left
0000120C                           271  HEXE
0000120C  0686 0000000E            272      ADD.L       #$E,D6              * Add value
00001212  6088                     273      BRA         FOUND               * found, decrease strlen, shift value left
00001214                           274  HEXF
00001214  0686 0000000F            275      ADD.L       #$F,D6              * Add value
0000121A  6080                     276      BRA         FOUND               * found, decrease strlen, shift value left 
0000121C                           277     
0000121C                           278  
0000121C                           279  
0000121C                           280  IS_LESSTHAN
0000121C  2838 5000                281      MOVE.L      BEGINADDR,D4        * Store beginning address in D4
00001220  2C38 5010                282      MOVE.L      ENDADDR,D6          * Store ending address in D6
00001224  B886                     283      CMP.L       D6,D4               * Is D4 < D6
00001226  6D00 000C                284      BLT         LT                  * Yes, mark true return to main
0000122A  11FC 0000 5021           285      MOVE.B      #0,HEXFLAG          * No, mark false
00001230  6000 FE5A                286      BRA         CLEAR               * Clear values, return to main
00001234                           287  
00001234                           288  LT
00001234  11FC 0001 5021           289      MOVE.B      #1,HEXFLAG          * Mark true
0000123A  4E75                     290      RTS                             * Return to main
0000123C                           291  
0000123C                           292  
0000123C                           293  
0000123C                           294  IS_HEX_EVEN      
0000123C  3606                     295      MOVE.W      D6,D3               * Move value to be modded into D3
0000123E  3A3C 0002                296      MOVE.W      #MOD,D5             * Move mod value into D5
00001242  86C5                     297      DIVU        D5,D3               * Divide D3 by D5
00001244  123C 0003                298      MOVE.B      #3,D1               * Set counter to shift value into word 
00001248                           299                                      * position    
00001248                           300  REPEAT 
00001248  E88B                     301      LSR.L       #4,D3               * Shift remainder to lower word
0000124A  57C9 FFFC                302      DBEQ        D1,REPEAT           * UNTIL [D0] = - 1
0000124E  4241                     303      CLR         D1                  * Clear
00001250                           304      
00001250  B6BC 00000000            305      CMP.L       #0,D3               * Is hex even?
00001256  6600 000E                306      BNE         NOTEVEN             * No, clear and go back to get_hex
0000125A  31C3 5050                307      MOVE.W      D3,REMAINDER        * Save remainder
0000125E  11FC 0001 5021           308      MOVE.B      #1,HEXFLAG          * Set true
00001264  4E75                     309      RTS                             * Return to main
00001266                           310  
00001266                           311  NOTEVEN
00001266  11FC 0000 5021           312      MOVE.B      #0,HEXFLAG          * Set false
0000126C  6000 FE1E                313      BRA         CLEAR               * Clear values
00001270                           314  
00001270                           315  
00001270                           316  
00001270                           317  MAKE_CHECKS
00001270  4EB8 10A6                318      JSR         GET_HEXSTRING       * Get string from user
00001274  0C38 0001 5021           319      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000127A  6600 0020                320      BNE         BAD_CHECK           * If no, get hex again
0000127E                           321     
0000127E  4EB8 10E0                322      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001282  0C38 0001 5021           323      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001288  6600 0012                324      BNE         BAD_CHECK           * If no, get hex again
0000128C                           325      
0000128C  4EB8 123C                326      JSR         IS_HEX_EVEN         * Check that hex value is even
00001290  0C38 0001 5021           327      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001296  6600 0004                328      BNE         BAD_CHECK           * If no, get hex again
0000129A                           329  
0000129A  4E75                     330      RTS                             * Return from subroutine
0000129C                           331  
0000129C                           332  BAD_CHECK    
0000129C  4E75                     333      RTS                             * Return from subroutine
0000129E                           334  
0000129E                           335  
0000129E                           336  
0000129E                           337  PRINT_HEXVALUE
0000129E  103C 000E                338      MOVE.B      #14,D0              * Moves the Task 14 into D0
000012A2  4E4F                     339      TRAP        #15                 * Displays contents of A1    
000012A4                           340      
000012A4  103C 0003                341      MOVE.B      #3,D0               * Moves the Task 3 into D0
000012A8  4E4F                     342      TRAP        #15                 * Displays contents of D1
000012AA                           343      
000012AA  4E75                     344      RTS                             * Return from subroutine                                  
000012AC                           345  
000012AC                           346  
000012AC                           347  NEW_LINE
000012AC  43F9 00001426            348      LEA         ENDL,A1             * Loads message into A1
000012B2  103C 000E                349      MOVE.B      #14,D0              * Moves the TRACK 14 into D0
000012B6  4E4F                     350      TRAP        #15                 * Displays New line
000012B8  4E75                     351      RTS                             * Return from subroutine
000012BA                           352  
000012BA                           353  
000012BA                           354  CLEARSCRN     
000012BA  103C 000B                355      MOVE.B      #11,D0              * Task 11 for clearing screen
000012BE  323C FF00                356      MOVE.W      #$FF00,D1           * FF00, Clear screen
000012C2  4E4F                     357      TRAP        #15                 * Wait for keystroke
000012C4  4E75                     358      RTS                             * Return from subroutine
000012C6                           359  
000012C6                           360  
000012C6                           361  
000012C6                           362  
000012C6                           363  ADDRESS_ERR
000012C6  6100 FFF2                364      BSR.W       CLEARSCRN           * Clear output before displaying error
000012CA  103C 000D                365      MOVE.B      #13,D0              * Moves the Task 13 into D0
000012CE  4E4F                     366      TRAP        #15                 * Displays contents of A1
000012D0  103C 0005                367      MOVE.B      #5,D0               * Read single character from 
000012D4  4E4F                     368      TRAP        #15                 * The keyboard into D1.B
000012D6  4E75                     369      RTS                             * Return from subroutine
000012D8                           370  
000012D8                           371  
000012D8                           372  
000012D8                           373  INVALID_DATA
000012D8  220E                     374      MOVE.L      A6,D1               * Move the address location to D1
000012DA  143C 0010                375      MOVE.B      #16,D2              * Move base 16 to D2
000012DE  103C 000F                376      MOVE.B      #15,D0              * Moves Task 15 into D0
000012E2  4E4F                     377      TRAP        #15                 * Displays contents of D1
000012E4                           378      
000012E4  43F9 00001429            379      LEA         TAB,A1              * Load TAB to A1
000012EA  103C 000E                380      MOVE.B      #14,D0              * Moves the Task 14 into D0
000012EE  4E4F                     381      TRAP        #15                 * Displays a tab of A1
000012F0                           382      
000012F0  43F9 000014DB            383      LEA         DATA,A1             * Load address location to A1
000012F6  103C 000E                384      MOVE.B      #14,D0              * Moves the Task 14 into D0
000012FA  4E4F                     385      TRAP        #15                 * Displays location of A1
000012FC                           386      
000012FC  43F9 00001429            387      LEA         TAB,A1              * Load TAB to A1
00001302  103C 000E                388      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001306  4E4F                     389      TRAP        #15                 * Displays a tab of A1
00001308                           390      
00001308  43F9 0000142E            391      LEA         DOLLAR,A1           * Load TAB to A1
0000130E  103C 000E                392      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001312  4E4F                     393      TRAP        #15                 * Displays a tab of A1
00001314                           394      
00001314  3216                     395      MOVE.W      (A6),D1             * Move the address value to D1
00001316  143C 0010                396      MOVE.B      #16,D2              * Move base 16 to D2
0000131A  103C 000F                397      MOVE.B      #15,D0              * Moves Task 15 into D0
0000131E  4E4F                     398      TRAP        #15                 * Displays value of D1
00001320                           399      
00001320  43F9 00001426            400      LEA         ENDL,A1             * Load TAB to A1
00001326  103C 000E                401      MOVE.B      #14,D0              * Moves the Task 14 into D0
0000132A  4E4F                     402      TRAP        #15                 * Displays a tab of A1
0000132C                           403      
0000132C  4E75                     404      RTS                             * Return from subroutine
0000132E                           405  
0000132E                           406  
0000132E                           407  
0000132E                           408  
0000132E= 57 45 4C 43 4F 4D ...    409  INTRO           DC.B 'WELCOME!',CR,LF,'THIS IS A 68K DISASSEMBLER.',CR,LF,0
00001356= 50 4C 45 41 53 45 ...    410  PS1             DC.B 'PLEASE ENTER THE STARTING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000013A0= 50 4C 45 41 53 45 ...    411  PS2             DC.B 'PLEASE ENTER THE ENDING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000013E8= 0D 0A 42 45 47 49 ...    412  BMESSAGE        DC.B CR,LF,'BEGINNING ADDRESS GIVEN IS: ',0
00001407= 0D 0A 45 4E 44 49 ...    413  EMESSAGE        DC.B CR,LF,'ENDING ADDRESS GIVEN IS   : ',0
00001426= 0D 0A 00                 414  ENDL            DC.B CR,LF,0
00001429= 20 20 20 20 00           415  TAB             DC.B '    ',0
0000142E= 24 00                    416  DOLLAR          DC.B '$',0
00001430                           417  
00001430= 54 48 45 20 42 45 ...    418  ADR_ERR_NOTLT   DC.B 'THE BEGINNING ADDRESS MUST BE LESS THAN THE ENDING ADDRESS.',CR,LF,'PRESS ANY KEY TO TRY AGAIN...',0
0000148B                           419  
0000148B                           420  HEXSTRING       DS.B 80             * Var for hex string
000014DB                           421  
000014DB= 44 41 54 41 00           422  DATA            DC.B 'DATA',0
000014E0                           423  
000014E0                           424  
000014E0                           425  
000014E0                           426  
000014E0                           427  
000014E0                           428  
000014E0                           429  
000014E0                           430  
000014E0                           431  
000014E0                           432  
000014E0                           433  -------------------- end include --------------------
000014E0                           434      INCLUDE 'OpCodes.X68'
000014E0                           435  
000014E0                           436          INCLUDE 'OCMessages.X68'
000014E0                           437  
000014E0                           438  
000014E0  =0000000D                439  CR      EQU     $0D
000014E0  =0000000A                440  LF      EQU     $0A
000014E0= 4E 4F 50 0D 0A 00        441  MESSAGENOP DC.B    'NOP',CR,LF, 0
000014E6                           442  
000014E6= 4D 4F 56 45 2E 57 ...    443  MESSAGEMOVEW DC.B    'MOVE.W',CR,LF, 0
000014EF= 4D 4F 56 45 2E 4C ...    444  MESSAGEMOVEL DC.B    'MOVE.L',CR,LF, 0
000014F8= 4D 4F 56 45 2E 42 ...    445  MESSAGEMOVEB DC.B    'MOVE.B',CR,LF, 0
00001501                           446  
00001501= 41 44 44 49 2E 57 ...    447  MESSAGEADDIW DC.B    'ADDI.W',CR,LF, 0
0000150A= 41 44 44 49 2E 4C ...    448  MESSAGEADDIL DC.B    'ADDI.L',CR,LF, 0
00001513= 41 44 44 49 2E 42 ...    449  MESSAGEADDIB DC.B    'ADDI.B',CR,LF, 0
0000151C                           450  
0000151C= 4D 4F 56 45 41 2E ...    451  MESSAGEMOVEAL DC.B    'MOVEA.L',CR,LF, 0
00001526= 4D 4F 56 45 41 2E ...    452  MESSAGEMOVEAW DC.B    'MOVEA.W',CR,LF, 0
00001530                           453  
00001530= 4D 4F 56 45 4D 2E ...    454  MESSAGEMOVEML DC.B    'MOVEM.L',CR,LF, 0
0000153A= 4D 4F 56 45 4D 2E ...    455  MESSAGEMOVEMW DC.B    'MOVEM.W',CR,LF, 0
00001544                           456  
00001544= 4A 53 52 0D 0A 00        457  MESSAGEJSR DC.B    'JSR',CR,LF, 0
0000154A                           458  
0000154A= 43 4C 52 0D 0A 00        459  MESSAGECLR DC.B    'CLR',CR,LF, 0
00001550                           460  
00001550= 52 54 53 0D 0A 00        461  MESSAGERTS DC.B    'RTS',CR,LF, 0
00001556                           462  
00001556= 4C 45 41 0D 0A 00        463  MESSAGELEA DC.B    'LEA',CR,LF, 0
0000155C                           464  
0000155C= 43 4C 52 2E 42 0D ...    465  MESSAGECLRB DC.B    'CLR.B',CR,LF, 0
00001564= 43 4C 52 2E 57 0D ...    466  MESSAGECLRW DC.B    'CLR.W',CR,LF, 0
0000156C= 43 4C 52 2E 4C 0D ...    467  MESSAGECLRL DC.B    'CLR.L',CR,LF, 0
00001574                           468  
00001574= 41 44 44 51 2E 42 ...    469  MESSAGEADDQB DC.B    'ADDQ.B',CR,LF, 0
0000157D= 41 44 44 51 2E 57 ...    470  MESSAGEADDQW DC.B    'ADDQ.W',CR,LF, 0
00001586= 41 44 44 51 2E 4C ...    471  MESSAGEADDQL DC.B    'ADDQ.L',CR,LF, 0
0000158F                           472  
0000158F= 43 4D 50 2E 42 0D ...    473  MESSAGECMPB DC.B    'CMP.B',CR,LF, 0
00001597= 43 4D 50 2E 57 0D ...    474  MESSAGECMPW DC.B    'CMP.W',CR,LF, 0
0000159F= 43 4D 50 2E 4C 0D ...    475  MESSAGECMPL DC.B    'CMP.L',CR,LF, 0
000015A7                           476  
000015A7= 53 55 42 2E 42 0D ...    477  MESSAGESUBB DC.B    'SUB.B',CR,LF, 0
000015AF= 53 55 42 2E 57 0D ...    478  MESSAGESUBW DC.B    'SUB.W',CR,LF, 0
000015B7= 53 55 42 2E 4C 0D ...    479  MESSAGESUBL DC.B    'SUB.L',CR,LF, 0
000015BF                           480  
000015BF= 41 44 44 2E 42 0D ...    481  MESSAGEADDB DC.B    'ADD.B',CR,LF, 0
000015C7= 41 44 44 2E 57 0D ...    482  MESSAGEADDW DC.B    'ADD.W',CR,LF, 0
000015CF= 41 44 44 2E 4C 0D ...    483  MESSAGEADDL DC.B    'ADD.L',CR,LF, 0
000015D7                           484  
000015D7= 41 44 44 41 2E 57 ...    485  MESSAGEADDAW DC.B    'ADDA.W',CR,LF, 0
000015E0= 41 44 44 41 2E 4C ...    486  MESSAGEADDAL DC.B    'ADDA.L',CR,LF, 0
000015E9                           487  
000015E9= 4D 4F 56 45 51 2E ...    488  MESSAGEMOVEQL DC.B    'MOVEQ.L',CR,LF, 0
000015F3                           489  
000015F3= 41 4E 44 2E 42 0D ...    490  MESSAGEANDB DC.B    'AND.B',CR,LF, 0
000015FB= 41 4E 44 2E 57 0D ...    491  MESSAGEANDW DC.B    'AND.W',CR,LF, 0
00001603= 41 4E 44 2E 4C 0D ...    492  MESSAGEANDL DC.B    'AND.L',CR,LF, 0
0000160B                           493  
0000160B= 4D 55 4C 53 2E 57 ...    494  MESSAGEMULSW DC.B    'MULS.W',CR,LF, 0
00001614                           495  
00001614= 41 53 52 2E 42 0D ...    496  MESSAGEASRB DC.B    'ASR.B',CR,LF, 0
0000161C= 41 53 52 2E 57 0D ...    497  MESSAGEASRW DC.B    'ASR.W',CR,LF, 0
00001624= 41 53 52 2E 4C 0D ...    498  MESSAGEASRL DC.B    'ASR.L',CR,LF, 0
0000162C                           499  
0000162C= 41 53 4C 2E 42 0D ...    500  MESSAGEASLB DC.B    'ASL.B',CR,LF, 0
00001634= 41 53 4C 2E 57 0D ...    501  MESSAGEASLW DC.B    'ASL.W',CR,LF, 0
0000163C= 41 53 4C 2E 4C 0D ...    502  MESSAGEASLL DC.B    'ASL.L',CR,LF, 0
00001644                           503  
00001644= 52 4F 52 2E 42 0D ...    504  MESSAGERORB DC.B    'ROR.B',CR,LF, 0
0000164C= 52 4F 52 2E 57 0D ...    505  MESSAGERORW DC.B    'ROR.W',CR,LF, 0
00001654= 52 4F 52 2E 4C 0D ...    506  MESSAGERORL DC.B    'ROR.L',CR,LF, 0
0000165C                           507  
0000165C= 52 4F 4C 2E 42 0D ...    508  MESSAGEROLB DC.B    'ROL.B',CR,LF, 0
00001664= 52 4F 4C 2E 57 0D ...    509  MESSAGEROLW DC.B    'ROL.W',CR,LF, 0
0000166C= 52 4F 4C 2E 4C 0D ...    510  MESSAGEROLL DC.B    'ROL.L',CR,LF, 0
00001674                           511  
00001674= 4C 53 52 2E 42 0D ...    512  MESSAGELSRB DC.B    'LSR.B',CR,LF, 0
0000167C= 4C 53 52 2E 57 0D ...    513  MESSAGELSRW DC.B    'LSR.W',CR,LF, 0
00001684= 4C 53 52 2E 4C 0D ...    514  MESSAGELSRL DC.B    'LSR.L',CR,LF, 0
0000168C                           515  
0000168C= 4C 53 4C 2E 42 0D ...    516  MESSAGELSLB DC.B    'LSL.B',CR,LF, 0
00001694= 4C 53 4C 2E 57 0D ...    517  MESSAGELSLW DC.B    'LSL.W',CR,LF, 0
0000169C= 4C 53 4C 2E 4C 0D ...    518  MESSAGELSLL DC.B    'LSL.L',CR,LF, 0
000016A4                           519  
000016A4= 4F 52 2E 42 0D 0A 00     520  MESSAGEORB DC.B    'OR.B',CR,LF, 0
000016AB= 4F 52 2E 57 0D 0A 00     521  MESSAGEORW DC.B    'OR.W',CR,LF, 0
000016B2= 4F 52 2E 4C 0D 0A 00     522  MESSAGEORL DC.B    'OR.L',CR,LF, 0
000016B9                           523  
000016B9= 44 49 56 55 2E 57 ...    524  MESSAGEDIVUW DC.B    'DIVU.W',CR,LF, 0
000016C2                           525  
000016C2= 42 43 43 0D 0A 00        526  MESSAGEBCC DC.B    'BCC',CR,LF, 0
000016C8= 42 47 54 0D 0A 00        527  MESSAGEBGT DC.B    'BGT',CR,LF, 0
000016CE= 42 4C 45 0D 0A 00        528  MESSAGEBLE DC.B    'BLE',CR,LF, 0
000016D4                           529  
000016D4= 54 68 61 74 20 69 ...    530  MESSAGEOPCODE_INVALID DC.B    'That is not an opcode!',CR,LF, 0
000016ED                           531  
000016ED                           532  
000016ED                           533  
000016ED                           534  
000016ED                           535  -------------------- end include --------------------
000016ED                           536  
000016ED                           537  
000016ED                           538  OC_PARSE:
000016EE  48E7 FFFE                539          MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000016F2  41F9 0000170A            540          LEA         initial_table,A0 ; Index into the table
000016F8  4280                     541          CLR.L       D0              ; Zero it
000016FA  3012                     542          MOVE.W      (A2),D0         ; We'll play with it here
000016FC  123C 000C                543          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001700  E268                     544          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001702                           545                                      ; and the rest are zeroed out)
00001702  C0FC 0006                546          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001706  4EF0 0000                547          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000170A                           548  
0000170A                           549  initial_table:
0000170A  4EF9 0000176A            550          JMP         code0000        ; ADDI.B, ADDI.W, or ADDI.L
00001710  4EF9 00001770            551          JMP         code0001        ; MOVE.B
00001716  4EF9 0000177C            552          JMP         code0010        ; MOVEA.L or MOVE.L
0000171C  4EF9 00001782            553          JMP         code0011        ; MOVEA.W or MOVE.W
00001722  4EF9 00001788            554          JMP         code0100        ; NOP or MOVEM.W or MOVEM.L or LEA or CLR.B or CLR.W or CLR.L or JSR or RTS or MULS.W
00001728  4EF9 00001794            555          JMP         code0101        ; ADDQ.B or ADDQ.W or ADDQ.L
0000172E  4EF9 000017A0            556          JMP         code0110        ; BCC or BGT or BLE
00001734  4EF9 000017AC            557          JMP         code0111        ; MOVEQ.L
0000173A  4EF9 000017B8            558          JMP         code1000        ; OR.B or OR.W or OR.L or DIVU (DIVU is either word or long depending on ea)
00001740  4EF9 000017C4            559          JMP         code1001        ; SUB.B or SUB.W or SUB.L
00001746  4EF9 000017D0            560          JMP         code1010
0000174C  4EF9 000017D8            561          JMP         code1011        ; CMP.B or CMP.W or CMP.L
00001752  4EF9 000017E4            562          JMP         code1100        ; AND_BorAND_WorAND_LorMULS_W
00001758  4EF9 000017F0            563          JMP         code1101        ; ADD.B or ADD.W or ADD.L
0000175E  4EF9 000017FC            564          JMP         code1110        ; ROd_LSd_ASd
00001764  4EF9 00001808            565          JMP         code1111
0000176A                           566  
0000176A  4EB9 000020F4            567  code0000 JSR        ADDI_BorADDI_WorADDI_L
00001770  4EB9 00002852            568  code0001 JSR        ISMOVEB
00001776  4EB9 00001810            569           JSR        DONE
0000177C  4EB9 0000214A            570  code0010 JSR        MOVEA_LorMOVE_L
00001782  4EB9 000021D8            571  code0011 JSR        MOVEA_WorMOVE_W
00001788  4EB9 00001FF6            572  code0100 JSR        NOP_MOVEM_LEA_JSR_CLR_RTS
0000178E  4EB9 00001810            573           JSR        DONE
00001794  4EB9 00001DF0            574  code0101 JSR        ADDQ_BorADDQ_WorADDQ_L
0000179A  4EB9 00001810            575           JSR        DONE
000017A0  4EB9 00001816            576  code0110 JSR        BCCorBGTorBLE
000017A6  4EB9 00001810            577           JSR        DONE
000017AC  4EB9 000026D4            578  code0111 JSR        ISMOVEQL
000017B2  4EB9 00001810            579           JSR        DONE
000017B8  4EB9 0000186C            580  code1000 JSR        OR_BorOR_WorOR_LorDIVU
000017BE  4EB9 00001810            581           JSR        DONE
000017C4  4EB9 00001D0C            582  code1001 JSR        SUB_BorSUB_WorSUB_L
000017CA  4EB9 00001810            583           JSR        DONE
000017D0  4EB9 00002266            584  code1010 JSR    OPCODE_INVALID              ;INVALID
000017D6  4E75                     585           RTS
000017D8  4EB9 00001D9A            586  code1011 JSR        CMP_BorCMP_WorCMP_L
000017DE  4EB9 00001810            587           JSR        DONE
000017E4  4EB9 00001BF0            588  code1100 JSR        AND_BorAND_WorAND_LorMULS_W
000017EA  4EB9 00001810            589           JSR        DONE
000017F0  4EB9 00001C7E            590  code1101 JSR        ADD_BorADD_WorADD_L
000017F6  4EB9 00001810            591           JSR        DONE
000017FC  4EB9 00001BA0            592  code1110 JSR        ROd_LSd_ASd
00001802  4EB9 00001810            593           JSR        DONE
00001808  4EB9 00002266            594  code1111 JSR    OPCODE_INVALID              ;INVALID
0000180E  4E75                     595           RTS
00001810  4CDF 7FFF                596  DONE    MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00001814  4E75                     597          RTS
00001816                           598  
00001816  41F9 00001834            599  BCCorBGTorBLE       LEA     tableBCCorBGTorBLE, A0            ; Index into the table
0000181C  4280                     600                      CLR.L   D0                  ; Zero it
0000181E  3016                     601                      MOVE.W  (A6),D0         ; We'll play with it here
00001820  123C 0006                602                      MOVE.B  #6,D1           ; Shift 6 bits left
00001824  E360                     603                      ASL.W   D1,D0
00001826  123C 000E                604                      MOVE.B  #14,D1           ; Shift 14 bits to the right
0000182A  E268                     605                      LSR.W   D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000182C                           606                                      ; and the rest are zeroed out)
0000182C  C0FC 0006                607                      MULU    #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001830  4EF0 0000                608                      JMP     0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
00001834                           609  
00001834  4EF9 0000184C            610  tableBCCorBGTorBLE   JMP    BCCorBGTorBLEcode00   ; BCC
0000183A  4EF9 00001854            611                       JMP    BCCorBGTorBLEcode01   ;
00001840  4EF9 0000185C            612                       JMP    BCCorBGTorBLEcode10   ; BGT
00001846  4EF9 00001864            613                       JMP    BCCorBGTorBLEcode11   ; BLE
0000184C                           614  
0000184C                           615  
0000184C                           616  
0000184C  4EB9 00002276            617  BCCorBGTorBLEcode00    JSR     ISBCC
00001852  4E75                     618                         RTS
00001854  4EB9 00002266            619  BCCorBGTorBLEcode01    JSR    OPCODE_INVALID              ;INVALID
0000185A  4E75                     620                         RTS
0000185C  4EB9 00002290            621  BCCorBGTorBLEcode10    JSR     ISBGT
00001862  4E75                     622                         RTS
00001864  4EB9 000022AA            623  BCCorBGTorBLEcode11    JSR     ISBLE
0000186A  4E75                     624                         RTS
0000186C                           625  
0000186C                           626  
0000186C                           627  OR_BorOR_WorOR_LorDIVU:
0000186C  41F9 0000188A            628          LEA         tableOR_BorOR_WorOR_LorDIVU, A0 ; Index into the table
00001872  4280                     629          CLR.L       D0              ; Zero it
00001874  3016                     630          MOVE.W      (A6),D0     ; We'll play with it here
00001876  123C 0007                631          MOVE.B      #7,D1           ; Shift 7 bits left
0000187A  E360                     632          ASL.W       D1,D0
0000187C  123C 000D                633          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001880  E268                     634          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001882                           635                                      ; and the rest are zeroed out)
00001882  C0FC 0006                636          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001886  4EF0 0000                637          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000188A                           638  
0000188A                           639  tableOR_BorOR_WorOR_LorDIVU
0000188A  4EF9 000018BA            640          JMP         OR_DIVUcode000  ; OR.B
00001890  4EF9 000018C2            641          JMP         OR_DIVUcode001  ; OR.W
00001896  4EF9 000018CA            642          JMP         OR_DIVUcode010  ; OR.L
0000189C  4EF9 000018D2            643          JMP         OR_DIVUcode011  ; DIVU.W
000018A2  4EF9 000018DA            644          JMP         OR_DIVUcode100  ; OR.B
000018A8  4EF9 000018E2            645          JMP         OR_DIVUcode101  ; OR.W
000018AE  4EF9 000018EA            646          JMP         OR_DIVUcode110  ; OR.L
000018B4  4EF9 000018F2            647          JMP         OR_DIVUcode111  ; INVALID
000018BA                           648  
000018BA                           649  
000018BA  4EB9 000022DE            650  OR_DIVUcode000 JSR  ISORB
000018C0  4E75                     651                 RTS
000018C2  4EB9 000022F8            652  OR_DIVUcode001 JSR  ISORW
000018C8  4E75                     653                 RTS
000018CA  4EB9 00002312            654  OR_DIVUcode010 JSR  ISORL
000018D0  4E75                     655                 RTS
000018D2  4EB9 000022C4            656  OR_DIVUcode011 JSR  ISDIVUW
000018D8  4E75                     657                 RTS
000018DA  4EB9 000022DE            658  OR_DIVUcode100 JSR  ISORB
000018E0  4E75                     659                 RTS
000018E2  4EB9 000022F8            660  OR_DIVUcode101 JSR  ISORW
000018E8  4E75                     661                 RTS
000018EA  4EB9 00002312            662  OR_DIVUcode110 JSR  ISORL
000018F0  4E75                     663                 RTS
000018F2  4EB9 00002266            664  OR_DIVUcode111 JSR    OPCODE_INVALID              ;INVALID
000018F8  4E75                     665                 RTS
000018FA                           666  
000018FA                           667  
000018FA                           668  someASR:
000018FA  41F9 00001918            669          LEA         tableSomeASR, A0 ; Index into the table
00001900  4280                     670          CLR.L       D0              ; Zero it
00001902  3016                     671          MOVE.W      (A6),D0         ; We'll play with it here
00001904  123C 0008                672          MOVE.B      #8,D1           ; Shift 8 bits left
00001908  E360                     673          ASL.W       D1,D0
0000190A  123C 000E                674          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000190E  E268                     675          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001910                           676                                      ; and the rest are zeroed out)
00001910  C0FC 0006                677          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001914  4EF0 0000                678          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001918                           679  
00001918                           680  tableSomeASR:
00001918  4EF9 00001930            681          JMP         ASRcode00       *ASR.B
0000191E  4EF9 00001938            682          JMP         ASRcode01       *ASR.W
00001924  4EF9 00001940            683          JMP         ASRcode10       *ASR.L
0000192A  4EF9 00001948            684          JMP         ASRcode11       *ASR.W
00001930                           685  
00001930  4EB9 0000232C            686  ASRcode00 JSR       ISASRB
00001936  4E75                     687            RTS
00001938  4EB9 00002346            688  ASRcode01 JSR       ISASRW
0000193E  4E75                     689            RTS
00001940  4EB9 00002360            690  ASRcode10 JSR       ISASRL
00001946  4E75                     691            RTS
00001948  4EB9 00002346            692  ASRcode11 JSR       ISASRW
0000194E  4E75                     693            RTS
00001950                           694  
00001950                           695  someASL:
00001950  41F9 0000196E            696          LEA         tableSomeASL, A0 ; Index into the table
00001956  4280                     697          CLR.L       D0              ; Zero it
00001958  3016                     698          MOVE.W      (A6),D0     ; We'll play with it here
0000195A  123C 0008                699          MOVE.B      #8,D1           ; Shift 8 bits left
0000195E  E360                     700          ASL.W       D1,D0
00001960  123C 000E                701          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001964  E268                     702          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001966                           703                                      ; and the rest are zeroed out)
00001966  C0FC 0006                704          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000196A  4EF0 0000                705          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000196E                           706  
0000196E                           707  tableSomeASL:
0000196E  4EF9 00001986            708          JMP         ASLcode00       *ASL.B
00001974  4EF9 0000198E            709          JMP         ASLcode01       *ASL.W
0000197A  4EF9 00001996            710          JMP         ASLcode10       *ASL.L
00001980  4EF9 0000199E            711          JMP         ASLcode11       *ASL.W
00001986                           712  
00001986  4EB9 0000237A            713  ASLcode00 JSR       ISASLB
0000198C  4E75                     714            RTS
0000198E  4EB9 00002394            715  ASLcode01 JSR       ISASLW
00001994  4E75                     716            RTS
00001996  4EB9 000023AE            717  ASLcode10 JSR       ISASLL
0000199C  4E75                     718            RTS
0000199E  4EB9 00002394            719  ASLcode11 JSR       ISASLW
000019A4  4E75                     720            RTS
000019A6                           721  
000019A6                           722  someLSR:
000019A6  41F9 000019C4            723          LEA         tableSomeLSR, A0 ; Index into the table
000019AC  4280                     724          CLR.L       D0              ; Zero it
000019AE  3016                     725          MOVE.W      (A6),D0     ; We'll play with it here
000019B0  123C 0008                726          MOVE.B      #8,D1           ; Shift 8 bits left
000019B4  E360                     727          ASL.W       D1,D0
000019B6  123C 000E                728          MOVE.B      #14,D1          ; Shift 14 bits to the right
000019BA  E268                     729          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000019BC                           730                                      ; and the rest are zeroed out)
000019BC  C0FC 0006                731          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000019C0  4EF0 0000                732          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000019C4                           733  
000019C4                           734  tableSomeLSR:
000019C4  4EF9 000019DC            735          JMP         LSRcode00       *LSR.B
000019CA  4EF9 000019E4            736          JMP         LSRcode01       *LSR.W
000019D0  4EF9 000019EC            737          JMP         LSRcode10       *LSR.L
000019D6  4EF9 000019F4            738          JMP         LSRcode11       *LSR.W
000019DC  4EB9 000023C8            739  LSRcode00 JSR       ISLSRB
000019E2  4E75                     740            RTS
000019E4  4EB9 000023E2            741  LSRcode01 JSR       ISLSRW
000019EA  4E75                     742            RTS
000019EC  4EB9 000023FC            743  LSRcode10 JSR       ISLSRL
000019F2  4E75                     744            RTS
000019F4  4EB9 000023E2            745  LSRcode11 JSR       ISLSRW
000019FA  4E75                     746            RTS
000019FC                           747  
000019FC                           748  someLSL:
000019FC  41F9 00001A1A            749          LEA         tableSomeLSL, A0 ; Index into the table
00001A02  4280                     750          CLR.L       D0              ; Zero it
00001A04  3016                     751          MOVE.W      (A6),D0     ; We'll play with it here
00001A06  123C 0008                752          MOVE.B      #8,D1           ; Shift 8 bits left
00001A0A  E360                     753          ASL.W       D1,D0
00001A0C  123C 000E                754          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001A10  E268                     755          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001A12                           756                                      ; and the rest are zeroed out)
00001A12  C0FC 0006                757          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001A16  4EF0 0000                758          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A1A                           759  
00001A1A                           760  tableSomeLSL:
00001A1A  4EF9 00001A32            761          JMP         LSLcode00       *LSL.B
00001A20  4EF9 00001A3A            762          JMP         LSLcode01       *LSL.W
00001A26  4EF9 00001A42            763          JMP         LSLcode10       *LSL.L
00001A2C  4EF9 00001A4A            764          JMP         LSLcode11       *LSL.W
00001A32                           765  
00001A32  4EB9 00002416            766  LSLcode00 JSR       ISLSLB
00001A38  4E75                     767            RTS
00001A3A  4EB9 00002430            768  LSLcode01 JSR       ISLSLW
00001A40  4E75                     769            RTS
00001A42  4EB9 0000244A            770  LSLcode10 JSR       ISLSLL
00001A48  4E75                     771            RTS
00001A4A  4EB9 00002430            772  LSLcode11 JSR       ISLSLW
00001A50  4E75                     773            RTS
00001A52                           774  
00001A52                           775  someROL:
00001A52  41F9 00001A70            776          LEA         tableSomeROL, A0 ; Index into the table
00001A58  4280                     777          CLR.L       D0              ; Zero it
00001A5A  3016                     778          MOVE.W      (A6),D0     ; We'll play with it here
00001A5C  123C 0008                779          MOVE.B      #8,D1           ; Shift 8 bits left
00001A60  E360                     780          ASL.W       D1,D0
00001A62  123C 000E                781          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001A66  E268                     782          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001A68                           783                                      ; and the rest are zeroed out)
00001A68  C0FC 0006                784          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001A6C  4EF0 0000                785          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A70                           786  
00001A70                           787  tableSomeROL:
00001A70  4EF9 00001A88            788          JMP         ROLcode00       *ROL.B
00001A76  4EF9 00001A90            789          JMP         ROLcode01       *ROL.W
00001A7C  4EF9 00001A98            790          JMP         ROLcode10       *ROL.L
00001A82  4EF9 00001AA0            791          JMP         ROLcode11       *ROL.W
00001A88                           792  
00001A88  4EB9 000024B2            793  ROLcode00 JSR       ISROLB
00001A8E  4E75                     794            RTS
00001A90  4EB9 000024CC            795  ROLcode01 JSR       ISROLW
00001A96  4E75                     796            RTS
00001A98  4EB9 000024E6            797  ROLcode10 JSR       ISROLL
00001A9E  4E75                     798            RTS
00001AA0  4EB9 000024CC            799  ROLcode11 JSR       ISROLW
00001AA6  4E75                     800            RTS
00001AA8                           801  
00001AA8                           802  
00001AA8                           803  someROR:
00001AA8  41F9 00001AC6            804          LEA         tableSomeROR, A0 ; Index into the table
00001AAE  4280                     805          CLR.L       D0              ; Zero it
00001AB0  3016                     806          MOVE.W      (A6),D0     ; We'll play with it here
00001AB2  123C 0008                807          MOVE.B      #8,D1           ; Shift 8 bits left
00001AB6  E360                     808          ASL.W       D1,D0
00001AB8  123C 000E                809          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001ABC  E268                     810          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001ABE                           811                                      ; and the rest are zeroed out)
00001ABE  C0FC 0006                812          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001AC2  4EF0 0000                813          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001AC6                           814  
00001AC6                           815  tableSomeROR:
00001AC6  4EF9 00001ADE            816          JMP         RORcode00       *ROR.B
00001ACC  4EF9 00001AE6            817          JMP         RORcode01       *ROR.W
00001AD2  4EF9 00001AEE            818          JMP         RORcode10       *ROR.L
00001AD8  4EF9 00001AF6            819          JMP         RORcode11       *ROR.W
00001ADE                           820  
00001ADE  4EB9 00002464            821  RORcode00 JSR       ISRORB
00001AE4  4E75                     822            RTS
00001AE6  4EB9 0000247E            823  RORcode01 JSR       ISRORW
00001AEC  4E75                     824            RTS
00001AEE  4EB9 00002498            825  RORcode10 JSR       ISRORL
00001AF4  4E75                     826            RTS
00001AF6  4EB9 0000247E            827  RORcode11 JSR       ISRORW
00001AFC  4E75                     828            RTS
00001AFE                           829  
00001AFE                           830  ROL_ROR:
00001AFE  41F9 00001B1C            831          LEA         tableROL_ROR, A0 ; Index into the table
00001B04  4280                     832          CLR.L       D0              ; Zero it
00001B06  3016                     833          MOVE.W      (A6),D0     ; We'll play with it here
00001B08  123C 0007                834          MOVE.B      #7,D1           ; Shift 7 bits left
00001B0C  E360                     835          ASL.W       D1,D0
00001B0E  123C 000F                836          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001B12  E268                     837          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B14                           838                                      ; and the rest are zeroed out)
00001B14  C0FC 0006                839          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B18  4EF0 0000                840          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B1C                           841  
00001B1C                           842  tableROL_ROR:
00001B1C  4EF9 00001B28            843          JMP         ROL_RORcode0    ; ROR
00001B22  4EF9 00001B2E            844          JMP         ROL_RORcode1    ; ROL
00001B28                           845  
00001B28  4EB8 1AA8                846  ROL_RORcode0 JSR    someROR
00001B2C  4E75                     847               RTS
00001B2E  4EB8 1A52                848  ROL_RORcode1 JSR    someROL
00001B32  4E75                     849               RTS
00001B34                           850  
00001B34                           851  LSL_LSR:
00001B34  41F9 00001B52            852          LEA         tableLSL_LSR, A0 ; Index into the table
00001B3A  4280                     853          CLR.L       D0              ; Zero it
00001B3C  3016                     854          MOVE.W      (A6),D0     ; We'll play with it here
00001B3E  123C 0007                855          MOVE.B      #7,D1           ; Shift 7 bits left
00001B42  E360                     856          ASL.W       D1,D0
00001B44  123C 000F                857          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001B48  E268                     858          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B4A                           859                                      ; and the rest are zeroed out)
00001B4A  C0FC 0006                860          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B4E  4EF0 0000                861          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B52                           862  
00001B52                           863  tableLSL_LSR:
00001B52  4EF9 00001B5E            864          JMP         LSL_LSRcode0    ; LSR
00001B58  4EF9 00001B64            865          JMP         LSL_LSRcode1    ; LSL
00001B5E                           866  
00001B5E  4EB8 19A6                867  LSL_LSRcode0 JSR    someLSR
00001B62  4E75                     868               RTS
00001B64  4EB8 19FC                869  LSL_LSRcode1 JSR    someLSL
00001B68  4E75                     870               RTS
00001B6A                           871  
00001B6A                           872  ASL_ASR:
00001B6A  41F9 00001B88            873          LEA         tableASL_ASR, A0 ; Index into the table
00001B70  4280                     874          CLR.L       D0              ; Zero it
00001B72  3016                     875          MOVE.W      (A6),D0     ; We'll play with it here
00001B74  123C 0007                876          MOVE.B      #7,D1           ; Shift 7 bits left
00001B78  E360                     877          ASL.W       D1,D0
00001B7A  123C 000F                878          MOVE.B      #15,D1          ; Shift 15 bits to the right
00001B7E  E268                     879          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B80                           880                                      ; and the rest are zeroed out)
00001B80  C0FC 0006                881          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B84  4EF0 0000                882          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B88                           883  
00001B88                           884  tableASL_ASR:
00001B88  4EF9 00001B94            885          JMP         ASL_ASRcode0    ; ASR
00001B8E  4EF9 00001B9A            886          JMP         ASL_ASRcode1    ; ASL
00001B94                           887  
00001B94  4EB8 18FA                888  ASL_ASRcode0 JSR    someASR
00001B98  4E75                     889               RTS
00001B9A  4EB8 1950                890  ASL_ASRcode1 JSR    someASL
00001B9E  4E75                     891               RTS
00001BA0                           892  
00001BA0                           893  ROd_LSd_ASd:
00001BA0  41F9 00001BBE            894          LEA         tableROd_LSd_ASd, A0 ; Index into the table
00001BA6  4280                     895          CLR.L       D0              ; Zero it
00001BA8  3016                     896          MOVE.W      (A6),D0     ; We'll play with it here
00001BAA  123C 000B                897          MOVE.B      #11,D1          ; Shift 11 bits left
00001BAE  E360                     898          ASL.W       D1,D0
00001BB0  123C 000F                899          MOVE.B      #15,D1          ; Shift 12 bits to the right
00001BB4  E268                     900          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001BB6                           901                                      ; and the rest are zeroed out)
00001BB6  C0FC 0006                902          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001BBA  4EF0 0000                903          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001BBE                           904  
00001BBE                           905  tableROd_LSd_ASd:
00001BBE  4EF9 00001BD6            906          JMP         ROd_LSd_ASdcode00 ; ASL_ASR
00001BC4  4EF9 00001BDC            907          JMP         ROd_LSd_ASdcode01 ; LSL_LSR
00001BCA  4EF9 00001BE2            908          JMP         ROd_LSd_ASdcode10
00001BD0  4EF9 00001BEA            909          JMP         ROd_LSd_ASdcode11 ; ROL_ROR
00001BD6                           910  
00001BD6  4EB8 1B6A                911  ROd_LSd_ASdcode00 JSR ASL_ASR
00001BDA  4E75                     912                    RTS
00001BDC  4EB8 1B34                913  ROd_LSd_ASdcode01 JSR LSL_LSR
00001BE0  4E75                     914                    RTS
00001BE2  4EB9 00002266            915  ROd_LSd_ASdcode10 JSR    OPCODE_INVALID              ;INVALID
00001BE8  4E75                     916                    RTS
00001BEA  4EB8 1AFE                917  ROd_LSd_ASdcode11 JSR ROL_ROR
00001BEE  4E75                     918                    RTS
00001BF0                           919  
00001BF0                           920  AND_BorAND_WorAND_LorMULS_W:
00001BF0  41F9 00001C0E            921          LEA         tableAND_BorAND_WorAND_LorMULS_W, A0            ; Index into the table
00001BF6  4280                     922          CLR.L       D0                  ; Zero it
00001BF8  3016                     923          MOVE.W      (A6),D0         ; We'll play with it here
00001BFA  123C 0007                924          MOVE.B      #7,D1           ; Shift 7 bits left
00001BFE  E360                     925          ASL.W       D1,D0
00001C00  123C 000D                926          MOVE.B      #13,D1              ; Shift 13 bits to the right
00001C04  E268                     927          LSR.W       D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001C06                           928                                  ; and the rest are zeroed out)
00001C06  C0FC 0006                929          MULU        #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001C0A  4EF0 0000                930          JMP         0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
00001C0E                           931  
00001C0E                           932  tableAND_BorAND_WorAND_LorMULS_W:
00001C0E  4EF9 00001C3E            933          JMP         ANDcode000   ; AND.B
00001C14  4EF9 00001C46            934          JMP         ANDcode001   ; AND.W
00001C1A  4EF9 00001C4E            935          JMP         ANDcode010   ; AND.L
00001C20  4EF9 00001C56            936          JMP         ANDcode011
00001C26  4EF9 00001C5E            937          JMP         ANDcode100   ; AND.B
00001C2C  4EF9 00001C66            938          JMP         ANDcode101   ; AND.W
00001C32  4EF9 00001C6E            939          JMP         ANDcode110   ; AND.L
00001C38  4EF9 00001C76            940          JMP         ANDcode111   ; MULS.W
00001C3E                           941  
00001C3E  4EB9 0000251A            942  ANDcode000 JSR      ISANDB
00001C44  4E75                     943             RTS
00001C46  4EB9 00002534            944  ANDcode001 JSR      ISANDW
00001C4C  4E75                     945             RTS
00001C4E  4EB9 0000254E            946  ANDcode010 JSR      ISANDL
00001C54  4E75                     947             RTS
00001C56  4EB9 00002266            948  ANDcode011 JSR    OPCODE_INVALID              ;INVALID
00001C5C  4E75                     949             RTS
00001C5E  4EB9 0000251A            950  ANDcode100 JSR      ISANDB
00001C64  4E75                     951             RTS
00001C66  4EB9 00002534            952  ANDcode101 JSR      ISANDW
00001C6C  4E75                     953             RTS
00001C6E  4EB9 0000254E            954  ANDcode110 JSR      ISANDL
00001C74  4E75                     955             RTS
00001C76  4EB9 00002500            956  ANDcode111 JSR      ISMULSW
00001C7C  4E75                     957             RTS
00001C7E                           958  
00001C7E                           959  ADD_BorADD_WorADD_L:
00001C7E  41F9 00001C9C            960          LEA         tableADD_BorADD_WorADD_L, A0 ; Index into the table
00001C84  4280                     961          CLR.L       D0              ; Zero it
00001C86  3016                     962          MOVE.W      (A6),D0     ; We'll play with it here
00001C88  123C 0007                963          MOVE.B      #7,D1           ; Shift 7 bits left
00001C8C  E360                     964          ASL.W       D1,D0
00001C8E  123C 000D                965          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001C92  E268                     966          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001C94                           967                                      ; and the rest are zeroed out)
00001C94  C0FC 0006                968          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001C98  4EF0 0000                969          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001C9C                           970  
00001C9C                           971  tableADD_BorADD_WorADD_L:
00001C9C  4EF9 00001CCC            972          JMP         ADDcode000      *ADD.B
00001CA2  4EF9 00001CD4            973          JMP         ADDcode001      *ADD.W
00001CA8  4EF9 00001CDC            974          JMP         ADDcode010      *ADD.L
00001CAE  4EF9 00001CE4            975          JMP         ADDcode011      *ADDA.W
00001CB4  4EF9 00001CEC            976          JMP         ADDcode100      *ADD.B
00001CBA  4EF9 00001CF4            977          JMP         ADDcode101      *ADD.W
00001CC0  4EF9 00001CFC            978          JMP         ADDcode110      *ADD.L
00001CC6  4EF9 00001D04            979          JMP         ADDcode111      *ADDA.L
00001CCC                           980  
00001CCC  4EB9 0000259C            981  ADDcode000 JSR      ISADDB
00001CD2  4E75                     982             RTS
00001CD4  4EB9 000025B6            983  ADDcode001 JSR      ISADDW
00001CDA  4E75                     984             RTS
00001CDC  4EB9 000025D0            985  ADDcode010 JSR      ISADDL
00001CE2  4E75                     986             RTS
00001CE4  4EB9 00002568            987  ADDcode011 JSR      ISADDAW
00001CEA  4E75                     988             RTS
00001CEC  4EB9 0000259C            989  ADDcode100 JSR      ISADDB
00001CF2  4E75                     990             RTS
00001CF4  4EB9 000025B6            991  ADDcode101 JSR      ISADDW
00001CFA  4E75                     992             RTS
00001CFC  4EB9 000025D0            993  ADDcode110 JSR      ISADDL
00001D02  4E75                     994             RTS
00001D04  4EB9 00002582            995  ADDcode111 JSR      ISADDAL
00001D0A  4E75                     996             RTS
00001D0C                           997  
00001D0C                           998  SUB_BorSUB_WorSUB_L:
00001D0C  41F9 00001D2A            999          LEA         tableSUB_BorSUB_WorSUB_L, A0 ; Index into the table
00001D12  4280                    1000          CLR.L       D0              ; Zero it
00001D14  3016                    1001          MOVE.W      (A6),D0     ; We'll play with it here
00001D16  123C 0007               1002          MOVE.B      #7,D1           ; Shift 7 bits left
00001D1A  E360                    1003          ASL.W       D1,D0
00001D1C  123C 000D               1004          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001D20  E268                    1005          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001D22                          1006                                      ; and the rest are zeroed out)
00001D22  C0FC 0006               1007          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001D26  4EF0 0000               1008          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001D2A                          1009  
00001D2A                          1010  tableSUB_BorSUB_WorSUB_L:
00001D2A  4EF9 00001D5A           1011          JMP         SUBcode000      *SUB.B
00001D30  4EF9 00001D62           1012          JMP         SUBcode001      *SUB.W
00001D36  4EF9 00001D6A           1013          JMP         SUBcode010      *SUB.L
00001D3C  4EF9 00001D72           1014          JMP         SUBcode011
00001D42  4EF9 00001D7A           1015          JMP         SUBcode100      *SUB.B
00001D48  4EF9 00001D82           1016          JMP         SUBcode101      *SUB.W
00001D4E  4EF9 00001D8A           1017          JMP         SUBcode110      *SUB.L
00001D54  4EF9 00001D92           1018          JMP         SUBcode111      ; INVALID
00001D5A                          1019  
00001D5A  4EB9 000025EA           1020  SUBcode000 JSR      ISSUBB
00001D60  4E75                    1021             RTS
00001D62  4EB9 00002604           1022  SUBcode001 JSR      ISSUBW
00001D68  4E75                    1023             RTS
00001D6A  4EB9 0000261E           1024  SUBcode010 JSR      ISSUBL
00001D70  4E75                    1025             RTS
00001D72  4EB9 00002266           1026  SUBcode011 JSR      OPCODE_INVALID              ;INVALID
00001D78  4E75                    1027             RTS
00001D7A  4EB9 000025EA           1028  SUBcode100 JSR      ISSUBB
00001D80  4E75                    1029             RTS
00001D82  4EB9 00002604           1030  SUBcode101 JSR      ISSUBW
00001D88  4E75                    1031             RTS
00001D8A  4EB9 0000261E           1032  SUBcode110 JSR      ISSUBL
00001D90  4E75                    1033             RTS
00001D92  4EB9 00002266           1034  SUBcode111 JSR      OPCODE_INVALID              ;INVALID
00001D98  4E75                    1035             RTS
00001D9A                          1036  
00001D9A                          1037  CMP_BorCMP_WorCMP_L:
00001D9A  41F9 00001DB8           1038          LEA         tableCMP_BorCMP_WorCMP_L, A0 ; Index into the table
00001DA0  4280                    1039          CLR.L       D0              ; Zero it
00001DA2  3016                    1040          MOVE.W      (A6),D0     ; We'll play with it here
00001DA4  123C 0008               1041          MOVE.B      #8,D1           ; Shift 8 bits left
00001DA8  E360                    1042          ASL.W       D1,D0
00001DAA  123C 000E               1043          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001DAE  E268                    1044          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001DB0                          1045                                      ; and the rest are zeroed out)
00001DB0  C0FC 0006               1046          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001DB4  4EF0 0000               1047          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001DB8                          1048  
00001DB8                          1049  tableCMP_BorCMP_WorCMP_L:
00001DB8  4EF9 00001DD0           1050          JMP         CMPcode00       *CMP.B
00001DBE  4EF9 00001DD8           1051          JMP         CMPcode01       *CMP.W
00001DC4  4EF9 00001DE0           1052          JMP         CMPcode10       *CMP.L
00001DCA  4EF9 00001DE8           1053          JMP         CMPcode11       ; INVALID
00001DD0                          1054  
00001DD0  4EB9 00002638           1055  CMPcode00   JSR      ISCMPB
00001DD6  4E75                    1056              RTS
00001DD8  4EB9 00002652           1057  CMPcode01   JSR      ISCMPW
00001DDE  4E75                    1058              RTS
00001DE0  4EB9 0000266C           1059  CMPcode10   JSR      ISCMPL
00001DE6  4E75                    1060              RTS
00001DE8  4EB9 00002266           1061  CMPcode11   JSR    OPCODE_INVALID              ;INVALID
00001DEE  4E75                    1062              RTS
00001DF0                          1063  
00001DF0                          1064  ADDQ_BorADDQ_WorADDQ_L:
00001DF0  41F9 00001E0E           1065          LEA         tableADDQ_BorADDQ_WorADDQ_L, A0 ; Index into the table
00001DF6  4280                    1066          CLR.L       D0              ; Zero it
00001DF8  3016                    1067          MOVE.W      (A6),D0     ; We'll play with it here
00001DFA  123C 0008               1068          MOVE.B      #8,D1           ; Shift 8 bits left
00001DFE  E360                    1069          ASL.W       D1,D0
00001E00  123C 000E               1070          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001E04  E268                    1071          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001E06                          1072                                      ; and the rest are zeroed out)
00001E06  C0FC 0006               1073          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001E0A  4EF0 0000               1074          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001E0E                          1075  
00001E0E                          1076  tableADDQ_BorADDQ_WorADDQ_L:
00001E0E  4EF9 00001E26           1077          JMP         ADDQcode00      *ADDQ.B
00001E14  4EF9 00001E2E           1078          JMP         ADDQcode01      *ADDQ.W
00001E1A  4EF9 00001E36           1079          JMP         ADDQcode10      *ADDQ.L
00001E20  4EF9 00001E3E           1080          JMP         ADDQcode11      ; INVALID
00001E26                          1081  
00001E26  4EB9 00002686           1082  ADDQcode00 JSR      ISADDQB
00001E2C  4E75                    1083             RTS
00001E2E  4EB9 000026A0           1084  ADDQcode01 JSR      ISADDQW
00001E34  4E75                    1085             RTS
00001E36  4EB9 000026BA           1086  ADDQcode10 JSR      ISADDQL
00001E3C  4E75                    1087             RTS
00001E3E  4EB9 00002266           1088  ADDQcode11   JSR    OPCODE_INVALID              ;INVALID
00001E44  4E75                    1089              RTS
00001E46                          1090  
00001E46                          1091  someCLR:
00001E46  41F9 00001E64           1092          LEA         tableSomeCLR, A0 ; Index into the table
00001E4C  4280                    1093          CLR.L       D0              ; Zero it
00001E4E  3016                    1094          MOVE.W      (A6),D0     ; We'll play with it here
00001E50  123C 0008               1095          MOVE.B      #8,D1           ; Shift 8 bits left
00001E54  E360                    1096          ASL.W       D1,D0
00001E56  123C 000E               1097          MOVE.B      #14,D1       ; Shift 12 bits to the right
00001E5A  E268                    1098          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001E5C                          1099                                      ; and the rest are zeroed out)
00001E5C  C0FC 0006               1100          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001E60  4EF0 0000               1101          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001E64                          1102  
00001E64                          1103  tableSomeCLR:
00001E64  4EF9 00001E7C           1104          JMP         CLRcode00       *CLR.B
00001E6A  4EF9 00001E84           1105          JMP         CLRcode01       *CLR.W
00001E70  4EF9 00001E8C           1106          JMP         CLRcode10       *CLR.L
00001E76  4EF9 00001E94           1107          JMP         CLRcode11       ; INVALID
00001E7C                          1108  
00001E7C  4EB9 000026EE           1109  CLRcode00 JSR       ISCLRB
00001E82  4E75                    1110            RTS
00001E84  4EB9 00002708           1111  CLRcode01 JSR       ISCLRW
00001E8A  4E75                    1112            RTS
00001E8C  4EB9 00002722           1113  CLRcode10 JSR       ISCLRL
00001E92  4E75                    1114            RTS
00001E94  4EB9 00002266           1115  CLRcode11 JSR    OPCODE_INVALID              ;INVALID
00001E9A  4E75                    1116            RTS
00001E9C                          1117  
00001E9C                          1118  NOPorCLRorRTSorJSR:
00001E9C  41F9 00001ECE           1119          LEA         tableNOPorCLRorRTSorJSR, A0 ; Index into the table
00001EA2  4280                    1120          CLR.L       D0              ; Zero it
00001EA4  3016                    1121          MOVE.W      (A6),D0     ; We'll play with it here
00001EA6                          1122  
00001EA6  323C 4E71               1123          MOVE.W      #%0100111001110001, D1 ; 0100111001110001 = NOP
00001EAA  B240                    1124          CMP.W       D0, D1
00001EAC  6700 0088               1125          BEQ         NOPcommand
00001EB0                          1126  
00001EB0  323C 4E75               1127          MOVE.W      #%0100111001110101, D1 ; 0100111001110101 = RTS
00001EB4  B240                    1128          CMP.W       D0, D1
00001EB6  6700 0076               1129          BEQ         RTScommand
00001EBA                          1130  
00001EBA  123C 0004               1131          MOVE.B      #4,D1           ; Shift 4 bits left
00001EBE  E360                    1132          ASL.W       D1,D0
00001EC0  123C 000C               1133          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001EC4  E268                    1134          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001EC6                          1135                                      ; and the rest are zeroed out)
00001EC6  C0FC 0006               1136          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001ECA  4EF0 0000               1137          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001ECE                          1138  
00001ECE                          1139  tableNOPorCLRorRTSorJSR:
00001ECE  4EF9 00001F3E           1140          JMP         JSRorCLRcode0000
00001ED4  4EF9 00001F46           1141          JMP         JSRorCLRcode0001
00001EDA  4EF9 00001F4E           1142          JMP         JSRorCLRcode0010
00001EE0  4EF9 00001F54           1143          JMP         JSRorCLRcode0011
00001EE6  4EF9 00001F5C           1144          JMP         JSRorCLRcode0100
00001EEC  4EF9 00001F64           1145          JMP         JSRorCLRcode0101
00001EF2  4EF9 00001F6C           1146          JMP         JSRorCLRcode0110
00001EF8  4EF9 00001F74           1147          JMP         JSRorCLRcode0111
00001EFE  4EF9 00001F7C           1148          JMP         JSRorCLRcode1000
00001F04  4EF9 00001F84           1149          JMP         JSRorCLRcode1001
00001F0A  4EF9 00001F8C           1150          JMP         JSRorCLRcode1010
00001F10  4EF9 00001F94           1151          JMP         JSRorCLRcode1011
00001F16  4EF9 00001F9C           1152          JMP         JSRorCLRcode1100
00001F1C  4EF9 00001FA4           1153          JMP         JSRorCLRcode1101
00001F22  4EF9 00001FAC           1154          JMP         JSRorCLRcode1110
00001F28  4EF9 00001FB4           1155          JMP         JSRorCLRcode1111
00001F2E                          1156  
00001F2E  4EB9 000027A4           1157  RTScommand JSR      ISRTS
00001F34  4E75                    1158             RTS
00001F36  4EB9 000027D4           1159  NOPcommand JSR      ISNOP
00001F3C  4E75                    1160             RTS
00001F3E  4EB9 00002266           1161  JSRorCLRcode0000 JSR    OPCODE_INVALID              ;INVALID
00001F44  4E75                    1162                   RTS
00001F46  4EB9 00002266           1163  JSRorCLRcode0001 JSR    OPCODE_INVALID              ;INVALID
00001F4C  4E75                    1164                   RTS
00001F4E  4EB8 1E46               1165  JSRorCLRcode0010 JSR someCLR
00001F52  4E75                    1166                   RTS
00001F54  4EB9 00002266           1167  JSRorCLRcode0011 JSR    OPCODE_INVALID              ;INVALID
00001F5A  4E75                    1168                   RTS
00001F5C  4EB9 00002266           1169  JSRorCLRcode0100 JSR    OPCODE_INVALID              ;INVALID
00001F62  4E75                    1170                   RTS
00001F64  4EB9 00002266           1171  JSRorCLRcode0101 JSR    OPCODE_INVALID              ;INVALID
00001F6A  4E75                    1172                   RTS
00001F6C  4EB9 00002266           1173  JSRorCLRcode0110 JSR    OPCODE_INVALID              ;INVALID
00001F72  4E75                    1174                   RTS
00001F74  4EB9 00002266           1175  JSRorCLRcode0111 JSR    OPCODE_INVALID              ;INVALID
00001F7A  4E75                    1176                   RTS
00001F7C  4EB9 00002266           1177  JSRorCLRcode1000 JSR    OPCODE_INVALID              ;INVALID
00001F82  4E75                    1178                   RTS
00001F84  4EB9 00002266           1179  JSRorCLRcode1001 JSR    OPCODE_INVALID              ;INVALID
00001F8A  4E75                    1180                   RTS
00001F8C  4EB9 00002266           1181  JSRorCLRcode1010 JSR    OPCODE_INVALID              ;INVALID
00001F92  4E75                    1182                   RTS
00001F94  4EB9 00002266           1183  JSRorCLRcode1011 JSR    OPCODE_INVALID              ;INVALID
00001F9A  4E75                    1184                   RTS
00001F9C  4EB9 00002266           1185  JSRorCLRcode1100 JSR    OPCODE_INVALID              ;INVALID
00001FA2  4E75                    1186                   RTS
00001FA4  4EB9 00002266           1187  JSRorCLRcode1101 JSR    OPCODE_INVALID              ;INVALID
00001FAA  4E75                    1188                   RTS
00001FAC  4EB9 0000278A           1189  JSRorCLRcode1110 JSR ISJSR
00001FB2  4E75                    1190                   RTS
00001FB4  4EB9 00002266           1191  JSRorCLRcode1111 JSR    OPCODE_INVALID              ;INVALID
00001FBA  4E75                    1192                   RTS
00001FBC                          1193  
00001FBC                          1194  someMOVEM:
00001FBC  41F9 00001FDA           1195          LEA         tableSomeMOVEM, A0 ; Index into the table
00001FC2  4280                    1196          CLR.L       D0              ; Zero it
00001FC4  3016                    1197          MOVE.W      (A6),D0     ; We'll play with it here
00001FC6  123C 0009               1198          MOVE.B      #9,D1           ; Shift 9 bits left
00001FCA  E360                    1199          ASL.W       D1,D0
00001FCC  123C 000F               1200          MOVE.B      #15,D1       ; Shift 12 bits to the right
00001FD0  E268                    1201          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001FD2                          1202                                      ; and the rest are zeroed out)
00001FD2  C0FC 0006               1203          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001FD6  4EF0 0000               1204          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001FDA                          1205  
00001FDA                          1206  tableSomeMOVEM:
00001FDA  4EF9 00001FE6           1207          JMP         MOVEMcode0      ; MOVEM.W
00001FE0  4EF9 00001FEE           1208          JMP         MOVEMcode1      ; MOVEM.L
00001FE6                          1209  
00001FE6  4EB9 00002756           1210  MOVEMcode0 JSR      ISMOVEMW
00001FEC  4E75                    1211             RTS
00001FEE  4EB9 0000273C           1212  MOVEMcode1 JSR      ISMOVEML
00001FF4  4E75                    1213             RTS
00001FF6                          1214  
00001FF6                          1215  NOP_MOVEM_LEA_JSR_CLR_RTS:
00001FF6  41F9 0000201A           1216          LEA         tableNOP_MOVEM_LEA_JSR_CLR_RTS, A0 ; Index into the table
00001FFC  4280                    1217          CLR.L       D0              ; Zero it
00001FFE  3016                    1218          MOVE.W      (A6),D0     ; We'll play with it here
00002000  123C 0007               1219          MOVE.B      #7,D1           ; Shift 7 bits right
00002004  E260                    1220          ASR.W       D1,D0
00002006  123C 000D               1221          MOVE.B      #13,D1          ; Shift 13 bits left
0000200A  E360                    1222          ASL.W       D1,D0
0000200C  123C 000C               1223          MOVE.B      #12,D1          ; Shift 12 bits to the right
00002010  E268                    1224          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00002012                          1225                                      ; and the rest are zeroed out)
00002012  C0FC 0006               1226          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002016  4EF0 0000               1227          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000201A                          1228  
0000201A                          1229  tableNOP_MOVEM_LEA_JSR_CLR_RTS:
0000201A  4EF9 0000207A           1230          JMP         LOTScode0000
00002020  4EF9 00002082           1231          JMP         LOTScode0001
00002026  4EF9 0000208A           1232          JMP         LOTScode0010
0000202C  4EF9 00002090           1233          JMP         LOTScode0011
00002032  4EF9 00002098           1234          JMP         LOTScode0100
00002038  4EF9 000020A0           1235          JMP         LOTScode0101
0000203E  4EF9 000020A8           1236          JMP         LOTScode0110
00002044  4EF9 000020B0           1237          JMP         LOTScode0111
0000204A  4EF9 000020B8           1238          JMP         LOTScode1000
00002050  4EF9 000020BE           1239          JMP         LOTScode1001
00002056  4EF9 000020C6           1240          JMP         LOTScode1010
0000205C  4EF9 000020CC           1241          JMP         LOTScode1011
00002062  4EF9 000020D4           1242          JMP         LOTScode1100
00002068  4EF9 000020DC           1243          JMP         LOTScode1101
0000206E  4EF9 000020E4           1244          JMP         LOTScode1110
00002074  4EF9 000020EC           1245          JMP         LOTScode1111
0000207A                          1246  
0000207A  4EB9 00002266           1247  LOTScode0000 JSR    OPCODE_INVALID              ; MULS.L and DIVU.L are not supported for 68000 Disassember
00002080  4E75                    1248               RTS
00002082  4EB9 00002266           1249  LOTScode0001 JSR    OPCODE_INVALID              ;INVALID
00002088  4E75                    1250               RTS
0000208A  4EB8 1FBC               1251  LOTScode0010 JSR    someMOVEM
0000208E  4E75                    1252               RTS
00002090  4EB9 00002266           1253  LOTScode0011 JSR    OPCODE_INVALID              ;INVALID
00002096  4E75                    1254               RTS
00002098  4EB9 00002266           1255  LOTScode0100 JSR    OPCODE_INVALID              ;INVALID
0000209E  4E75                    1256               RTS
000020A0  4EB9 00002266           1257  LOTScode0101 JSR    OPCODE_INVALID              ;INVALID
000020A6  4E75                    1258               RTS
000020A8  4EB9 00002770           1259  LOTScode0110 JSR    ISLEA
000020AE  4E75                    1260               RTS
000020B0  4EB9 00002266           1261  LOTScode0111 JSR    OPCODE_INVALID              ;INVALID
000020B6  4E75                    1262               RTS
000020B8  4EB8 1E9C               1263  LOTScode1000 JSR    NOPorCLRorRTSorJSR
000020BC  4E75                    1264               RTS
000020BE  4EB9 00002266           1265  LOTScode1001 JSR    OPCODE_INVALID              ;INVALID
000020C4  4E75                    1266               RTS
000020C6  4EB8 1E9C               1267  LOTScode1010 JSR    NOPorCLRorRTSorJSR
000020CA  4E75                    1268               RTS
000020CC  4EB9 00002266           1269  LOTScode1011 JSR    OPCODE_INVALID              ;INVALID
000020D2  4E75                    1270               RTS
000020D4  4EB9 00002266           1271  LOTScode1100 JSR    OPCODE_INVALID              ;INVALID
000020DA  4E75                    1272               RTS
000020DC  4EB9 00002266           1273  LOTScode1101 JSR    OPCODE_INVALID              ;INVALID
000020E2  4E75                    1274               RTS
000020E4  4EB9 00002770           1275  LOTScode1110 JSR    ISLEA
000020EA  4E75                    1276               RTS
000020EC  4EB9 00002266           1277  LOTScode1111 JSR    OPCODE_INVALID              ;INVALID
000020F2  4E75                    1278               RTS
000020F4                          1279  
000020F4                          1280  ADDI_BorADDI_WorADDI_L:
000020F4  41F9 00002112           1281          LEA         tableADDI_BorADDI_WorADDI_L,A0 ; Index into the table
000020FA  4280                    1282          CLR.L       D0              ; Zero it
000020FC  3016                    1283          MOVE.W      (A6),D0     ; We'll play with it here
000020FE  123C 0007               1284          MOVE.B      #7,D1           ; Shift 7 bits left
00002102  E360                    1285          ASL.W       D1,D0
00002104  123C 000D               1286          MOVE.B      #13,D1          ; Shift 13 bits right
00002108  E260                    1287          ASR.W       D1,D0
0000210A  C0FC 0006               1288          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000210E  4EF0 0000               1289          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00002112                          1290  
00002112                          1291  tableADDI_BorADDI_WorADDI_L:
00002112  4EF9 0000212A           1292          JMP         ADDIBcode00
00002118  4EF9 00002132           1293          JMP         ADDIWcode01
0000211E  4EF9 0000213A           1294          JMP         ADDILcode10
00002124  4EF9 00002142           1295          JMP         ADDILcode11
0000212A                          1296  
0000212A  4EB9 000028A0           1297  ADDIBcode00 JSR     ISADDIB
00002130  4E75                    1298              RTS
00002132  4EB9 0000286C           1299  ADDIWcode01 JSR     ISADDIW
00002138  4E75                    1300              RTS
0000213A  4EB9 00002886           1301  ADDILcode10 JSR     ISADDIL
00002140  4E75                    1302              RTS
00002142  4EB9 00002266           1303  ADDILcode11 JSR    OPCODE_INVALID              ;INVALID
00002148  4E75                    1304              RTS
0000214A                          1305  
0000214A                          1306  MOVEA_LorMOVE_L:
0000214A  41F9 00002168           1307          LEA         tableMOVEA_LorMOVE_L,A0 ; Index into the table
00002150  4280                    1308          CLR.L       D0              ; Zero it
00002152  3016                    1309          MOVE.W      (A6),D0         ; We'll play with it here
00002154  123C 0007               1310          MOVE.B      #7,D1           ; Shift 7 bits left
00002158  E360                    1311          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
0000215A  123C 000D               1312          MOVE.B      #13,D1          ; Shift 13 bits right
0000215E  E260                    1313          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
00002160  C0FC 0006               1314          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002164  4EF0 0000               1315          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00002168                          1316  
00002168                          1317  tableMOVEA_LorMOVE_L:
00002168  4EF9 00002198           1318          JMP         MOVEcode000
0000216E  4EF9 000021A0           1319          JMP         MOVEAcode001
00002174  4EF9 000021A8           1320          JMP         MOVEcode010
0000217A  4EF9 000021B0           1321          JMP         MOVEcode011
00002180  4EF9 000021B8           1322          JMP         MOVEcode100
00002186  4EF9 000021C0           1323          JMP         MOVEcode101
0000218C  4EF9 000021C8           1324          JMP         MOVEcode110
00002192  4EF9 000021D0           1325          JMP         MOVEcode111
00002198                          1326  
00002198  4EB9 0000281E           1327  MOVEcode000 JSR     ISMOVEL
0000219E  4E75                    1328              RTS
000021A0  4EB9 00002838           1329  MOVEAcode001 JSR    ISMOVEAL
000021A6  4E75                    1330               RTS
000021A8  4EB9 0000281E           1331  MOVEcode010 JSR     ISMOVEL
000021AE  4E75                    1332              RTS
000021B0  4EB9 0000281E           1333  MOVEcode011 JSR     ISMOVEL
000021B6  4E75                    1334              RTS
000021B8  4EB9 0000281E           1335  MOVEcode100 JSR     ISMOVEL
000021BE  4E75                    1336              RTS
000021C0  4EB9 0000281E           1337  MOVEcode101 JSR     ISMOVEL
000021C6  4E75                    1338              RTS
000021C8  4EB9 0000281E           1339  MOVEcode110 JSR     ISMOVEL
000021CE  4E75                    1340              RTS
000021D0  4EB9 0000281E           1341  MOVEcode111 JSR     ISMOVEL
000021D6  4E75                    1342              RTS
000021D8                          1343  
000021D8                          1344  MOVEA_WorMOVE_W:
000021D8  41F9 000021F6           1345          LEA         tableMOVEA_WorMOVE_W,A0 ; Index into the table
000021DE  4280                    1346          CLR.L       D0              ; Zero it
000021E0  3016                    1347          MOVE.W      (A6),D0     ; We'll play with it here
000021E2  123C 0007               1348          MOVE.B      #7,D1           ; Shift 7 bits left
000021E6  E360                    1349          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
000021E8  123C 000D               1350          MOVE.B      #13,D1          ; Shift 13 bits right
000021EC  E260                    1351          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
000021EE  C0FC 0006               1352          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000021F2  4EF0 0000               1353          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000021F6                          1354  
000021F6                          1355  tableMOVEA_WorMOVE_W:
000021F6  4EF9 00002226           1356          JMP         MOVEWcode000
000021FC  4EF9 0000222E           1357          JMP         MOVEAWcode001
00002202  4EF9 00002236           1358          JMP         MOVEWcode010
00002208  4EF9 0000223E           1359          JMP         MOVEWcode011
0000220E  4EF9 00002246           1360          JMP         MOVEWcode100
00002214  4EF9 0000224E           1361          JMP         MOVEWcode101
0000221A  4EF9 00002256           1362          JMP         MOVEWcode110
00002220  4EF9 0000225E           1363          JMP         MOVEWcode111
00002226                          1364  
00002226  4EB9 000027EA           1365  MOVEWcode000 JSR    ISMOVEW
0000222C  4E75                    1366               RTS
0000222E  4EB9 00002804           1367  MOVEAWcode001 JSR   ISMOVEAW
00002234  4E75                    1368                RTS
00002236  4EB9 000027EA           1369  MOVEWcode010 JSR    ISMOVEW
0000223C  4E75                    1370               RTS
0000223E  4EB9 000027EA           1371  MOVEWcode011 JSR    ISMOVEW
00002244  4E75                    1372               RTS
00002246  4EB9 000027EA           1373  MOVEWcode100 JSR    ISMOVEW
0000224C  4E75                    1374               RTS
0000224E  4EB9 000027EA           1375  MOVEWcode101 JSR    ISMOVEW
00002254  4E75                    1376               RTS
00002256  4EB9 000027EA           1377  MOVEWcode110 JSR    ISMOVEW
0000225C  4E75                    1378               RTS
0000225E  4EB9 000027EA           1379  MOVEWcode111 JSR    ISMOVEW
00002264  4E75                    1380               RTS
00002266                          1381  
00002266                          1382  ; TODO: adjust workflow to:
00002266                          1383  ;   1) save message address to buffer pointer
00002266  48E7 FFFE               1384  OPCODE_INVALID  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000226A  4EB8 12D8               1385              JSR     INVALID_DATA
0000226E  548E                    1386              ADDA.L      #$00000002, A6          ; Increment past current opcode word
00002270  4CDF 7FFF               1387              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00002274  4E75                    1388              RTS
00002276                          1389  
00002276  48E7 FFFE               1390  ISBCC  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000227A  43F8 16C2               1391              LEA MESSAGEBCC, A1
0000227E  103C 000E               1392              MOVE.B  #14, D0
00002282  4E4F                    1393              TRAP    #15
00002284  4EB9 00003226           1394              JSR     EA_Bcc
0000228A  4CDF 7FFF               1395              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
0000228E  4E75                    1396              RTS
00002290  48E7 FFFE               1397  ISBGT  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002294  43F8 16C8               1398              LEA MESSAGEBGT, A1
00002298  103C 000E               1399              MOVE.B  #14, D0
0000229C  4E4F                    1400              TRAP    #15
0000229E  4EB9 00003226           1401              JSR     EA_Bcc
000022A4  4CDF 7FFF               1402              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
000022A8  4E75                    1403              RTS
000022AA                          1404  
000022AA  48E7 FFFE               1405  ISBLE  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022AE  43F8 16CE               1406              LEA MESSAGEBLE, A1
000022B2  103C 000E               1407              MOVE.B  #14, D0
000022B6  4E4F                    1408              TRAP    #15
000022B8  4EB9 00003226           1409              JSR     EA_Bcc
000022BE  4CDF 7FFF               1410              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
000022C2  4E75                    1411              RTS
000022C4                          1412  
000022C4  48E7 FFFE               1413  ISDIVUW     MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022C8  43F8 16B9               1414              LEA MESSAGEDIVUW, A1
000022CC  103C 000E               1415              MOVE.B  #14, D0
000022D0  4E4F                    1416              TRAP    #15
000022D2  4EB9 0000344C           1417              JSR     EA_DIVU_W
000022D8  4CDF 7FFF               1418              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
000022DC  4E75                    1419              RTS
000022DE                          1420  
000022DE  48E7 FFFE               1421  ISORB   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022E2  43F8 16A4               1422          LEA         MESSAGEORB, A1
000022E6  103C 000E               1423          MOVE.B      #14, D0
000022EA  4E4F                    1424          TRAP        #15
000022EC  4EB9 00003C24           1425          JSR         EA_OR
000022F2  4CDF 7FFF               1426          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022F6  4E75                    1427          RTS
000022F8                          1428  
000022F8  48E7 FFFE               1429  ISORW   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022FC  43F8 16AB               1430          LEA         MESSAGEORW, A1
00002300  103C 000E               1431          MOVE.B      #14, D0
00002304  4E4F                    1432          TRAP        #15
00002306  4EB9 00003C24           1433          JSR         EA_OR
0000230C  4CDF 7FFF               1434          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002310  4E75                    1435          RTS
00002312                          1436  
00002312  48E7 FFFE               1437  ISORL   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002316  43F8 16B2               1438          LEA         MESSAGEORL, A1
0000231A  103C 000E               1439          MOVE.B      #14, D0
0000231E  4E4F                    1440          TRAP        #15
00002320  4EB9 00003C24           1441          JSR         EA_OR
00002326  4CDF 7FFF               1442          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000232A  4E75                    1443          RTS
0000232C                          1444  
0000232C  48E7 FFFE               1445  ISASRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002330  43F8 1614               1446          LEA         MESSAGEASRB, A1
00002334  103C 000E               1447          MOVE.B      #14, D0
00002338  4E4F                    1448          TRAP        #15
0000233A  4EB9 00003112           1449          JSR         EA_ASd
00002340  4CDF 7FFF               1450          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002344  4E75                    1451          RTS
00002346                          1452  
00002346  48E7 FFFE               1453  ISASRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000234A  43F8 161C               1454          LEA         MESSAGEASRW, A1
0000234E  103C 000E               1455          MOVE.B      #14, D0
00002352  4E4F                    1456          TRAP        #15
00002354  4EB9 00003112           1457          JSR         EA_ASd
0000235A  4CDF 7FFF               1458          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000235E  4E75                    1459          RTS
00002360                          1460  
00002360  48E7 FFFE               1461  ISASRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002364  43F8 1624               1462          LEA         MESSAGEASRL, A1
00002368  103C 000E               1463          MOVE.B      #14, D0
0000236C  4E4F                    1464          TRAP        #15
0000236E  4EB9 00003112           1465          JSR         EA_ASd
00002374  4CDF 7FFF               1466          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002378  4E75                    1467          RTS
0000237A                          1468  
0000237A  48E7 FFFE               1469  ISASLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000237E  43F8 162C               1470          LEA         MESSAGEASLB, A1
00002382  103C 000E               1471          MOVE.B      #14, D0
00002386  4E4F                    1472          TRAP        #15
00002388  4EB9 00003112           1473          JSR         EA_ASd
0000238E  4CDF 7FFF               1474          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002392  4E75                    1475          RTS
00002394                          1476  
00002394  48E7 FFFE               1477  ISASLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002398  43F8 1634               1478          LEA         MESSAGEASLW, A1
0000239C  103C 000E               1479          MOVE.B      #14, D0
000023A0  4E4F                    1480          TRAP        #15
000023A2  4EB9 00003112           1481          JSR         EA_ASd
000023A8  4CDF 7FFF               1482          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023AC  4E75                    1483          RTS
000023AE                          1484  
000023AE  48E7 FFFE               1485  ISASLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023B2  43F8 163C               1486          LEA         MESSAGEASLL, A1
000023B6  103C 000E               1487          MOVE.B      #14, D0
000023BA  4E4F                    1488          TRAP        #15
000023BC  4EB9 00003112           1489          JSR         EA_ASd
000023C2  4CDF 7FFF               1490          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023C6  4E75                    1491          RTS
000023C8                          1492  
000023C8  48E7 FFFE               1493  ISLSRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023CC  43F8 1674               1494          LEA         MESSAGELSRB, A1
000023D0  103C 000E               1495          MOVE.B      #14, D0
000023D4  4E4F                    1496          TRAP        #15
000023D6  4EB9 000036D4           1497          JSR         EA_LSd
000023DC  4CDF 7FFF               1498          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023E0  4E75                    1499          RTS
000023E2                          1500  
000023E2  48E7 FFFE               1501  ISLSRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023E6  43F8 167C               1502          LEA         MESSAGELSRW, A1
000023EA  103C 000E               1503          MOVE.B      #14, D0
000023EE  4E4F                    1504          TRAP        #15
000023F0  4EB9 000036D4           1505          JSR         EA_LSd
000023F6  4CDF 7FFF               1506          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023FA  4E75                    1507          RTS
000023FC                          1508  
000023FC  48E7 FFFE               1509  ISLSRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002400  43F8 1684               1510          LEA         MESSAGELSRL, A1
00002404  103C 000E               1511          MOVE.B      #14, D0
00002408  4E4F                    1512          TRAP        #15
0000240A  4EB9 000036D4           1513          JSR         EA_LSd
00002410  4CDF 7FFF               1514          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002414  4E75                    1515          RTS
00002416                          1516  
00002416  48E7 FFFE               1517  ISLSLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000241A  43F8 168C               1518          LEA         MESSAGELSLB, A1
0000241E  103C 000E               1519          MOVE.B      #14, D0
00002422  4E4F                    1520          TRAP        #15
00002424  4EB9 000036D4           1521          JSR         EA_LSd
0000242A  4CDF 7FFF               1522          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000242E  4E75                    1523          RTS
00002430                          1524  
00002430  48E7 FFFE               1525  ISLSLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002434  43F8 1694               1526          LEA         MESSAGELSLW, A1
00002438  103C 000E               1527          MOVE.B      #14, D0
0000243C  4E4F                    1528          TRAP        #15
0000243E  4EB9 000036D4           1529          JSR         EA_LSd
00002444  4CDF 7FFF               1530          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002448  4E75                    1531          RTS
0000244A                          1532  
0000244A  48E7 FFFE               1533  ISLSLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000244E  43F8 169C               1534          LEA         MESSAGELSLL, A1
00002452  103C 000E               1535          MOVE.B      #14, D0
00002456  4E4F                    1536          TRAP        #15
00002458  4EB9 000036D4           1537          JSR         EA_LSd
0000245E  4CDF 7FFF               1538          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002462  4E75                    1539          RTS
00002464                          1540  
00002464  48E7 FFFE               1541  ISRORB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002468  43F8 1644               1542          LEA         MESSAGERORB, A1
0000246C  103C 000E               1543          MOVE.B      #14, D0
00002470  4E4F                    1544          TRAP        #15
00002472  4EB9 00003DD0           1545          JSR         EA_ROd
00002478  4CDF 7FFF               1546          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000247C  4E75                    1547          RTS
0000247E                          1548  
0000247E  48E7 FFFE               1549  ISRORW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002482  43F8 164C               1550          LEA         MESSAGERORW, A1
00002486  103C 000E               1551          MOVE.B      #14, D0
0000248A  4E4F                    1552          TRAP        #15
0000248C  4EB9 00003DD0           1553          JSR         EA_ROd
00002492  4CDF 7FFF               1554          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002496  4E75                    1555          RTS
00002498                          1556  
00002498  48E7 FFFE               1557  ISRORL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000249C  43F8 1654               1558          LEA         MESSAGERORL, A1
000024A0  103C 000E               1559          MOVE.B      #14, D0
000024A4  4E4F                    1560          TRAP        #15
000024A6  4EB9 00003DD0           1561          JSR         EA_ROd
000024AC  4CDF 7FFF               1562          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024B0  4E75                    1563          RTS
000024B2                          1564  
000024B2  48E7 FFFE               1565  ISROLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024B6  43F8 165C               1566          LEA         MESSAGEROLB, A1
000024BA  103C 000E               1567          MOVE.B      #14, D0
000024BE  4E4F                    1568          TRAP        #15
000024C0  4EB9 00003DD0           1569          JSR         EA_ROd
000024C6  4CDF 7FFF               1570          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024CA  4E75                    1571          RTS
000024CC                          1572  
000024CC  48E7 FFFE               1573  ISROLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024D0  43F8 1664               1574          LEA         MESSAGEROLW, A1
000024D4  103C 000E               1575          MOVE.B      #14, D0
000024D8  4E4F                    1576          TRAP        #15
000024DA  4EB9 00003DD0           1577          JSR         EA_ROd
000024E0  4CDF 7FFF               1578          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024E4  4E75                    1579          RTS
000024E6                          1580  
000024E6  48E7 FFFE               1581  ISROLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024EA  43F8 166C               1582          LEA         MESSAGEROLL, A1
000024EE  103C 000E               1583          MOVE.B      #14, D0
000024F2  4E4F                    1584          TRAP        #15
000024F4  4EB9 00003DD0           1585          JSR         EA_ROd
000024FA  4CDF 7FFF               1586          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024FE  4E75                    1587          RTS
00002500                          1588  
00002500  48E7 FFFE               1589  ISMULSW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002504  43F8 160B               1590          LEA         MESSAGEMULSW, A1 *OPCODE is MULS.W
00002508  103C 000E               1591          MOVE.B      #14, D0
0000250C  4E4F                    1592          TRAP        #15
0000250E  4EB9 00003B34           1593          JSR         EA_MULS_W
00002514  4CDF 7FFF               1594          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002518  4E75                    1595          RTS
0000251A                          1596  
0000251A  48E7 FFFE               1597  ISANDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000251E  43F8 15F3               1598          LEA         MESSAGEANDB, A1 *OPCODE is AND.B
00002522  103C 000E               1599          MOVE.B      #14, D0
00002526  4E4F                    1600          TRAP        #15
00002528  4EB9 00002F6C           1601          JSR         EA_AND
0000252E  4CDF 7FFF               1602          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002532  4E75                    1603          RTS
00002534                          1604  
00002534  48E7 FFFE               1605  ISANDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002538  43F8 15FB               1606          LEA         MESSAGEANDW, A1 *OPCODE is AND.W
0000253C  103C 000E               1607          MOVE.B      #14, D0
00002540  4E4F                    1608          TRAP        #15
00002542  4EB9 00002F6C           1609          JSR         EA_AND
00002548  4CDF 7FFF               1610          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000254C  4E75                    1611          RTS
0000254E                          1612  
0000254E  48E7 FFFE               1613  ISANDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002552  43F8 1603               1614          LEA         MESSAGEANDL, A1 *OPCODE is AND.L
00002556  103C 000E               1615          MOVE.B      #14, D0
0000255A  4E4F                    1616          TRAP        #15
0000255C  4EB9 00002F6C           1617          JSR         EA_AND
00002562  4CDF 7FFF               1618          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002566  4E75                    1619          RTS
00002568                          1620  
00002568  48E7 FFFE               1621  ISADDAW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000256C  43F8 15D7               1622          LEA         MESSAGEADDAW, A1 *OPCODE is ADDA.W
00002570  103C 000E               1623          MOVE.B      #14, D0
00002574  4E4F                    1624          TRAP        #15
00002576  4EB9 00002C8A           1625          JSR         EA_ADDA
0000257C  4CDF 7FFF               1626          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002580  4E75                    1627          RTS
00002582                          1628  
00002582  48E7 FFFE               1629  ISADDAL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002586  43F8 15E0               1630          LEA         MESSAGEADDAL, A1 *OPCODE is ADDA.L
0000258A  103C 000E               1631          MOVE.B      #14, D0
0000258E  4E4F                    1632          TRAP        #15
00002590  4EB9 00002C8A           1633          JSR         EA_ADDA
00002596  4CDF 7FFF               1634          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000259A  4E75                    1635          RTS
0000259C                          1636  
0000259C  48E7 FFFE               1637  ISADDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025A0  43F8 15BF               1638          LEA         MESSAGEADDB, A1 *OPCODE is ADD.B
000025A4  103C 000E               1639          MOVE.B      #14, D0
000025A8  4E4F                    1640          TRAP        #15
000025AA  4EB9 00002AD6           1641          JSR         EA_ADD
000025B0  4CDF 7FFF               1642          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025B4  4E75                    1643          RTS
000025B6                          1644  
000025B6  48E7 FFFE               1645  ISADDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025BA  43F8 15C7               1646          LEA         MESSAGEADDW, A1 *OPCODE is ADD.W
000025BE  103C 000E               1647          MOVE.B      #14, D0
000025C2  4E4F                    1648          TRAP        #15
000025C4  4EB9 00002AD6           1649          JSR         EA_ADD
000025CA  4CDF 7FFF               1650          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025CE  4E75                    1651          RTS
000025D0                          1652  
000025D0  48E7 FFFE               1653  ISADDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025D4  43F8 15CF               1654          LEA         MESSAGEADDL, A1 *OPCODE is ADD.L
000025D8  103C 000E               1655          MOVE.B      #14, D0
000025DC  4E4F                    1656          TRAP        #15
000025DE  4EB9 00002AD6           1657          JSR         EA_ADD
000025E4  4CDF 7FFF               1658          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025E8  4E75                    1659          RTS
000025EA                          1660  
000025EA  48E7 FFFE               1661  ISSUBB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025EE  43F8 15A7               1662          LEA         MESSAGESUBB, A1 *OPCODE is SUB.B
000025F2  103C 000E               1663          MOVE.B      #14, D0
000025F6  4E4F                    1664          TRAP        #15
000025F8  4EB9 00003EE4           1665          JSR         EA_SUB
000025FE  4CDF 7FFF               1666          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002602  4E75                    1667          RTS
00002604                          1668  
00002604  48E7 FFFE               1669  ISSUBW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002608  43F8 15AF               1670          LEA         MESSAGESUBW, A1 *OPCODE is SUB.W
0000260C  103C 000E               1671          MOVE.B      #14, D0
00002610  4E4F                    1672          TRAP        #15
00002612  4EB9 00003EE4           1673          JSR         EA_SUB
00002618  4CDF 7FFF               1674          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000261C  4E75                    1675          RTS
0000261E                          1676  
0000261E  48E7 FFFE               1677  ISSUBL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002622  43F8 15B7               1678          LEA         MESSAGESUBL, A1 *OPCODE is SUB.L
00002626  103C 000E               1679          MOVE.B      #14, D0
0000262A  4E4F                    1680          TRAP        #15
0000262C  4EB9 00003EE4           1681          JSR         EA_SUB
00002632  4CDF 7FFF               1682          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002636  4E75                    1683          RTS
00002638                          1684  
00002638  48E7 FFFE               1685  ISCMPB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000263C  43F8 158F               1686          LEA         MESSAGECMPB, A1 *OPCODE is CMP.B
00002640  103C 000E               1687          MOVE.B      #14, D0
00002644  4E4F                    1688          TRAP        #15
00002646  4EB9 0000337C           1689          JSR         EA_CMP
0000264C  4CDF 7FFF               1690          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002650  4E75                    1691          RTS
00002652                          1692  
00002652  48E7 FFFE               1693  ISCMPW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002656  43F8 1597               1694          LEA         MESSAGECMPW, A1 *OPCODE is CMP.W
0000265A  103C 000E               1695          MOVE.B      #14, D0
0000265E  4E4F                    1696          TRAP        #15
00002660  4EB9 0000337C           1697          JSR         EA_CMP
00002666  4CDF 7FFF               1698          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000266A  4E75                    1699          RTS
0000266C                          1700  
0000266C  48E7 FFFE               1701  ISCMPL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002670  43F8 159F               1702          LEA         MESSAGECMPL, A1 *OPCODE is CMP.L
00002674  103C 000E               1703          MOVE.B      #14, D0
00002678  4E4F                    1704          TRAP        #15
0000267A  4EB9 0000337C           1705          JSR         EA_CMP
00002680  4CDF 7FFF               1706          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002684  4E75                    1707          RTS
00002686                          1708  
00002686  48E7 FFFE               1709  ISADDQB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000268A  43F8 1574               1710          LEA         MESSAGEADDQB, A1 *OPCODE is ADDQ.B
0000268E  103C 000E               1711          MOVE.B      #14, D0
00002692  4E4F                    1712          TRAP        #15
00002694  4EB9 00002E8A           1713          JSR         EA_ADDQ
0000269A  4CDF 7FFF               1714          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000269E  4E75                    1715          RTS
000026A0                          1716  
000026A0  48E7 FFFE               1717  ISADDQW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026A4  43F8 157D               1718          LEA         MESSAGEADDQW, A1 *OPCODE is ADDQ.W
000026A8  103C 000E               1719          MOVE.B      #14, D0
000026AC  4E4F                    1720          TRAP        #15
000026AE  4EB9 00002E8A           1721          JSR         EA_ADDQ
000026B4  4CDF 7FFF               1722          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026B8  4E75                    1723          RTS
000026BA                          1724  
000026BA  48E7 FFFE               1725  ISADDQL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026BE  43F8 1586               1726          LEA         MESSAGEADDQL, A1 *OPCODE is ADDQ.L
000026C2  103C 000E               1727          MOVE.B      #14, D0
000026C6  4E4F                    1728          TRAP        #15
000026C8  4EB9 00002E8A           1729          JSR         EA_ADDQ
000026CE  4CDF 7FFF               1730          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026D2  4E75                    1731          RTS
000026D4                          1732  
000026D4  48E7 FFFE               1733  ISMOVEQL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000026D8  43F8 15E9               1734          LEA         MESSAGEMOVEQL, A1 *OPCODE is MOVEQ.L
000026DC  103C 000E               1735          MOVE.B      #14, D0
000026E0  4E4F                    1736          TRAP        #15
000026E2  4EB9 00003AF0           1737          JSR         EA_MOVEQ
000026E8  4CDF 7FFF               1738          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026EC  4E75                    1739          RTS
000026EE                          1740  
000026EE  48E7 FFFE               1741  ISCLRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026F2  43F8 155C               1742          LEA         MESSAGECLRB, A1 *OPCODE is CLR.B
000026F6  103C 000E               1743          MOVE.B      #14, D0
000026FA  4E4F                    1744          TRAP        #15
000026FC  4EB9 00003AF0           1745          JSR         EA_MOVEQ
00002702  4CDF 7FFF               1746          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002706  4E75                    1747          RTS
00002708                          1748  
00002708  48E7 FFFE               1749  ISCLRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000270C  43F8 1564               1750          LEA         MESSAGECLRW, A1 *OPCODE is CLR.W
00002710  103C 000E               1751          MOVE.B      #14, D0
00002714  4E4F                    1752          TRAP        #15
00002716  4EB9 000032B4           1753          JSR         EA_CLR
0000271C  4CDF 7FFF               1754          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002720  4E75                    1755          RTS
00002722                          1756  
00002722  48E7 FFFE               1757  ISCLRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002726  43F8 156C               1758          LEA         MESSAGECLRL, A1 *OPCODE is CLR.L
0000272A  103C 000E               1759          MOVE.B      #14, D0
0000272E  4E4F                    1760          TRAP        #15
00002730  4EB9 000032B4           1761          JSR         EA_CLR
00002736  4CDF 7FFF               1762          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000273A  4E75                    1763          RTS
0000273C                          1764  
0000273C  48E7 FFFE               1765  ISMOVEML MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
00002740  43F8 1530               1766          LEA         MESSAGEMOVEML, A1 *OPCODE is MOVEM.L
00002744  103C 000E               1767          MOVE.B      #14, D0
00002748  4E4F                    1768          TRAP        #15
0000274A  4EB9 00003AEA           1769          JSR         EA_MOVEM
00002750  4CDF 7FFF               1770          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002754  4E75                    1771          RTS
00002756                          1772  
00002756  48E7 FFFE               1773  ISMOVEMW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
0000275A  43F8 153A               1774          LEA         MESSAGEMOVEMW, A1 *OPCODE is MOVEM.W
0000275E  103C 000E               1775          MOVE.B      #14, D0
00002762  4E4F                    1776          TRAP        #15
00002764  4EB9 00003AEA           1777          JSR         EA_MOVEM
0000276A  4CDF 7FFF               1778          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000276E  4E75                    1779          RTS
00002770                          1780  
00002770  48E7 FFFE               1781  ISLEA   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002774  43F8 1556               1782          LEA         MESSAGELEA, A1  *OPCODE is LEA so display LEA message
00002778  103C 000E               1783          MOVE.B      #14, D0
0000277C  4E4F                    1784          TRAP        #15
0000277E  4EB9 00003604           1785          JSR         EA_LEA
00002784  4CDF 7FFF               1786          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002788  4E75                    1787          RTS                         ; Exit subroutine
0000278A                          1788  
0000278A  48E7 FFFE               1789  ISJSR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000278E  43F8 1544               1790          LEA         MESSAGEJSR, A1  *OPCODE is NOP so display NOP message
00002792  103C 000E               1791          MOVE.B      #14, D0
00002796  4E4F                    1792          TRAP        #15
00002798  4EB9 0000353C           1793          JSR         EA_JSR
0000279E  4CDF 7FFF               1794          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027A2  4E75                    1795          RTS                         ; Exit subroutine
000027A4                          1796  
000027A4  48E7 FFFE               1797  ISRTS   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027A8  43F8 1550               1798          LEA         MESSAGERTS, A1  *OPCODE is RTS
000027AC  103C 000E               1799          MOVE.B      #14, D0
000027B0  4E4F                    1800          TRAP        #15
000027B2  548E                    1801          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
000027B4  4CDF 7FFF               1802          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027B8  4E75                    1803          RTS
000027BA                          1804  
000027BA  48E7 FFFE               1805  ISCLR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027BE  43F8 154A               1806          LEA         MESSAGECLR, A1  *OPCODE is CLR
000027C2  103C 000E               1807          MOVE.B      #14, D0
000027C6  4E4F                    1808          TRAP        #15
000027C8  4EB9 000032B4           1809          JSR         EA_CLR
000027CE  4CDF 7FFF               1810          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027D2  4E75                    1811          RTS
000027D4                          1812  
000027D4  48E7 FFFE               1813  ISNOP   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027D8  43F8 14E0               1814          LEA         MESSAGENOP, A1  *OPCODE is NOP so display NOP message
000027DC  103C 000E               1815          MOVE.B      #14, D0
000027E0  4E4F                    1816          TRAP        #15
000027E2  548E                    1817          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
000027E4  4CDF 7FFF               1818          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027E8  4E75                    1819          RTS                         ; Exit subroutine
000027EA                          1820  
000027EA  48E7 FFFE               1821  ISMOVEW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027EE  43F8 14E6               1822          LEA         MESSAGEMOVEW, A1 *OPCODE is MOVE.W so display MOVEW message
000027F2  103C 000E               1823          MOVE.B      #14, D0
000027F6  4E4F                    1824          TRAP        #15
000027F8  4EB9 000037E8           1825          JSR         EA_MOVE
000027FE  4CDF 7FFF               1826          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002802  4E75                    1827          RTS                         ; Exit subroutine
00002804                          1828  
00002804  48E7 FFFE               1829  ISMOVEAW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
00002808  43F8 1526               1830          LEA         MESSAGEMOVEAW, A1 *OPCODE is MOVEA.W so display MOVEA.W message
0000280C  103C 000E               1831          MOVE.B      #14, D0
00002810  4E4F                    1832          TRAP        #15
00002812  4EB9 000039C0           1833          JSR         EA_MOVEA
00002818  4CDF 7FFF               1834          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000281C  4E75                    1835          RTS                         ; Exit subroutine
0000281E                          1836  
0000281E  48E7 FFFE               1837  ISMOVEL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002822  43F8 14EF               1838          LEA         MESSAGEMOVEL, A1 *OPCODE is MOVE.L so display MOVE.L message
00002826  103C 000E               1839          MOVE.B      #14, D0
0000282A  4E4F                    1840          TRAP        #15
0000282C  4EB9 000037E8           1841          JSR         EA_MOVE
00002832  4CDF 7FFF               1842          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002836  4E75                    1843          RTS                         ; Exit subroutine
00002838                          1844  
00002838  48E7 FFFE               1845  ISMOVEAL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
0000283C  43F8 151C               1846          LEA         MESSAGEMOVEAL, A1 *OPCODE is MOVEA.L so display MOVEA.L message
00002840  103C 000E               1847          MOVE.B      #14, D0
00002844  4E4F                    1848          TRAP        #15
00002846  4EB9 000039C0           1849          JSR         EA_MOVEA
0000284C  4CDF 7FFF               1850          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002850  4E75                    1851          RTS                         ; Exit subroutine
00002852                          1852  
00002852  48E7 FFFE               1853  ISMOVEB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002856  43F8 14F8               1854          LEA         MESSAGEMOVEB, A1 *OPCODE is MOVE.B so display MOVEB message
0000285A  103C 000E               1855          MOVE.B      #14, D0
0000285E  4E4F                    1856          TRAP        #15
00002860  4EB9 000037E8           1857          JSR         EA_MOVE
00002866  4CDF 7FFF               1858          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000286A  4E75                    1859          RTS                         ; Exit subroutine
0000286C                          1860  
0000286C  48E7 FFFE               1861  ISADDIW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002870  43F8 1501               1862          LEA         MESSAGEADDIW, A1 *OPCODE is ADDI.W so display ADDI.W message
00002874  103C 000E               1863          MOVE.B      #14, D0
00002878  4E4F                    1864          TRAP        #15
0000287A  4EB9 00002D6E           1865          JSR         EA_ADDI
00002880  4CDF 7FFF               1866          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002884  4E75                    1867          RTS                         ; Exit subroutine
00002886                          1868  
00002886  48E7 FFFE               1869  ISADDIL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000288A  43F8 150A               1870          LEA         MESSAGEADDIL, A1 *OPCODE is ADDI.L so display ADDI.L message
0000288E  103C 000E               1871          MOVE.B      #14, D0
00002892  4E4F                    1872          TRAP        #15
00002894  4EB9 00002D6E           1873          JSR         EA_ADDI
0000289A  4CDF 7FFF               1874          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000289E  4E75                    1875          RTS                         ; Exit subroutine
000028A0                          1876  
000028A0  48E7 FFFE               1877  ISADDIB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000028A4  43F8 1513               1878          LEA         MESSAGEADDIB, A1 *OPCODE is ADDI.B so display ADDI.B message
000028A8  103C 000E               1879          MOVE.B      #14, D0
000028AC  4E4F                    1880          TRAP        #15
000028AE  4EB9 00002D6E           1881          JSR         EA_ADDI
000028B4  4CDF 7FFF               1882          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000028B8  4E75                    1883          RTS                         ; Exit subroutine
000028BA                          1884  
000028BA                          1885  
000028BA                          1886  
000028BA                          1887  
000028BA                          1888  
000028BA                          1889  
000028BA                          1890  
000028BA                          1891  -------------------- end include --------------------
000028BA                          1892      INCLUDE 'EA.X68'
000028BA                          1893  
000028BA                          1894      INCLUDE 'EAMessages.X68'
000028BA                          1895  
000028BA= 00                      1896  EA_MSG_NULL         DC.B    0
000028BB= 20                      1897  EA_MSG_SPACE        DC.B    ' '
000028BC= 2C 20                   1898  EA_MSG_COMMA        DC.B    ', '
000028BE= 28                      1899  EA_MSG_OPENPAREN    DC.B    '('
000028BF= 29                      1900  EA_MSG_CLOSEPAREN   DC.B    ')'
000028C0= 2D                      1901  EA_MSG_MIN          DC.B    '-'
000028C1= 2B                      1902  EA_MSG_PLUS         DC.B    '+'
000028C2= 23                      1903  EA_MSG_HASH         DC.B    '#'
000028C3= 24                      1904  EA_MSG_HEX          DC.B    '$'
000028C4                          1905  
000028C4= 44 30                   1906  EA_MSG_D0           DC.B    'D0'
000028C6= 44 31                   1907  EA_MSG_D1           DC.B    'D1'
000028C8= 44 32                   1908  EA_MSG_D2           DC.B    'D2'
000028CA= 44 33                   1909  EA_MSG_D3           DC.B    'D3'
000028CC= 44 34                   1910  EA_MSG_D4           DC.B    'D4'
000028CE= 44 35                   1911  EA_MSG_D5           DC.B    'D5'
000028D0= 44 36                   1912  EA_MSG_D6           DC.B    'D6'
000028D2= 44 37                   1913  EA_MSG_D7           DC.B    'D7'
000028D4                          1914  
000028D4= 41 30                   1915  EA_MSG_A0           DC.B    'A0'
000028D6= 41 31                   1916  EA_MSG_A1           DC.B    'A1'
000028D8= 41 32                   1917  EA_MSG_A2           DC.B    'A2'
000028DA= 41 33                   1918  EA_MSG_A3           DC.B    'A3'
000028DC= 41 34                   1919  EA_MSG_A4           DC.B    'A4'
000028DE= 41 35                   1920  EA_MSG_A5           DC.B    'A5'
000028E0= 41 36                   1921  EA_MSG_A6           DC.B    'A6'
000028E2= 41 37                   1922  EA_MSG_A7           DC.B    'A7'
000028E4                          1923  
000028E4                          1924  
000028E4                          1925  -------------------- end include --------------------
000028E4                          1926      INCLUDE 'EA_UTIL.X68'
000028E4                          1927  
000028E4                          1928  
000028E4                          1929  EA_UNIMPLEMENTED:
000028E4  548E                    1930      ADDA.L      #$00000002, A6      ; Increment past current opcode word
000028E6                          1931      *print unimplemented message
000028E6  4E75                    1932      RTS
000028E8                          1933  
000028E8                          1934  EA_INVALID:
000028E8  2A4E                    1935      MOVEA.L     A6, A5              ; Copy global pointer
000028EA  548D                    1936      ADDA.L      #$00000002, A5      ; Increment past current opcode word
000028EC  4EB8 12D8               1937      JSR         INVALID_DATA        ; Print data error message
000028F0  4E75                    1938      RTS
000028F2                          1939  
000028F2                          1940  EA_UPDATE_POINTER:
000028F2  BDCD                    1941      CMP.L       A5, A6              ; Check if A5==A6
000028F4  6600 0004               1942      BNE         UPDATE_PTR          ; If NOT equal (a.k.a if any extra operands
000028F8                          1943                                      ; were read, and is already up to date),
000028F8                          1944                                      ; update global with current
000028F8  548D                    1945      ADDA.L      #$00000002, A5      ; Else, increment past current opcode word, then update
000028FA                          1946  UPDATE_PTR:
000028FA  2C4D                    1947      MOVEA.L     A5, A6              ; Update global pointer
000028FC  4E75                    1948      RTS
000028FE                          1949  
000028FE                          1950  EA_COPY_PTR:
000028FE  2A4E                    1951      MOVEA.L     A6, A5              ; Save global pointer
00002900  4E75                    1952      RTS
00002902                          1953  
00002902                          1954  EA_DEFAULT_COMBO:
00002902  4286                    1955      CLR.L       D6                  ; Clear space for mode bits
00002904  4287                    1956      CLR.L       D7                  ; Clear space for register bits
00002906  2216                    1957      MOVE.L      (A6), D1            ; Load opcode to data register 1
00002908  143C 000A               1958      MOVE.B      #10, D2             ; Clear upper 10 bits of opcode word
0000290C  E569                    1959      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
0000290E  143C 000D               1960      MOVE.B      #13, D2             ; 'Right-align' bits 3-5 to determine mode bits
00002912  E469                    1961      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002914  1C01                    1962      MOVE.B      D1, D6              ; Save mode bits to D6
00002916  2216                    1963      MOVE.L      (A6), D1            ; Reload opcode to data register 1
00002918  143C 000D               1964      MOVE.B      #13, D2             ; Clear upper 13 bits of opcode word
0000291C  E569                    1965      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
0000291E  143C 000D               1966      MOVE.B      #13, D2             ; 'Right-align' bits 0-2 to determine register bits
00002922  E469                    1967      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002924  1E01                    1968      MOVE.B      D1, D7              ; Save register bits to D7
00002926  4E75                    1969      RTS                             ; Return from subroutine
00002928                          1970  
00002928                          1971  EA_OPMODE_COMBO:
00002928  4286                    1972      CLR.L       D6                  ; Clear space for mode bits
0000292A  4287                    1973      CLR.L       D7                  ; Clear space for register bits
0000292C  2216                    1974      MOVE.L      (A6), D1            ; Load opcode to data register 1
0000292E  143C 0007               1975      MOVE.B      #7, D2              ; Clear upper 7 bits of opcode word
00002932  E569                    1976      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002934  143C 000D               1977      MOVE.B      #13, D2             ; 'Right-align' bits 6-8 to determine opmode bits
00002938  E469                    1978      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
0000293A  1C01                    1979      MOVE.B      D1, D6              ; Save opmode bits to D6
0000293C  2216                    1980      MOVE.L      (A6), D1            ; Reload opcode to data register 1
0000293E  143C 0004               1981      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00002942  E569                    1982      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002944  143C 000D               1983      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register bits
00002948  E469                    1984      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
0000294A  1E01                    1985      MOVE.B      D1, D7              ; Save register bits to D7
0000294C  4E75                    1986      RTS                             ; Return from subroutine
0000294E                          1987  
0000294E                          1988  EA_SIZE_BITS:
0000294E  4287                    1989      CLR.L       D7
00002950  2E16                    1990      MOVE.L      (A6), D7            ; Load opcode to data register 1
00002952  143C 0008               1991      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00002956  E56F                    1992      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00002958  143C 000E               1993      MOVE.B      #14, D2             ; 'Right-align' bits 6-7 to determine size bits
0000295C  E46F                    1994      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
0000295E  4E75                    1995      RTS
00002960                          1996  
00002960                          1997  
00002960                          1998  EA_PRINT_DN:
00002960  41F9 0000296E           1999      LEA         EA_PRINT_DN_JMP, A0 ; Set index '0' for jump table
00002966  CEFC 0006               2000      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000296A  4EF0 7000               2001      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000296E                          2002  EA_PRINT_DN_JMP:
0000296E  4EF9 0000299E           2003      JMP         DN_000 ; D0
00002974  4EF9 0000299E           2004      JMP         DN_001 ; D1
0000297A  4EF9 0000299E           2005      JMP         DN_010 ; D2
00002980  4EF9 0000299E           2006      JMP         DN_011 ; D3
00002986  4EF9 0000299E           2007      JMP         DN_100 ; D4
0000298C  4EF9 0000299E           2008      JMP         DN_101 ; D5
00002992  4EF9 0000299E           2009      JMP         DN_110 ; D6
00002998  4EF9 0000299E           2010      JMP         DN_111 ; D7
0000299E                          2011  DN_000: ; D0
0000299E                          2012      *MOVE.L      #DREG0, A4
0000299E                          2013      *JSR         WRITE_LINE
0000299E                          2014  DN_001 ; D1
0000299E                          2015  DN_010 ; D2
0000299E                          2016  DN_011 ; D3
0000299E                          2017  DN_100 ; D4
0000299E                          2018  DN_101 ; D5
0000299E                          2019  DN_110 ; D6
0000299E                          2020  DN_111 ; D7
0000299E                          2021  
0000299E                          2022  EA_PRINT_DN_END:
0000299E  4E75                    2023      RTS
000029A0                          2024  
000029A0                          2025  EA_PRINT_AN:
000029A0  41F9 000029AE           2026      LEA         AN_JMP, A0          ; Set index '0' for jump table
000029A6  CEFC 0006               2027      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000029AA  4EF0 7000               2028      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000029AE                          2029  AN_JMP:
000029AE  4EF9 000029DE           2030      JMP         AN_000 ; A0
000029B4  4EF9 000029DE           2031      JMP         AN_001 ; A1
000029BA  4EF9 000029DE           2032      JMP         AN_010 ; A2
000029C0  4EF9 000029DE           2033      JMP         AN_011 ; A3
000029C6  4EF9 000029DE           2034      JMP         AN_100 ; A4
000029CC  4EF9 000029DE           2035      JMP         AN_101 ; A5
000029D2  4EF9 000029DE           2036      JMP         AN_110 ; A6
000029D8  4EF9 000029DE           2037      JMP         AN_111 ; A7
000029DE                          2038  AN_000 ; A0
000029DE                          2039  AN_001 ; A1
000029DE                          2040  AN_010 ; A2
000029DE                          2041  AN_011 ; A3
000029DE                          2042  AN_100 ; A4
000029DE                          2043  AN_101 ; A5
000029DE                          2044  AN_110 ; A6
000029DE                          2045  AN_111 ; A7
000029DE                          2046  
000029DE                          2047  EA_PRINT_AN_END:
000029DE  4E75                    2048      RTS
000029E0                          2049  EA_PRINT_IND:
000029E0  41F9 000029EE           2050      LEA         IND_JMP, A0         ; Set index '0' for jump table
000029E6  CEFC 0006               2051      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000029EA  4EF0 7000               2052      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000029EE                          2053  IND_JMP:
000029EE  4EF9 00002A1E           2054      JMP         IND_000 ; (A0)
000029F4  4EF9 00002A1E           2055      JMP         IND_001 ; (A1)
000029FA  4EF9 00002A1E           2056      JMP         IND_010 ; (A2)
00002A00  4EF9 00002A1E           2057      JMP         IND_011 ; (A3)
00002A06  4EF9 00002A1E           2058      JMP         IND_100 ; (A4)
00002A0C  4EF9 00002A1E           2059      JMP         IND_101 ; (A5)
00002A12  4EF9 00002A1E           2060      JMP         IND_110 ; (A6)
00002A18  4EF9 00002A1E           2061      JMP         IND_111 ; (A7)
00002A1E                          2062  IND_000 ; (A0)
00002A1E                          2063  IND_001 ; (A1)
00002A1E                          2064  IND_010 ; (A2)
00002A1E                          2065  IND_011 ; (A3)
00002A1E                          2066  IND_100 ; (A4)
00002A1E                          2067  IND_101 ; (A5)
00002A1E                          2068  IND_110 ; (A6)
00002A1E                          2069  IND_111 ; (A7)
00002A1E                          2070  
00002A1E                          2071  EA_PRINT_IND_END:
00002A1E  4E75                    2072      RTS
00002A20                          2073  EA_PRINT_IMM:
00002A20  224D                    2074      MOVEA.L     A5, A1              ; copy pointer to temp
00002A22  5489                    2075      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002A24  BA7C 0003               2076      CMP         #3, D5
00002A28  6700 000C               2077      BEQ         PRINT_IMM_L         ; if L, branch
00002A2C  3011                    2078      MOVE.W      (A1), D0            ; store value in a register (todo, register tbd)
00002A2E                          2079      *print value TODO
00002A2E  5489                    2080      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002A30  4EF9 00002A3A           2081      JMP         PRINT_IMM_END
00002A36                          2082  PRINT_IMM_L:
00002A36  2011                    2083      MOVE.L      (A1), D0            ; store value in a register (todo, register tbd)
00002A38                          2084      *print value TODO
00002A38  5889                    2085      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002A3A                          2086  PRINT_IMM_END:
00002A3A  2A49                    2087      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002A3C  4E75                    2088      RTS
00002A3E                          2089  EA_PRINT_POSTINC:
00002A3E  41F9 00002A4C           2090      LEA         POSTINC_JMP, A0     ; Set index '0' for jump table
00002A44  CEFC 0006               2091      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002A48  4EF0 7000               2092      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002A4C                          2093  POSTINC_JMP:
00002A4C  4EF9 00002A7C           2094      JMP         POSTINC_000 ; (A0)+
00002A52  4EF9 00002A7C           2095      JMP         POSTINC_001 ; (A1)+
00002A58  4EF9 00002A7C           2096      JMP         POSTINC_010 ; (A2)+
00002A5E  4EF9 00002A7C           2097      JMP         POSTINC_011 ; (A3)+
00002A64  4EF9 00002A7C           2098      JMP         POSTINC_100 ; (A4)+
00002A6A  4EF9 00002A7C           2099      JMP         POSTINC_101 ; (A5)+
00002A70  4EF9 00002A7C           2100      JMP         POSTINC_110 ; (A6)+
00002A76  4EF9 00002A7C           2101      JMP         POSTINC_111 ; (A7)+
00002A7C                          2102  POSTINC_000 ; (A0)+
00002A7C                          2103  POSTINC_001 ; (A1)+
00002A7C                          2104  POSTINC_010 ; (A2)+
00002A7C                          2105  POSTINC_011 ; (A3)+
00002A7C                          2106  POSTINC_100 ; (A4)+
00002A7C                          2107  POSTINC_101 ; (A5)+
00002A7C                          2108  POSTINC_110 ; (A6)+
00002A7C                          2109  POSTINC_111 ; (A7)+
00002A7C                          2110  
00002A7C                          2111  EA_PRINT_PI_END:
00002A7C  4E75                    2112      RTS
00002A7E                          2113  EA_PRINT_PREDEC:
00002A7E  41F9 00002A8C           2114      LEA         PREDEC_JMP, A0      ; Set index '0' for jump table
00002A84  CEFC 0006               2115      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002A88  4EF0 7000               2116      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002A8C                          2117  PREDEC_JMP:
00002A8C  4EF9 00002ABC           2118      JMP         PREDEC_000 ; -(A0)
00002A92  4EF9 00002ABC           2119      JMP         PREDEC_001 ; -(A1)
00002A98  4EF9 00002ABC           2120      JMP         PREDEC_010 ; -(A2)
00002A9E  4EF9 00002ABC           2121      JMP         PREDEC_011 ; -(A3)
00002AA4  4EF9 00002ABC           2122      JMP         PREDEC_100 ; -(A4)
00002AAA  4EF9 00002ABC           2123      JMP         PREDEC_101 ; -(A5)
00002AB0  4EF9 00002ABC           2124      JMP         PREDEC_110 ; -(A6)
00002AB6  4EF9 00002ABC           2125      JMP         PREDEC_111 ; -(A7)
00002ABC                          2126  PREDEC_000 ; -(A0)
00002ABC                          2127  PREDEC_001 ; -(A1)
00002ABC                          2128  PREDEC_010 ; -(A2)
00002ABC                          2129  PREDEC_011 ; -(A3)
00002ABC                          2130  PREDEC_100 ; -(A4)
00002ABC                          2131  PREDEC_101 ; -(A5)
00002ABC                          2132  PREDEC_110 ; -(A6)
00002ABC                          2133  PREDEC_111 ; -(A7)
00002ABC                          2134  
00002ABC                          2135  EA_PRINT_PD_END:
00002ABC  4E75                    2136      RTS
00002ABE                          2137  EA_PRINT_ABS_L:
00002ABE  224D                    2138      MOVEA.L     A5, A1              ; copy pointer to temp
00002AC0  5489                    2139      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002AC2  2011                    2140      MOVE.L      (A1), D0            ; store longword address to print TODO
00002AC4                          2141      *print value TODO
00002AC4  5889                    2142      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002AC6  2A49                    2143      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002AC8  4E75                    2144      RTS
00002ACA                          2145  EA_PRINT_ABS_W:
00002ACA  224D                    2146      MOVEA.L     A5, A1              ; copy pointer to temp
00002ACC  5489                    2147      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002ACE  2011                    2148      MOVE.L      (A1), D0            ; store word address to print in TODO
00002AD0                          2149      *print value TODO
00002AD0  5489                    2150      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002AD2  2A49                    2151      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002AD4  4E75                    2152      RTS
00002AD6                          2153  
00002AD6                          2154  
00002AD6                          2155  -------------------- end include --------------------
00002AD6                          2156  
00002AD6                          2157  EA_ADD:
00002AD6  48E7 FFFC               2158      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002ADA  4EB8 28FE               2159      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002ADE  4EB8 2928               2160      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00002AE2  41F9 00002AF0           2161      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
00002AE8  CCFC 0006               2162      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002AEC  4EF0 6000               2163      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002AF0                          2164  ADD_OPMODE:
00002AF0  4EF9 00002B20           2165      JMP         ADD_OPMODE_000      ; mode 1, byte
00002AF6  4EF9 00002B2A           2166      JMP         ADD_OPMODE_001      ; mode 1, word
00002AFC  4EF9 00002B34           2167      JMP         ADD_OPMODE_010      ; mode 1, long
00002B02  4EF9 00002B3E           2168      JMP         ADD_OPMODE_011      ; Invalid value
00002B08  4EF9 00002B48           2169      JMP         ADD_OPMODE_100      ; mode 2, byte
00002B0E  4EF9 00002B52           2170      JMP         ADD_OPMODE_101      ; mode 2, word
00002B14  4EF9 00002B5C           2171      JMP         ADD_OPMODE_110      ; mode 2, long
00002B1A  4EF9 00002B66           2172      JMP         ADD_OPMODE_111      ; Invalid value
00002B20                          2173  ADD_OPMODE_000: ; mode 1, byte
00002B20  1A3C 0001               2174      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002B24  4EF9 00002B70           2175      JMP         ADD_MODE_1
00002B2A                          2176  ADD_OPMODE_001: ; mode 1, word
00002B2A  1A3C 0002               2177      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00002B2E  4EF9 00002B70           2178      JMP         ADD_MODE_1
00002B34                          2179  ADD_OPMODE_010: ; mode 1, long
00002B34  1A3C 0003               2180      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00002B38  4EF9 00002B70           2181      JMP         ADD_MODE_1
00002B3E                          2182  ADD_OPMODE_011: ; Invalid value
00002B3E  4EB8 28E8               2183      JSR         EA_INVALID
00002B42  4EF9 00002C80           2184      JMP         ADD_END
00002B48                          2185  ADD_OPMODE_100: ; mode 2, byte
00002B48  1A3C 0001               2186      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002B4C  4EF9 00002B8E           2187      JMP         ADD_MODE_2
00002B52                          2188  ADD_OPMODE_101: ; mode 2, word
00002B52  1A3C 0001               2189      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002B56  4EF9 00002B8E           2190      JMP         ADD_MODE_2
00002B5C                          2191  ADD_OPMODE_110: ; mode 2, long
00002B5C  1A3C 0001               2192      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002B60  4EF9 00002B8E           2193      JMP         ADD_MODE_2
00002B66                          2194  ADD_OPMODE_111: ; Invalid value
00002B66  4EB8 28E8               2195      JSR         EA_INVALID
00002B6A  4EF9 00002C80           2196      JMP         ADD_END
00002B70                          2197  ADD_MODE_1:
00002B70  4280                    2198      CLR.L       D0                  ; Clear data register 0
00002B72  103C 0001               2199      MOVE.B      #1, D0              ; Save mode number to D0
00002B76  3207                    2200      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00002B78  4EB8 2902               2201      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002B7C  4EB9 00002BA8           2202      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002B82                          2203      *PRINT COMMA TODO
00002B82  3E01                    2204      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00002B84  4EB8 2960               2205      JSR         EA_PRINT_DN         ; Print data register
00002B88  4EF9 00002C80           2206      JMP         ADD_END
00002B8E                          2207  ADD_MODE_2:
00002B8E  4280                    2208      CLR.L       D0                  ; Clear data register 0
00002B90  103C 0002               2209      MOVE.B      #2, D0              ; Save mode number to D0
00002B94  4EB8 2960               2210      JSR         EA_PRINT_DN         ; Print data register
00002B98                          2211      *PRINT COMMA TODO
00002B98  4EB8 2902               2212      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002B9C  4EB9 00002BA8           2213      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002BA2  4EF9 00002C80           2214      JMP         ADD_END
00002BA8                          2215  ADD_EVAL_EA:
00002BA8  41F9 00002BB6           2216      LEA         ADD_MODE, A0        ; Set index '0' for jump table
00002BAE  CCFC 0006               2217      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002BB2  4EF0 6000               2218      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002BB6                          2219  ADD_MODE:
00002BB6  4EF9 00002BE6           2220      JMP         ADD_MODE_000        ; Dn (invalid if opmode 2)
00002BBC  4EF9 00002BF8           2221      JMP         ADD_MODE_001        ; An (invalid if opmode 2)
00002BC2  4EF9 00002C0A           2222      JMP         ADD_MODE_010        ; (An)
00002BC8  4EF9 00002C14           2223      JMP         ADD_MODE_011        ; (An)+
00002BCE  4EF9 00002C1E           2224      JMP         ADD_MODE_100        ; -(An)
00002BD4  4EF9 00002C28           2225      JMP         ADD_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00002BDA  4EF9 00002C2E           2226      JMP         ADD_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002BE0  4EF9 00002C34           2227      JMP         ADD_MODE_111        ; The rest (not all valid, validated by register number)
00002BE6                          2228  ADD_MODE_000: ; Dn (invalid if opmode 2)
00002BE6  B07C 0002               2229      CMP         #2, D0
00002BEA  6700 008E               2230      BEQ         ADD_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00002BEE  4EB8 2960               2231      JSR         EA_PRINT_DN         ; Print data register direct operand
00002BF2  4EF9 00002C78           2232      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002BF8                          2233  ADD_MODE_001: ; An (invalid if opmode 2)
00002BF8  B07C 0002               2234      CMP         #2, D0
00002BFC  6700 007C               2235      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002C00  4EB8 29A0               2236      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002C04  4EF9 00002C78           2237      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002C0A                          2238  ADD_MODE_010: ; (An)
00002C0A  4EB8 29E0               2239      JSR         EA_PRINT_IND         ; Print address register indirect
00002C0E  4EF9 00002C78           2240      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002C14                          2241  ADD_MODE_011: ; (An)+
00002C14  4EB8 2A3E               2242      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002C18  4EF9 00002C78           2243      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002C1E                          2244  ADD_MODE_100: ; -(An)
00002C1E  4EB8 2A7E               2245      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002C22  4EF9 00002C78           2246      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002C28                          2247  ADD_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002C28  4EF9 00002C7A           2248      JMP         ADD_MODE_INVALID
00002C2E                          2249  ADD_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002C2E  4EF9 00002C7A           2250      JMP         ADD_MODE_INVALID
00002C34                          2251  ADD_MODE_111: ; The rest (not all valid, validated by register number)
00002C34  BE3C 0000               2252      CMP.B       #$00, D7            ; Test for absolute word address
00002C38  6700 0018               2253      BEQ         ADD_ABS_W
00002C3C  BE3C 0001               2254      CMP.B       #$01, D7            ; Test for absolute long address
00002C40  6700 001A               2255      BEQ         ADD_ABS_L
00002C44  BE3C 0004               2256      CMP.B       #$04, D7            ; Test for immediate data
00002C48  6700 001C               2257      BEQ         ADD_IMM
00002C4C  4EF9 00002C7A           2258      JMP         ADD_MODE_INVALID    ; else, invalid
00002C52                          2259  ADD_ABS_W:
00002C52  4EB8 2ACA               2260      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002C56  4EF9 00002C78           2261      JMP         ADD_MODE_END
00002C5C                          2262  ADD_ABS_L:
00002C5C  4EB8 2ABE               2263      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002C60  4EF9 00002C78           2264      JMP         ADD_MODE_END
00002C66                          2265  ADD_IMM: ; invalid if opmode is 2
00002C66  B07C 0002               2266      CMP         #2, D0
00002C6A  6700 000E               2267      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002C6E  4EB8 2A20               2268      JSR         EA_PRINT_IMM        ; Print immediate data
00002C72  4EF9 00002C78           2269      JMP         ADD_MODE_END
00002C78                          2270  ADD_MODE_END:
00002C78  4E75                    2271      RTS                             ; Finish evaluating EA bits
00002C7A                          2272  ADD_MODE_INVALID:
00002C7A  4EB8 28E8               2273      JSR         EA_INVALID          ; Opcode word is Invalid
00002C7E  4E75                    2274      RTS                             ; Finish evaluating EA bits
00002C80                          2275  ADD_END:
00002C80  4EB8 28F2               2276      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00002C84  4CDF 3FFF               2277      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002C88  4E75                    2278      RTS
00002C8A                          2279  
00002C8A                          2280  EA_ADDA:
00002C8A  48E7 FFFC               2281      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002C8E  4EB8 28FE               2282      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002C92  4EB8 2902               2283      JSR         EA_DEFAULT_COMBO    ; Mode: D6, register: D7
00002C96  41F9 00002CA4           2284      LEA         ADDA_MODE, A0       ; Set index '0' for jump table
00002C9C  CCFC 0006               2285      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002CA0  4EF0 6000               2286      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002CA4                          2287  ADDA_MODE:
00002CA4  4EF9 00002CD4           2288      JMP         ADDA_MODE_000       ; Dn
00002CAA  4EF9 00002CDE           2289      JMP         ADDA_MODE_001       ; An
00002CB0  4EF9 00002CE8           2290      JMP         ADDA_MODE_010       ; (An)
00002CB6  4EF9 00002CF2           2291      JMP         ADDA_MODE_011       ; (An)+
00002CBC  4EF9 00002CFC           2292      JMP         ADDA_MODE_100       ; -(An)
00002CC2  4EF9 00002D06           2293      JMP         ADDA_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00002CC8  4EF9 00002D0C           2294      JMP         ADDA_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002CCE  4EF9 00002D12           2295      JMP         ADDA_MODE_111       ; The rest (not all valid, validated by register number)
00002CD4                          2296  ADDA_MODE_000: ; Dn
00002CD4  4EB8 2960               2297      JSR         EA_PRINT_DN         ; Print data register direct operand
00002CD8  4EF9 00002D5C           2298      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002CDE                          2299  ADDA_MODE_001: ; An
00002CDE  4EB8 29A0               2300      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002CE2  4EF9 00002D5C           2301      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002CE8                          2302  ADDA_MODE_010: ; (An)
00002CE8  4EB8 29E0               2303      JSR         EA_PRINT_IND         ; Print address register indirect
00002CEC  4EF9 00002D5C           2304      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002CF2                          2305  ADDA_MODE_011: ; (An)+
00002CF2  4EB8 2A3E               2306      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002CF6  4EF9 00002D5C           2307      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002CFC                          2308  ADDA_MODE_100: ; -(An)
00002CFC  4EB8 2A7E               2309      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002D00  4EF9 00002D5C           2310      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002D06                          2311  ADDA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002D06  4EF9 00002D52           2312      JMP         ADDA_MODE_INVALID
00002D0C                          2313  ADDA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002D0C  4EF9 00002D52           2314      JMP         ADDA_MODE_INVALID
00002D12                          2315  ADDA_MODE_111: ; The rest (not all valid, validated by register number)
00002D12  BE3C 0000               2316      CMP.B       #$00, D7            ; Test for absolute word address
00002D16  6700 0018               2317      BEQ         ADDA_ABS_W
00002D1A  BE3C 0001               2318      CMP.B       #$01, D7            ; Test for absolute long address
00002D1E  6700 001A               2319      BEQ         ADDA_ABS_L
00002D22  BE3C 0004               2320      CMP.B       #$04, D7            ; Test for immediate data
00002D26  6700 001C               2321      BEQ         ADDA_IMM
00002D2A  4EF9 00002D52           2322      JMP         ADDA_MODE_INVALID   ; Else, invalid
00002D30                          2323  ADDA_ABS_W:
00002D30  4EB8 2ACA               2324      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002D34  4EF9 00002D5C           2325      JMP         ADDA_MODE_END
00002D3A                          2326  ADDA_ABS_L:
00002D3A  4EB8 2ABE               2327      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002D3E  4EF9 00002D5C           2328      JMP         ADDA_MODE_END
00002D44                          2329  ADDA_IMM:
00002D44  4EB8 2928               2330      JSR         EA_OPMODE_COMBO     ; Get opmode bits in
00002D48  4EB8 2A20               2331      JSR         EA_PRINT_IMM        ; Print immediate data
00002D4C  4EF9 00002D5C           2332      JMP         ADDA_MODE_END
00002D52                          2333  ADDA_MODE_INVALID:
00002D52  4EB8 28E8               2334      JSR         EA_INVALID          ; Opcode word is Invalid
00002D56  4EF9 00002D64           2335      JMP         ADDA_END
00002D5C                          2336  ADDA_MODE_END:
00002D5C                          2337      *PRINT COMMA TODO
00002D5C  4EB8 2928               2338      JSR         EA_OPMODE_COMBO     ; Opmode: D6, register: D7
00002D60  4EB8 29A0               2339      JSR         EA_PRINT_AN         ; Print address register
00002D64                          2340  ADDA_END:
00002D64  4EB8 28F2               2341      JSR         EA_UPDATE_POINTER   ; Update global pointer
00002D68  4CDF 3FFF               2342      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002D6C  4E75                    2343      RTS
00002D6E                          2344  
00002D6E                          2345  EA_ADDI:
00002D6E  48E7 FFFC               2346      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002D72  4EB8 28FE               2347      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002D76  4EB8 294E               2348      JSR         EA_SIZE_BITS        ; get size bits in D7
00002D7A  BE3C 0000               2349      CMP.B       #$00, D7            ; Test if size: byte
00002D7E  6700 001C               2350      BEQ         ADDI_B
00002D82  BE3C 0001               2351      CMP.B       #$01, D7            ; Test if size: word
00002D86  6700 002E               2352      BEQ         ADDI_W
00002D8A  BE3C 0002               2353      CMP.B       #$02, D7            ; Test if size: long
00002D8E  6700 0034               2354      BEQ         ADDI_L
00002D92  4EB8 28E8               2355      JSR         EA_INVALID          ; Else, invalid
00002D96  4EF9 00002E80           2356      JMP         ADDI_END
00002D9C                          2357  ADDI_B:
00002D9C  548D                    2358      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002D9E  4280                    2359      CLR.L       D0
00002DA0  3015                    2360      MOVE.W      (A5), D0            ; read next word in memory and save
00002DA2  143C 0008               2361      MOVE.B      #8, D2              ; Clear upper 8 bits of operand word
00002DA6  E568                    2362      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00002DA8  143C 0008               2363      MOVE.B      #8, D2             ; 'Right-align' bits 0-7 to get value
00002DAC  E468                    2364      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00002DAE                          2365      *print data
00002DAE  548D                    2366      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
00002DB0  4EF9 00002DCA           2367      JMP         ADDI_GET_DEST
00002DB6                          2368  ADDI_W:
00002DB6  548D                    2369      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002DB8  4280                    2370      CLR.L       D0
00002DBA  3015                    2371      MOVE.W      (A5), D0            ; read next word in memory and save
00002DBC                          2372      *print data
00002DBC  548D                    2373      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
00002DBE  4EF9 00002DCA           2374      JMP         ADDI_GET_DEST
00002DC4                          2375  ADDI_L:
00002DC4  548D                    2376      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002DC6  2015                    2377      MOVE.L      (A5), D0            ; read next two words in memory and save
00002DC8  588D                    2378      ADDA.L      #$00000004, A5      ; Increment A5 past operand longword
00002DCA                          2379  ADDI_GET_DEST:
00002DCA                          2380      *PRINT COMMA
00002DCA  4EB8 2902               2381      JSR         EA_DEFAULT_COMBO    ; get mode bits in D6, register bits in D7
00002DCE  41F9 00002DDC           2382      LEA         ADDI_MODE, A0       ; Set index '0' for jump table
00002DD4  CCFC 0006               2383      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002DD8  4EF0 6000               2384      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002DDC                          2385  ADDI_MODE:
00002DDC  4EF9 00002E0C           2386      JMP         ADDI_MODE_000       ; Dn
00002DE2  4EF9 00002E16           2387      JMP         ADDI_MODE_001       ; Invalid: An
00002DE8  4EF9 00002E20           2388      JMP         ADDI_MODE_010       ; (An)
00002DEE  4EF9 00002E2A           2389      JMP         ADDI_MODE_011       ; (An)+
00002DF4  4EF9 00002E34           2390      JMP         ADDI_MODE_100       ; -(An)
00002DFA  4EF9 00002E3E           2391      JMP         ADDI_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00002E00  4EF9 00002E48           2392      JMP         ADDI_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002E06  4EF9 00002E52           2393      JMP         ADDI_MODE_111       ; The rest (not all valid, validated by register number)
00002E0C                          2394  ADDI_MODE_000: ; Dn
00002E0C  4EB8 2960               2395      JSR         EA_PRINT_DN         ; Print data register direct operand
00002E10  4EF9 00002E80           2396      JMP         ADDI_END
00002E16                          2397  ADDI_MODE_001: ; Invalid: An
00002E16  4EB8 28E8               2398      JSR         EA_INVALID          ; Opcode word is Invalid
00002E1A  4EF9 00002E80           2399      JMP         ADDI_END
00002E20                          2400  ADDI_MODE_010: ; (An)
00002E20  4EB8 29E0               2401      JSR         EA_PRINT_IND         ; Print address register indirect
00002E24  4EF9 00002E80           2402      JMP         ADDI_END            ; End evaluation of ea mode
00002E2A                          2403  ADDI_MODE_011: ; (An)+
00002E2A  4EB8 2A3E               2404      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002E2E  4EF9 00002E80           2405      JMP         ADDI_END            ; End evaluation of ea mode
00002E34                          2406  ADDI_MODE_100: ; -(An)
00002E34  4EB8 2A7E               2407      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002E38  4EF9 00002E80           2408      JMP         ADDI_END            ; End evaluation of ea mode
00002E3E                          2409  ADDI_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002E3E  4EB8 28E8               2410      JSR         EA_INVALID          ; Opcode word is Invalid
00002E42  4EF9 00002E80           2411      JMP         ADDI_END
00002E48                          2412  ADDI_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002E48  4EB8 28E8               2413      JSR         EA_INVALID          ; Opcode word is Invalid
00002E4C  4EF9 00002E80           2414      JMP         ADDI_END
00002E52                          2415  ADDI_MODE_111: ; The rest (not all valid, validated by register number)
00002E52  BE3C 0000               2416      CMP.B       #$00, D7            ; Test for absolute word address
00002E56  6700 0014               2417      BEQ         ADDI_ABS_W
00002E5A  BE3C 0001               2418      CMP.B       #$01, D7            ; Test for absolute long address
00002E5E  6700 0016               2419      BEQ         ADDI_ABS_L
00002E62  4EB8 28E8               2420      JSR         EA_INVALID          ; else, invalid
00002E66  4EF9 00002E80           2421      JMP         ADDI_END
00002E6C                          2422  ADDI_ABS_W:
00002E6C  4EB8 2ACA               2423      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002E70  4EF9 00002E80           2424      JMP         ADDI_END
00002E76                          2425  ADDI_ABS_L:
00002E76  4EB8 2ABE               2426      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002E7A  4EF9 00002E80           2427      JMP         ADDI_END
00002E80                          2428  ADDI_END:
00002E80  4EB8 28F2               2429      JSR         EA_UPDATE_POINTER   ; Update global pointer
00002E84  4CDF 3FFF               2430      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002E88  4E75                    2431      RTS
00002E8A                          2432  EA_ADDQ:
00002E8A  48E7 FFFC               2433      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002E8E  4EB8 28FE               2434      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002E92  2216                    2435      MOVE.L      (A6), D1            ; Load opcode to data register 1
00002E94  143C 0004               2436      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00002E98  E569                    2437      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00002E9A  143C 000D               2438      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine mode bits
00002E9E  E469                    2439      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002EA0  B23C 0000               2440      CMP.B       #$00, D1            ; Check for special case (if imm. data is 0, value is actually 8)
00002EA4  6600 0006               2441      BNE         ADDQ_PRINT_IMM      ; If any value other than 0, print the data
00002EA8  123C 0008               2442      MOVE.B      #$08, D1            ; Else, the value is 0 and therefore symbolic of the value 8, so replace with the value 8
00002EAC                          2443  ADDQ_PRINT_IMM:
00002EAC                          2444      *PRINT HASH TODO
00002EAC                          2445      *PRINT IMM DATA IN D1 AS BYTE TODO
00002EAC                          2446      *PRINT COMMA TODO
00002EAC  4EB8 2902               2447      JSR         EA_DEFAULT_COMBO
00002EB0  41F9 00002EBE           2448      LEA         ADDQ_MODE, A0       ; Set index '0' for jump table
00002EB6  CCFC 0006               2449      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002EBA  4EF0 6000               2450      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002EBE                          2451  ADDQ_MODE:
00002EBE  4EF9 00002EEE           2452      JMP         ADDQ_MODE_000       ; Dn
00002EC4  4EF9 00002EF8           2453      JMP         ADDQ_MODE_001       ; An
00002ECA  4EF9 00002F02           2454      JMP         ADDQ_MODE_010       ; (An)
00002ED0  4EF9 00002F0C           2455      JMP         ADDQ_MODE_011       ; (An)+
00002ED6  4EF9 00002F16           2456      JMP         ADDQ_MODE_100       ; -(An)
00002EDC  4EF9 00002F20           2457      JMP         ADDQ_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00002EE2  4EF9 00002F2A           2458      JMP         ADDQ_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002EE8  4EF9 00002F34           2459      JMP         ADDQ_MODE_111       ; The rest (not all valid, validated by register number)
00002EEE                          2460  ADDQ_MODE_000: ; Dn
00002EEE  4EB8 2960               2461      JSR         EA_PRINT_DN         ; Print data register direct operand
00002EF2  4EF9 00002F62           2462      JMP         ADDQ_END            ; End evaluation of ea mode
00002EF8                          2463  ADDQ_MODE_001: ; An
00002EF8  4EB8 29A0               2464      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002EFC  4EF9 00002F62           2465      JMP         ADDQ_END            ; End evaluation of ea mode
00002F02                          2466  ADDQ_MODE_010: ; (An)
00002F02  4EB8 29E0               2467      JSR         EA_PRINT_IND         ; Print address register indirect
00002F06  4EF9 00002F62           2468      JMP         ADDQ_END            ; End evaluation of ea mode
00002F0C                          2469  ADDQ_MODE_011: ; (An)+
00002F0C  4EB8 2A3E               2470      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002F10  4EF9 00002F62           2471      JMP         ADDQ_END            ; End evaluation of ea mode
00002F16                          2472  ADDQ_MODE_100: ; -(An)
00002F16  4EB8 2A7E               2473      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002F1A  4EF9 00002F62           2474      JMP         ADDQ_END            ; End evaluation of ea mode
00002F20                          2475  ADDQ_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002F20  4EB8 28E8               2476      JSR         EA_INVALID          ; Opcode word is Invalid
00002F24  4EF9 00002F62           2477      JMP         ADDQ_END
00002F2A                          2478  ADDQ_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002F2A  4EB8 28E8               2479      JSR         EA_INVALID          ; Opcode word is Invalid
00002F2E  4EF9 00002F62           2480      JMP         ADDQ_END
00002F34                          2481  ADDQ_MODE_111: ; The rest (not all valid, validated by register number)
00002F34  BE3C 0000               2482      CMP.B       #$00, D7            ; Test for absolute word address
00002F38  6700 0014               2483      BEQ         ADDQ_ABS_W
00002F3C  BE3C 0001               2484      CMP.B       #$01, D7            ; Test for absolute long address
00002F40  6700 0016               2485      BEQ         ADDQ_ABS_L
00002F44  4EB8 28E8               2486      JSR         EA_INVALID          ; Opcode word is Invalid
00002F48  4EF9 00002F62           2487      JMP         ADDQ_END
00002F4E                          2488  ADDQ_ABS_W:
00002F4E  4EB8 2ACA               2489      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002F52  4EF9 00002F62           2490      JMP         ADDQ_END
00002F58                          2491  ADDQ_ABS_L:
00002F58  4EB8 2ABE               2492      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002F5C  4EF9 00002F62           2493      JMP         ADDQ_END
00002F62                          2494  
00002F62                          2495  ADDQ_END:
00002F62  4EB8 28F2               2496      JSR         EA_UPDATE_POINTER   ; Update global pointer
00002F66  4CDF 3FFF               2497      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002F6A  4E75                    2498      RTS
00002F6C                          2499  EA_AND:
00002F6C  48E7 FFFC               2500      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002F70  4EB8 28FE               2501      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002F74  4EB8 2928               2502      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00002F78  41F8 2AF0               2503      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
00002F7C  CCFC 0006               2504      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002F80  4EF0 6000               2505      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002F84                          2506  AND_OPMODE:
00002F84  4EF9 00002FB4           2507      JMP         AND_OPMODE_000      ; mode 1, byte
00002F8A  4EF9 00002FBE           2508      JMP         AND_OPMODE_001      ; mode 1, word
00002F90  4EF9 00002FC8           2509      JMP         AND_OPMODE_010      ; mode 1, long
00002F96  4EF9 00002FD2           2510      JMP         AND_OPMODE_011      ; Invalid value
00002F9C  4EF9 00002FDC           2511      JMP         AND_OPMODE_100      ; mode 2, byte
00002FA2  4EF9 00002FE6           2512      JMP         AND_OPMODE_101      ; mode 2, word
00002FA8  4EF9 00002FF0           2513      JMP         AND_OPMODE_110      ; mode 2, long
00002FAE  4EF9 00002FFA           2514      JMP         AND_OPMODE_111      ; Invalid value
00002FB4                          2515  AND_OPMODE_000: ; mode 1, byte
00002FB4  1A3C 0001               2516      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002FB8  4EF9 00003004           2517      JMP         AND_MODE_1
00002FBE                          2518  AND_OPMODE_001: ; mode 1, word
00002FBE  1A3C 0002               2519      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00002FC2  4EF9 00003004           2520      JMP         AND_MODE_1
00002FC8                          2521  AND_OPMODE_010: ; mode 1, long
00002FC8  1A3C 0003               2522      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00002FCC  4EF9 00003004           2523      JMP         AND_MODE_1
00002FD2                          2524  AND_OPMODE_011: ; Invalid value
00002FD2  4EB8 28E8               2525      JSR         EA_INVALID
00002FD6  4EF9 00003108           2526      JMP         AND_END
00002FDC                          2527  AND_OPMODE_100: ; mode 2, byte
00002FDC  1A3C 0001               2528      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002FE0  4EF9 00003022           2529      JMP         AND_MODE_2
00002FE6                          2530  AND_OPMODE_101: ; mode 2, word
00002FE6  1A3C 0001               2531      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002FEA  4EF9 00003022           2532      JMP         AND_MODE_2
00002FF0                          2533  AND_OPMODE_110: ; mode 2, long
00002FF0  1A3C 0001               2534      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002FF4  4EF9 00003022           2535      JMP         AND_MODE_2
00002FFA                          2536  AND_OPMODE_111: ; Invalid value
00002FFA  4EB8 28E8               2537      JSR         EA_INVALID
00002FFE  4EF9 00003108           2538      JMP         AND_END
00003004                          2539  AND_MODE_1:
00003004  4280                    2540      CLR.L       D0                  ; Clear data register 0
00003006  103C 0001               2541      MOVE.B      #1, D0              ; Save mode number to D0
0000300A  3207                    2542      MOVE.W      D7, D1              ; Save register value for printing dest. operand
0000300C  4EB8 2902               2543      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003010  4EB9 0000303C           2544      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
00003016                          2545      *PRINT COMMA TODO
00003016  3E01                    2546      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003018  4EB8 2960               2547      JSR         EA_PRINT_DN         ; Print data register
0000301C  4EF9 00003108           2548      JMP         AND_END
00003022                          2549  AND_MODE_2:
00003022  4280                    2550      CLR.L       D0                  ; Clear data register 0
00003024  103C 0002               2551      MOVE.B      #2, D0              ; Save mode number to D0
00003028  4EB8 2960               2552      JSR         EA_PRINT_DN         ; Print data register
0000302C                          2553      *PRINT COMMA TODO
0000302C  4EB8 2902               2554      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003030  4EB9 0000303C           2555      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
00003036  4EF9 00003108           2556      JMP         AND_END
0000303C                          2557  AND_EVAL_EA:
0000303C  41F9 0000304A           2558      LEA         AND_MODE, A0        ; Set index '0' for jump table
00003042  CCFC 0006               2559      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003046  4EF0 6000               2560      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000304A                          2561  AND_MODE:
0000304A  4EF9 0000307A           2562      JMP         AND_MODE_000        ; Dn (invalid if opmode 2)
00003050  4EF9 0000308C           2563      JMP         AND_MODE_001        ; Invalid: An
00003056  4EF9 00003092           2564      JMP         AND_MODE_010        ; (An)
0000305C  4EF9 0000309C           2565      JMP         AND_MODE_011        ; (An)+
00003062  4EF9 000030A6           2566      JMP         AND_MODE_100        ; -(An)
00003068  4EF9 000030B0           2567      JMP         AND_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
0000306E  4EF9 000030B6           2568      JMP         AND_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003074  4EF9 000030BC           2569      JMP         AND_MODE_111        ; The rest (not all valid, validated by register number)
0000307A                          2570  AND_MODE_000: ; Dn (invalid if opmode 2)
0000307A  B07C 0002               2571      CMP         #2, D0
0000307E  6700 0082               2572      BEQ         AND_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00003082  4EB8 2960               2573      JSR         EA_PRINT_DN         ; Print data register direct operand
00003086  4EF9 00003100           2574      JMP         AND_MODE_END        ; End evaluation of ea mode
0000308C                          2575  AND_MODE_001: ; Invalid: An
0000308C  4EF9 00003102           2576      JMP         AND_MODE_INVALID
00003092                          2577  AND_MODE_010: ; (An)
00003092  4EB8 29E0               2578      JSR         EA_PRINT_IND         ; Print address register indirect
00003096  4EF9 00003100           2579      JMP         AND_MODE_END        ; End evaluation of ea mode
0000309C                          2580  AND_MODE_011: ; (An)+
0000309C  4EB8 2A3E               2581      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000030A0  4EF9 00003100           2582      JMP         AND_MODE_END        ; End evaluation of ea mode
000030A6                          2583  AND_MODE_100: ; -(An)
000030A6  4EB8 2A7E               2584      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000030AA  4EF9 00003100           2585      JMP         AND_MODE_END        ; End evaluation of ea mode
000030B0                          2586  AND_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000030B0  4EF9 00003102           2587      JMP         AND_MODE_INVALID
000030B6                          2588  AND_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000030B6  4EF9 00003102           2589      JMP         AND_MODE_INVALID
000030BC                          2590  AND_MODE_111: ; The rest (not all valid, validated by register number)
000030BC  BE3C 0000               2591      CMP.B       #$00, D7            ; Test for absolute word address
000030C0  6700 0018               2592      BEQ         AND_ABS_W
000030C4  BE3C 0001               2593      CMP.B       #$01, D7            ; Test for absolute long address
000030C8  6700 001A               2594      BEQ         AND_ABS_L
000030CC  BE3C 0004               2595      CMP.B       #$04, D7            ; Test for immediate data
000030D0  6700 001C               2596      BEQ         AND_IMM
000030D4  4EF9 00003102           2597      JMP         AND_MODE_INVALID    ; else, invalid
000030DA                          2598  AND_ABS_W:
000030DA  4EB8 2ACA               2599      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000030DE  4EF9 00003100           2600      JMP         AND_MODE_END
000030E4                          2601  AND_ABS_L:
000030E4  4EB8 2ABE               2602      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000030E8  4EF9 00003100           2603      JMP         AND_MODE_END
000030EE                          2604  AND_IMM: ; invalid if opmode is 2
000030EE  B07C 0002               2605      CMP         #2, D0
000030F2  6700 000E               2606      BEQ         AND_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
000030F6  4EB8 2A20               2607      JSR         EA_PRINT_IMM        ; Print immediate data
000030FA  4EF9 00003100           2608      JMP         AND_MODE_END
00003100                          2609  AND_MODE_END:
00003100  4E75                    2610      RTS                             ; Finish evaluating EA bits
00003102                          2611  AND_MODE_INVALID:
00003102  4EB8 28E8               2612      JSR         EA_INVALID          ; Opcode word is Invalid
00003106  4E75                    2613      RTS                             ; Finish evaluating EA bits
00003108                          2614  AND_END:
00003108  4EB8 28F2               2615      JSR         EA_UPDATE_POINTER   ; Updates global pointer
0000310C  4CDF 3FFF               2616      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003110  4E75                    2617      RTS
00003112                          2618  EA_ASd:
00003112  48E7 FFFC               2619      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003116  4EB8 28FE               2620      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000311A  4EB8 294E               2621      JSR         EA_SIZE_BITS        ; get size bits in D7
0000311E  BE3C 0003               2622      CMP.B       #$03, D7            ; test if memory shift
00003122  6700 0042               2623      BEQ         ASd_MEM
00003126  6000 0002               2624      BRA         ASd_REG             ; else, register shfit
0000312A                          2625  ASd_REG:
0000312A  3E16                    2626      MOVE.W      (A6), D7            ; read opcode word in memory and save,
0000312C                          2627                                      ; (using D7 because EA_PRINT_DN uses D7)
0000312C  143C 0004               2628      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
00003130  E56F                    2629      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003132  143C 000D               2630      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
00003136  E46F                    2631      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003138  3016                    2632      MOVE.W      (A6), D0            ; read opcode word in memory and save
0000313A  143C 000A               2633      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
0000313E  E568                    2634      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00003140  143C 000F               2635      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
00003144  E468                    2636      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00003146  B03C 0000               2637      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
0000314A  6700 000C               2638      BEQ         ASd_REG_COUNT
0000314E                          2639  ASd_REG_REG:                        ; Else, count/register field contains register number
0000314E  4EB8 2960               2640      JSR         EA_PRINT_DN         ; Print register value, stored in D7
00003152  4EF9 00003158           2641      JMP         ASd_REG_END         ; Jump to end of ASd_REG
00003158                          2642  ASd_REG_COUNT:
00003158                          2643      *print hash todo
00003158                          2644      *print hex value in D7 as byte todo, continue on to ASd_REG_END
00003158                          2645  ASd_REG_END:
00003158                          2646      *PRINT COMMA todo
00003158  4EB8 2902               2647      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
0000315C  4EB8 2960               2648      JSR         EA_PRINT_DN         ; Print register value in D7
00003160  4EF9 0000321C           2649      JMP         ASd_END
00003166                          2650  ASd_MEM:
00003166  4EB8 2902               2651      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
0000316A  41F9 00003178           2652      LEA         ASd_MEM_MODE, A0    ; Set index '0' for jump table
00003170  CCFC 0006               2653      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003174  4EF0 6000               2654      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003178                          2655  ASd_MEM_MODE:
00003178  4EF9 000031A8           2656      JMP         ASd_MEM_MODE_000     ; Invalid: Dn
0000317E  4EF9 000031B2           2657      JMP         ASd_MEM_MODE_001     ; Invalid: An
00003184  4EF9 000031BC           2658      JMP         ASd_MEM_MODE_010     ; (An)
0000318A  4EF9 000031C6           2659      JMP         ASd_MEM_MODE_011     ; (An)+
00003190  4EF9 000031D0           2660      JMP         ASd_MEM_MODE_100     ; -(An)
00003196  4EF9 000031DA           2661      JMP         ASd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
0000319C  4EF9 000031E4           2662      JMP         ASd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000031A2  4EF9 000031EE           2663      JMP         ASd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
000031A8                          2664  ASd_MEM_MODE_000: ; Invalid: Dn
000031A8  4EB8 28E8               2665      JSR         EA_INVALID          ; Data register direct is invalid mode
000031AC  4EF9 0000321C           2666      JMP         ASd_END
000031B2                          2667  ASd_MEM_MODE_001: ; Invalid: An
000031B2  4EB8 28E8               2668      JSR         EA_INVALID          ; Address register direct is invalid mode
000031B6  4EF9 0000321C           2669      JMP         ASd_END
000031BC                          2670  ASd_MEM_MODE_010: ; (An)
000031BC  4EB8 29E0               2671      JSR         EA_PRINT_IND         ; Print address register indirect
000031C0  4EF9 0000321C           2672      JMP         ASd_END
000031C6                          2673  ASd_MEM_MODE_011: ; (An)+
000031C6  4EB8 2A3E               2674      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000031CA  4EF9 0000321C           2675      JMP         ASd_END
000031D0                          2676  ASd_MEM_MODE_100: ; -(An)
000031D0  4EB8 2A7E               2677      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000031D4  4EF9 0000321C           2678      JMP         ASd_END         ; Continue with parsing destination operand
000031DA                          2679  ASd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000031DA  4EB8 28E8               2680      JSR         EA_INVALID          ; Opcode word is Invalid
000031DE  4EF9 0000321C           2681      JMP         ASd_END
000031E4                          2682  ASd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000031E4  4EB8 28E8               2683      JSR         EA_INVALID          ; Opcode word is Invalid
000031E8  4EF9 0000321C           2684      JMP         ASd_END
000031EE                          2685  ASd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
000031EE  BE3C 0000               2686      CMP.B       #$00, D7            ; Test for absolute word address
000031F2  6700 0014               2687      BEQ         ASd_MEM_ABS_W
000031F6  BE3C 0001               2688      CMP.B       #$01, D7            ; Test for absolute long address
000031FA  6700 0016               2689      BEQ         ASd_MEM_ABS_L
000031FE  4EB8 28E8               2690      JSR         EA_INVALID          ; Else: invalid
00003202  4EF9 0000321C           2691      JMP         ASd_END
00003208                          2692  ASd_MEM_ABS_W:
00003208  4EB8 2ACA               2693      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000320C  4EF9 0000321C           2694      JMP         ASd_END
00003212                          2695  ASd_MEM_ABS_L:
00003212  4EB8 2ABE               2696      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003216  4EF9 0000321C           2697      JMP         ASd_END
0000321C                          2698  ASd_END:
0000321C  4EB8 28F2               2699      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003220  4CDF 3FFF               2700      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003224  4E75                    2701      RTS
00003226                          2702  EA_Bcc: *ONLY BCC (0100), BGT (1110), BLE (1111)
00003226                          2703          *two's complement and stuff. for later TODO
00003226  48E7 FFFC               2704      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000322A  4EB8 28FE               2705      JSR         EA_COPY_PTR         ; Copy global pointer to A5
0000322E  2216                    2706      MOVE.L      (A6), D1            ; Load opcode to data register 1
00003230  143C 0008               2707      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003234  E569                    2708      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00003236  143C 0008               2709      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine condition
0000323A  E469                    2710      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
0000323C                          2711      *save ultimate address to be printed
0000323C  284E                    2712      MOVEA.L     A6, A4              ; Copy global pointer for dislay
0000323E  B23C 0000               2713      CMP.B       #$00, D1            ; If value is zero, real value is next word in memory
00003242  6700 0034               2714      BEQ         BCC_W
00003246  B23C 00FF               2715      CMP.B       #$FF, D1            ; If value is FF, real value is next longword
0000324A  6700 004E               2716      BEQ         BCC_L
0000324E  4EF9 00003254           2717      JMP         BCC_B               ; Else, parse lower-order byte of opcode word
00003254                          2718  BCC_B:
00003254  548C                    2719      ADDA.L      #$00000002, A4      ; Increment display pointer past opcode word
00003256  3616                    2720      MOVE.W      (A6), D3            ; Save opcode word
00003258  143C 0008               2721      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
0000325C  E56B                    2722      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
0000325E  143C 000F               2723      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
00003262  E46B                    2724      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003264  B63C 0000               2725      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003268  6700 003E               2726      BEQ         BCC_DISPLAY
0000326C  0681 FFFFFF00           2727      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
00003272  4EF9 000032A8           2728      JMP         BCC_DISPLAY
00003278                          2729  BCC_W:
00003278  588C                    2730      ADDA.L      #$00000004, A4      ; Increment display pointer past opcode word
0000327A                          2731                                      ; and displacement word in memory
0000327A  548D                    2732      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
0000327C  3615                    2733      MOVE.W      (A5), D3            ; Read word displacement from memory
0000327E  548D                    2734      ADDA.L      #$00000002, A5      ; Increment A5 past word read
00003280  143C 000F               2735      MOVE.B      #15, D2             ; 'Right-align' bit 15 to determine MSB
00003284  E46B                    2736      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003286  B63C 0000               2737      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
0000328A  6700 001C               2738      BEQ         BCC_DISPLAY
0000328E  0681 FFFF0000           2739      ADD.L       #$FFFF0000, D1      ; Else, sign extend data with F
00003294  4EF9 000032A8           2740      JMP         BCC_DISPLAY
0000329A                          2741  BCC_L:
0000329A  5C8C                    2742      ADDA.L      #$00000006, A4      ; Increment display pointer past opcode word
0000329C                          2743                                      ; and displacement longword in memory
0000329C  548D                    2744      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
0000329E  2215                    2745      MOVE.L      (A5), D1            ; Read longword displacement from memory
000032A0  588D                    2746      ADDA.L      #$00000004, A5      ; Increment A5 past longword read
000032A2  4EF9 000032A8           2747      JMP         BCC_DISPLAY
000032A8                          2748  BCC_DISPLAY:
000032A8  D9C1                    2749      ADDA.L      D1, A4              ; add displacement to current addressing
000032AA                          2750      *print address in A4
000032AA  4EB8 28F2               2751      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000032AE  4CDF 3FFF               2752      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000032B2  4E75                    2753      RTS
000032B4                          2754  EA_CLR:
000032B4  48E7 FFFC               2755      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000032B8  4EB8 28FE               2756      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000032BC  4EB8 2902               2757      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000032C0  41F9 000032CE           2758      LEA         CLR_MODE, A0        ; Set index '0' for jump table
000032C6  CCFC 0006               2759      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000032CA  4EF0 6000               2760      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000032CE                          2761  CLR_MODE:
000032CE  4EF9 000032FE           2762      JMP         CLR_MODE_000        ; Dn
000032D4  4EF9 00003308           2763      JMP         CLR_MODE_001        ; Invalid: An
000032DA  4EF9 00003312           2764      JMP         CLR_MODE_010        ; (An)
000032E0  4EF9 0000331C           2765      JMP         CLR_MODE_011        ; (An)+
000032E6  4EF9 00003326           2766      JMP         CLR_MODE_100        ; -(An)
000032EC  4EF9 00003330           2767      JMP         CLR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000032F2  4EF9 0000333A           2768      JMP         CLR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000032F8  4EF9 00003344           2769      JMP         CLR_MODE_111        ; The rest (not all valid, validated by register number)
000032FE                          2770  CLR_MODE_000: ; Dn
000032FE  4EB8 2960               2771      JSR         EA_PRINT_DN
00003302  4EF9 00003372           2772      JMP         CLR_END
00003308                          2773  CLR_MODE_001: ; Invalid: An
00003308  4EB8 28E8               2774      JSR         EA_INVALID          ; Address register direct is invalid mode
0000330C  4EF9 00003372           2775      JMP         CLR_END
00003312                          2776  CLR_MODE_010: ; (An)
00003312  4EB8 29E0               2777      JSR         EA_PRINT_IND         ; Print address register indirect
00003316  4EF9 00003372           2778      JMP         CLR_END
0000331C                          2779  CLR_MODE_011: ; (An)+
0000331C  4EB8 2A3E               2780      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003320  4EF9 00003372           2781      JMP         CLR_END
00003326                          2782  CLR_MODE_100: ; -(An)
00003326  4EB8 2A7E               2783      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000332A  4EF9 00003372           2784      JMP         CLR_END             ; Continue with parsing destination operand
00003330                          2785  CLR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003330  4EB8 28E8               2786      JSR         EA_INVALID          ; Opcode word is Invalid
00003334  4EF9 00003372           2787      JMP         CLR_END
0000333A                          2788  CLR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000333A  4EB8 28E8               2789      JSR         EA_INVALID          ; Opcode word is Invalid
0000333E  4EF9 00003372           2790      JMP         CLR_END
00003344                          2791  CLR_MODE_111: ; The rest (not all valid, validated by register number)
00003344  BE3C 0000               2792      CMP.B       #$00, D7            ; Test for absolute word address
00003348  6700 0014               2793      BEQ         CLR_ABS_W
0000334C  BE3C 0001               2794      CMP.B       #$01, D7            ; Test for absolute long address
00003350  6700 0016               2795      BEQ         CLR_ABS_L
00003354  4EB8 28E8               2796      JSR         EA_INVALID          ; Else: invalid
00003358  4EF9 00003372           2797      JMP         CLR_END
0000335E                          2798  CLR_ABS_W:
0000335E  4EB8 2ACA               2799      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003362  4EF9 00003372           2800      JMP         CLR_END
00003368                          2801  CLR_ABS_L:
00003368  4EB8 2ABE               2802      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000336C  4EF9 00003372           2803      JMP         CLR_END
00003372                          2804  CLR_END:
00003372  4EB8 28F2               2805      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003376  4CDF 3FFF               2806      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000337A  4E75                    2807      RTS
0000337C                          2808  EA_CMP:
0000337C  48E7 FFFC               2809      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003380  4EB8 28FE               2810      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003384  4EB8 2902               2811      JSR         EA_DEFAULT_COMBO
00003388  41F9 00003396           2812      LEA         CMP_MODE, A0       ; Set index '0' for jump table
0000338E  CCFC 0006               2813      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003392  4EF0 6000               2814      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003396                          2815  CMP_MODE:
00003396  4EF9 000033C6           2816      JMP         CMP_MODE_000       ; Dn
0000339C  4EF9 000033D0           2817      JMP         CMP_MODE_001       ; An
000033A2  4EF9 000033DA           2818      JMP         CMP_MODE_010       ; (An)
000033A8  4EF9 000033E4           2819      JMP         CMP_MODE_011       ; (An)+
000033AE  4EF9 000033EE           2820      JMP         CMP_MODE_100       ; -(An)
000033B4  4EF9 000033F8           2821      JMP         CMP_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
000033BA  4EF9 00003402           2822      JMP         CMP_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000033C0  4EF9 0000340C           2823      JMP         CMP_MODE_111       ; The rest (not all valid, validated by register number)
000033C6                          2824  CMP_MODE_000: ; Dn
000033C6  4EB8 2960               2825      JSR         EA_PRINT_DN         ; Print data register direct operand
000033CA  4EF9 0000343A           2826      JMP         CMP_MODE_END        ; End evaluation of ea mode
000033D0                          2827  CMP_MODE_001: ; An
000033D0  4EB8 29A0               2828      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
000033D4  4EF9 0000343A           2829      JMP         CMP_MODE_END        ; End evaluation of ea mode
000033DA                          2830  CMP_MODE_010: ; (An)
000033DA  4EB8 29E0               2831      JSR         EA_PRINT_IND        ; Print address register indirect
000033DE  4EF9 0000343A           2832      JMP         CMP_MODE_END        ; End evaluation of ea mode
000033E4                          2833  CMP_MODE_011: ; (An)+
000033E4  4EB8 2A3E               2834      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000033E8  4EF9 0000343A           2835      JMP         CMP_MODE_END        ; End evaluation of ea mode
000033EE                          2836  CMP_MODE_100: ; -(An)
000033EE  4EB8 2A7E               2837      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000033F2  4EF9 0000343A           2838      JMP         CMP_MODE_END        ; End evaluation of ea mode
000033F8                          2839  CMP_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000033F8  4EB8 28E8               2840      JSR         EA_INVALID          ; Opcode word is Invalid
000033FC  4EF9 00003442           2841      JMP         CMP_END
00003402                          2842  CMP_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003402  4EB8 28E8               2843      JSR         EA_INVALID          ; Opcode word is Invalid
00003406  4EF9 00003442           2844      JMP         CMP_END
0000340C                          2845  CMP_MODE_111: ; The rest (not all valid, validated by register number)
0000340C  BE3C 0000               2846      CMP.B       #$00, D7            ; Test for absolute word address
00003410  6700 0014               2847      BEQ         CMP_ABS_W
00003414  BE3C 0001               2848      CMP.B       #$01, D7            ; Test for absolute long address
00003418  6700 0016               2849      BEQ         CMP_ABS_L
0000341C  4EB8 28E8               2850      JSR         EA_INVALID          ; Opcode word is Invalid
00003420  4EF9 00003442           2851      JMP         CMP_END
00003426                          2852  CMP_ABS_W:
00003426  4EB8 2ACA               2853      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000342A  4EF9 0000343A           2854      JMP         CMP_MODE_END
00003430                          2855  CMP_ABS_L:
00003430  4EB8 2ABE               2856      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003434  4EF9 0000343A           2857      JMP         CMP_MODE_END
0000343A                          2858  CMP_MODE_END:
0000343A  4EB8 2928               2859      JSR         EA_OPMODE_COMBO     ; get register bits in D7, opmode bits not used
0000343E  4EB8 2960               2860      JSR         EA_PRINT_DN         ; print register
00003442                          2861  CMP_END:
00003442  4EB8 28F2               2862      JSR         EA_UPDATE_POINTER   ; Update global pointer
00003446  4CDF 3FFF               2863      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000344A  4E75                    2864      RTS
0000344C                          2865  EA_DIVU_W:
0000344C  48E7 FFFC               2866      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003450  4EB8 28FE               2867      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003454  4EB8 2902               2868      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003458  41F9 00003466           2869      LEA         DIVU_W_MODE, A0       ; Set index '0' for jump table
0000345E  CCFC 0006               2870      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003462  4EF0 6000               2871      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003466                          2872  DIVU_W_MODE:
00003466  4EF9 00003496           2873      JMP         DIVU_W_MODE_000     ; Dn
0000346C  4EF9 000034A0           2874      JMP         DIVU_W_MODE_001     ; Invalid: An
00003472  4EF9 000034AA           2875      JMP         DIVU_W_MODE_010     ; (An)
00003478  4EF9 000034B4           2876      JMP         DIVU_W_MODE_011     ; (An)+
0000347E  4EF9 000034BE           2877      JMP         DIVU_W_MODE_100     ; -(An)
00003484  4EF9 000034C8           2878      JMP         DIVU_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
0000348A  4EF9 000034D2           2879      JMP         DIVU_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003490  4EF9 000034DC           2880      JMP         DIVU_W_MODE_111     ; The rest (not all valid, validated by register number)
00003496                          2881  DIVU_W_MODE_000: ; Dn
00003496  4EB8 2960               2882      JSR         EA_PRINT_DN         ; Print data register direct operand
0000349A  4EF9 00003520           2883      JMP         DIVU_W_DEST         ; Go to: print destination operand
000034A0                          2884  DIVU_W_MODE_001: ; Invalid: An
000034A0  4EB8 28E8               2885      JSR         EA_INVALID          ; Address register direct is invalid mode
000034A4  4EF9 00003532           2886      JMP         DIVU_W_END
000034AA                          2887  DIVU_W_MODE_010: ; (An)
000034AA  4EB8 29E0               2888      JSR         EA_PRINT_IND         ; Print address register indirect
000034AE  4EF9 00003520           2889      JMP         DIVU_W_DEST
000034B4                          2890  DIVU_W_MODE_011: ; (An)+
000034B4  4EB8 2A3E               2891      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000034B8  4EF9 00003520           2892      JMP         DIVU_W_DEST
000034BE                          2893  DIVU_W_MODE_100: ; -(An)
000034BE  4EB8 2A7E               2894      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000034C2  4EF9 00003520           2895      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000034C8                          2896  DIVU_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000034C8  4EB8 28E8               2897      JSR         EA_INVALID          ; Opcode word is Invalid
000034CC  4EF9 00003532           2898      JMP         DIVU_W_END
000034D2                          2899  DIVU_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000034D2  4EB8 28E8               2900      JSR         EA_INVALID          ; Opcode word is Invalid
000034D6  4EF9 00003532           2901      JMP         DIVU_W_END
000034DC                          2902  DIVU_W_MODE_111: ; The rest (not all valid, validated by register number)
000034DC  BE3C 0000               2903      CMP.B       #$00, D7            ; Test for absolute word address
000034E0  6700 001C               2904      BEQ         DIVU_W_ABS_W
000034E4  BE3C 0001               2905      CMP.B       #$01, D7            ; Test for absolute long address
000034E8  6700 001E               2906      BEQ         DIVU_W_ABS_L
000034EC  BE3C 0004               2907      CMP.B       #$04, D7            ; Test for immediate data
000034F0  6700 0020               2908      BEQ         DIVU_W_IMM
000034F4  4EB8 28E8               2909      JSR         EA_INVALID          ; Else: invalid
000034F8  4EF9 00003532           2910      JMP         DIVU_W_END
000034FE                          2911  DIVU_W_ABS_W:
000034FE  4EB8 2ACA               2912      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003502  4EF9 00003520           2913      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
00003508                          2914  DIVU_W_ABS_L:
00003508  4EB8 2ABE               2915      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000350C  4EF9 00003520           2916      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
00003512                          2917  DIVU_W_IMM:
00003512  1A3C 0002               2918      MOVE.B      #2, D5              ; Size is word
00003516  4EB8 2A20               2919      JSR         EA_PRINT_IMM        ; Print immediate data
0000351A  4EF9 00003520           2920      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
00003520                          2921  DIVU_W_DEST:
00003520                          2922      *print EA_MSG_COMMA
00003520                          2923      *Get destination register
00003520  3E16                    2924      MOVE.W      (A6), D7            ; Load word at current pointer to D1
00003522  143C 0004               2925      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00003526  E56F                    2926      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003528  143C 000D               2927      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
0000352C  E46F                    2928      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
0000352E  4EB8 2960               2929      JSR         EA_PRINT_DN         ; Print data register direct operand
00003532                          2930  DIVU_W_END:
00003532  4EB8 28F2               2931      JSR         EA_UPDATE_POINTER   ; Update global pointer
00003536  4CDF 3FFF               2932      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000353A  4E75                    2933      RTS
0000353C                          2934  EA_JSR:
0000353C  48E7 FFFC               2935      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003540  4EB8 28FE               2936      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003544  4EB8 2902               2937      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003548  41F9 00003556           2938      LEA         JSR_MODE, A0        ; Set index '0' for jump table
0000354E  CCFC 0006               2939      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003552  4EF0 6000               2940      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003556                          2941  JSR_MODE:
00003556  4EF9 00003586           2942      JMP         JSR_MODE_000        ; Invalid: Dn
0000355C  4EF9 00003590           2943      JMP         JSR_MODE_001        ; Invalid: An
00003562  4EF9 0000359A           2944      JMP         JSR_MODE_010        ; (An)
00003568  4EF9 000035A4           2945      JMP         JSR_MODE_011        ; Invalid: (An)+
0000356E  4EF9 000035AE           2946      JMP         JSR_MODE_100        ; Invalid: -(An)
00003574  4EF9 000035B8           2947      JMP         JSR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
0000357A  4EF9 000035C2           2948      JMP         JSR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003580  4EF9 000035CC           2949      JMP         JSR_MODE_111        ; The rest (not all valid, validated by register number)
00003586                          2950  JSR_MODE_000: ; Invalid: Dn
00003586  4EB8 28E8               2951      JSR         EA_INVALID          ; Data register direct is invalid mode
0000358A  4EF9 000035FA           2952      JMP         JSR_END
00003590                          2953  JSR_MODE_001: ; Invalid: An
00003590  4EB8 28E8               2954      JSR         EA_INVALID          ; Address register direct is invalid mode
00003594  4EF9 000035FA           2955      JMP         JSR_END
0000359A                          2956  JSR_MODE_010: ; (An)
0000359A  4EB8 29E0               2957      JSR         EA_PRINT_IND         ; Print address register indirect
0000359E  4EF9 000035FA           2958      JMP         JSR_END
000035A4                          2959  JSR_MODE_011: ; (An)+
000035A4  4EB8 28E8               2960      JSR         EA_INVALID          ; Address register indirect w/ post increment is invalid mode
000035A8  4EF9 000035FA           2961      JMP         JSR_END
000035AE                          2962  JSR_MODE_100: ; -(An)
000035AE  4EB8 28E8               2963      JSR         EA_INVALID          ; Address register indirect w/ pre decrement is invalid mode
000035B2  4EF9 000035FA           2964      JMP         JSR_END
000035B8                          2965  JSR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000035B8  4EB8 28E8               2966      JSR         EA_INVALID          ; Opcode word is Invalid
000035BC  4EF9 000035FA           2967      JMP         JSR_END
000035C2                          2968  JSR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000035C2  4EB8 28E8               2969      JSR         EA_INVALID          ; Opcode word is Invalid
000035C6  4EF9 000035FA           2970      JMP         JSR_END
000035CC                          2971  JSR_MODE_111: ; The rest (not all valid, validated by register number)
000035CC  BE3C 0000               2972      CMP.B       #$00, D7            ; Test for absolute word address
000035D0  6700 0014               2973      BEQ         JSR_ABS_W
000035D4  BE3C 0001               2974      CMP.B       #$01, D7            ; Test for absolute long address
000035D8  6700 0016               2975      BEQ         JSR_ABS_L
000035DC  4EB8 28E8               2976      JSR         EA_INVALID          ; Else: invalid
000035E0  4EF9 000035FA           2977      JMP         JSR_END
000035E6                          2978  JSR_ABS_W:
000035E6  4EB8 2ACA               2979      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000035EA  4EF9 000035FA           2980      JMP         JSR_END
000035F0                          2981  JSR_ABS_L:
000035F0  4EB8 2ABE               2982      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000035F4  4EF9 000035FA           2983      JMP         JSR_END
000035FA                          2984  JSR_END:
000035FA  4EB8 28F2               2985      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000035FE  4CDF 3FFF               2986      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003602  4E75                    2987      RTS
00003604                          2988  EA_LEA:
00003604  48E7 FFFC               2989      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003608  4EB8 28FE               2990      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
0000360C  4EB8 2902               2991      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003610  41F9 0000361E           2992      LEA         LEA_MODE, A0        ; Set index '0' for jump table
00003616  CCFC 0006               2993      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000361A  4EF0 6000               2994      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000361E                          2995  LEA_MODE:
0000361E  4EF9 0000364E           2996      JMP         LEA_MODE_000        ; Dn
00003624  4EF9 00003658           2997      JMP         LEA_MODE_001        ; Invalid: An
0000362A  4EF9 00003662           2998      JMP         LEA_MODE_010        ; (An)
00003630  4EF9 0000366C           2999      JMP         LEA_MODE_011        ; (An)+
00003636  4EF9 00003676           3000      JMP         LEA_MODE_100        ; -(An)
0000363C  4EF9 00003680           3001      JMP         LEA_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003642  4EF9 0000368A           3002      JMP         LEA_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003648  4EF9 00003694           3003      JMP         LEA_MODE_111        ; The rest (not all valid, validated by register number)
0000364E                          3004  LEA_MODE_000: ; Invalid: Dn
0000364E  4EB8 28E8               3005      JSR         EA_INVALID          ; Data register direct is invalid mode
00003652  4EF9 000036CA           3006      JMP         LEA_END
00003658                          3007  LEA_MODE_001: ; Invalid: An
00003658  4EB8 28E8               3008      JSR         EA_INVALID          ; Address register direct is invalid mode
0000365C  4EF9 000036CA           3009      JMP         LEA_END
00003662                          3010  LEA_MODE_010: ; (An)
00003662  4EB8 29E0               3011      JSR         EA_PRINT_IND         ; Print address register indirect
00003666  4EF9 000036C2           3012      JMP         LEA_DEST
0000366C                          3013  LEA_MODE_011: ; (An)+
0000366C  4EB8 28E8               3014      JSR         EA_INVALID          ; Address register indirect with post increment is invalid
00003670  4EF9 000036CA           3015      JMP         LEA_END
00003676                          3016  LEA_MODE_100: ; -(An)
00003676  4EB8 28E8               3017      JSR         EA_INVALID          ; Adress register indirect with pre decrement is invalid
0000367A  4EF9 000036CA           3018      JMP         LEA_END             ; Continue with parsing destination operand
00003680                          3019  LEA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003680  4EB8 28E8               3020      JSR         EA_INVALID          ; Opcode word is Invalid
00003684  4EF9 000036CA           3021      JMP         LEA_END
0000368A                          3022  LEA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000368A  4EB8 28E8               3023      JSR         EA_INVALID          ; Opcode word is Invalid
0000368E  4EF9 000036CA           3024      JMP         LEA_END
00003694                          3025  LEA_MODE_111: ; The rest (not all valid, validated by register number)
00003694  BE3C 0000               3026      CMP.B       #$00, D7            ; Test for absolute word address
00003698  6700 0014               3027      BEQ         LEA_ABS_W
0000369C  BE3C 0001               3028      CMP.B       #$01, D7            ; Test for absolute long address
000036A0  6700 0016               3029      BEQ         LEA_ABS_L
000036A4  4EB8 28E8               3030      JSR         EA_INVALID          ; Else: invalid
000036A8  4EF9 000036C2           3031      JMP         LEA_DEST
000036AE                          3032  LEA_ABS_W:
000036AE  4EB8 2ACA               3033      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000036B2  4EF9 000036C2           3034      JMP         LEA_DEST
000036B8                          3035  LEA_ABS_L:
000036B8  4EB8 2ABE               3036      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000036BC  4EF9 000036C2           3037      JMP         LEA_DEST
000036C2                          3038  LEA_DEST:
000036C2                          3039      *print comma TODO
000036C2  4EB8 2928               3040      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, opmode bits unused
000036C6  4EB8 29A0               3041      JSR         EA_PRINT_AN         ; Print address register
000036CA                          3042  LEA_END:
000036CA  4EB8 28F2               3043      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000036CE  4CDF 3FFF               3044      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000036D2  4E75                    3045      RTS
000036D4                          3046  EA_LSd:
000036D4  48E7 FFFC               3047      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000036D8  4EB8 28FE               3048      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000036DC  4EB8 294E               3049      JSR         EA_SIZE_BITS        ; get size bits in D7
000036E0  BE3C 0003               3050      CMP.B       #$03, D7            ; test if memory shift
000036E4  6700 0042               3051      BEQ         LSd_MEM
000036E8  6000 0002               3052      BRA         LSd_REG             ; else, register shfit
000036EC                          3053  LSd_REG:
000036EC  3E16                    3054      MOVE.W      (A6), D7            ; read opcode word in memory and save,
000036EE                          3055                                      ; (using D7 because EA_PRINT_DN uses D7)
000036EE  143C 0004               3056      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
000036F2  E56F                    3057      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000036F4  143C 000D               3058      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
000036F8  E46F                    3059      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000036FA  3016                    3060      MOVE.W      (A6), D0            ; read opcode word in memory and save
000036FC  143C 000A               3061      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
00003700  E568                    3062      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00003702  143C 000F               3063      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
00003706  E468                    3064      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00003708  B03C 0000               3065      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
0000370C  6700 000C               3066      BEQ         LSd_REG_COUNT
00003710                          3067  LSd_REG_REG:                        ; Else, count/register field contains register number
00003710  4EB8 2960               3068      JSR         EA_PRINT_DN         ; Print register value, stored in D7
00003714  4EF9 0000371A           3069      JMP         LSd_REG_END         ; Jump to end of LSd_REG
0000371A                          3070  LSd_REG_COUNT:
0000371A                          3071      *print hash todo
0000371A                          3072      *print hex value in D7 as byte todo, continue on to LSd_REG_END
0000371A                          3073  LSd_REG_END:
0000371A                          3074      *PRINT COMMA todo
0000371A  4EB8 2902               3075      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
0000371E  4EB8 2960               3076      JSR         EA_PRINT_DN         ; Print register value in D7
00003722  4EF9 000037DE           3077      JMP         LSd_END
00003728                          3078  LSd_MEM:
00003728  4EB8 2902               3079      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
0000372C  41F9 0000373A           3080      LEA         LSd_MEM_MODE, A0    ; Set index '0' for jump table
00003732  CCFC 0006               3081      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003736  4EF0 6000               3082      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000373A                          3083  LSd_MEM_MODE:
0000373A  4EF9 0000376A           3084      JMP         LSd_MEM_MODE_000     ; Invalid: Dn
00003740  4EF9 00003774           3085      JMP         LSd_MEM_MODE_001     ; Invalid: An
00003746  4EF9 0000377E           3086      JMP         LSd_MEM_MODE_010     ; (An)
0000374C  4EF9 00003788           3087      JMP         LSd_MEM_MODE_011     ; (An)+
00003752  4EF9 00003792           3088      JMP         LSd_MEM_MODE_100     ; -(An)
00003758  4EF9 0000379C           3089      JMP         LSd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
0000375E  4EF9 000037A6           3090      JMP         LSd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003764  4EF9 000037B0           3091      JMP         LSd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
0000376A                          3092  LSd_MEM_MODE_000: ; Invalid: Dn
0000376A  4EB8 28E8               3093      JSR         EA_INVALID          ; Data register direct is invalid mode
0000376E  4EF9 000037DE           3094      JMP         LSd_END
00003774                          3095  LSd_MEM_MODE_001: ; Invalid: An
00003774  4EB8 28E8               3096      JSR         EA_INVALID          ; Address register direct is invalid mode
00003778  4EF9 000037DE           3097      JMP         LSd_END
0000377E                          3098  LSd_MEM_MODE_010: ; (An)
0000377E  4EB8 29E0               3099      JSR         EA_PRINT_IND         ; Print address register indirect
00003782  4EF9 000037DE           3100      JMP         LSd_END
00003788                          3101  LSd_MEM_MODE_011: ; (An)+
00003788  4EB8 2A3E               3102      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000378C  4EF9 000037DE           3103      JMP         LSd_END
00003792                          3104  LSd_MEM_MODE_100: ; -(An)
00003792  4EB8 2A7E               3105      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003796  4EF9 000037DE           3106      JMP         LSd_END         ; Continue with parsing destination operand
0000379C                          3107  LSd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000379C  4EB8 28E8               3108      JSR         EA_INVALID          ; Opcode word is Invalid
000037A0  4EF9 000037DE           3109      JMP         LSd_END
000037A6                          3110  LSd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000037A6  4EB8 28E8               3111      JSR         EA_INVALID          ; Opcode word is Invalid
000037AA  4EF9 000037DE           3112      JMP         LSd_END
000037B0                          3113  LSd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
000037B0  BE3C 0000               3114      CMP.B       #$00, D7            ; Test for absolute word address
000037B4  6700 0014               3115      BEQ         LSd_MEM_ABS_W
000037B8  BE3C 0001               3116      CMP.B       #$01, D7            ; Test for absolute long address
000037BC  6700 0016               3117      BEQ         LSd_MEM_ABS_L
000037C0  4EB8 28E8               3118      JSR         EA_INVALID          ; Else: invalid
000037C4  4EF9 000037DE           3119      JMP         LSd_END
000037CA                          3120  LSd_MEM_ABS_W:
000037CA  4EB8 2ACA               3121      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000037CE  4EF9 000037DE           3122      JMP         LSd_END
000037D4                          3123  LSd_MEM_ABS_L:
000037D4  4EB8 2ABE               3124      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000037D8  4EF9 000037DE           3125      JMP         LSd_END
000037DE                          3126  LSd_END:
000037DE  4EB8 28F2               3127      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000037E2  4CDF 3FFF               3128      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000037E6  4E75                    3129      RTS
000037E8                          3130  EA_MOVE:
000037E8  48E7 FFFC               3131      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000037EC  4EB8 28FE               3132      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000037F0  2A16                    3133      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
000037F2  143C 0002               3134      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
000037F6  E56D                    3135      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
000037F8  143C 000E               3136      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
000037FC  E46D                    3137      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
000037FE  BA3C 0003               3138      CMP.B       #$03, D5            ; if size bits are 11, correct D5
00003802                          3139                                      ; to 10 for use with immediate data subroutine
00003802  6700 0010               3140      BEQ         MOVE_ADJUST_W
00003806  BA3C 0002               3141      CMP.B       #$02, D5            ; if size bits are 10, correct D5
0000380A                          3142                                      ; to 11 for use with immediate data subroutine
0000380A  6700 0012               3143      BEQ         MOVE_ADJUST_L
0000380E  4EF9 00003828           3144      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003814                          3145  MOVE_ADJUST_W:
00003814  1A3C 0002               3146      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
00003818  4EF9 00003828           3147      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
0000381E                          3148  MOVE_ADJUST_L:
0000381E  1A3C 0003               3149      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
00003822  4EF9 00003828           3150      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003828                          3151  MOVE_SOURCE:
00003828  48E7 FFFC               3152      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000382C  4EB8 28FE               3153      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003830  4EB8 2902               3154      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003834  41F9 00003842           3155      LEA         MOVE_SRC_MODE, A0   ; Set index '0' for jump table
0000383A  CCFC 0006               3156      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000383E  4EF0 6000               3157      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003842                          3158  MOVE_SRC_MODE:
00003842  4EF9 00003872           3159      JMP         MOVE_SRC_MODE_000   ; Dn
00003848  4EF9 0000387C           3160      JMP         MOVE_SRC_MODE_001   ; An
0000384E  4EF9 00003886           3161      JMP         MOVE_SRC_MODE_010   ; (An)
00003854  4EF9 00003890           3162      JMP         MOVE_SRC_MODE_011   ; (An)+
0000385A  4EF9 0000389A           3163      JMP         MOVE_SRC_MODE_100   ; -(An)
00003860  4EF9 000038A4           3164      JMP         MOVE_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003866  4EF9 000038AE           3165      JMP         MOVE_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000386C  4EF9 000038B8           3166      JMP         MOVE_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003872                          3167  MOVE_SRC_MODE_000: ; Dn
00003872  4EB8 2960               3168      JSR         EA_PRINT_DN         ; Print data register in D7
00003876  4EF9 000038F8           3169      JMP         MOVE_DESTINATION
0000387C                          3170  MOVE_SRC_MODE_001: ; Invalid: An
0000387C  4EB8 29A0               3171      JSR         EA_PRINT_AN         ; Print address register in D7
00003880  4EF9 000038F8           3172      JMP         MOVE_DESTINATION
00003886                          3173  MOVE_SRC_MODE_010: ; (An)
00003886  4EB8 29E0               3174      JSR         EA_PRINT_IND         ; Print address register indirect
0000388A  4EF9 000038F8           3175      JMP         MOVE_DESTINATION
00003890                          3176  MOVE_SRC_MODE_011: ; (An)+
00003890  4EB8 2A3E               3177      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003894  4EF9 000038F8           3178      JMP         MOVE_DESTINATION
0000389A                          3179  MOVE_SRC_MODE_100: ; -(An)
0000389A  4EB8 2A7E               3180      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000389E  4EF9 000038F8           3181      JMP         MOVE_DESTINATION    ; Continue with parsing destination operand
000038A4                          3182  MOVE_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000038A4  4EB8 28E8               3183      JSR         EA_INVALID          ; Opcode word is Invalid
000038A8  4EF9 000039B6           3184      JMP         MOVE_END
000038AE                          3185  MOVE_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000038AE  4EB8 28E8               3186      JSR         EA_INVALID          ; Opcode word is Invalid
000038B2  4EF9 000039B6           3187      JMP         MOVE_END
000038B8                          3188  MOVE_SRC_MODE_111: ; The rest (not all valid, validated by register number)
000038B8  BE3C 0000               3189      CMP.B       #$00, D7            ; Test for absolute word address
000038BC  6700 001C               3190      BEQ         MOVE_SRC_ABS_W
000038C0  BE3C 0001               3191      CMP.B       #$01, D7            ; Test for absolute long address
000038C4  6700 001E               3192      BEQ         MOVE_SRC_ABS_L
000038C8  BE3C 0004               3193      CMP.B       #$04, D7            ; Test for immediate data
000038CC  6700 0020               3194      BEQ         MOVE_SRC_IMM
000038D0  4EB8 28E8               3195      JSR         EA_INVALID          ; Else: invalid
000038D4  4EF9 000039B6           3196      JMP         MOVE_END
000038DA                          3197  MOVE_SRC_ABS_W:
000038DA  4EB8 2ACA               3198      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000038DE  4EF9 000038F8           3199      JMP         MOVE_DESTINATION
000038E4                          3200  MOVE_SRC_ABS_L:
000038E4  4EB8 2ABE               3201      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000038E8  4EF9 000038F8           3202      JMP         MOVE_DESTINATION
000038EE                          3203  MOVE_SRC_IMM:
000038EE  4EB8 2A20               3204      JSR         EA_PRINT_IMM        ; Print immediate data
000038F2  4EF9 000038F8           3205      JMP         MOVE_DESTINATION
000038F8                          3206  MOVE_DESTINATION:
000038F8                          3207      *PRINT COMMA TODO
000038F8  48E7 FFFC               3208      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000038FC  4EB8 28FE               3209      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003900  4EB8 2928               3210      JSR         EA_OPMODE_COMBO     ; mode: D6, register: D7 (destination bits)
00003904  41F9 00003912           3211      LEA         MOVE_DST_MODE, A0   ; Set index '0' for jump table
0000390A  CCFC 0006               3212      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000390E  4EF0 6000               3213      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003912                          3214  MOVE_DST_MODE:
00003912  4EF9 00003942           3215      JMP         MOVE_DST_MODE_000   ; Dn
00003918  4EF9 0000394C           3216      JMP         MOVE_DST_MODE_001   ; Invalid: An
0000391E  4EF9 00003956           3217      JMP         MOVE_DST_MODE_010   ; (An)
00003924  4EF9 00003960           3218      JMP         MOVE_DST_MODE_011   ; (An)+
0000392A  4EF9 0000396A           3219      JMP         MOVE_DST_MODE_100   ; -(An)
00003930  4EF9 00003974           3220      JMP         MOVE_DST_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003936  4EF9 0000397E           3221      JMP         MOVE_DST_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000393C  4EF9 00003988           3222      JMP         MOVE_DST_MODE_111   ; The rest (not all valid, validated by register number)
00003942                          3223  MOVE_DST_MODE_000: ; Dn
00003942  4EB8 2960               3224      JSR         EA_PRINT_DN         ; Print data register in D7
00003946  4EF9 000039B6           3225      JMP         MOVE_END
0000394C                          3226  MOVE_DST_MODE_001: ; Invalid: An
0000394C  4EB8 28E8               3227      JSR         EA_INVALID          ; Print address register in D7
00003950  4EF9 000039B6           3228      JMP         MOVE_END
00003956                          3229  MOVE_DST_MODE_010: ; (An)
00003956  4EB8 29E0               3230      JSR         EA_PRINT_IND         ; Print address register indirect
0000395A  4EF9 000039B6           3231      JMP         MOVE_END
00003960                          3232  MOVE_DST_MODE_011: ; (An)+
00003960  4EB8 2A3E               3233      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003964  4EF9 000039B6           3234      JMP         MOVE_END
0000396A                          3235  MOVE_DST_MODE_100: ; -(An)
0000396A  4EB8 2A7E               3236      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000396E  4EF9 000039B6           3237      JMP         MOVE_END    ; Continue with parsing destination operand
00003974                          3238  MOVE_DST_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003974  4EB8 28E8               3239      JSR         EA_INVALID          ; Opcode word is Invalid
00003978  4EF9 000039B6           3240      JMP         MOVE_END
0000397E                          3241  MOVE_DST_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000397E  4EB8 28E8               3242      JSR         EA_INVALID          ; Opcode word is Invalid
00003982  4EF9 000039B6           3243      JMP         MOVE_END
00003988                          3244  MOVE_DST_MODE_111: ; The rest (not all valid, validated by register number)
00003988  BE3C 0000               3245      CMP.B       #$00, D7            ; Test for absolute word address
0000398C  6700 0014               3246      BEQ         MOVE_DST_ABS_W
00003990  BE3C 0001               3247      CMP.B       #$01, D7            ; Test for absolute long address
00003994  6700 0016               3248      BEQ         MOVE_DST_ABS_L
00003998  4EB8 28E8               3249      JSR         EA_INVALID          ; Else: invalid
0000399C  4EF9 000039B6           3250      JMP         MOVE_END
000039A2                          3251  MOVE_DST_ABS_W:
000039A2  4EB8 2ACA               3252      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000039A6  4EF9 000039B6           3253      JMP         MOVE_END
000039AC                          3254  MOVE_DST_ABS_L:
000039AC  4EB8 2ABE               3255      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000039B0  4EF9 000039B6           3256      JMP         MOVE_END
000039B6                          3257  MOVE_END:
000039B6  4EB8 28F2               3258      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000039BA  4CDF 3FFF               3259      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000039BE  4E75                    3260      RTS
000039C0                          3261  EA_MOVEA:
000039C0  48E7 FFFC               3262      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000039C4  4EB8 28FE               3263      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000039C8  2A16                    3264      MOVE.L      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
000039CA  143C 0002               3265      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
000039CE  E56D                    3266      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
000039D0  143C 000E               3267      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
000039D4  E46D                    3268      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
000039D6  BA3C 0003               3269      CMP.B       #$03, D5            ; if size bits are 11, correct D5
000039DA                          3270                                      ; to 10 for use with immediate data subroutine
000039DA  6700 0010               3271      BEQ         MOVEA_ADJUST_W
000039DE  BA3C 0002               3272      CMP.B       #$02, D5            ; if size bits are 10, correct D5
000039E2                          3273                                      ; to 11 for use with immediate data subroutine
000039E2  6700 0012               3274      BEQ         MOVEA_ADJUST_L
000039E6  4EF9 00003A00           3275      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
000039EC                          3276  MOVEA_ADJUST_W:
000039EC  1A3C 0002               3277      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
000039F0  4EF9 00003A00           3278      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
000039F6                          3279  MOVEA_ADJUST_L:
000039F6  1A3C 0003               3280      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
000039FA  4EF9 00003A00           3281      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003A00                          3282  MOVEA_SOURCE:
00003A00  48E7 FFFC               3283      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003A04  4EB8 28FE               3284      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003A08  4EB8 2902               3285      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003A0C  41F9 00003A1A           3286      LEA         MOVEA_SRC_MODE, A0   ; Set index '0' for jump table
00003A12  CCFC 0006               3287      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003A16  4EF0 6000               3288      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003A1A                          3289  MOVEA_SRC_MODE:
00003A1A  4EF9 00003A4A           3290      JMP         MOVEA_SRC_MODE_000   ; Dn
00003A20  4EF9 00003A54           3291      JMP         MOVEA_SRC_MODE_001   ; An
00003A26  4EF9 00003A5E           3292      JMP         MOVEA_SRC_MODE_010   ; (An)
00003A2C  4EF9 00003A68           3293      JMP         MOVEA_SRC_MODE_011   ; (An)+
00003A32  4EF9 00003A72           3294      JMP         MOVEA_SRC_MODE_100   ; -(An)
00003A38  4EF9 00003A7C           3295      JMP         MOVEA_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003A3E  4EF9 00003A86           3296      JMP         MOVEA_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A44  4EF9 00003A90           3297      JMP         MOVEA_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003A4A                          3298  MOVEA_SRC_MODE_000: ; Dn
00003A4A  4EB8 2960               3299      JSR         EA_PRINT_DN         ; Print data register in D7
00003A4E  4EF9 00003AD0           3300      JMP         MOVEA_DESTINATION
00003A54                          3301  MOVEA_SRC_MODE_001: ; Invalid: An
00003A54  4EB8 29A0               3302      JSR         EA_PRINT_AN         ; Print address register in D7
00003A58  4EF9 00003AD0           3303      JMP         MOVEA_DESTINATION
00003A5E                          3304  MOVEA_SRC_MODE_010: ; (An)
00003A5E  4EB8 29E0               3305      JSR         EA_PRINT_IND         ; Print address register indirect
00003A62  4EF9 00003AD0           3306      JMP         MOVEA_DESTINATION
00003A68                          3307  MOVEA_SRC_MODE_011: ; (An)+
00003A68  4EB8 2A3E               3308      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003A6C  4EF9 00003AD0           3309      JMP         MOVEA_DESTINATION
00003A72                          3310  MOVEA_SRC_MODE_100: ; -(An)
00003A72  4EB8 2A7E               3311      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003A76  4EF9 00003AD0           3312      JMP         MOVEA_DESTINATION    ; Continue with parsing destination operand
00003A7C                          3313  MOVEA_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003A7C  4EB8 28E8               3314      JSR         EA_INVALID          ; Opcode word is Invalid
00003A80  4EF9 00003AE0           3315      JMP         MOVEA_END
00003A86                          3316  MOVEA_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A86  4EB8 28E8               3317      JSR         EA_INVALID          ; Opcode word is Invalid
00003A8A  4EF9 00003AE0           3318      JMP         MOVEA_END
00003A90                          3319  MOVEA_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003A90  BE3C 0000               3320      CMP.B       #$00, D7            ; Test for absolute word address
00003A94  6700 001C               3321      BEQ         MOVEA_SRC_ABS_W
00003A98  BE3C 0001               3322      CMP.B       #$01, D7            ; Test for absolute long address
00003A9C  6700 001E               3323      BEQ         MOVEA_SRC_ABS_L
00003AA0  BE3C 0004               3324      CMP.B       #$04, D7            ; Test for immediate data
00003AA4  6700 0020               3325      BEQ         MOVEA_SRC_IMM
00003AA8  4EB8 28E8               3326      JSR         EA_INVALID          ; Else: invalid
00003AAC  4EF9 00003AE0           3327      JMP         MOVEA_END
00003AB2                          3328  MOVEA_SRC_ABS_W:
00003AB2  4EB8 2ACA               3329      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003AB6  4EF9 00003AD0           3330      JMP         MOVEA_DESTINATION
00003ABC                          3331  MOVEA_SRC_ABS_L:
00003ABC  4EB8 2ABE               3332      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003AC0  4EF9 00003AD0           3333      JMP         MOVEA_DESTINATION
00003AC6                          3334  MOVEA_SRC_IMM:
00003AC6  4EB8 2A20               3335      JSR         EA_PRINT_IMM        ; Print immediate data
00003ACA  4EF9 00003AD0           3336      JMP         MOVEA_DESTINATION
00003AD0                          3337  MOVEA_DESTINATION:
00003AD0                          3338      *PRINT COMMA TODO
00003AD0  48E7 FFFC               3339      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003AD4  4EB8 28FE               3340      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003AD8  4EB8 2928               3341      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003ADC  4EB8 29A0               3342      JSR         EA_PRINT_AN         ; Print address register, continue to end
00003AE0                          3343  MOVEA_END:
00003AE0  4EB8 28F2               3344      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003AE4  4CDF 3FFF               3345      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003AE8  4E75                    3346      RTS
00003AEA                          3347  EA_MOVEM:
00003AEA                          3348      *seems complicated, todo
00003AEA  4EB8 28E4               3349      JSR         EA_UNIMPLEMENTED
00003AEE  4E75                    3350      RTS
00003AF0                          3351  EA_MOVEQ:
00003AF0  48E7 FFFC               3352      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003AF4  4EB8 28FE               3353      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003AF8  2216                    3354      MOVE.L      (A6), D1            ; Load opcode to data register 1
00003AFA  143C 0008               3355      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003AFE  E569                    3356      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00003B00  143C 0008               3357      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine data bits
00003B04  E469                    3358      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00003B06  2616                    3359      MOVE.L      (A6), D3            ; Save mode bits to D6
00003B08  143C 0008               3360      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003B0C  E56B                    3361      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
00003B0E  143C 000F               3362      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
00003B12  E46B                    3363      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003B14  B63C 0000               3364      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003B18  6700 0008               3365      BEQ         MOVEQ_PRINT_DATA
00003B1C  0681 FFFFFF00           3366      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
00003B22                          3367  MOVEQ_PRINT_DATA:
00003B22                          3368      *print hash TODO
00003B22                          3369      *print data in
00003B22                          3370      *PRINT COMMA TODO
00003B22  4EB8 2928               3371      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003B26  4EB8 2960               3372      JSR         EA_PRINT_DN         ; Print data register
00003B2A  4EB8 28F2               3373      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003B2E  4CDF 3FFF               3374      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003B32  4E75                    3375      RTS
00003B34                          3376  EA_MULS_W:
00003B34  48E7 FFFC               3377      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003B38  4EB8 28FE               3378      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003B3C  4EB8 2902               3379      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003B40  41F9 00003B4E           3380      LEA         MULS_W_MODE, A0     ; Set index '0' for jump table
00003B46  CCFC 0006               3381      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003B4A  4EF0 6000               3382      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003B4E                          3383  MULS_W_MODE:
00003B4E  4EF9 00003B7E           3384      JMP         MULS_W_MODE_000     ; Dn
00003B54  4EF9 00003B88           3385      JMP         MULS_W_MODE_001     ; Invalid: An
00003B5A  4EF9 00003B92           3386      JMP         MULS_W_MODE_010     ; (An)
00003B60  4EF9 00003B9C           3387      JMP         MULS_W_MODE_011     ; (An)+
00003B66  4EF9 00003BA6           3388      JMP         MULS_W_MODE_100     ; -(An)
00003B6C  4EF9 00003BB0           3389      JMP         MULS_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003B72  4EF9 00003BBA           3390      JMP         MULS_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003B78  4EF9 00003BC4           3391      JMP         MULS_W_MODE_111     ; The rest (not all valid, validated by register number)
00003B7E                          3392  MULS_W_MODE_000: ; Dn
00003B7E  4EB8 2960               3393      JSR         EA_PRINT_DN         ; Print data register direct operand
00003B82  4EF9 00003C08           3394      JMP         MULS_W_DEST         ; Go to: print destination operand
00003B88                          3395  MULS_W_MODE_001: ; Invalid: An
00003B88  4EB8 28E8               3396      JSR         EA_INVALID          ; Address register direct is invalid mode
00003B8C  4EF9 00003C1A           3397      JMP         MULS_W_END
00003B92                          3398  MULS_W_MODE_010: ; (An)
00003B92  4EB8 29E0               3399      JSR         EA_PRINT_IND         ; Print address register indirect
00003B96  4EF9 00003C08           3400      JMP         MULS_W_DEST
00003B9C                          3401  MULS_W_MODE_011: ; (An)+
00003B9C  4EB8 2A3E               3402      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003BA0  4EF9 00003C08           3403      JMP         MULS_W_DEST
00003BA6                          3404  MULS_W_MODE_100: ; -(An)
00003BA6  4EB8 2A7E               3405      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003BAA  4EF9 00003C08           3406      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003BB0                          3407  MULS_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003BB0  4EB8 28E8               3408      JSR         EA_INVALID          ; Opcode word is Invalid
00003BB4  4EF9 00003C1A           3409      JMP         MULS_W_END
00003BBA                          3410  MULS_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003BBA  4EB8 28E8               3411      JSR         EA_INVALID          ; Opcode word is Invalid
00003BBE  4EF9 00003C1A           3412      JMP         MULS_W_END
00003BC4                          3413  MULS_W_MODE_111: ; The rest (not all valid, validated by register number)
00003BC4  BE3C 0000               3414      CMP.B       #$00, D7            ; Test for absolute word address
00003BC8  6700 001C               3415      BEQ         MULS_W_ABS_W
00003BCC  BE3C 0001               3416      CMP.B       #$01, D7            ; Test for absolute long address
00003BD0  6700 001E               3417      BEQ         MULS_W_ABS_L
00003BD4  BE3C 0004               3418      CMP.B       #$04, D7            ; Test for immediate data
00003BD8  6700 0020               3419      BEQ         MULS_W_IMM
00003BDC  4EB8 28E8               3420      JSR         EA_INVALID          ; Else: invalid
00003BE0  4EF9 00003C1A           3421      JMP         MULS_W_END
00003BE6                          3422  MULS_W_ABS_W:
00003BE6  4EB8 2ACA               3423      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003BEA  4EF9 00003C08           3424      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003BF0                          3425  MULS_W_ABS_L:
00003BF0  4EB8 2ABE               3426      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003BF4  4EF9 00003C08           3427      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003BFA                          3428  MULS_W_IMM:
00003BFA  1A3C 0002               3429      MOVE.B      #2, D5              ; Size is word
00003BFE  4EB8 2A20               3430      JSR         EA_PRINT_IMM        ; Print immediate data
00003C02  4EF9 00003C08           3431      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003C08                          3432  MULS_W_DEST:
00003C08                          3433      *print EA_MSG_COMMA
00003C08                          3434      *Get destination register
00003C08  3E16                    3435      MOVE.W      (A6), D7            ; Load word at current pointer to D1
00003C0A  143C 0004               3436      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00003C0E  E56F                    3437      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003C10  143C 000D               3438      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
00003C14  E46F                    3439      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003C16  4EB8 2960               3440      JSR         EA_PRINT_DN         ; Print data register direct operand
00003C1A                          3441  MULS_W_END:
00003C1A  4EB8 28F2               3442      JSR         EA_UPDATE_POINTER   ; Update global pointer
00003C1E  4CDF 3FFF               3443      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003C22  4E75                    3444      RTS
00003C24                          3445  
00003C24                          3446  EA_OR:
00003C24  48E7 FFFC               3447      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003C28  4EB8 28FE               3448      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003C2C  4EB8 2928               3449      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00003C30  41F9 00003C3E           3450      LEA         OR_OPMODE, A0       ; Set index '0' for jump table
00003C36  CCFC 0006               3451      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003C3A  4EF0 6000               3452      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003C3E                          3453  OR_OPMODE:
00003C3E  4EF9 00003C6E           3454      JMP         OR_OPMODE_000       ; mode 1, byte
00003C44  4EF9 00003C78           3455      JMP         OR_OPMODE_001       ; mode 1, word
00003C4A  4EF9 00003C82           3456      JMP         OR_OPMODE_010       ; mode 1, long
00003C50  4EF9 00003C8C           3457      JMP         OR_OPMODE_011       ; Invalid value
00003C56  4EF9 00003C96           3458      JMP         OR_OPMODE_100       ; mode 2, byte
00003C5C  4EF9 00003CA0           3459      JMP         OR_OPMODE_101       ; mode 2, word
00003C62  4EF9 00003CAA           3460      JMP         OR_OPMODE_110       ; mode 2, long
00003C68  4EF9 00003CB4           3461      JMP         OR_OPMODE_111       ; Invalid value
00003C6E                          3462  OR_OPMODE_000: ; mode 1, byte
00003C6E  1A3C 0001               3463      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003C72  4EF9 00003CBE           3464      JMP         OR_MODE_1
00003C78                          3465  OR_OPMODE_001: ; mode 1, word
00003C78  1A3C 0002               3466      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00003C7C  4EF9 00003CBE           3467      JMP         OR_MODE_1
00003C82                          3468  OR_OPMODE_010: ; mode 1, long
00003C82  1A3C 0003               3469      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00003C86  4EF9 00003CBE           3470      JMP         OR_MODE_1
00003C8C                          3471  OR_OPMODE_011: ; Invalid value
00003C8C  4EB8 28E8               3472      JSR         EA_INVALID
00003C90  4EF9 00003DC6           3473      JMP         OR_END
00003C96                          3474  OR_OPMODE_100: ; mode 2, byte
00003C96  1A3C 0001               3475      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003C9A  4EF9 00003CDC           3476      JMP         OR_MODE_2
00003CA0                          3477  OR_OPMODE_101: ; mode 2, word
00003CA0  1A3C 0001               3478      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003CA4  4EF9 00003CDC           3479      JMP         OR_MODE_2
00003CAA                          3480  OR_OPMODE_110: ; mode 2, long
00003CAA  1A3C 0001               3481      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003CAE  4EF9 00003CDC           3482      JMP         OR_MODE_2
00003CB4                          3483  OR_OPMODE_111: ; Invalid value
00003CB4  4EB8 28E8               3484      JSR         EA_INVALID
00003CB8  4EF9 00003DC6           3485      JMP         OR_END
00003CBE                          3486  OR_MODE_1:
00003CBE  4280                    3487      CLR.L       D0                  ; Clear data register 0
00003CC0  103C 0001               3488      MOVE.B      #1, D0              ; Save mode number to D0
00003CC4  3207                    3489      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003CC6  4EB8 2902               3490      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003CCA  4EB9 00003CF6           3491      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
00003CD0                          3492      *PRINT COMMA TODO
00003CD0  3E01                    3493      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003CD2  4EB8 2960               3494      JSR         EA_PRINT_DN         ; Print data register
00003CD6  4EF9 00003DC6           3495      JMP         OR_END
00003CDC                          3496  OR_MODE_2:
00003CDC  4280                    3497      CLR.L       D0                  ; Clear data register 0
00003CDE  103C 0002               3498      MOVE.B      #2, D0              ; Save mode number to D0
00003CE2  4EB8 2960               3499      JSR         EA_PRINT_DN         ; Print data register
00003CE6                          3500      *PRINT COMMA TODO
00003CE6  4EB8 2902               3501      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003CEA  4EB9 00003CF6           3502      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
00003CF0  4EF9 00003DC6           3503      JMP         OR_END
00003CF6                          3504  OR_EVAL_EA:
00003CF6  41F9 00003D04           3505      LEA         OR_MODE, A0         ; Set index '0' for jump table
00003CFC  CCFC 0006               3506      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003D00  4EF0 6000               3507      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003D04                          3508  OR_MODE:
00003D04  4EF9 00003D34           3509      JMP         OR_MODE_000         ; Invalid: Dn
00003D0A  4EF9 00003D3E           3510      JMP         OR_MODE_001         ; An (invalid if opmode 2)
00003D10  4EF9 00003D50           3511      JMP         OR_MODE_010         ; (An)
00003D16  4EF9 00003D5A           3512      JMP         OR_MODE_011         ; (An)+
00003D1C  4EF9 00003D64           3513      JMP         OR_MODE_100         ; -(An)
00003D22  4EF9 00003D6E           3514      JMP         OR_MODE_101         ; Invalid: Address Register Indirect with Displacement Mode
00003D28  4EF9 00003D74           3515      JMP         OR_MODE_110         ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003D2E  4EF9 00003D7A           3516      JMP         OR_MODE_111         ; The rest (not all valid, validated by register number)
00003D34                          3517  OR_MODE_000: ; Invalid: Dn
00003D34  4EB8 28E8               3518      JSR         EA_INVALID          ; Invalid for both opmodes
00003D38  4EF9 00003DBE           3519      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D3E                          3520  OR_MODE_001: ; An (invalid if opmode 2)
00003D3E  B07C 0002               3521      CMP         #2, D0
00003D42  6700 007C               3522      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
00003D46  4EB8 29A0               3523      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00003D4A  4EF9 00003DBE           3524      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D50                          3525  OR_MODE_010: ; (An)
00003D50  4EB8 29E0               3526      JSR         EA_PRINT_IND         ; Print address register indirect
00003D54  4EF9 00003DBE           3527      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D5A                          3528  OR_MODE_011: ; (An)+
00003D5A  4EB8 2A3E               3529      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003D5E  4EF9 00003DBE           3530      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D64                          3531  OR_MODE_100: ; -(An)
00003D64  4EB8 2A7E               3532      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003D68  4EF9 00003DBE           3533      JMP         OR_MODE_END         ; End evaluation of ea mode
00003D6E                          3534  OR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003D6E  4EF9 00003DC0           3535      JMP         OR_MODE_INVALID
00003D74                          3536  OR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003D74  4EF9 00003DC0           3537      JMP         OR_MODE_INVALID
00003D7A                          3538  OR_MODE_111: ; The rest (not all valid, validated by register number)
00003D7A  BE3C 0000               3539      CMP.B       #$00, D7            ; Test for absolute word address
00003D7E  6700 0018               3540      BEQ         OR_ABS_W
00003D82  BE3C 0001               3541      CMP.B       #$01, D7            ; Test for absolute long address
00003D86  6700 001A               3542      BEQ         OR_ABS_L
00003D8A  BE3C 0004               3543      CMP.B       #$04, D7            ; Test for immediate data
00003D8E  6700 001C               3544      BEQ         OR_IMM
00003D92  4EF9 00003DC0           3545      JMP         OR_MODE_INVALID     ; else, invalid
00003D98                          3546  OR_ABS_W:
00003D98  4EB8 2ACA               3547      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003D9C  4EF9 00003DBE           3548      JMP         OR_MODE_END
00003DA2                          3549  OR_ABS_L:
00003DA2  4EB8 2ABE               3550      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003DA6  4EF9 00003DBE           3551      JMP         OR_MODE_END
00003DAC                          3552  OR_IMM: ; invalid if opmode is 2
00003DAC  B07C 0002               3553      CMP         #2, D0
00003DB0  6700 000E               3554      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
00003DB4  4EB8 2A20               3555      JSR         EA_PRINT_IMM        ; Print immediate data
00003DB8  4EF9 00003DBE           3556      JMP         OR_MODE_END
00003DBE                          3557  OR_MODE_END:
00003DBE  4E75                    3558      RTS                             ; Finish evaluating EA bits
00003DC0                          3559  OR_MODE_INVALID:
00003DC0  4EB8 28E8               3560      JSR         EA_INVALID          ; Opcode word is Invalid
00003DC4  4E75                    3561      RTS
00003DC6                          3562  OR_END:
00003DC6  4EB8 28F2               3563      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003DCA  4CDF 3FFF               3564      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003DCE  4E75                    3565      RTS
00003DD0                          3566  EA_ROd:
00003DD0  48E7 FFFC               3567      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003DD4  4EB8 28FE               3568      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003DD8  4EB8 294E               3569      JSR         EA_SIZE_BITS        ; get size bits in D7
00003DDC  BE3C 0003               3570      CMP.B       #$03, D7            ; test if memory shift
00003DE0  6700 0042               3571      BEQ         ROd_MEM
00003DE4  6000 0002               3572      BRA         ROd_REG             ; else, register shfit
00003DE8                          3573  ROd_REG:
00003DE8  3E16                    3574      MOVE.W      (A6), D7            ; read opcode word in memory and save,
00003DEA                          3575                                      ; (using D7 because EA_PRINT_DN uses D7)
00003DEA  143C 0004               3576      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
00003DEE  E56F                    3577      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003DF0  143C 000D               3578      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
00003DF4  E46F                    3579      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003DF6  3016                    3580      MOVE.W      (A6), D0            ; read opcode word in memory and save
00003DF8  143C 000A               3581      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
00003DFC  E568                    3582      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00003DFE  143C 000F               3583      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
00003E02  E468                    3584      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00003E04  B03C 0000               3585      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
00003E08  6700 000C               3586      BEQ         ROd_REG_COUNT
00003E0C                          3587  ROd_REG_REG:                        ; Else, count/register field contains register number
00003E0C  4EB8 2960               3588      JSR         EA_PRINT_DN         ; Print register value, stored in D7
00003E10  4EF9 00003E16           3589      JMP         ROd_REG_END         ; Jump to end of ROd_REG
00003E16                          3590  ROd_REG_COUNT:
00003E16                          3591      *print hash todo
00003E16                          3592      *print hex value in D7 as byte todo, continue on to ROd_REG_END
00003E16                          3593  ROd_REG_END:
00003E16                          3594      *PRINT COMMA todo
00003E16  4EB8 2902               3595      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
00003E1A  4EB8 2960               3596      JSR         EA_PRINT_DN         ; Print register value in D7
00003E1E  4EF9 00003EDA           3597      JMP         ROd_END
00003E24                          3598  ROd_MEM:
00003E24  4EB8 2902               3599      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003E28  41F9 00003E36           3600      LEA         ROd_MEM_MODE, A0    ; Set index '0' for jump table
00003E2E  CCFC 0006               3601      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003E32  4EF0 6000               3602      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003E36                          3603  ROd_MEM_MODE:
00003E36  4EF9 00003E66           3604      JMP         ROd_MEM_MODE_000     ; Invalid: Dn
00003E3C  4EF9 00003E70           3605      JMP         ROd_MEM_MODE_001     ; Invalid: An
00003E42  4EF9 00003E7A           3606      JMP         ROd_MEM_MODE_010     ; (An)
00003E48  4EF9 00003E84           3607      JMP         ROd_MEM_MODE_011     ; (An)+
00003E4E  4EF9 00003E8E           3608      JMP         ROd_MEM_MODE_100     ; -(An)
00003E54  4EF9 00003E98           3609      JMP         ROd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003E5A  4EF9 00003EA2           3610      JMP         ROd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E60  4EF9 00003EAC           3611      JMP         ROd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00003E66                          3612  ROd_MEM_MODE_000: ; Invalid: Dn
00003E66  4EB8 28E8               3613      JSR         EA_INVALID          ; Data register direct is invalid mode
00003E6A  4EF9 00003EDA           3614      JMP         ROd_END
00003E70                          3615  ROd_MEM_MODE_001: ; Invalid: An
00003E70  4EB8 28E8               3616      JSR         EA_INVALID          ; Address register direct is invalid mode
00003E74  4EF9 00003EDA           3617      JMP         ROd_END
00003E7A                          3618  ROd_MEM_MODE_010: ; (An)
00003E7A  4EB8 29E0               3619      JSR         EA_PRINT_IND         ; Print address register indirect
00003E7E  4EF9 00003EDA           3620      JMP         ROd_END
00003E84                          3621  ROd_MEM_MODE_011: ; (An)+
00003E84  4EB8 2A3E               3622      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003E88  4EF9 00003EDA           3623      JMP         ROd_END
00003E8E                          3624  ROd_MEM_MODE_100: ; -(An)
00003E8E  4EB8 2A7E               3625      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003E92  4EF9 00003EDA           3626      JMP         ROd_END         ; Continue with parsing destination operand
00003E98                          3627  ROd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003E98  4EB8 28E8               3628      JSR         EA_INVALID          ; Opcode word is Invalid
00003E9C  4EF9 00003EDA           3629      JMP         ROd_END
00003EA2                          3630  ROd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003EA2  4EB8 28E8               3631      JSR         EA_INVALID          ; Opcode word is Invalid
00003EA6  4EF9 00003EDA           3632      JMP         ROd_END
00003EAC                          3633  ROd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
00003EAC  BE3C 0000               3634      CMP.B       #$00, D7            ; Test for absolute word address
00003EB0  6700 0014               3635      BEQ         ROd_MEM_ABS_W
00003EB4  BE3C 0001               3636      CMP.B       #$01, D7            ; Test for absolute long address
00003EB8  6700 0016               3637      BEQ         ROd_MEM_ABS_L
00003EBC  4EB8 28E8               3638      JSR         EA_INVALID          ; Else: invalid
00003EC0  4EF9 00003EDA           3639      JMP         ROd_END
00003EC6                          3640  ROd_MEM_ABS_W:
00003EC6  4EB8 2ACA               3641      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003ECA  4EF9 00003EDA           3642      JMP         ROd_END
00003ED0                          3643  ROd_MEM_ABS_L:
00003ED0  4EB8 2ABE               3644      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003ED4  4EF9 00003EDA           3645      JMP         ROd_END
00003EDA                          3646  ROd_END:
00003EDA  4EB8 28F2               3647      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003EDE  4CDF 3FFF               3648      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003EE2  4E75                    3649      RTS
00003EE4                          3650  EA_SUB:
00003EE4  4EB8 2928               3651      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00003EE8  41F9 00003EF6           3652      LEA         SUB_OPMODE, A0      ; Set index '0' for jump table
00003EEE  CCFC 0006               3653      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003EF2  4EF0 6000               3654      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003EF6                          3655  SUB_OPMODE:
00003EF6  4EF9 00003F26           3656      JMP         SUB_OPMODE_000      ; mode 1, byte
00003EFC  4EF9 00003F30           3657      JMP         SUB_OPMODE_001      ; mode 1, word
00003F02  4EF9 00003F3A           3658      JMP         SUB_OPMODE_010      ; mode 1, long
00003F08  4EF9 00003F44           3659      JMP         SUB_OPMODE_011      ; Invalid value
00003F0E  4EF9 00003F4E           3660      JMP         SUB_OPMODE_100      ; mode 2, byte
00003F14  4EF9 00003F58           3661      JMP         SUB_OPMODE_101      ; mode 2, word
00003F1A  4EF9 00003F62           3662      JMP         SUB_OPMODE_110      ; mode 2, long
00003F20  4EF9 00003F6C           3663      JMP         SUB_OPMODE_111      ; Invalid value
00003F26                          3664  SUB_OPMODE_000: ; mode 1, byte
00003F26  1A3C 0001               3665      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F2A  4EF9 00003F76           3666      JMP         SUB_MODE_1
00003F30                          3667  SUB_OPMODE_001: ; mode 1, word
00003F30  1A3C 0002               3668      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00003F34  4EF9 00003F76           3669      JMP         SUB_MODE_1
00003F3A                          3670  SUB_OPMODE_010: ; mode 1, long
00003F3A  1A3C 0003               3671      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00003F3E  4EF9 00003F76           3672      JMP         SUB_MODE_1
00003F44                          3673  SUB_OPMODE_011: ; Invalid value
00003F44  4EB8 28E8               3674      JSR         EA_INVALID
00003F48  4EF9 00004086           3675      JMP         SUB_END
00003F4E                          3676  SUB_OPMODE_100: ; mode 2, byte
00003F4E  1A3C 0001               3677      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F52  4EF9 00003F94           3678      JMP         SUB_MODE_2
00003F58                          3679  SUB_OPMODE_101: ; mode 2, word
00003F58  1A3C 0001               3680      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F5C  4EF9 00003F94           3681      JMP         SUB_MODE_2
00003F62                          3682  SUB_OPMODE_110: ; mode 2, long
00003F62  1A3C 0001               3683      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F66  4EF9 00003F94           3684      JMP         SUB_MODE_2
00003F6C                          3685  SUB_OPMODE_111: ; Invalid value
00003F6C  4EB8 28E8               3686      JSR         EA_INVALID
00003F70  4EF9 00004086           3687      JMP         SUB_END
00003F76                          3688  SUB_MODE_1:
00003F76  4280                    3689      CLR.L       D0                  ; Clear data register 0
00003F78  103C 0001               3690      MOVE.B      #1, D0              ; Save mode number to D0
00003F7C  3207                    3691      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003F7E  4EB8 2902               3692      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003F82  4EB9 00003FAE           3693      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
00003F88  3E01                    3694      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003F8A  4EB8 2960               3695      JSR         EA_PRINT_DN         ; Print data register
00003F8E  4EF9 00004086           3696      JMP         SUB_END
00003F94                          3697  SUB_MODE_2:
00003F94  4280                    3698      CLR.L       D0                  ; Clear data register 0
00003F96  103C 0002               3699      MOVE.B      #2, D0              ; Save mode number to D0
00003F9A  4EB8 2960               3700      JSR         EA_PRINT_DN         ; Print data register
00003F9E  4EB8 2902               3701      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003FA2  4EB9 00003FAE           3702      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
00003FA8  4EF9 00004086           3703      JMP         SUB_END
00003FAE                          3704  SUB_EVAL_EA:
00003FAE  41F9 00003FBC           3705      LEA         SUB_MODE, A0        ; Set index '0' for jump table
00003FB4  CCFC 0006               3706      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003FB8  4EF0 6000               3707      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003FBC                          3708  SUB_MODE:
00003FBC  4EF9 00003FEC           3709      JMP         SUB_MODE_000        ; Dn (invalid if opmode 2)
00003FC2  4EF9 00003FFE           3710      JMP         SUB_MODE_001        ; An (invalid if opmode 2)
00003FC8  4EF9 00004010           3711      JMP         SUB_MODE_010        ; (An)
00003FCE  4EF9 0000401A           3712      JMP         SUB_MODE_011        ; (An)+
00003FD4  4EF9 00004024           3713      JMP         SUB_MODE_100        ; -(An)
00003FDA  4EF9 0000402E           3714      JMP         SUB_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003FE0  4EF9 00004034           3715      JMP         SUB_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003FE6  4EF9 0000403A           3716      JMP         SUB_MODE_111        ; The rest (not all valid, validated by register number)
00003FEC                          3717  SUB_MODE_000: ; Dn (invalid if opmode 2)
00003FEC  B07C 0002               3718      CMP         #2, D0
00003FF0  6700 008E               3719      BEQ         SUB_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00003FF4  4EB8 2960               3720      JSR         EA_PRINT_DN         ; Print data register direct operand
00003FF8  4EF9 0000407E           3721      JMP         SUB_MODE_END        ; End evaluation of ea mode
00003FFE                          3722  SUB_MODE_001: ; An (invalid if opmode 2)
00003FFE  B07C 0002               3723      CMP         #2, D0
00004002  6700 007C               3724      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00004006  4EB8 29A0               3725      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
0000400A  4EF9 0000407E           3726      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004010                          3727  SUB_MODE_010: ; (An)
00004010  4EB8 29E0               3728      JSR         EA_PRINT_IND         ; Print address register indirect
00004014  4EF9 0000407E           3729      JMP         SUB_MODE_END        ; End evaluation of ea mode
0000401A                          3730  SUB_MODE_011: ; (An)+
0000401A  4EB8 2A3E               3731      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000401E  4EF9 0000407E           3732      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004024                          3733  SUB_MODE_100: ; -(An)
00004024  4EB8 2A7E               3734      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00004028  4EF9 0000407E           3735      JMP         SUB_MODE_END        ; End evaluation of ea mode
0000402E                          3736  SUB_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000402E  4EF9 00004080           3737      JMP         SUB_MODE_INVALID
00004034                          3738  SUB_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004034  4EF9 00004080           3739      JMP         SUB_MODE_INVALID
0000403A                          3740  SUB_MODE_111: ; The rest (not all valid, validated by register number)
0000403A  BE3C 0000               3741      CMP.B       #$00, D7            ; Test for absolute word address
0000403E  6700 0018               3742      BEQ         SUB_ABS_W
00004042  BE3C 0001               3743      CMP.B       #$01, D7            ; Test for absolute long address
00004046  6700 001A               3744      BEQ         SUB_ABS_L
0000404A  BE3C 0004               3745      CMP.B       #$04, D7            ; Test for immediate data
0000404E  6700 001C               3746      BEQ         SUB_IMM
00004052  4EF9 00004080           3747      JMP         SUB_MODE_INVALID    ; else, invalid
00004058                          3748  SUB_ABS_W:
00004058  4EB8 2ACA               3749      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000405C  4EF9 0000407E           3750      JMP         SUB_MODE_END
00004062                          3751  SUB_ABS_L:
00004062  4EB8 2ABE               3752      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00004066  4EF9 0000407E           3753      JMP         SUB_MODE_END
0000406C                          3754  SUB_IMM: ; invalid if opmode is 2
0000406C  B07C 0002               3755      CMP         #2, D0
00004070  6700 000E               3756      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00004074  4EB8 2A20               3757      JSR         EA_PRINT_IMM        ; Print immediate data
00004078  4EF9 0000407E           3758      JMP         SUB_MODE_END
0000407E                          3759  SUB_MODE_END:
0000407E  4E75                    3760      RTS                             ; Finish evaluating EA bits
00004080                          3761  SUB_MODE_INVALID:
00004080  4EB8 28E8               3762      JSR         EA_INVALID          ; Opcode word is Invalid
00004084  4E75                    3763      RTS
00004086                          3764  SUB_END:
00004086  4EB8 28F2               3765      JSR         EA_UPDATE_POINTER   ; Updates global pointer
0000408A  4CDF 3FFF               3766      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000408E  4E75                    3767      RTS
00004090                          3768  
00004090                          3769  
00004090                          3770  
00004090                          3771  -------------------- end include --------------------
00004090                          3772      INCLUDE 'EndProgram.X68'
00004090                          3773  
00004090                          3774  
00004090                          3775  
00004090  =00000059               3776  UPYES     EQU   'Y'
00004090  =00000079               3777  LOWYES    EQU   'y'
00004090                          3778  
00004090                          3779  
00004090                          3780  
00004090                          3781  KEEP_RUNNING
00004090  6100 0004               3782      BSR.W       RERUN               * Run welcome subroutine
00004094  4E75                    3783      RTS                             * Return to Disassembler
00004096                          3784      
00004096                          3785  
00004096                          3786  
00004096                          3787             
00004096                          3788  
00004096                          3789  RERUN 
00004096  43F9 000040D0           3790      LEA         ENDQUESTION,A1      * Loads message into A1
0000409C  103C 000E               3791      MOVE.B      #14,D0              * Moves the Task 14 into D0
000040A0  4E4F                    3792      TRAP        #15                 * Displays Intro Message
000040A2                          3793      
000040A2  103C 0005               3794      MOVE.B      #5,D0               * Move task 5 to read one char
000040A6  4E4F                    3795      TRAP        #15                 * Trap 15 for IO
000040A8                          3796      
000040A8  0C01 0059               3797      CMPI.B      #UPYES,D1           * Is char = Y
000040AC  6700 0012               3798      BEQ         NOTDONE             * If yes, notdone
000040B0  0C01 0079               3799      CMPI.B      #LOWYES,D1          * Is char = y   
000040B4  6700 000A               3800      BEQ         NOTDONE             * If yes, notdone
000040B8  11FC 0000 6000          3801      MOVE.B      #0,(RUNAGAIN)       * 0 for false to end program
000040BE  4E75                    3802      RTS 
000040C0                          3803      
000040C0                          3804  NOTDONE
000040C0  11FC 0001 6000          3805      MOVE.B      #1,(RUNAGAIN)       * 1 for true to rerun program
000040C6  6100 CFC4               3806      BSR.W       CLEAR               * Clear all values
000040CA  6100 D1EE               3807      BSR.W       CLEARSCRN           * Clear screen and return from subroutine
000040CE  4E75                    3808      RTS         
000040D0                          3809          
000040D0                          3810  
000040D0                          3811  
000040D0                          3812  
000040D0= 57 4F 55 4C 44 20 ...   3813  ENDQUESTION     DC.B 'WOULD YOU LIKE TO RUN THE PROGRAM AGAIN (Y/N)? ',0
00004100                          3814  
00004100                          3815  
00004100                          3816  
00004100                          3817  
00004100                          3818  -------------------- end include --------------------
00004100                          3819  
00004100                          3820  *********** END INCLUDES *****************************************************
00004100                          3821  
00004100                          3822  
00004100                          3823  ******************************************************************************
00004100                          3824  *           BEGIN CODE                                                       *
00004100                          3825  ******************************************************************************
00004100                          3826  
00004100                          3827  *---------- START ------------------------------------------------------------
00004100                          3828  * Begins program's logical flow. Similar to main in C/C++
00004100                          3829  *-----------------------------------------------------------------------------
00004100                          3830  START
00004100  4FF8 7000               3831      LEA         STACK,SP            * SP is stored in A7
00004104  4EB8 1000               3832      JSR         GET_ADDRESSES       * Runs GET_ADDRESSES and IO_WELCOME
00004108  2C78 5000               3833      MOVEA.L     BEGINADDR,A6        * Assign beginning address to A6 for use
0000410C                          3834  
0000410C                          3835  LOOP
0000410C                          3836      * OC_PARSE Command doesn't work due to issues in the Opcode include
0000410C                          3837      * many errors need to be fixed. Same with EA include
0000410C                          3838      *JSR         OC_PARSE            * Determine if there is an initial opcode match
0000410C  4EB8 12D8               3839      JSR         INVALID_DATA
00004110                          3840      * decrement row count
00004110                          3841      * if at 0, prompt for next page
00004110                          3842      * else, continue
00004110  548E                    3843      ADDA.L      #$00000002,A6            * Advance address to test LOOP (test only)
00004112                          3844  
00004112                          3845  LOOP_CHECK
00004112                          3846      * Changed the following code from:
00004112                          3847      * CMPA        A6, ENDADDR
00004112                          3848      * to:
00004112                          3849      * CMPA      (ENDADDR),A6
00004112                          3850      * When using the CMPA, destination must be an address so A6
00004112  BDF8 5010               3851      CMPA.L      ENDADDR,A6          * Is pointer at end of address range?
00004116                          3852  
00004116  6E00 0004               3853      BGT         END_LOOP            * If yes, END_LOOP
0000411A                          3854      ; in case this resets status register, do another compare TODO
0000411A                          3855  
0000411A  66F0                    3856      BNE         LOOP                * If not, continue processing addresses
0000411C                          3857      ; If at end of address range, check if user wants to continue
0000411C                          3858      ; if user wants to continue, restart
0000411C                          3859      ; else, end
0000411C                          3860  
0000411C                          3861  END_LOOP
0000411C  4EB8 4090               3862      JSR         KEEP_RUNNING        * Does the user want to run program again
00004120  0C38 0001 6000          3863      CMPI.B      #1,(RUNAGAIN)       * Does RUNAGAIN = TRUE?
00004126  67D8                    3864      BEQ         START               * If yes, rerun program
00004128  4E72 3000               3865      STOP        #$3000              * Else, end program
0000412C                          3866  
0000412C                          3867  *---------- END - START ------------------------------------------------------
0000412C                          3868  
0000412C                          3869  *********** END BEGIN CODE ***************************************************
0000412C                          3870  
0000412C                          3871  
0000412C                          3872  ******************************************************************************
0000412C                          3873  *           VARIABLES AND CONSTANTS                                          *
0000412C                          3874  ******************************************************************************
0000412C                          3875  
0000412C                          3876  
0000412C                          3877  
0000412C                          3878  *---------- Reserved Registers -----------------------------
0000412C                          3879  *   A7: stack pointer
0000412C                          3880  *   A6: current address (updated by subroutines)
0000412C                          3881  *   D0: instruction validity flag (reset by main control
0000412C                          3882  *       code, can be set to false by subroutines)
0000412C                          3883  *-----------------------------------------------------------
0000412C                          3884  
0000412C                          3885  *---------- End --------------------------------------------
0000412C                          3886                 END  START          * Last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDA_ABS_L          2D3A
ADDA_ABS_W          2D30
ADDA_END            2D64
ADDA_IMM            2D44
ADDA_MODE           2CA4
ADDA_MODE_000       2CD4
ADDA_MODE_001       2CDE
ADDA_MODE_010       2CE8
ADDA_MODE_011       2CF2
ADDA_MODE_100       2CFC
ADDA_MODE_101       2D06
ADDA_MODE_110       2D0C
ADDA_MODE_111       2D12
ADDA_MODE_END       2D5C
ADDA_MODE_INVALID   2D52
ADDCODE000          1CCC
ADDCODE001          1CD4
ADDCODE010          1CDC
ADDCODE011          1CE4
ADDCODE100          1CEC
ADDCODE101          1CF4
ADDCODE110          1CFC
ADDCODE111          1D04
ADDIBCODE00         212A
ADDILCODE10         213A
ADDILCODE11         2142
ADDIWCODE01         2132
ADDI_ABS_L          2E76
ADDI_ABS_W          2E6C
ADDI_B              2D9C
ADDI_BORADDI_WORADDI_L  20F4
ADDI_END            2E80
ADDI_GET_DEST       2DCA
ADDI_L              2DC4
ADDI_MODE           2DDC
ADDI_MODE_000       2E0C
ADDI_MODE_001       2E16
ADDI_MODE_010       2E20
ADDI_MODE_011       2E2A
ADDI_MODE_100       2E34
ADDI_MODE_101       2E3E
ADDI_MODE_110       2E48
ADDI_MODE_111       2E52
ADDI_W              2DB6
ADDQCODE00          1E26
ADDQCODE01          1E2E
ADDQCODE10          1E36
ADDQCODE11          1E3E
ADDQ_ABS_L          2F58
ADDQ_ABS_W          2F4E
ADDQ_BORADDQ_WORADDQ_L  1DF0
ADDQ_END            2F62
ADDQ_MODE           2EBE
ADDQ_MODE_000       2EEE
ADDQ_MODE_001       2EF8
ADDQ_MODE_010       2F02
ADDQ_MODE_011       2F0C
ADDQ_MODE_100       2F16
ADDQ_MODE_101       2F20
ADDQ_MODE_110       2F2A
ADDQ_MODE_111       2F34
ADDQ_PRINT_IMM      2EAC
ADDRESS_ERR         12C6
ADD_ABS_L           2C5C
ADD_ABS_W           2C52
ADD_BORADD_WORADD_L  1C7E
ADD_END             2C80
ADD_EVAL_EA         2BA8
ADD_IMM             2C66
ADD_MODE            2BB6
ADD_MODE_000        2BE6
ADD_MODE_001        2BF8
ADD_MODE_010        2C0A
ADD_MODE_011        2C14
ADD_MODE_1          2B70
ADD_MODE_100        2C1E
ADD_MODE_101        2C28
ADD_MODE_110        2C2E
ADD_MODE_111        2C34
ADD_MODE_2          2B8E
ADD_MODE_END        2C78
ADD_MODE_INVALID    2C7A
ADD_OPMODE          2AF0
ADD_OPMODE_000      2B20
ADD_OPMODE_001      2B2A
ADD_OPMODE_010      2B34
ADD_OPMODE_011      2B3E
ADD_OPMODE_100      2B48
ADD_OPMODE_101      2B52
ADD_OPMODE_110      2B5C
ADD_OPMODE_111      2B66
ADR_ERR_NOTLT       1430
ANDCODE000          1C3E
ANDCODE001          1C46
ANDCODE010          1C4E
ANDCODE011          1C56
ANDCODE100          1C5E
ANDCODE101          1C66
ANDCODE110          1C6E
ANDCODE111          1C76
AND_ABS_L           30E4
AND_ABS_W           30DA
AND_BORAND_WORAND_LORMULS_W  1BF0
AND_END             3108
AND_EVAL_EA         303C
AND_IMM             30EE
AND_MODE            304A
AND_MODE_000        307A
AND_MODE_001        308C
AND_MODE_010        3092
AND_MODE_011        309C
AND_MODE_1          3004
AND_MODE_100        30A6
AND_MODE_101        30B0
AND_MODE_110        30B6
AND_MODE_111        30BC
AND_MODE_2          3022
AND_MODE_END        3100
AND_MODE_INVALID    3102
AND_OPMODE          2F84
AND_OPMODE_000      2FB4
AND_OPMODE_001      2FBE
AND_OPMODE_010      2FC8
AND_OPMODE_011      2FD2
AND_OPMODE_100      2FDC
AND_OPMODE_101      2FE6
AND_OPMODE_110      2FF0
AND_OPMODE_111      2FFA
AN_000              29DE
AN_001              29DE
AN_010              29DE
AN_011              29DE
AN_100              29DE
AN_101              29DE
AN_110              29DE
AN_111              29DE
AN_JMP              29AE
ASCII_TO_HEX        10E0
ASD_END             321C
ASD_MEM             3166
ASD_MEM_ABS_L       3212
ASD_MEM_ABS_W       3208
ASD_MEM_MODE        3178
ASD_MEM_MODE_000    31A8
ASD_MEM_MODE_001    31B2
ASD_MEM_MODE_010    31BC
ASD_MEM_MODE_011    31C6
ASD_MEM_MODE_100    31D0
ASD_MEM_MODE_101    31DA
ASD_MEM_MODE_110    31E4
ASD_MEM_MODE_111    31EE
ASD_REG             312A
ASD_REG_COUNT       3158
ASD_REG_END         3158
ASD_REG_REG         314E
ASLCODE00           1986
ASLCODE01           198E
ASLCODE10           1996
ASLCODE11           199E
ASL_ASR             1B6A
ASL_ASRCODE0        1B94
ASL_ASRCODE1        1B9A
ASRCODE00           1930
ASRCODE01           1938
ASRCODE10           1940
ASRCODE11           1948
BAD_CHECK           129C
BAD_LENGTH          10D8
BCCORBGTORBLE       1816
BCCORBGTORBLECODE00  184C
BCCORBGTORBLECODE01  1854
BCCORBGTORBLECODE10  185C
BCCORBGTORBLECODE11  1864
BCC_B               3254
BCC_DISPLAY         32A8
BCC_L               329A
BCC_W               3278
BEGINADDR           5000
BMESSAGE            13E8
CHECK_BADDR_IS_LESS_THAN_EADDR  1058
CLEAR               108C
CLEARSCRN           12BA
CLRCODE00           1E7C
CLRCODE01           1E84
CLRCODE10           1E8C
CLRCODE11           1E94
CLR_ABS_L           3368
CLR_ABS_W           335E
CLR_END             3372
CLR_MODE            32CE
CLR_MODE_000        32FE
CLR_MODE_001        3308
CLR_MODE_010        3312
CLR_MODE_011        331C
CLR_MODE_100        3326
CLR_MODE_101        3330
CLR_MODE_110        333A
CLR_MODE_111        3344
CMPCODE00           1DD0
CMPCODE01           1DD8
CMPCODE10           1DE0
CMPCODE11           1DE8
CMP_ABS_L           3430
CMP_ABS_W           3426
CMP_BORCMP_WORCMP_L  1D9A
CMP_END             3442
CMP_MODE            3396
CMP_MODE_000        33C6
CMP_MODE_001        33D0
CMP_MODE_010        33DA
CMP_MODE_011        33E4
CMP_MODE_100        33EE
CMP_MODE_101        33F8
CMP_MODE_110        3402
CMP_MODE_111        340C
CMP_MODE_END        343A
CODE0000            176A
CODE0001            1770
CODE0010            177C
CODE0011            1782
CODE0100            1788
CODE0101            1794
CODE0110            17A0
CODE0111            17AC
CODE1000            17B8
CODE1001            17C4
CODE1010            17D0
CODE1011            17D8
CODE1100            17E4
CODE1101            17F0
CODE1110            17FC
CODE1111            1808
CR                  D
DATA                14DB
DIVU_W_ABS_L        3508
DIVU_W_ABS_W        34FE
DIVU_W_DEST         3520
DIVU_W_END          3532
DIVU_W_IMM          3512
DIVU_W_MODE         3466
DIVU_W_MODE_000     3496
DIVU_W_MODE_001     34A0
DIVU_W_MODE_010     34AA
DIVU_W_MODE_011     34B4
DIVU_W_MODE_100     34BE
DIVU_W_MODE_101     34C8
DIVU_W_MODE_110     34D2
DIVU_W_MODE_111     34DC
DN_000              299E
DN_001              299E
DN_010              299E
DN_011              299E
DN_100              299E
DN_101              299E
DN_110              299E
DN_111              299E
DOLLAR              142E
DONE                1810
EA_ADD              2AD6
EA_ADDA             2C8A
EA_ADDI             2D6E
EA_ADDQ             2E8A
EA_AND              2F6C
EA_ASD              3112
EA_BCC              3226
EA_CLR              32B4
EA_CMP              337C
EA_COPY_PTR         28FE
EA_DEFAULT_COMBO    2902
EA_DIVU_W           344C
EA_INVALID          28E8
EA_JSR              353C
EA_LEA              3604
EA_LSD              36D4
EA_MOVE             37E8
EA_MOVEA            39C0
EA_MOVEM            3AEA
EA_MOVEQ            3AF0
EA_MSG_A0           28D4
EA_MSG_A1           28D6
EA_MSG_A2           28D8
EA_MSG_A3           28DA
EA_MSG_A4           28DC
EA_MSG_A5           28DE
EA_MSG_A6           28E0
EA_MSG_A7           28E2
EA_MSG_CLOSEPAREN   28BF
EA_MSG_COMMA        28BC
EA_MSG_D0           28C4
EA_MSG_D1           28C6
EA_MSG_D2           28C8
EA_MSG_D3           28CA
EA_MSG_D4           28CC
EA_MSG_D5           28CE
EA_MSG_D6           28D0
EA_MSG_D7           28D2
EA_MSG_HASH         28C2
EA_MSG_HEX          28C3
EA_MSG_MIN          28C0
EA_MSG_NULL         28BA
EA_MSG_OPENPAREN    28BE
EA_MSG_PLUS         28C1
EA_MSG_SPACE        28BB
EA_MULS_W           3B34
EA_OPMODE_COMBO     2928
EA_OR               3C24
EA_PRINT_ABS_L      2ABE
EA_PRINT_ABS_W      2ACA
EA_PRINT_AN         29A0
EA_PRINT_AN_END     29DE
EA_PRINT_DN         2960
EA_PRINT_DN_END     299E
EA_PRINT_DN_JMP     296E
EA_PRINT_IMM        2A20
EA_PRINT_IND        29E0
EA_PRINT_IND_END    2A1E
EA_PRINT_PD_END     2ABC
EA_PRINT_PI_END     2A7C
EA_PRINT_POSTINC    2A3E
EA_PRINT_PREDEC     2A7E
EA_ROD              3DD0
EA_SIZE_BITS        294E
EA_SUB              3EE4
EA_UNIMPLEMENTED    28E4
EA_UPDATE_POINTER   28F2
EMESSAGE            1407
ENDADDR             5010
ENDL                1426
ENDQUESTION         40D0
END_LOOP            411C
FINISHED            1076
FOUND               119C
GET_ADDRESSES       1000
GET_FIRST_ADDRESS   100C
GET_HEXSTRING       10A6
GET_SECOND_ADDRESS  1032
HEXA                11EC
HEXB                11F4
HEXC                11FC
HEXD                1204
HEXE                120C
HEXEIGHT            11E0
HEXF                1214
HEXFIVE             11D4
HEXFLAG             5021
HEXFOUR             11D0
HEXNINE             11E4
HEXONE              11C4
HEXSEVEN            11DC
HEXSIX              11D8
HEXSTRING           148B
HEXTHREE            11CC
HEXTWO              11C8
HEXVALUE            5030
HEXZERO             11BC
IND_000             2A1E
IND_001             2A1E
IND_010             2A1E
IND_011             2A1E
IND_100             2A1E
IND_101             2A1E
IND_110             2A1E
IND_111             2A1E
IND_JMP             29EE
INITIAL_TABLE       170A
INTRO               132E
INVALID_DATA        12D8
IO_WELCOME          1078
ISADDAL             2582
ISADDAW             2568
ISADDB              259C
ISADDIB             28A0
ISADDIL             2886
ISADDIW             286C
ISADDL              25D0
ISADDQB             2686
ISADDQL             26BA
ISADDQW             26A0
ISADDW              25B6
ISANDB              251A
ISANDL              254E
ISANDW              2534
ISASLB              237A
ISASLL              23AE
ISASLW              2394
ISASRB              232C
ISASRL              2360
ISASRW              2346
ISBCC               2276
ISBGT               2290
ISBLE               22AA
ISCLR               27BA
ISCLRB              26EE
ISCLRL              2722
ISCLRW              2708
ISCMPB              2638
ISCMPL              266C
ISCMPW              2652
ISDIVUW             22C4
ISJSR               278A
ISLEA               2770
ISLSLB              2416
ISLSLL              244A
ISLSLW              2430
ISLSRB              23C8
ISLSRL              23FC
ISLSRW              23E2
ISMOVEAL            2838
ISMOVEAW            2804
ISMOVEB             2852
ISMOVEL             281E
ISMOVEML            273C
ISMOVEMW            2756
ISMOVEQL            26D4
ISMOVEW             27EA
ISMULSW             2500
ISNOP               27D4
ISORB               22DE
ISORL               2312
ISORW               22F8
ISROLB              24B2
ISROLL              24E6
ISROLW              24CC
ISRORB              2464
ISRORL              2498
ISRORW              247E
ISRTS               27A4
ISSUBB              25EA
ISSUBL              261E
ISSUBW              2604
IS_HEX_EVEN         123C
IS_LESSTHAN         121C
JSRORCLRCODE0000    1F3E
JSRORCLRCODE0001    1F46
JSRORCLRCODE0010    1F4E
JSRORCLRCODE0011    1F54
JSRORCLRCODE0100    1F5C
JSRORCLRCODE0101    1F64
JSRORCLRCODE0110    1F6C
JSRORCLRCODE0111    1F74
JSRORCLRCODE1000    1F7C
JSRORCLRCODE1001    1F84
JSRORCLRCODE1010    1F8C
JSRORCLRCODE1011    1F94
JSRORCLRCODE1100    1F9C
JSRORCLRCODE1101    1FA4
JSRORCLRCODE1110    1FAC
JSRORCLRCODE1111    1FB4
JSR_ABS_L           35F0
JSR_ABS_W           35E6
JSR_END             35FA
JSR_MODE            3556
JSR_MODE_000        3586
JSR_MODE_001        3590
JSR_MODE_010        359A
JSR_MODE_011        35A4
JSR_MODE_100        35AE
JSR_MODE_101        35B8
JSR_MODE_110        35C2
JSR_MODE_111        35CC
KEEP_RUNNING        4090
LEA_ABS_L           36B8
LEA_ABS_W           36AE
LEA_DEST            36C2
LEA_END             36CA
LEA_MODE            361E
LEA_MODE_000        364E
LEA_MODE_001        3658
LEA_MODE_010        3662
LEA_MODE_011        366C
LEA_MODE_100        3676
LEA_MODE_101        3680
LEA_MODE_110        368A
LEA_MODE_111        3694
LF                  A
LOOP                410C
LOOP_CHECK          4112
LOTSCODE0000        207A
LOTSCODE0001        2082
LOTSCODE0010        208A
LOTSCODE0011        2090
LOTSCODE0100        2098
LOTSCODE0101        20A0
LOTSCODE0110        20A8
LOTSCODE0111        20B0
LOTSCODE1000        20B8
LOTSCODE1001        20BE
LOTSCODE1010        20C6
LOTSCODE1011        20CC
LOTSCODE1100        20D4
LOTSCODE1101        20DC
LOTSCODE1110        20E4
LOTSCODE1111        20EC
LOWYES              79
LSD_END             37DE
LSD_MEM             3728
LSD_MEM_ABS_L       37D4
LSD_MEM_ABS_W       37CA
LSD_MEM_MODE        373A
LSD_MEM_MODE_000    376A
LSD_MEM_MODE_001    3774
LSD_MEM_MODE_010    377E
LSD_MEM_MODE_011    3788
LSD_MEM_MODE_100    3792
LSD_MEM_MODE_101    379C
LSD_MEM_MODE_110    37A6
LSD_MEM_MODE_111    37B0
LSD_REG             36EC
LSD_REG_COUNT       371A
LSD_REG_END         371A
LSD_REG_REG         3710
LSLCODE00           1A32
LSLCODE01           1A3A
LSLCODE10           1A42
LSLCODE11           1A4A
LSL_LSR             1B34
LSL_LSRCODE0        1B5E
LSL_LSRCODE1        1B64
LSRCODE00           19DC
LSRCODE01           19E4
LSRCODE10           19EC
LSRCODE11           19F4
LT                  1234
MAKE_CHECKS         1270
MESSAGEADDAL        15E0
MESSAGEADDAW        15D7
MESSAGEADDB         15BF
MESSAGEADDIB        1513
MESSAGEADDIL        150A
MESSAGEADDIW        1501
MESSAGEADDL         15CF
MESSAGEADDQB        1574
MESSAGEADDQL        1586
MESSAGEADDQW        157D
MESSAGEADDW         15C7
MESSAGEANDB         15F3
MESSAGEANDL         1603
MESSAGEANDW         15FB
MESSAGEASLB         162C
MESSAGEASLL         163C
MESSAGEASLW         1634
MESSAGEASRB         1614
MESSAGEASRL         1624
MESSAGEASRW         161C
MESSAGEBCC          16C2
MESSAGEBGT          16C8
MESSAGEBLE          16CE
MESSAGECLR          154A
MESSAGECLRB         155C
MESSAGECLRL         156C
MESSAGECLRW         1564
MESSAGECMPB         158F
MESSAGECMPL         159F
MESSAGECMPW         1597
MESSAGEDIVUW        16B9
MESSAGEJSR          1544
MESSAGELEA          1556
MESSAGELSLB         168C
MESSAGELSLL         169C
MESSAGELSLW         1694
MESSAGELSRB         1674
MESSAGELSRL         1684
MESSAGELSRW         167C
MESSAGEMOVEAL       151C
MESSAGEMOVEAW       1526
MESSAGEMOVEB        14F8
MESSAGEMOVEL        14EF
MESSAGEMOVEML       1530
MESSAGEMOVEMW       153A
MESSAGEMOVEQL       15E9
MESSAGEMOVEW        14E6
MESSAGEMULSW        160B
MESSAGENOP          14E0
MESSAGEOPCODE_INVALID  16D4
MESSAGEORB          16A4
MESSAGEORL          16B2
MESSAGEORW          16AB
MESSAGEROLB         165C
MESSAGEROLL         166C
MESSAGEROLW         1664
MESSAGERORB         1644
MESSAGERORL         1654
MESSAGERORW         164C
MESSAGERTS          1550
MESSAGESUBB         15A7
MESSAGESUBL         15B7
MESSAGESUBW         15AF
MOD                 2
MOVEACODE001        21A0
MOVEAWCODE001       222E
MOVEA_ADJUST_L      39F6
MOVEA_ADJUST_W      39EC
MOVEA_DESTINATION   3AD0
MOVEA_END           3AE0
MOVEA_LORMOVE_L     214A
MOVEA_SOURCE        3A00
MOVEA_SRC_ABS_L     3ABC
MOVEA_SRC_ABS_W     3AB2
MOVEA_SRC_IMM       3AC6
MOVEA_SRC_MODE      3A1A
MOVEA_SRC_MODE_000  3A4A
MOVEA_SRC_MODE_001  3A54
MOVEA_SRC_MODE_010  3A5E
MOVEA_SRC_MODE_011  3A68
MOVEA_SRC_MODE_100  3A72
MOVEA_SRC_MODE_101  3A7C
MOVEA_SRC_MODE_110  3A86
MOVEA_SRC_MODE_111  3A90
MOVEA_WORMOVE_W     21D8
MOVECODE000         2198
MOVECODE010         21A8
MOVECODE011         21B0
MOVECODE100         21B8
MOVECODE101         21C0
MOVECODE110         21C8
MOVECODE111         21D0
MOVEMCODE0          1FE6
MOVEMCODE1          1FEE
MOVEQ_PRINT_DATA    3B22
MOVEWCODE000        2226
MOVEWCODE010        2236
MOVEWCODE011        223E
MOVEWCODE100        2246
MOVEWCODE101        224E
MOVEWCODE110        2256
MOVEWCODE111        225E
MOVE_ADJUST_L       381E
MOVE_ADJUST_W       3814
MOVE_DESTINATION    38F8
MOVE_DST_ABS_L      39AC
MOVE_DST_ABS_W      39A2
MOVE_DST_MODE       3912
MOVE_DST_MODE_000   3942
MOVE_DST_MODE_001   394C
MOVE_DST_MODE_010   3956
MOVE_DST_MODE_011   3960
MOVE_DST_MODE_100   396A
MOVE_DST_MODE_101   3974
MOVE_DST_MODE_110   397E
MOVE_DST_MODE_111   3988
MOVE_END            39B6
MOVE_SOURCE         3828
MOVE_SRC_ABS_L      38E4
MOVE_SRC_ABS_W      38DA
MOVE_SRC_IMM        38EE
MOVE_SRC_MODE       3842
MOVE_SRC_MODE_000   3872
MOVE_SRC_MODE_001   387C
MOVE_SRC_MODE_010   3886
MOVE_SRC_MODE_011   3890
MOVE_SRC_MODE_100   389A
MOVE_SRC_MODE_101   38A4
MOVE_SRC_MODE_110   38AE
MOVE_SRC_MODE_111   38B8
MULS_W_ABS_L        3BF0
MULS_W_ABS_W        3BE6
MULS_W_DEST         3C08
MULS_W_END          3C1A
MULS_W_IMM          3BFA
MULS_W_MODE         3B4E
MULS_W_MODE_000     3B7E
MULS_W_MODE_001     3B88
MULS_W_MODE_010     3B92
MULS_W_MODE_011     3B9C
MULS_W_MODE_100     3BA6
MULS_W_MODE_101     3BB0
MULS_W_MODE_110     3BBA
MULS_W_MODE_111     3BC4
NEW_LINE            12AC
NOPCOMMAND          1F36
NOPORCLRORRTSORJSR  1E9C
NOP_MOVEM_LEA_JSR_CLR_RTS  1FF6
NOTDONE             40C0
NOTEVEN             1266
OC_PARSE            16ED
OPCODE_INVALID      2266
OR_ABS_L            3DA2
OR_ABS_W            3D98
OR_BOROR_WOROR_LORDIVU  186C
OR_DIVUCODE000      18BA
OR_DIVUCODE001      18C2
OR_DIVUCODE010      18CA
OR_DIVUCODE011      18D2
OR_DIVUCODE100      18DA
OR_DIVUCODE101      18E2
OR_DIVUCODE110      18EA
OR_DIVUCODE111      18F2
OR_END              3DC6
OR_EVAL_EA          3CF6
OR_IMM              3DAC
OR_MODE             3D04
OR_MODE_000         3D34
OR_MODE_001         3D3E
OR_MODE_010         3D50
OR_MODE_011         3D5A
OR_MODE_1           3CBE
OR_MODE_100         3D64
OR_MODE_101         3D6E
OR_MODE_110         3D74
OR_MODE_111         3D7A
OR_MODE_2           3CDC
OR_MODE_END         3DBE
OR_MODE_INVALID     3DC0
OR_OPMODE           3C3E
OR_OPMODE_000       3C6E
OR_OPMODE_001       3C78
OR_OPMODE_010       3C82
OR_OPMODE_011       3C8C
OR_OPMODE_100       3C96
OR_OPMODE_101       3CA0
OR_OPMODE_110       3CAA
OR_OPMODE_111       3CB4
POSTINC_000         2A7C
POSTINC_001         2A7C
POSTINC_010         2A7C
POSTINC_011         2A7C
POSTINC_100         2A7C
POSTINC_101         2A7C
POSTINC_110         2A7C
POSTINC_111         2A7C
POSTINC_JMP         2A4C
PREDEC_000          2ABC
PREDEC_001          2ABC
PREDEC_010          2ABC
PREDEC_011          2ABC
PREDEC_100          2ABC
PREDEC_101          2ABC
PREDEC_110          2ABC
PREDEC_111          2ABC
PREDEC_JMP          2A8C
PRINT_HEXVALUE      129E
PRINT_IMM_END       2A3A
PRINT_IMM_L         2A36
PS1                 1356
PS2                 13A0
REMAINDER           5050
REPEAT              1248
RERUN               4096
ROD_END             3EDA
ROD_LSD_ASD         1BA0
ROD_LSD_ASDCODE00   1BD6
ROD_LSD_ASDCODE01   1BDC
ROD_LSD_ASDCODE10   1BE2
ROD_LSD_ASDCODE11   1BEA
ROD_MEM             3E24
ROD_MEM_ABS_L       3ED0
ROD_MEM_ABS_W       3EC6
ROD_MEM_MODE        3E36
ROD_MEM_MODE_000    3E66
ROD_MEM_MODE_001    3E70
ROD_MEM_MODE_010    3E7A
ROD_MEM_MODE_011    3E84
ROD_MEM_MODE_100    3E8E
ROD_MEM_MODE_101    3E98
ROD_MEM_MODE_110    3EA2
ROD_MEM_MODE_111    3EAC
ROD_REG             3DE8
ROD_REG_COUNT       3E16
ROD_REG_END         3E16
ROD_REG_REG         3E0C
ROLCODE00           1A88
ROLCODE01           1A90
ROLCODE10           1A98
ROLCODE11           1AA0
ROL_ROR             1AFE
ROL_RORCODE0        1B28
ROL_RORCODE1        1B2E
RORCODE00           1ADE
RORCODE01           1AE6
RORCODE10           1AEE
RORCODE11           1AF6
RTSCOMMAND          1F2E
RUNAGAIN            6000
SHIFTLEFT           11B6
SOMEASL             1950
SOMEASR             18FA
SOMECLR             1E46
SOMELSL             19FC
SOMELSR             19A6
SOMEMOVEM           1FBC
SOMEROL             1A52
SOMEROR             1AA8
STACK               7000
START               4100
STR_LEN             5020
SUBCODE000          1D5A
SUBCODE001          1D62
SUBCODE010          1D6A
SUBCODE011          1D72
SUBCODE100          1D7A
SUBCODE101          1D82
SUBCODE110          1D8A
SUBCODE111          1D92
SUB_ABS_L           4062
SUB_ABS_W           4058
SUB_BORSUB_WORSUB_L  1D0C
SUB_END             4086
SUB_EVAL_EA         3FAE
SUB_IMM             406C
SUB_MODE            3FBC
SUB_MODE_000        3FEC
SUB_MODE_001        3FFE
SUB_MODE_010        4010
SUB_MODE_011        401A
SUB_MODE_1          3F76
SUB_MODE_100        4024
SUB_MODE_101        402E
SUB_MODE_110        4034
SUB_MODE_111        403A
SUB_MODE_2          3F94
SUB_MODE_END        407E
SUB_MODE_INVALID    4080
SUB_OPMODE          3EF6
SUB_OPMODE_000      3F26
SUB_OPMODE_001      3F30
SUB_OPMODE_010      3F3A
SUB_OPMODE_011      3F44
SUB_OPMODE_100      3F4E
SUB_OPMODE_101      3F58
SUB_OPMODE_110      3F62
SUB_OPMODE_111      3F6C
TAB                 1429
TABLEADDI_BORADDI_WORADDI_L  2112
TABLEADDQ_BORADDQ_WORADDQ_L  1E0E
TABLEADD_BORADD_WORADD_L  1C9C
TABLEAND_BORAND_WORAND_LORMULS_W  1C0E
TABLEASL_ASR        1B88
TABLEBCCORBGTORBLE  1834
TABLECMP_BORCMP_WORCMP_L  1DB8
TABLELSL_LSR        1B52
TABLEMOVEA_LORMOVE_L  2168
TABLEMOVEA_WORMOVE_W  21F6
TABLENOPORCLRORRTSORJSR  1ECE
TABLENOP_MOVEM_LEA_JSR_CLR_RTS  201A
TABLEOR_BOROR_WOROR_LORDIVU  188A
TABLEROD_LSD_ASD    1BBE
TABLEROL_ROR        1B1C
TABLESOMEASL        196E
TABLESOMEASR        1918
TABLESOMECLR        1E64
TABLESOMELSL        1A1A
TABLESOMELSR        19C4
TABLESOMEMOVEM      1FDA
TABLESOMEROL        1A70
TABLESOMEROR        1AC6
TABLESUB_BORSUB_WORSUB_L  1D2A
UPDATE_PTR          28FA
UPYES               59
