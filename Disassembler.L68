00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/2/2016 4:05:48 PM

00000000                             1  ******************************************************************************
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Brandon Authier (Hblkr), Jack S. Eldridge
00000000                             4  *              (JackScottie), Marijn Burger (marijnburger)
00000000                             5  * Date       : 16 May 2016
00000000                             6  * Description: An inverse assembler that will convert a memory
00000000                             7  *              image of instructions and data back to the display.
00000000                             8  *              The following will be decoded:
00000000                             9  *
00000000                            10  *              Addressing Modes
00000000                            11  *
00000000                            12  *                Data Register Direct
00000000                            13  *                Address Register Direct
00000000                            14  *                Address Register Indirect
00000000                            15  *                Immediate Data
00000000                            16  *                Address Register Indirect with Post Increment
00000000                            17  *                Address Register Indirect with Pre Decrement
00000000                            18  *                Absolute Long Address
00000000                            19  *                Absolute Word Address
00000000                            20  *
00000000                            21  *              Instructions
00000000                            22  *
00000000                            23  *                NOP
00000000                            24  *                MOVE
00000000                            25  *                MOVEA
00000000                            26  *                MOVEQ
00000000                            27  *                MOVEM
00000000                            28  *                ADD
00000000                            29  *                ADDA
00000000                            30  *                ADDI
00000000                            31  *                ADDQ
00000000                            32  *                SUB
00000000                            33  *                MULS
00000000                            34  *                DIVU
00000000                            35  *                LEA
00000000                            36  *                CLR
00000000                            37  *                AND
00000000                            38  *                OR
00000000                            39  *                LSL
00000000                            40  *                LSR
00000000                            41  *                ASR
00000000                            42  *                ASL
00000000                            43  *                ROL
00000000                            44  *                ROR
00000000                            45  *                CMP
00000000                            46  *                Bcc (BCC, BGT, BLE)
00000000                            47  *                JSR
00000000                            48  *                RTS
00000000                            49  *
00000000                            50  ******************************************************************************
00000000                            51  
00000000                            52  ******************************************************************************
00000000                            53  *           DEFINITIONS                                                      *
00000000                            54  ******************************************************************************
00000000  =00007000                 55  STACK     EQU   $7000               * Beginning address for stack pointer
00000000                            56  
00000000  =00005000                 57  BEGINADDR EQU   $5000               * Variable to hold beginning address value
00000000  =00005010                 58  ENDADDR   EQU   $5010               * Variable to hold ending address value
00000000                            59  
00000000  =00006000                 60  RUNAGAIN  EQU   $6000               * Value equivalent to 'true'
00000000                            61  
00001000                            62  START     ORG   $1000               * Program begins at address 1000
00001000                            63  
00001000                            64  *********** END DEFINITIONS **************************************************
00001000                            65  
00001000                            66  
00001000                            67  ******************************************************************************
00001000                            68  *           BEGIN CODE                                                       *
00001000                            69  ******************************************************************************
00001000                            70  
00001000                            71  *---------- START ------------------------------------------------------------
00001000                            72  * Begins program's logical flow. Similar to main in C/C++
00001000                            73  *-----------------------------------------------------------------------------
00001000  4FF8 7000                 74      LEA         STACK,SP            * SP is stored in A7
00001004  4EB9 0000104E             75      JSR         GET_ADDRESSES       * Runs GET_ADDRESSES and IO_WELCOME
0000100A  2C78 5000                 76      MOVEA.L     BEGINADDR,A6        * Assign beginning address to A6 for use
0000100E                            77  
0000100E                            78  LOOP
0000100E                            79      * OC_PARSE Command doesn't work due to issues in the Opcode include
0000100E                            80      * many errors need to be fixed. Same with EA include
0000100E                            81  
0000100E  45F9 00002000             82      LEA         BUFFER, A2
00001014  4EB9 0000137C             83      JSR         OC_PARSE            * Determine if there is an initial opcode match
0000101A  4EB9 00004422             84      JSR         WRITE_ENDL
00001020  4EB9 00004430             85      JSR         PRINTLN
00001026  45F9 00002000             86      LEA         BUFFER, A2
0000102C  4EB9 0000443E             87      JSR         CLEAN_BUFF
00001032                            88  
00001032                            89      * decrement row count
00001032                            90      * if at 0, prompt for next page
00001032                            91      * else, continue
00001032                            92  
00001032                            93      *JSR         INVALID_DATA
00001032                            94      *ADDA.L      #$00000002,A6            * Advance address to test LOOP (test only)
00001032                            95  
00001032                            96  LOOP_CHECK
00001032                            97      * Changed the following code from:
00001032                            98      * CMPA        A6, ENDADDR
00001032                            99      * to:
00001032                           100      * CMPA      (ENDADDR),A6
00001032                           101      * When using the CMPA, destination must be an address so A6
00001032  BDF8 5010                102      CMPA.L      ENDADDR,A6          * Is pointer at end of address range?
00001036                           103  
00001036  6E00 0004                104      BGT         END_LOOP            * If yes, END_LOOP
0000103A                           105      ; in case this resets status register, do another compare TODO
0000103A                           106  
0000103A  66D2                     107      BNE         LOOP                * If not, continue processing addresses
0000103C                           108      ; If at end of address range, check if user wants to continue
0000103C                           109      ; if user wants to continue, restart
0000103C                           110      ; else, end
0000103C                           111  
0000103C                           112  END_LOOP
0000103C  4EB9 000043B2            113      JSR         KEEP_RUNNING        * Does the user want to run program again
00001042  0C38 0001 6000           114      CMPI.B      #1,(RUNAGAIN)       * Does RUNAGAIN = TRUE?
00001048  67B6                     115      BEQ         START               * If yes, rerun program
0000104A  4E72 3000                116      STOP        #$3000              * Else, end program
0000104E                           117  
0000104E                           118  *---------- END - START ------------------------------------------------------
0000104E                           119  
0000104E                           120  *********** END BEGIN CODE ***************************************************
0000104E                           121  
0000104E                           122  
0000104E                           123  ******************************************************************************
0000104E                           124  *           VARIABLES AND CONSTANTS                                          *
0000104E                           125  ******************************************************************************
0000104E                           126  
0000104E                           127  ******************************************************************************
0000104E                           128  *           INCLUDES                                                         *
0000104E                           129  ******************************************************************************
0000104E                           130  
0000104E                           131      INCLUDE 'IO.X68'
0000104E                           132  
0000104E                           133  
0000104E                           134  
0000104E  =00005020                135  STR_LEN   EQU   $5020
0000104E  =00005021                136  HEXFLAG   EQU   $5021
0000104E  =00005030                137  HEXVALUE  EQU   $5030
0000104E  =00005050                138  REMAINDER EQU   $5050
0000104E  =00000002                139  MOD       EQU   2
0000104E                           140  
0000104E  =0000000D                141  CR        EQU   $0D
0000104E  =0000000A                142  LF        EQU   $0A
0000104E                           143  
0000104E                           144  
0000104E                           145  GET_ADDRESSES
0000104E  4EB9 00001308            146      JSR         CLEARSCRN
00001054  4EB9 000010C6            147      JSR         IO_WELCOME          * Run welcome subroutine
0000105A                           148  
0000105A                           149  GET_FIRST_ADDRESS
0000105A  43F9 0000449A            150      LEA         PS1,A1              * Loads message into A1
00001060  4EB9 000012BE            151      JSR         MAKE_CHECKS         * Get address and perform checks
00001066  0C38 0001 5021           152      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000106C  66EC                     153      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000106E                           154  
0000106E  21F8 5030 5000           155      MOVE.L      HEXVALUE,BEGINADDR  * Copy hex value to begin
00001074  4EB9 000012FA            156      JSR         NEW_LINE            * Space
0000107A  4EB9 000010DA            157      JSR         CLEAR               * Clear values for next hex
00001080                           158  
00001080                           159  GET_SECOND_ADDRESS
00001080  43F9 000044E4            160      LEA         PS2,A1              * Loads message into A1
00001086  4EB9 000012BE            161      JSR         MAKE_CHECKS         * Get address and perform checks
0000108C  0C38 0001 5021           162      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001092  66EC                     163      BNE         GET_SECOND_ADDRESS  * If no, get hex again
00001094                           164  
00001094  21F8 5030 5010           165      MOVE.L      HEXVALUE,ENDADDR    * Copy hex value to begin
0000109A  4EB9 000012FA            166      JSR         NEW_LINE            * Space
000010A0  4EB9 000010DA            167      JSR         CLEAR               * Clear values for next hex
000010A6                           168  
000010A6                           169  CHECK_BADDR_IS_LESS_THAN_EADDR
000010A6  4EB9 0000126A            170      JSR         IS_LESSTHAN         *
000010AC  0C38 0001 5021           171      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000010B2  6700 0010                172      BEQ         FINISHED            * If yes, finished
000010B6  43F9 0000456A            173      LEA         ADR_ERR_NOTLT,A1    * Else, load error message
000010BC  6100 0256                174      BSR.W       ADDRESS_ERR
000010C0  6100 FF3E                175      BSR.W       START
000010C4                           176  
000010C4                           177  
000010C4                           178  FINISHED
000010C4  4E75                     179      RTS                             * Return to Disassembler
000010C6                           180  
000010C6                           181  
000010C6                           182  
000010C6                           183  
000010C6                           184  
000010C6                           185  IO_WELCOME:
000010C6  43F9 00004472            186      LEA         INTRO,A1            * Loads message into A1
000010CC  103C 000E                187      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010D0  4E4F                     188      TRAP        #15                 * Displays Intro Message
000010D2                           189  
000010D2  4EB9 000012FA            190      JSR         NEW_LINE            * Call Subroutine
000010D8  4E75                     191      RTS                             * Return from subroutine
000010DA                           192  
000010DA                           193  
000010DA                           194  
000010DA                           195  CLEAR
000010DA  4286                     196      CLR.L       D6                   * Clear
000010DC  31FC FFFF 5020           197      MOVE.W      #$FFFF,STR_LEN       * Clear
000010E2  21FC FFFFFFFF 5030       198      MOVE.L      #$FFFFFFFF,HEXVALUE  * Clear
000010EA  21FC FFFFFFFF 5050       199      MOVE.L      #$FFFFFFFF,REMAINDER * Clear
000010F2  4E75                     200      RTS                              * Return to main to get hex
000010F4                           201  
000010F4                           202  
000010F4                           203  
000010F4                           204  GET_HEXSTRING
000010F4  103C 000E                205      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010F8  323C 004A                206      MOVE.W      #(PS2-PS1),D1       * The prompt string length
000010FC  4E4F                     207      TRAP        #15                 * Displays contents of A1
000010FE                           208  
000010FE  43F9 000045C5            209      LEA         HEXSTRING,A1        * Pointer to store the sentence
00001104  103C 0002                210      MOVE.B      #2,D0               * Set up readstring function
00001108  4E4F                     211      TRAP        #15                 * Get string from keyboard
0000110A  11C1 5020                212      MOVE.B      D1,STR_LEN          * Save length of input string
0000110E                           213  
0000110E  0C38 0008 5020           214      CMPI.B      #8,(STR_LEN)        * Is length > 8?
00001114  6E00 0010                215      BGT         BAD_LENGTH          * If yes, get hex again
00001118                           216  
00001118  41F9 000045C5            217      LEA         HEXSTRING,A0        * Load address for verification
0000111E  11FC 0001 5021           218      MOVE.B      #1,(HEXFLAG)
00001124  4E75                     219      RTS                             * Return from subroutine
00001126                           220  
00001126                           221  BAD_LENGTH
00001126  11FC 0000 5021           222      MOVE.B      #0,(HEXFLAG)        * Bad length set HEXFLAG to false
0000112C  4E75                     223      RTS                             * Return to subroutine
0000112E                           224  
0000112E                           225  
0000112E                           226  
0000112E                           227  ASCII_TO_HEX
0000112E  1618                     228      MOVE.B      (A0)+,D3            * Move first char into D3
00001130  0C03 0030                229      CMPI.B      #'0',D3             * Is Char equal to 0?
00001134  6700 00D4                230      BEQ         HEXZERO
00001138  0C03 0031                231      CMPI.B      #'1',D3             * Is Char equal to 1?
0000113C  6700 00D4                232      BEQ         HEXONE
00001140  0C03 0032                233      CMPI.B      #'2',D3             * Is Char equal to 2?
00001144  6700 00D0                234      BEQ         HEXTWO
00001148  0C03 0033                235      CMPI.B      #'3',D3             * Is Char equal to 3?
0000114C  6700 00CC                236      BEQ         HEXTHREE
00001150  0C03 0034                237      CMPI.B      #'4',D3             * Is Char equal to 4?
00001154  6700 00C8                238      BEQ         HEXFOUR
00001158  0C03 0035                239      CMPI.B      #'5',D3             * Is Char equal to 5?
0000115C  6700 00C4                240      BEQ         HEXFIVE
00001160  0C03 0036                241      CMPI.B      #'6',D3             * Is Char equal to 6?
00001164  6700 00C0                242      BEQ         HEXSIX
00001168  0C03 0037                243      CMPI.B      #'7',D3             * Is Char equal to 7?
0000116C  6700 00BC                244      BEQ         HEXSEVEN
00001170  0C03 0038                245      CMPI.B      #'8',D3             * Is Char equal to 8?
00001174  6700 00B8                246      BEQ         HEXEIGHT
00001178  0C03 0039                247      CMPI.B      #'9',D3             * Is Char equal to 9?
0000117C  6700 00B4                248      BEQ         HEXNINE
00001180  0C03 0041                249      CMPI.B      #'A',D3             * Is Char equal to A?
00001184  6700 00B4                250      BEQ         HEXA
00001188  0C03 0042                251      CMPI.B      #'B',D3             * Is Char equal to B?
0000118C  6700 00B4                252      BEQ         HEXB
00001190  0C03 0043                253      CMPI.B      #'C',D3             * Is Char equal to C?
00001194  6700 00B4                254      BEQ         HEXC
00001198  0C03 0044                255      CMPI.B      #'D',D3             * Is Char equal to D?
0000119C  6700 00B4                256      BEQ         HEXD
000011A0  0C03 0045                257      CMPI.B      #'E',D3             * Is Char equal to E?
000011A4  6700 00B4                258      BEQ         HEXE
000011A8  0C03 0046                259      CMPI.B      #'F',D3             * Is Char equal to F?
000011AC  6700 00B4                260      BEQ         HEXF
000011B0  0C03 0061                261      CMPI.B      #'a',D3             * Is Char equal to a?
000011B4  6700 0084                262      BEQ         HEXA
000011B8  0C03 0062                263      CMPI.B      #'b',D3             * Is Char equal to b?
000011BC  6700 0084                264      BEQ         HEXB
000011C0  0C03 0063                265      CMPI.B      #'c',D3             * Is Char equal to c?
000011C4  6700 0084                266      BEQ         HEXC
000011C8  0C03 0064                267      CMPI.B      #'d',D3             * Is Char equal to d?
000011CC  6700 0084                268      BEQ         HEXD
000011D0  0C03 0065                269      CMPI.B      #'e',D3             * Is Char equal to e?
000011D4  6700 0084                270      BEQ         HEXE
000011D8  0C03 0066                271      CMPI.B      #'f',D3             * Is Char equal to f?
000011DC  6700 0084                272      BEQ         HEXF
000011E0                           273  
000011E0  11FC 0000 5021           274      MOVE.B      #0,HEXFLAG          * Set false
000011E6  6000 FEF2                275      BRA         CLEAR               * Clear some values
000011EA                           276  
000011EA                           277  FOUND
000011EA  5338 5020                278      SUBI.B      #1,STR_LEN          * Decrease string by one
000011EE  0C38 0000 5020           279      CMPI.B      #0,STR_LEN          * Is string = 0?
000011F4  6600 000E                280      BNE         SHIFTLEFT           * If no, shift value left
000011F8  21C6 5030                281      MOVE.L      D6,HEXVALUE         * If yes, save hex value
000011FC  11FC 0001 5021           282      MOVE.B      #1,HEXFLAG          * Set true
00001202  4E75                     283      RTS                             * Then, return to main
00001204                           284  
00001204                           285  SHIFTLEFT
00001204  E98E                     286      LSL.L       #4,D6               * Shift the value left
00001206  6000 FF26                287      BRA         ASCII_TO_HEX        * Check next char
0000120A                           288  
0000120A                           289  HEXZERO
0000120A  0686 00000000            290      ADD.L       #$0,D6              * Add value
00001210  60D8                     291      BRA         FOUND               * found, decrease strlen, shift value left
00001212                           292  HEXONE
00001212  5286                     293      ADD.L       #$1,D6              * Add value
00001214  60D4                     294      BRA         FOUND               * found, decrease strlen, shift value left
00001216                           295  HEXTWO
00001216  5486                     296      ADD.L       #$2,D6              * Add value
00001218  60D0                     297      BRA         FOUND               * found, decrease strlen, shift value left
0000121A                           298  HEXTHREE
0000121A  5686                     299      ADD.L       #$3,D6              * Add value
0000121C  60CC                     300      BRA         FOUND               * found, decrease strlen, shift value left
0000121E                           301  HEXFOUR
0000121E  5886                     302      ADD.L       #$4,D6              * Add value
00001220  60C8                     303      BRA         FOUND               * found, decrease strlen, shift value left
00001222                           304  HEXFIVE
00001222  5A86                     305      ADD.L       #$5,D6              * Add value
00001224  60C4                     306      BRA         FOUND               * found, decrease strlen, shift value left
00001226                           307  HEXSIX
00001226  5C86                     308      ADD.L       #$6,D6              * Add value
00001228  60C0                     309      BRA         FOUND               * found, decrease strlen, shift value left
0000122A                           310  HEXSEVEN
0000122A  5E86                     311      ADD.L       #$7,D6              * Add value
0000122C  60BC                     312      BRA         FOUND               * found, decrease strlen, shift value left
0000122E                           313  HEXEIGHT
0000122E  5086                     314      ADD.L       #$8,D6              * Add value
00001230  60B8                     315      BRA         FOUND               * found, decrease strlen, shift value left
00001232                           316  HEXNINE
00001232  0686 00000009            317      ADD.L       #$9,D6              * Add value
00001238  60B0                     318      BRA         FOUND               * found, decrease strlen, shift value left
0000123A                           319  HEXA
0000123A  0686 0000000A            320      ADD.L       #$A,D6              * Add value
00001240  60A8                     321      BRA         FOUND               * found, decrease strlen, shift value left
00001242                           322  HEXB
00001242  0686 0000000B            323      ADD.L       #$B,D6              * Add value
00001248  60A0                     324      BRA         FOUND               * found, decrease strlen, shift value left
0000124A                           325  HEXC
0000124A  0686 0000000C            326      ADD.L       #$C,D6              * Add value
00001250  6098                     327      BRA         FOUND               * found, decrease strlen, shift value left
00001252                           328  HEXD
00001252  0686 0000000D            329      ADD.L       #$D,D6              * Add value
00001258  6090                     330      BRA         FOUND               * found, decrease strlen, shift value left
0000125A                           331  HEXE
0000125A  0686 0000000E            332      ADD.L       #$E,D6              * Add value
00001260  6088                     333      BRA         FOUND               * found, decrease strlen, shift value left
00001262                           334  HEXF
00001262  0686 0000000F            335      ADD.L       #$F,D6              * Add value
00001268  6080                     336      BRA         FOUND               * found, decrease strlen, shift value left
0000126A                           337  
0000126A                           338  
0000126A                           339  
0000126A                           340  IS_LESSTHAN
0000126A  2838 5000                341      MOVE.L      BEGINADDR,D4        * Store beginning address in D4
0000126E  2C38 5010                342      MOVE.L      ENDADDR,D6          * Store ending address in D6
00001272  B886                     343      CMP.L       D6,D4               * Is D4 < D6
00001274  6D00 000C                344      BLT         LT                  * Yes, mark true return to main
00001278  11FC 0000 5021           345      MOVE.B      #0,HEXFLAG          * No, mark false
0000127E  6000 FE5A                346      BRA         CLEAR               * Clear values, return to main
00001282                           347  
00001282                           348  LT
00001282  11FC 0001 5021           349      MOVE.B      #1,HEXFLAG          * Mark true
00001288  4E75                     350      RTS                             * Return to main
0000128A                           351  
0000128A                           352  
0000128A                           353  
0000128A                           354  IS_HEX_EVEN
0000128A  3606                     355      MOVE.W      D6,D3               * Move value to be modded into D3
0000128C  3A3C 0002                356      MOVE.W      #MOD,D5             * Move mod value into D5
00001290  86C5                     357      DIVU        D5,D3               * Divide D3 by D5
00001292  123C 0003                358      MOVE.B      #3,D1               * Set counter to shift value into word
00001296                           359                                      * position
00001296                           360  REPEAT
00001296  E88B                     361      LSR.L       #4,D3               * Shift remainder to lower word
00001298  57C9 FFFC                362      DBEQ        D1,REPEAT           * UNTIL [D0] = - 1
0000129C  4241                     363      CLR         D1                  * Clear
0000129E                           364  
0000129E  B6BC 00000000            365      CMP.L       #0,D3               * Is hex even?
000012A4  6600 000E                366      BNE         NOTEVEN             * No, clear and go back to get_hex
000012A8  31C3 5050                367      MOVE.W      D3,REMAINDER        * Save remainder
000012AC  11FC 0001 5021           368      MOVE.B      #1,HEXFLAG          * Set true
000012B2  4E75                     369      RTS                             * Return to main
000012B4                           370  
000012B4                           371  NOTEVEN
000012B4  11FC 0000 5021           372      MOVE.B      #0,HEXFLAG          * Set false
000012BA  6000 FE1E                373      BRA         CLEAR               * Clear values
000012BE                           374  
000012BE                           375  
000012BE                           376  
000012BE                           377  MAKE_CHECKS
000012BE  4EB8 10F4                378      JSR         GET_HEXSTRING       * Get string from user
000012C2  0C38 0001 5021           379      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000012C8  6600 0020                380      BNE         BAD_CHECK           * If no, get hex again
000012CC                           381  
000012CC  4EB8 112E                382      JSR         ASCII_TO_HEX        * Convert ascii to hex
000012D0  0C38 0001 5021           383      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000012D6  6600 0012                384      BNE         BAD_CHECK           * If no, get hex again
000012DA                           385  
000012DA  4EB8 128A                386      JSR         IS_HEX_EVEN         * Check that hex value is even
000012DE  0C38 0001 5021           387      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000012E4  6600 0004                388      BNE         BAD_CHECK           * If no, get hex again
000012E8                           389  
000012E8  4E75                     390      RTS                             * Return from subroutine
000012EA                           391  
000012EA                           392  BAD_CHECK
000012EA  4E75                     393      RTS                             * Return from subroutine
000012EC                           394  
000012EC                           395  
000012EC                           396  
000012EC                           397  PRINT_HEXVALUE
000012EC  103C 000E                398      MOVE.B      #14,D0              * Moves the Task 14 into D0
000012F0  4E4F                     399      TRAP        #15                 * Displays contents of A1
000012F2                           400  
000012F2  103C 0003                401      MOVE.B      #3,D0               * Moves the Task 3 into D0
000012F6  4E4F                     402      TRAP        #15                 * Displays contents of D1
000012F8                           403  
000012F8  4E75                     404      RTS                             * Return from subroutine
000012FA                           405  
000012FA                           406  
000012FA                           407  NEW_LINE
000012FA  43F9 000048AF            408      LEA         ENDL,A1             * Loads message into A1
00001300  103C 000E                409      MOVE.B      #14,D0              * Moves the TRACK 14 into D0
00001304  4E4F                     410      TRAP        #15                 * Displays New line
00001306  4E75                     411      RTS                             * Return from subroutine
00001308                           412  
00001308                           413  
00001308                           414  CLEARSCRN
00001308  103C 000B                415      MOVE.B      #11,D0              * Task 11 for clearing screen
0000130C  323C FF00                416      MOVE.W      #$FF00,D1           * FF00, Clear screen
00001310  4E4F                     417      TRAP        #15                 * Wait for keystroke
00001312  4E75                     418      RTS                             * Return from subroutine
00001314                           419  
00001314                           420  
00001314                           421  
00001314                           422  
00001314                           423  ADDRESS_ERR
00001314  6100 FFF2                424      BSR.W       CLEARSCRN           * Clear output before displaying error
00001318  103C 000D                425      MOVE.B      #13,D0              * Moves the Task 13 into D0
0000131C  4E4F                     426      TRAP        #15                 * Displays contents of A1
0000131E  103C 0005                427      MOVE.B      #5,D0               * Read single character from
00001322  4E4F                     428      TRAP        #15                 * The keyboard into D1.B
00001324  4E75                     429      RTS                             * Return from subroutine
00001326                           430  
00001326                           431  
00001326                           432  
00001326                           433  INVALID_DATA
00001326  220E                     434      MOVE.L      A6,D1               * Move the address location to D1
00001328  143C 0010                435      MOVE.B      #16,D2              * Move base 16 to D2
0000132C  103C 000F                436      MOVE.B      #15,D0              * Moves Task 15 into D0
00001330  4E4F                     437      TRAP        #15                 * Displays contents of D1
00001332                           438  
00001332  43F9 000048F3            439      LEA         TAB,A1              * Load TAB to A1
00001338  103C 000E                440      MOVE.B      #14,D0              * Moves the Task 14 into D0
0000133C  4E4F                     441      TRAP        #15                 * Displays a tab of A1
0000133E                           442  
0000133E  43F9 00004615            443      LEA         DATA,A1             * Load address location to A1
00001344  103C 000E                444      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001348  4E4F                     445      TRAP        #15                 * Displays location of A1
0000134A                           446  
0000134A  43F9 000048F3            447      LEA         TAB,A1              * Load TAB to A1
00001350  103C 000E                448      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001354  4E4F                     449      TRAP        #15                 * Displays a tab of A1
00001356                           450  
00001356  43F9 000048E4            451      LEA         DOLLAR,A1           * Load TAB to A1
0000135C  103C 000E                452      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001360  4E4F                     453      TRAP        #15                 * Displays a tab of A1
00001362                           454  
00001362  3216                     455      MOVE.W      (A6),D1             * Move the address value to D1
00001364  143C 0010                456      MOVE.B      #16,D2              * Move base 16 to D2
00001368  103C 000F                457      MOVE.B      #15,D0              * Moves Task 15 into D0
0000136C  4E4F                     458      TRAP        #15                 * Displays value of D1
0000136E                           459  
0000136E  43F9 000048AF            460      LEA         ENDL,A1             * Load TAB to A1
00001374  103C 000E                461      MOVE.B      #14,D0              * Moves the Task 14 into D0
00001378  4E4F                     462      TRAP        #15                 * Displays a tab of A1
0000137A                           463  
0000137A  4E75                     464      RTS                             * Return from subroutine
0000137C                           465  
0000137C                           466  
0000137C                           467  
0000137C                           468  
0000137C                           469  
0000137C                           470  
0000137C                           471  
0000137C                           472  
0000137C                           473  
0000137C                           474  
0000137C                           475  
0000137C                           476  -------------------- end include --------------------
0000137C                           477      INCLUDE 'OpCodes.X68'
0000137C                           478  
0000137C                           479  
0000137C                           480  OC_PARSE:
0000137C  48E7 FFFE                481          MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001380  41F9 00001398            482          LEA         initial_table,A0 ; Index into the table
00001386  4280                     483          CLR.L       D0              ; Zero it
00001388  3016                     484          MOVE.W      (A6),D0         ; We'll play with it here
0000138A  123C 000C                485          MOVE.B      #12,D1          ; Shift 12 bits to the right
0000138E  E268                     486          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001390                           487                                      ; and the rest are zeroed out)
00001390  C0FC 0006                488          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001394  4EF0 0000                489          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001398                           490  
00001398                           491  initial_table:
00001398  4EF9 000013F8            492          JMP         code0000        ; ADDI.B, ADDI.W, or ADDI.L
0000139E  4EF9 000013FE            493          JMP         code0001        ; MOVE.B
000013A4  4EF9 0000140A            494          JMP         code0010        ; MOVEA.L or MOVE.L
000013AA  4EF9 00001410            495          JMP         code0011        ; MOVEA.W or MOVE.W
000013B0  4EF9 00001416            496          JMP         code0100        ; NOP or MOVEM.W or MOVEM.L or LEA or CLR.B or CLR.W or CLR.L or JSR or RTS or MULS.W
000013B6  4EF9 00001422            497          JMP         code0101        ; ADDQ.B or ADDQ.W or ADDQ.L
000013BC  4EF9 0000142E            498          JMP         code0110        ; BCC or BGT or BLE
000013C2  4EF9 0000143A            499          JMP         code0111        ; MOVEQ.L
000013C8  4EF9 00001446            500          JMP         code1000        ; OR.B or OR.W or OR.L or DIVU (DIVU is either word or long depending on ea)
000013CE  4EF9 00001452            501          JMP         code1001        ; SUB.B or SUB.W or SUB.L
000013D4  4EF9 0000145E            502          JMP         code1010
000013DA  4EF9 00001466            503          JMP         code1011        ; CMP.B or CMP.W or CMP.L
000013E0  4EF9 00001472            504          JMP         code1100        ; AND_BorAND_WorAND_LorMULS_W
000013E6  4EF9 0000147E            505          JMP         code1101        ; ADD.B or ADD.W or ADD.L
000013EC  4EF9 0000148A            506          JMP         code1110        ; ROd_LSd_ASd
000013F2  4EF9 00001496            507          JMP         code1111
000013F8                           508  
000013F8  4EB9 00001D82            509  code0000 JSR        ADDI_BorADDI_WorADDI_L
000013FE  4EB9 00002800            510  code0001 JSR        ISMOVEB
00001404  4EF9 0000149E            511           JMP        DONE
0000140A  4EB9 00001DD8            512  code0010 JSR        MOVEA_LorMOVE_L
00001410  4EB9 00001E66            513  code0011 JSR        MOVEA_WorMOVE_W
00001416  4EB9 00001C84            514  code0100 JSR        NOP_MOVEM_LEA_JSR_CLR_RTS
0000141C  4EF9 0000149E            515           JMP        DONE
00001422  4EB9 00001A7E            516  code0101 JSR        ADDQ_BorADDQ_WorADDQ_L
00001428  4EF9 0000149E            517           JMP        DONE
0000142E  4EB9 000014A4            518  code0110 JSR        BCCorBGTorBLE
00001434  4EF9 0000149E            519           JMP        DONE
0000143A  4EB9 000025B0            520  code0111 JSR        ISMOVEQL
00001440  4EF9 0000149E            521           JMP        DONE
00001446  4EB9 000014FA            522  code1000 JSR        OR_BorOR_WorOR_LorDIVU
0000144C  4EF9 0000149E            523           JMP        DONE
00001452  4EB9 0000199A            524  code1001 JSR        SUB_BorSUB_WorSUB_L
00001458  4EF9 0000149E            525           JMP        DONE
0000145E  4EB9 00001EF4            526  code1010 JSR    OPCODE_INVALID              ;INVALID
00001464  4E75                     527           RTS
00001466  4EB9 00001A28            528  code1011 JSR        CMP_BorCMP_WorCMP_L
0000146C  4EF9 0000149E            529           JMP        DONE
00001472  4EB9 0000187E            530  code1100 JSR        AND_BorAND_WorAND_LorMULS_W
00001478  4EF9 0000149E            531           JMP        DONE
0000147E  4EB9 0000190C            532  code1101 JSR        ADD_BorADD_WorADD_L
00001484  4EF9 0000149E            533           JMP        DONE
0000148A  4EB9 0000182E            534  code1110 JSR        ROd_LSd_ASd
00001490  4EF9 0000149E            535           JMP        DONE
00001496  4EB9 00001EF4            536  code1111 JSR    OPCODE_INVALID              ;INVALID
0000149C  4E75                     537           RTS
0000149E  4CDF 7FFF                538  DONE    MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000014A2  4E75                     539          RTS
000014A4                           540  
000014A4  41F9 000014C2            541  BCCorBGTorBLE       LEA     tableBCCorBGTorBLE, A0            ; Index into the table
000014AA  4280                     542                      CLR.L   D0                  ; Zero it
000014AC  3016                     543                      MOVE.W  (A6),D0         ; We'll play with it here
000014AE  123C 0006                544                      MOVE.B  #6,D1           ; Shift 6 bits left
000014B2  E360                     545                      ASL.W   D1,D0
000014B4  123C 000E                546                      MOVE.B  #14,D1           ; Shift 14 bits to the right
000014B8  E268                     547                      LSR.W   D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
000014BA                           548                                      ; and the rest are zeroed out)
000014BA  C0FC 0006                549                      MULU    #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
000014BE  4EF0 0000                550                      JMP     0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
000014C2                           551  
000014C2  4EF9 000014DA            552  tableBCCorBGTorBLE   JMP    BCCorBGTorBLEcode00   ; BCC
000014C8  4EF9 000014E2            553                       JMP    BCCorBGTorBLEcode01   ;
000014CE  4EF9 000014EA            554                       JMP    BCCorBGTorBLEcode10   ; BGT
000014D4  4EF9 000014F2            555                       JMP    BCCorBGTorBLEcode11   ; BLE
000014DA                           556  
000014DA                           557  
000014DA                           558  
000014DA  4EB9 00001F04            559  BCCorBGTorBLEcode00    JSR     ISBCC
000014E0  4E75                     560                         RTS
000014E2  4EB9 00001EF4            561  BCCorBGTorBLEcode01    JSR    OPCODE_INVALID              ;INVALID
000014E8  4E75                     562                         RTS
000014EA  4EB9 00001F2C            563  BCCorBGTorBLEcode10    JSR     ISBGT
000014F0  4E75                     564                         RTS
000014F2  4EB9 00001F54            565  BCCorBGTorBLEcode11    JSR     ISBLE
000014F8  4E75                     566                         RTS
000014FA                           567  
000014FA                           568  
000014FA                           569  OR_BorOR_WorOR_LorDIVU:
000014FA  41F9 00001518            570          LEA         tableOR_BorOR_WorOR_LorDIVU, A0 ; Index into the table
00001500  4280                     571          CLR.L       D0              ; Zero it
00001502  3016                     572          MOVE.W      (A6),D0     ; We'll play with it here
00001504  123C 0007                573          MOVE.B      #7,D1           ; Shift 7 bits left
00001508  E360                     574          ASL.W       D1,D0
0000150A  123C 000D                575          MOVE.B      #13,D1          ; Shift 13 bits to the right
0000150E  E268                     576          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001510                           577                                      ; and the rest are zeroed out)
00001510  C0FC 0006                578          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001514  4EF0 0000                579          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001518                           580  
00001518                           581  tableOR_BorOR_WorOR_LorDIVU
00001518  4EF9 00001548            582          JMP         OR_DIVUcode000  ; OR.B
0000151E  4EF9 00001550            583          JMP         OR_DIVUcode001  ; OR.W
00001524  4EF9 00001558            584          JMP         OR_DIVUcode010  ; OR.L
0000152A  4EF9 00001560            585          JMP         OR_DIVUcode011  ; DIVU.W
00001530  4EF9 00001568            586          JMP         OR_DIVUcode100  ; OR.B
00001536  4EF9 00001570            587          JMP         OR_DIVUcode101  ; OR.W
0000153C  4EF9 00001578            588          JMP         OR_DIVUcode110  ; OR.L
00001542  4EF9 00001580            589          JMP         OR_DIVUcode111  ; INVALID
00001548                           590  
00001548                           591  
00001548  4EB9 00001FA4            592  OR_DIVUcode000 JSR  ISORB
0000154E  4E75                     593                 RTS
00001550  4EB9 00001FCC            594  OR_DIVUcode001 JSR  ISORW
00001556  4E75                     595                 RTS
00001558  4EB9 00001FF4            596  OR_DIVUcode010 JSR  ISORL
0000155E  4E75                     597                 RTS
00001560  4EB9 00001F7C            598  OR_DIVUcode011 JSR  ISDIVUW
00001566  4E75                     599                 RTS
00001568  4EB9 00001FA4            600  OR_DIVUcode100 JSR  ISORB
0000156E  4E75                     601                 RTS
00001570  4EB9 00001FCC            602  OR_DIVUcode101 JSR  ISORW
00001576  4E75                     603                 RTS
00001578  4EB9 00001FF4            604  OR_DIVUcode110 JSR  ISORL
0000157E  4E75                     605                 RTS
00001580  4EB9 00001EF4            606  OR_DIVUcode111 JSR    OPCODE_INVALID              ;INVALID
00001586  4E75                     607                 RTS
00001588                           608  
00001588                           609  
00001588                           610  someASR:
00001588  41F9 000015A6            611          LEA         tableSomeASR, A0 ; Index into the table
0000158E  4280                     612          CLR.L       D0              ; Zero it
00001590  3016                     613          MOVE.W      (A6),D0         ; We'll play with it here
00001592  123C 0008                614          MOVE.B      #8,D1           ; Shift 8 bits left
00001596  E360                     615          ASL.W       D1,D0
00001598  123C 000E                616          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000159C  E268                     617          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000159E                           618                                      ; and the rest are zeroed out)
0000159E  C0FC 0006                619          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000015A2  4EF0 0000                620          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000015A6                           621  
000015A6                           622  tableSomeASR:
000015A6  4EF9 000015BE            623          JMP         ASRcode00       *ASR.B
000015AC  4EF9 000015C6            624          JMP         ASRcode01       *ASR.W
000015B2  4EF9 000015CE            625          JMP         ASRcode10       *ASR.L
000015B8  4EF9 000015D6            626          JMP         ASRcode11       *ASR.W
000015BE                           627  
000015BE  4EB9 0000201C            628  ASRcode00 JSR       ISASRB
000015C4  4E75                     629            RTS
000015C6  4EB9 00002044            630  ASRcode01 JSR       ISASRW
000015CC  4E75                     631            RTS
000015CE  4EB9 0000206C            632  ASRcode10 JSR       ISASRL
000015D4  4E75                     633            RTS
000015D6  4EB9 00002044            634  ASRcode11 JSR       ISASRW
000015DC  4E75                     635            RTS
000015DE                           636  
000015DE                           637  someASL:
000015DE  41F9 000015FC            638          LEA         tableSomeASL, A0 ; Index into the table
000015E4  4280                     639          CLR.L       D0              ; Zero it
000015E6  3016                     640          MOVE.W      (A6),D0     ; We'll play with it here
000015E8  123C 0008                641          MOVE.B      #8,D1           ; Shift 8 bits left
000015EC  E360                     642          ASL.W       D1,D0
000015EE  123C 000E                643          MOVE.B      #14,D1          ; Shift 14 bits to the right
000015F2  E268                     644          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000015F4                           645                                      ; and the rest are zeroed out)
000015F4  C0FC 0006                646          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000015F8  4EF0 0000                647          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000015FC                           648  
000015FC                           649  tableSomeASL:
000015FC  4EF9 00001614            650          JMP         ASLcode00       *ASL.B
00001602  4EF9 0000161C            651          JMP         ASLcode01       *ASL.W
00001608  4EF9 00001624            652          JMP         ASLcode10       *ASL.L
0000160E  4EF9 0000162C            653          JMP         ASLcode11       *ASL.W
00001614                           654  
00001614  4EB9 00002094            655  ASLcode00 JSR       ISASLB
0000161A  4E75                     656            RTS
0000161C  4EB9 000020BC            657  ASLcode01 JSR       ISASLW
00001622  4E75                     658            RTS
00001624  4EB9 000020E4            659  ASLcode10 JSR       ISASLL
0000162A  4E75                     660            RTS
0000162C  4EB9 000020BC            661  ASLcode11 JSR       ISASLW
00001632  4E75                     662            RTS
00001634                           663  
00001634                           664  someLSR:
00001634  41F9 00001652            665          LEA         tableSomeLSR, A0 ; Index into the table
0000163A  4280                     666          CLR.L       D0              ; Zero it
0000163C  3016                     667          MOVE.W      (A6),D0     ; We'll play with it here
0000163E  123C 0008                668          MOVE.B      #8,D1           ; Shift 8 bits left
00001642  E360                     669          ASL.W       D1,D0
00001644  123C 000E                670          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001648  E268                     671          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000164A                           672                                      ; and the rest are zeroed out)
0000164A  C0FC 0006                673          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000164E  4EF0 0000                674          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001652                           675  
00001652                           676  tableSomeLSR:
00001652  4EF9 0000166A            677          JMP         LSRcode00       *LSR.B
00001658  4EF9 00001672            678          JMP         LSRcode01       *LSR.W
0000165E  4EF9 0000167A            679          JMP         LSRcode10       *LSR.L
00001664  4EF9 00001682            680          JMP         LSRcode11       *LSR.W
0000166A  4EB9 0000210C            681  LSRcode00 JSR       ISLSRB
00001670  4E75                     682            RTS
00001672  4EB9 00002134            683  LSRcode01 JSR       ISLSRW
00001678  4E75                     684            RTS
0000167A  4EB9 0000215C            685  LSRcode10 JSR       ISLSRL
00001680  4E75                     686            RTS
00001682  4EB9 00002134            687  LSRcode11 JSR       ISLSRW
00001688  4E75                     688            RTS
0000168A                           689  
0000168A                           690  someLSL:
0000168A  41F9 000016A8            691          LEA         tableSomeLSL, A0 ; Index into the table
00001690  4280                     692          CLR.L       D0              ; Zero it
00001692  3016                     693          MOVE.W      (A6),D0     ; We'll play with it here
00001694  123C 0008                694          MOVE.B      #8,D1           ; Shift 8 bits left
00001698  E360                     695          ASL.W       D1,D0
0000169A  123C 000E                696          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000169E  E268                     697          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000016A0                           698                                      ; and the rest are zeroed out)
000016A0  C0FC 0006                699          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000016A4  4EF0 0000                700          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000016A8                           701  
000016A8                           702  tableSomeLSL:
000016A8  4EF9 000016C0            703          JMP         LSLcode00       *LSL.B
000016AE  4EF9 000016C8            704          JMP         LSLcode01       *LSL.W
000016B4  4EF9 000016D0            705          JMP         LSLcode10       *LSL.L
000016BA  4EF9 000016D8            706          JMP         LSLcode11       *LSL.W
000016C0                           707  
000016C0  4EB9 00002184            708  LSLcode00 JSR       ISLSLB
000016C6  4E75                     709            RTS
000016C8  4EB9 000021AC            710  LSLcode01 JSR       ISLSLW
000016CE  4E75                     711            RTS
000016D0  4EB9 000021D4            712  LSLcode10 JSR       ISLSLL
000016D6  4E75                     713            RTS
000016D8  4EB9 000021AC            714  LSLcode11 JSR       ISLSLW
000016DE  4E75                     715            RTS
000016E0                           716  
000016E0                           717  someROL:
000016E0  41F9 000016FE            718          LEA         tableSomeROL, A0 ; Index into the table
000016E6  4280                     719          CLR.L       D0              ; Zero it
000016E8  3016                     720          MOVE.W      (A6),D0     ; We'll play with it here
000016EA  123C 0008                721          MOVE.B      #8,D1           ; Shift 8 bits left
000016EE  E360                     722          ASL.W       D1,D0
000016F0  123C 000E                723          MOVE.B      #14,D1          ; Shift 14 bits to the right
000016F4  E268                     724          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000016F6                           725                                      ; and the rest are zeroed out)
000016F6  C0FC 0006                726          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000016FA  4EF0 0000                727          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000016FE                           728  
000016FE                           729  tableSomeROL:
000016FE  4EF9 00001716            730          JMP         ROLcode00       *ROL.B
00001704  4EF9 0000171E            731          JMP         ROLcode01       *ROL.W
0000170A  4EF9 00001726            732          JMP         ROLcode10       *ROL.L
00001710  4EF9 0000172E            733          JMP         ROLcode11       *ROL.W
00001716                           734  
00001716  4EB9 00002274            735  ROLcode00 JSR       ISROLB
0000171C  4E75                     736            RTS
0000171E  4EB9 0000229C            737  ROLcode01 JSR       ISROLW
00001724  4E75                     738            RTS
00001726  4EB9 000022C4            739  ROLcode10 JSR       ISROLL
0000172C  4E75                     740            RTS
0000172E  4EB9 0000229C            741  ROLcode11 JSR       ISROLW
00001734  4E75                     742            RTS
00001736                           743  
00001736                           744  
00001736                           745  someROR:
00001736  41F9 00001754            746          LEA         tableSomeROR, A0 ; Index into the table
0000173C  4280                     747          CLR.L       D0              ; Zero it
0000173E  3016                     748          MOVE.W      (A6),D0     ; We'll play with it here
00001740  123C 0008                749          MOVE.B      #8,D1           ; Shift 8 bits left
00001744  E360                     750          ASL.W       D1,D0
00001746  123C 000E                751          MOVE.B      #14,D1          ; Shift 14 bits to the right
0000174A  E268                     752          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000174C                           753                                      ; and the rest are zeroed out)
0000174C  C0FC 0006                754          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001750  4EF0 0000                755          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001754                           756  
00001754                           757  tableSomeROR:
00001754  4EF9 0000176C            758          JMP         RORcode00       *ROR.B
0000175A  4EF9 00001774            759          JMP         RORcode01       *ROR.W
00001760  4EF9 0000177C            760          JMP         RORcode10       *ROR.L
00001766  4EF9 00001784            761          JMP         RORcode11       *ROR.W
0000176C                           762  
0000176C  4EB9 000021FC            763  RORcode00 JSR       ISRORB
00001772  4E75                     764            RTS
00001774  4EB9 00002224            765  RORcode01 JSR       ISRORW
0000177A  4E75                     766            RTS
0000177C  4EB9 0000224C            767  RORcode10 JSR       ISRORL
00001782  4E75                     768            RTS
00001784  4EB9 00002224            769  RORcode11 JSR       ISRORW
0000178A  4E75                     770            RTS
0000178C                           771  
0000178C                           772  ROL_ROR:
0000178C  41F9 000017AA            773          LEA         tableROL_ROR, A0 ; Index into the table
00001792  4280                     774          CLR.L       D0              ; Zero it
00001794  3016                     775          MOVE.W      (A6),D0     ; We'll play with it here
00001796  123C 0007                776          MOVE.B      #7,D1           ; Shift 7 bits left
0000179A  E360                     777          ASL.W       D1,D0
0000179C  123C 000F                778          MOVE.B      #15,D1          ; Shift 15 bits to the right
000017A0  E268                     779          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000017A2                           780                                      ; and the rest are zeroed out)
000017A2  C0FC 0006                781          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000017A6  4EF0 0000                782          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000017AA                           783  
000017AA                           784  tableROL_ROR:
000017AA  4EF9 000017B6            785          JMP         ROL_RORcode0    ; ROR
000017B0  4EF9 000017BC            786          JMP         ROL_RORcode1    ; ROL
000017B6                           787  
000017B6  4EB8 1736                788  ROL_RORcode0 JSR    someROR
000017BA  4E75                     789               RTS
000017BC  4EB8 16E0                790  ROL_RORcode1 JSR    someROL
000017C0  4E75                     791               RTS
000017C2                           792  
000017C2                           793  LSL_LSR:
000017C2  41F9 000017E0            794          LEA         tableLSL_LSR, A0 ; Index into the table
000017C8  4280                     795          CLR.L       D0              ; Zero it
000017CA  3016                     796          MOVE.W      (A6),D0     ; We'll play with it here
000017CC  123C 0007                797          MOVE.B      #7,D1           ; Shift 7 bits left
000017D0  E360                     798          ASL.W       D1,D0
000017D2  123C 000F                799          MOVE.B      #15,D1          ; Shift 15 bits to the right
000017D6  E268                     800          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000017D8                           801                                      ; and the rest are zeroed out)
000017D8  C0FC 0006                802          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000017DC  4EF0 0000                803          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000017E0                           804  
000017E0                           805  tableLSL_LSR:
000017E0  4EF9 000017EC            806          JMP         LSL_LSRcode0    ; LSR
000017E6  4EF9 000017F2            807          JMP         LSL_LSRcode1    ; LSL
000017EC                           808  
000017EC  4EB8 1634                809  LSL_LSRcode0 JSR    someLSR
000017F0  4E75                     810               RTS
000017F2  4EB8 168A                811  LSL_LSRcode1 JSR    someLSL
000017F6  4E75                     812               RTS
000017F8                           813  
000017F8                           814  ASL_ASR:
000017F8  41F9 00001816            815          LEA         tableASL_ASR, A0 ; Index into the table
000017FE  4280                     816          CLR.L       D0              ; Zero it
00001800  3016                     817          MOVE.W      (A6),D0     ; We'll play with it here
00001802  123C 0007                818          MOVE.B      #7,D1           ; Shift 7 bits left
00001806  E360                     819          ASL.W       D1,D0
00001808  123C 000F                820          MOVE.B      #15,D1          ; Shift 15 bits to the right
0000180C  E268                     821          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
0000180E                           822                                      ; and the rest are zeroed out)
0000180E  C0FC 0006                823          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001812  4EF0 0000                824          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001816                           825  
00001816                           826  tableASL_ASR:
00001816  4EF9 00001822            827          JMP         ASL_ASRcode0    ; ASR
0000181C  4EF9 00001828            828          JMP         ASL_ASRcode1    ; ASL
00001822                           829  
00001822  4EB8 1588                830  ASL_ASRcode0 JSR    someASR
00001826  4E75                     831               RTS
00001828  4EB8 15DE                832  ASL_ASRcode1 JSR    someASL
0000182C  4E75                     833               RTS
0000182E                           834  
0000182E                           835  ROd_LSd_ASd:
0000182E  41F9 0000184C            836          LEA         tableROd_LSd_ASd, A0 ; Index into the table
00001834  4280                     837          CLR.L       D0              ; Zero it
00001836  3016                     838          MOVE.W      (A6),D0     ; We'll play with it here
00001838  123C 000B                839          MOVE.B      #11,D1          ; Shift 11 bits left
0000183C  E360                     840          ASL.W       D1,D0
0000183E  123C 000F                841          MOVE.B      #15,D1          ; Shift 12 bits to the right
00001842  E268                     842          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001844                           843                                      ; and the rest are zeroed out)
00001844  C0FC 0006                844          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001848  4EF0 0000                845          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000184C                           846  
0000184C                           847  tableROd_LSd_ASd:
0000184C  4EF9 00001864            848          JMP         ROd_LSd_ASdcode00 ; ASL_ASR
00001852  4EF9 0000186A            849          JMP         ROd_LSd_ASdcode01 ; LSL_LSR
00001858  4EF9 00001870            850          JMP         ROd_LSd_ASdcode10
0000185E  4EF9 00001878            851          JMP         ROd_LSd_ASdcode11 ; ROL_ROR
00001864                           852  
00001864  4EB8 17F8                853  ROd_LSd_ASdcode00 JSR ASL_ASR
00001868  4E75                     854                    RTS
0000186A  4EB8 17C2                855  ROd_LSd_ASdcode01 JSR LSL_LSR
0000186E  4E75                     856                    RTS
00001870  4EB9 00001EF4            857  ROd_LSd_ASdcode10 JSR    OPCODE_INVALID              ;INVALID
00001876  4E75                     858                    RTS
00001878  4EB8 178C                859  ROd_LSd_ASdcode11 JSR ROL_ROR
0000187C  4E75                     860                    RTS
0000187E                           861  
0000187E                           862  AND_BorAND_WorAND_LorMULS_W:
0000187E  41F9 0000189C            863          LEA         tableAND_BorAND_WorAND_LorMULS_W, A0            ; Index into the table
00001884  4280                     864          CLR.L       D0                  ; Zero it
00001886  3016                     865          MOVE.W      (A6),D0         ; We'll play with it here
00001888  123C 0007                866          MOVE.B      #7,D1           ; Shift 7 bits left
0000188C  E360                     867          ASL.W       D1,D0
0000188E  123C 000D                868          MOVE.B      #13,D1              ; Shift 13 bits to the right
00001892  E268                     869          LSR.W       D1,D0               ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001894                           870                                  ; and the rest are zeroed out)
00001894  C0FC 0006                871          MULU        #6,D0               ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001898  4EF0 0000                872          JMP         0(A0,D0)            ; Jump indirect with index, i.e. jump to 'table' + displacement
0000189C                           873  
0000189C                           874  tableAND_BorAND_WorAND_LorMULS_W:
0000189C  4EF9 000018CC            875          JMP         ANDcode000   ; AND.B
000018A2  4EF9 000018D4            876          JMP         ANDcode001   ; AND.W
000018A8  4EF9 000018DC            877          JMP         ANDcode010   ; AND.L
000018AE  4EF9 000018E4            878          JMP         ANDcode011
000018B4  4EF9 000018EC            879          JMP         ANDcode100   ; AND.B
000018BA  4EF9 000018F4            880          JMP         ANDcode101   ; AND.W
000018C0  4EF9 000018FC            881          JMP         ANDcode110   ; AND.L
000018C6  4EF9 00001904            882          JMP         ANDcode111   ; MULS.W
000018CC                           883  
000018CC  4EB9 00002314            884  ANDcode000 JSR      ISANDB
000018D2  4E75                     885             RTS
000018D4  4EB9 0000233C            886  ANDcode001 JSR      ISANDW
000018DA  4E75                     887             RTS
000018DC  4EB9 00002364            888  ANDcode010 JSR      ISANDL
000018E2  4E75                     889             RTS
000018E4  4EB9 00001EF4            890  ANDcode011 JSR    OPCODE_INVALID              ;INVALID
000018EA  4E75                     891             RTS
000018EC  4EB9 00002314            892  ANDcode100 JSR      ISANDB
000018F2  4E75                     893             RTS
000018F4  4EB9 0000233C            894  ANDcode101 JSR      ISANDW
000018FA  4E75                     895             RTS
000018FC  4EB9 00002364            896  ANDcode110 JSR      ISANDL
00001902  4E75                     897             RTS
00001904  4EB9 000022EC            898  ANDcode111 JSR      ISMULSW
0000190A  4E75                     899             RTS
0000190C                           900  
0000190C                           901  ADD_BorADD_WorADD_L:
0000190C  41F9 0000192A            902          LEA         tableADD_BorADD_WorADD_L, A0 ; Index into the table
00001912  4280                     903          CLR.L       D0              ; Zero it
00001914  3016                     904          MOVE.W      (A6),D0     ; We'll play with it here
00001916  123C 0007                905          MOVE.B      #7,D1           ; Shift 7 bits left
0000191A  E360                     906          ASL.W       D1,D0
0000191C  123C 000D                907          MOVE.B      #13,D1          ; Shift 13 bits to the right
00001920  E268                     908          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001922                           909                                      ; and the rest are zeroed out)
00001922  C0FC 0006                910          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001926  4EF0 0000                911          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
0000192A                           912  
0000192A                           913  tableADD_BorADD_WorADD_L:
0000192A  4EF9 0000195A            914          JMP         ADDcode000      *ADD.B
00001930  4EF9 00001962            915          JMP         ADDcode001      *ADD.W
00001936  4EF9 0000196A            916          JMP         ADDcode010      *ADD.L
0000193C  4EF9 00001972            917          JMP         ADDcode011      *ADDA.W
00001942  4EF9 0000197A            918          JMP         ADDcode100      *ADD.B
00001948  4EF9 00001982            919          JMP         ADDcode101      *ADD.W
0000194E  4EF9 0000198A            920          JMP         ADDcode110      *ADD.L
00001954  4EF9 00001992            921          JMP         ADDcode111      *ADDA.L
0000195A                           922  
0000195A  4EB9 000023DC            923  ADDcode000 JSR      ISADDB
00001960  4E75                     924             RTS
00001962  4EB9 00002404            925  ADDcode001 JSR      ISADDW
00001968  4E75                     926             RTS
0000196A  4EB9 0000242C            927  ADDcode010 JSR      ISADDL
00001970  4E75                     928             RTS
00001972  4EB9 0000238C            929  ADDcode011 JSR      ISADDAW
00001978  4E75                     930             RTS
0000197A  4EB9 000023DC            931  ADDcode100 JSR      ISADDB
00001980  4E75                     932             RTS
00001982  4EB9 00002404            933  ADDcode101 JSR      ISADDW
00001988  4E75                     934             RTS
0000198A  4EB9 0000242C            935  ADDcode110 JSR      ISADDL
00001990  4E75                     936             RTS
00001992  4EB9 000023B4            937  ADDcode111 JSR      ISADDAL
00001998  4E75                     938             RTS
0000199A                           939  
0000199A                           940  SUB_BorSUB_WorSUB_L:
0000199A  41F9 000019B8            941          LEA         tableSUB_BorSUB_WorSUB_L, A0 ; Index into the table
000019A0  4280                     942          CLR.L       D0              ; Zero it
000019A2  3016                     943          MOVE.W      (A6),D0     ; We'll play with it here
000019A4  123C 0007                944          MOVE.B      #7,D1           ; Shift 7 bits left
000019A8  E360                     945          ASL.W       D1,D0
000019AA  123C 000D                946          MOVE.B      #13,D1          ; Shift 13 bits to the right
000019AE  E268                     947          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
000019B0                           948                                      ; and the rest are zeroed out)
000019B0  C0FC 0006                949          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
000019B4  4EF0 0000                950          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
000019B8                           951  
000019B8                           952  tableSUB_BorSUB_WorSUB_L:
000019B8  4EF9 000019E8            953          JMP         SUBcode000      *SUB.B
000019BE  4EF9 000019F0            954          JMP         SUBcode001      *SUB.W
000019C4  4EF9 000019F8            955          JMP         SUBcode010      *SUB.L
000019CA  4EF9 00001A00            956          JMP         SUBcode011
000019D0  4EF9 00001A08            957          JMP         SUBcode100      *SUB.B
000019D6  4EF9 00001A10            958          JMP         SUBcode101      *SUB.W
000019DC  4EF9 00001A18            959          JMP         SUBcode110      *SUB.L
000019E2  4EF9 00001A20            960          JMP         SUBcode111      ; INVALID
000019E8                           961  
000019E8  4EB9 00002454            962  SUBcode000 JSR      ISSUBB
000019EE  4E75                     963             RTS
000019F0  4EB9 0000247C            964  SUBcode001 JSR      ISSUBW
000019F6  4E75                     965             RTS
000019F8  4EB9 000024A4            966  SUBcode010 JSR      ISSUBL
000019FE  4E75                     967             RTS
00001A00  4EB9 00001EF4            968  SUBcode011 JSR      OPCODE_INVALID              ;INVALID
00001A06  4E75                     969             RTS
00001A08  4EB9 00002454            970  SUBcode100 JSR      ISSUBB
00001A0E  4E75                     971             RTS
00001A10  4EB9 0000247C            972  SUBcode101 JSR      ISSUBW
00001A16  4E75                     973             RTS
00001A18  4EB9 000024A4            974  SUBcode110 JSR      ISSUBL
00001A1E  4E75                     975             RTS
00001A20  4EB9 00001EF4            976  SUBcode111 JSR      OPCODE_INVALID              ;INVALID
00001A26  4E75                     977             RTS
00001A28                           978  
00001A28                           979  CMP_BorCMP_WorCMP_L:
00001A28  41F9 00001A46            980          LEA         tableCMP_BorCMP_WorCMP_L, A0 ; Index into the table
00001A2E  4280                     981          CLR.L       D0              ; Zero it
00001A30  3016                     982          MOVE.W      (A6),D0     ; We'll play with it here
00001A32  123C 0008                983          MOVE.B      #8,D1           ; Shift 8 bits left
00001A36  E360                     984          ASL.W       D1,D0
00001A38  123C 000E                985          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001A3C  E268                     986          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001A3E                           987                                      ; and the rest are zeroed out)
00001A3E  C0FC 0006                988          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001A42  4EF0 0000                989          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A46                           990  
00001A46                           991  tableCMP_BorCMP_WorCMP_L:
00001A46  4EF9 00001A5E            992          JMP         CMPcode00       *CMP.B
00001A4C  4EF9 00001A66            993          JMP         CMPcode01       *CMP.W
00001A52  4EF9 00001A6E            994          JMP         CMPcode10       *CMP.L
00001A58  4EF9 00001A76            995          JMP         CMPcode11       ; INVALID
00001A5E                           996  
00001A5E  4EB9 000024CC            997  CMPcode00   JSR      ISCMPB
00001A64  4E75                     998              RTS
00001A66  4EB9 000024F4            999  CMPcode01   JSR      ISCMPW
00001A6C  4E75                    1000              RTS
00001A6E  4EB9 0000251C           1001  CMPcode10   JSR      ISCMPL
00001A74  4E75                    1002              RTS
00001A76  4EB9 00001EF4           1003  CMPcode11   JSR    OPCODE_INVALID              ;INVALID
00001A7C  4E75                    1004              RTS
00001A7E                          1005  
00001A7E                          1006  ADDQ_BorADDQ_WorADDQ_L:
00001A7E  41F9 00001A9C           1007          LEA         tableADDQ_BorADDQ_WorADDQ_L, A0 ; Index into the table
00001A84  4280                    1008          CLR.L       D0              ; Zero it
00001A86  3016                    1009          MOVE.W      (A6),D0     ; We'll play with it here
00001A88  123C 0008               1010          MOVE.B      #8,D1           ; Shift 8 bits left
00001A8C  E360                    1011          ASL.W       D1,D0
00001A8E  123C 000E               1012          MOVE.B      #14,D1          ; Shift 14 bits to the right
00001A92  E268                    1013          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001A94                          1014                                      ; and the rest are zeroed out)
00001A94  C0FC 0006               1015          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001A98  4EF0 0000               1016          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001A9C                          1017  
00001A9C                          1018  tableADDQ_BorADDQ_WorADDQ_L:
00001A9C  4EF9 00001AB4           1019          JMP         ADDQcode00      *ADDQ.B
00001AA2  4EF9 00001ABC           1020          JMP         ADDQcode01      *ADDQ.W
00001AA8  4EF9 00001AC4           1021          JMP         ADDQcode10      *ADDQ.L
00001AAE  4EF9 00001ACC           1022          JMP         ADDQcode11      ; INVALID
00001AB4                          1023  
00001AB4  4EB9 00002544           1024  ADDQcode00 JSR      ISADDQB
00001ABA  4E75                    1025             RTS
00001ABC  4EB9 0000256C           1026  ADDQcode01 JSR      ISADDQW
00001AC2  4E75                    1027             RTS
00001AC4  4EB9 00002594           1028  ADDQcode10 JSR      ISADDQL
00001ACA  4E75                    1029             RTS
00001ACC  4EB9 00001EF4           1030  ADDQcode11   JSR    OPCODE_INVALID              ;INVALID
00001AD2  4E75                    1031              RTS
00001AD4                          1032  
00001AD4                          1033  someCLR:
00001AD4  41F9 00001AF2           1034          LEA         tableSomeCLR, A0 ; Index into the table
00001ADA  4280                    1035          CLR.L       D0              ; Zero it
00001ADC  3016                    1036          MOVE.W      (A6),D0     ; We'll play with it here
00001ADE  123C 0008               1037          MOVE.B      #8,D1           ; Shift 8 bits left
00001AE2  E360                    1038          ASL.W       D1,D0
00001AE4  123C 000E               1039          MOVE.B      #14,D1       ; Shift 12 bits to the right
00001AE8  E268                    1040          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001AEA                          1041                                      ; and the rest are zeroed out)
00001AEA  C0FC 0006               1042          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001AEE  4EF0 0000               1043          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001AF2                          1044  
00001AF2                          1045  tableSomeCLR:
00001AF2  4EF9 00001B0A           1046          JMP         CLRcode00       *CLR.B
00001AF8  4EF9 00001B12           1047          JMP         CLRcode01       *CLR.W
00001AFE  4EF9 00001B1A           1048          JMP         CLRcode10       *CLR.L
00001B04  4EF9 00001B22           1049          JMP         CLRcode11       ; INVALID
00001B0A                          1050  
00001B0A  4EB9 000025D8           1051  CLRcode00 JSR       ISCLRB
00001B10  4E75                    1052            RTS
00001B12  4EB9 00002600           1053  CLRcode01 JSR       ISCLRW
00001B18  4E75                    1054            RTS
00001B1A  4EB9 00002628           1055  CLRcode10 JSR       ISCLRL
00001B20  4E75                    1056            RTS
00001B22  4EB9 00001EF4           1057  CLRcode11 JSR    OPCODE_INVALID              ;INVALID
00001B28  4E75                    1058            RTS
00001B2A                          1059  
00001B2A                          1060  NOPorCLRorRTSorJSR:
00001B2A  41F9 00001B5C           1061          LEA         tableNOPorCLRorRTSorJSR, A0 ; Index into the table
00001B30  4280                    1062          CLR.L       D0              ; Zero it
00001B32  3016                    1063          MOVE.W      (A6),D0     ; We'll play with it here
00001B34                          1064  
00001B34  323C 4E71               1065          MOVE.W      #%0100111001110001, D1 ; 0100111001110001 = NOP
00001B38  B240                    1066          CMP.W       D0, D1
00001B3A  6700 0088               1067          BEQ         NOPcommand
00001B3E                          1068  
00001B3E  323C 4E75               1069          MOVE.W      #%0100111001110101, D1 ; 0100111001110101 = RTS
00001B42  B240                    1070          CMP.W       D0, D1
00001B44  6700 0076               1071          BEQ         RTScommand
00001B48                          1072  
00001B48  123C 0004               1073          MOVE.B      #4,D1           ; Shift 4 bits left
00001B4C  E360                    1074          ASL.W       D1,D0
00001B4E  123C 000C               1075          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001B52  E268                    1076          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001B54                          1077                                      ; and the rest are zeroed out)
00001B54  C0FC 0006               1078          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001B58  4EF0 0000               1079          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001B5C                          1080  
00001B5C                          1081  tableNOPorCLRorRTSorJSR:
00001B5C  4EF9 00001BCC           1082          JMP         JSRorCLRcode0000
00001B62  4EF9 00001BD4           1083          JMP         JSRorCLRcode0001
00001B68  4EF9 00001BDC           1084          JMP         JSRorCLRcode0010
00001B6E  4EF9 00001BE2           1085          JMP         JSRorCLRcode0011
00001B74  4EF9 00001BEA           1086          JMP         JSRorCLRcode0100
00001B7A  4EF9 00001BF2           1087          JMP         JSRorCLRcode0101
00001B80  4EF9 00001BFA           1088          JMP         JSRorCLRcode0110
00001B86  4EF9 00001C02           1089          JMP         JSRorCLRcode0111
00001B8C  4EF9 00001C0A           1090          JMP         JSRorCLRcode1000
00001B92  4EF9 00001C12           1091          JMP         JSRorCLRcode1001
00001B98  4EF9 00001C1A           1092          JMP         JSRorCLRcode1010
00001B9E  4EF9 00001C22           1093          JMP         JSRorCLRcode1011
00001BA4  4EF9 00001C2A           1094          JMP         JSRorCLRcode1100
00001BAA  4EF9 00001C32           1095          JMP         JSRorCLRcode1101
00001BB0  4EF9 00001C3A           1096          JMP         JSRorCLRcode1110
00001BB6  4EF9 00001C42           1097          JMP         JSRorCLRcode1111
00001BBC                          1098  
00001BBC  4EB9 000026F0           1099  RTScommand JSR      ISRTS
00001BC2  4E75                    1100             RTS
00001BC4  4EB9 0000273C           1101  NOPcommand JSR      ISNOP
00001BCA  4E75                    1102             RTS
00001BCC  4EB9 00001EF4           1103  JSRorCLRcode0000 JSR    OPCODE_INVALID              ;INVALID
00001BD2  4E75                    1104                   RTS
00001BD4  4EB9 00001EF4           1105  JSRorCLRcode0001 JSR    OPCODE_INVALID              ;INVALID
00001BDA  4E75                    1106                   RTS
00001BDC  4EB8 1AD4               1107  JSRorCLRcode0010 JSR someCLR
00001BE0  4E75                    1108                   RTS
00001BE2  4EB9 00001EF4           1109  JSRorCLRcode0011 JSR    OPCODE_INVALID              ;INVALID
00001BE8  4E75                    1110                   RTS
00001BEA  4EB9 00001EF4           1111  JSRorCLRcode0100 JSR    OPCODE_INVALID              ;INVALID
00001BF0  4E75                    1112                   RTS
00001BF2  4EB9 00001EF4           1113  JSRorCLRcode0101 JSR    OPCODE_INVALID              ;INVALID
00001BF8  4E75                    1114                   RTS
00001BFA  4EB9 00001EF4           1115  JSRorCLRcode0110 JSR    OPCODE_INVALID              ;INVALID
00001C00  4E75                    1116                   RTS
00001C02  4EB9 00001EF4           1117  JSRorCLRcode0111 JSR    OPCODE_INVALID              ;INVALID
00001C08  4E75                    1118                   RTS
00001C0A  4EB9 00001EF4           1119  JSRorCLRcode1000 JSR    OPCODE_INVALID              ;INVALID
00001C10  4E75                    1120                   RTS
00001C12  4EB9 00001EF4           1121  JSRorCLRcode1001 JSR    OPCODE_INVALID              ;INVALID
00001C18  4E75                    1122                   RTS
00001C1A  4EB9 00001EF4           1123  JSRorCLRcode1010 JSR    OPCODE_INVALID              ;INVALID
00001C20  4E75                    1124                   RTS
00001C22  4EB9 00001EF4           1125  JSRorCLRcode1011 JSR    OPCODE_INVALID              ;INVALID
00001C28  4E75                    1126                   RTS
00001C2A  4EB9 00001EF4           1127  JSRorCLRcode1100 JSR    OPCODE_INVALID              ;INVALID
00001C30  4E75                    1128                   RTS
00001C32  4EB9 00001EF4           1129  JSRorCLRcode1101 JSR    OPCODE_INVALID              ;INVALID
00001C38  4E75                    1130                   RTS
00001C3A  4EB9 000026C8           1131  JSRorCLRcode1110 JSR ISJSR
00001C40  4E75                    1132                   RTS
00001C42  4EB9 00001EF4           1133  JSRorCLRcode1111 JSR    OPCODE_INVALID              ;INVALID
00001C48  4E75                    1134                   RTS
00001C4A                          1135  
00001C4A                          1136  someMOVEM:
00001C4A  41F9 00001C68           1137          LEA         tableSomeMOVEM, A0 ; Index into the table
00001C50  4280                    1138          CLR.L       D0              ; Zero it
00001C52  3016                    1139          MOVE.W      (A6),D0     ; We'll play with it here
00001C54  123C 0009               1140          MOVE.B      #9,D1           ; Shift 9 bits left
00001C58  E360                    1141          ASL.W       D1,D0
00001C5A  123C 000F               1142          MOVE.B      #15,D1       ; Shift 12 bits to the right
00001C5E  E268                    1143          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001C60                          1144                                      ; and the rest are zeroed out)
00001C60  C0FC 0006               1145          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001C64  4EF0 0000               1146          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001C68                          1147  
00001C68                          1148  tableSomeMOVEM:
00001C68  4EF9 00001C74           1149          JMP         MOVEMcode0      ; MOVEM.W
00001C6E  4EF9 00001C7C           1150          JMP         MOVEMcode1      ; MOVEM.L
00001C74                          1151  
00001C74  4EB9 00002678           1152  MOVEMcode0 JSR      ISMOVEMW
00001C7A  4E75                    1153             RTS
00001C7C  4EB9 00002650           1154  MOVEMcode1 JSR      ISMOVEML
00001C82  4E75                    1155             RTS
00001C84                          1156  
00001C84                          1157  NOP_MOVEM_LEA_JSR_CLR_RTS:
00001C84  41F9 00001CA8           1158          LEA         tableNOP_MOVEM_LEA_JSR_CLR_RTS, A0 ; Index into the table
00001C8A  4280                    1159          CLR.L       D0              ; Zero it
00001C8C  3016                    1160          MOVE.W      (A6),D0     ; We'll play with it here
00001C8E  123C 0007               1161          MOVE.B      #7,D1           ; Shift 7 bits right
00001C92  E260                    1162          ASR.W       D1,D0
00001C94  123C 000D               1163          MOVE.B      #13,D1          ; Shift 13 bits left
00001C98  E360                    1164          ASL.W       D1,D0
00001C9A  123C 000C               1165          MOVE.B      #12,D1          ; Shift 12 bits to the right
00001C9E  E268                    1166          LSR.W       D1,D0           ; Move the bits (moves highest 4 bits to lowest 4 positions,
00001CA0                          1167                                      ; and the rest are zeroed out)
00001CA0  C0FC 0006               1168          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001CA4  4EF0 0000               1169          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001CA8                          1170  
00001CA8                          1171  tableNOP_MOVEM_LEA_JSR_CLR_RTS:
00001CA8  4EF9 00001D08           1172          JMP         LOTScode0000
00001CAE  4EF9 00001D10           1173          JMP         LOTScode0001
00001CB4  4EF9 00001D18           1174          JMP         LOTScode0010
00001CBA  4EF9 00001D1E           1175          JMP         LOTScode0011
00001CC0  4EF9 00001D26           1176          JMP         LOTScode0100
00001CC6  4EF9 00001D2E           1177          JMP         LOTScode0101
00001CCC  4EF9 00001D36           1178          JMP         LOTScode0110
00001CD2  4EF9 00001D3E           1179          JMP         LOTScode0111
00001CD8  4EF9 00001D46           1180          JMP         LOTScode1000
00001CDE  4EF9 00001D4C           1181          JMP         LOTScode1001
00001CE4  4EF9 00001D54           1182          JMP         LOTScode1010
00001CEA  4EF9 00001D5A           1183          JMP         LOTScode1011
00001CF0  4EF9 00001D62           1184          JMP         LOTScode1100
00001CF6  4EF9 00001D6A           1185          JMP         LOTScode1101
00001CFC  4EF9 00001D72           1186          JMP         LOTScode1110
00001D02  4EF9 00001D7A           1187          JMP         LOTScode1111
00001D08                          1188  
00001D08  4EB9 00001EF4           1189  LOTScode0000 JSR    OPCODE_INVALID              ; MULS.L and DIVU.L are not supported for 68000 Disassember
00001D0E  4E75                    1190               RTS
00001D10  4EB9 00001EF4           1191  LOTScode0001 JSR    OPCODE_INVALID              ;INVALID
00001D16  4E75                    1192               RTS
00001D18  4EB8 1C4A               1193  LOTScode0010 JSR    someMOVEM
00001D1C  4E75                    1194               RTS
00001D1E  4EB9 00001EF4           1195  LOTScode0011 JSR    OPCODE_INVALID              ;INVALID
00001D24  4E75                    1196               RTS
00001D26  4EB9 00001EF4           1197  LOTScode0100 JSR    OPCODE_INVALID              ;INVALID
00001D2C  4E75                    1198               RTS
00001D2E  4EB9 00001EF4           1199  LOTScode0101 JSR    OPCODE_INVALID              ;INVALID
00001D34  4E75                    1200               RTS
00001D36  4EB9 000026A0           1201  LOTScode0110 JSR    ISLEA
00001D3C  4E75                    1202               RTS
00001D3E  4EB9 00001EF4           1203  LOTScode0111 JSR    OPCODE_INVALID              ;INVALID
00001D44  4E75                    1204               RTS
00001D46  4EB8 1B2A               1205  LOTScode1000 JSR    NOPorCLRorRTSorJSR
00001D4A  4E75                    1206               RTS
00001D4C  4EB9 00001EF4           1207  LOTScode1001 JSR    OPCODE_INVALID              ;INVALID
00001D52  4E75                    1208               RTS
00001D54  4EB8 1B2A               1209  LOTScode1010 JSR    NOPorCLRorRTSorJSR
00001D58  4E75                    1210               RTS
00001D5A  4EB9 00001EF4           1211  LOTScode1011 JSR    OPCODE_INVALID              ;INVALID
00001D60  4E75                    1212               RTS
00001D62  4EB9 00001EF4           1213  LOTScode1100 JSR    OPCODE_INVALID              ;INVALID
00001D68  4E75                    1214               RTS
00001D6A  4EB9 00001EF4           1215  LOTScode1101 JSR    OPCODE_INVALID              ;INVALID
00001D70  4E75                    1216               RTS
00001D72  4EB9 000026A0           1217  LOTScode1110 JSR    ISLEA
00001D78  4E75                    1218               RTS
00001D7A  4EB9 00001EF4           1219  LOTScode1111 JSR    OPCODE_INVALID              ;INVALID
00001D80  4E75                    1220               RTS
00001D82                          1221  
00001D82                          1222  ADDI_BorADDI_WorADDI_L:
00001D82  41F9 00001DA0           1223          LEA         tableADDI_BorADDI_WorADDI_L,A0 ; Index into the table
00001D88  4280                    1224          CLR.L       D0              ; Zero it
00001D8A  3016                    1225          MOVE.W      (A6),D0     ; We'll play with it here
00001D8C  123C 0007               1226          MOVE.B      #7,D1           ; Shift 7 bits left
00001D90  E360                    1227          ASL.W       D1,D0
00001D92  123C 000D               1228          MOVE.B      #13,D1          ; Shift 13 bits right
00001D96  E260                    1229          ASR.W       D1,D0
00001D98  C0FC 0006               1230          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001D9C  4EF0 0000               1231          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001DA0                          1232  
00001DA0                          1233  tableADDI_BorADDI_WorADDI_L:
00001DA0  4EF9 00001DB8           1234          JMP         ADDIBcode00
00001DA6  4EF9 00001DC0           1235          JMP         ADDIWcode01
00001DAC  4EF9 00001DC8           1236          JMP         ADDILcode10
00001DB2  4EF9 00001DD0           1237          JMP         ADDILcode11
00001DB8                          1238  
00001DB8  4EB9 00002878           1239  ADDIBcode00 JSR     ISADDIB
00001DBE  4E75                    1240              RTS
00001DC0  4EB9 00002828           1241  ADDIWcode01 JSR     ISADDIW
00001DC6  4E75                    1242              RTS
00001DC8  4EB9 00002850           1243  ADDILcode10 JSR     ISADDIL
00001DCE  4E75                    1244              RTS
00001DD0  4EB9 00001EF4           1245  ADDILcode11 JSR    OPCODE_INVALID              ;INVALID
00001DD6  4E75                    1246              RTS
00001DD8                          1247  
00001DD8                          1248  MOVEA_LorMOVE_L:
00001DD8  41F9 00001DF6           1249          LEA         tableMOVEA_LorMOVE_L,A0 ; Index into the table
00001DDE  4280                    1250          CLR.L       D0              ; Zero it
00001DE0  3016                    1251          MOVE.W      (A6),D0         ; We'll play with it here
00001DE2  123C 0007               1252          MOVE.B      #7,D1           ; Shift 7 bits left
00001DE6  E360                    1253          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
00001DE8  123C 000D               1254          MOVE.B      #13,D1          ; Shift 13 bits right
00001DEC  E260                    1255          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
00001DEE  C0FC 0006               1256          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001DF2  4EF0 0000               1257          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001DF6                          1258  
00001DF6                          1259  tableMOVEA_LorMOVE_L:
00001DF6  4EF9 00001E26           1260          JMP         MOVEcode000
00001DFC  4EF9 00001E2E           1261          JMP         MOVEAcode001
00001E02  4EF9 00001E36           1262          JMP         MOVEcode010
00001E08  4EF9 00001E3E           1263          JMP         MOVEcode011
00001E0E  4EF9 00001E46           1264          JMP         MOVEcode100
00001E14  4EF9 00001E4E           1265          JMP         MOVEcode101
00001E1A  4EF9 00001E56           1266          JMP         MOVEcode110
00001E20  4EF9 00001E5E           1267          JMP         MOVEcode111
00001E26                          1268  
00001E26  4EB9 000027B0           1269  MOVEcode000 JSR     ISMOVEL
00001E2C  4E75                    1270              RTS
00001E2E  4EB9 000027D8           1271  MOVEAcode001 JSR    ISMOVEAL
00001E34  4E75                    1272               RTS
00001E36  4EB9 000027B0           1273  MOVEcode010 JSR     ISMOVEL
00001E3C  4E75                    1274              RTS
00001E3E  4EB9 000027B0           1275  MOVEcode011 JSR     ISMOVEL
00001E44  4E75                    1276              RTS
00001E46  4EB9 000027B0           1277  MOVEcode100 JSR     ISMOVEL
00001E4C  4E75                    1278              RTS
00001E4E  4EB9 000027B0           1279  MOVEcode101 JSR     ISMOVEL
00001E54  4E75                    1280              RTS
00001E56  4EB9 000027B0           1281  MOVEcode110 JSR     ISMOVEL
00001E5C  4E75                    1282              RTS
00001E5E  4EB9 000027B0           1283  MOVEcode111 JSR     ISMOVEL
00001E64  4E75                    1284              RTS
00001E66                          1285  
00001E66                          1286  MOVEA_WorMOVE_W:
00001E66  41F9 00001E84           1287          LEA         tableMOVEA_WorMOVE_W,A0 ; Index into the table
00001E6C  4280                    1288          CLR.L       D0              ; Zero it
00001E6E  3016                    1289          MOVE.W      (A6),D0     ; We'll play with it here
00001E70  123C 0007               1290          MOVE.B      #7,D1           ; Shift 7 bits left
00001E74  E360                    1291          ASL.W       D1,D0           ; 0011 1010 0100 0100 to 0010 0000 0000 0000
00001E76  123C 000D               1292          MOVE.B      #13,D1          ; Shift 13 bits right
00001E7A  E260                    1293          ASR.W       D1,D0           ; 0010 0000 0000 0000 to 0000 0000 0000 0001
00001E7C  C0FC 0006               1294          MULU        #6,D0           ; Form offset (move 6 bytes in memory for every 'JMP' command)
00001E80  4EF0 0000               1295          JMP         0(A0,D0)        ; Jump indirect with index, i.e. jump to 'table' + displacement
00001E84                          1296  
00001E84                          1297  tableMOVEA_WorMOVE_W:
00001E84  4EF9 00001EB4           1298          JMP         MOVEWcode000
00001E8A  4EF9 00001EBC           1299          JMP         MOVEAWcode001
00001E90  4EF9 00001EC4           1300          JMP         MOVEWcode010
00001E96  4EF9 00001ECC           1301          JMP         MOVEWcode011
00001E9C  4EF9 00001ED4           1302          JMP         MOVEWcode100
00001EA2  4EF9 00001EDC           1303          JMP         MOVEWcode101
00001EA8  4EF9 00001EE4           1304          JMP         MOVEWcode110
00001EAE  4EF9 00001EEC           1305          JMP         MOVEWcode111
00001EB4                          1306  
00001EB4  4EB9 00002760           1307  MOVEWcode000 JSR    ISMOVEW
00001EBA  4E75                    1308               RTS
00001EBC  4EB9 00002788           1309  MOVEAWcode001 JSR   ISMOVEAW
00001EC2  4E75                    1310                RTS
00001EC4  4EB9 00002760           1311  MOVEWcode010 JSR    ISMOVEW
00001ECA  4E75                    1312               RTS
00001ECC  4EB9 00002760           1313  MOVEWcode011 JSR    ISMOVEW
00001ED2  4E75                    1314               RTS
00001ED4  4EB9 00002760           1315  MOVEWcode100 JSR    ISMOVEW
00001EDA  4E75                    1316               RTS
00001EDC  4EB9 00002760           1317  MOVEWcode101 JSR    ISMOVEW
00001EE2  4E75                    1318               RTS
00001EE4  4EB9 00002760           1319  MOVEWcode110 JSR    ISMOVEW
00001EEA  4E75                    1320               RTS
00001EEC  4EB9 00002760           1321  MOVEWcode111 JSR    ISMOVEW
00001EF2  4E75                    1322               RTS
00001EF4                          1323  
00001EF4                          1324  ; TODO: adjust workflow to:
00001EF4                          1325  ;   1) save message address to buffer pointer
00001EF4  48E7 FFFE               1326  OPCODE_INVALID  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001EF8  4EB8 1326               1327              JSR     INVALID_DATA
00001EFC  548E                    1328              ADDA.L      #$00000002, A6          ; Increment past current opcode word
00001EFE  4CDF 7FFF               1329              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001F02  4E75                    1330              RTS
00001F04                          1331  
00001F04  48E7 FFFE               1332  ISBCC  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001F08  49F9 00004788           1333              LEA    MESSAGEBCC, A4
00001F0E  4EB9 0000440E           1334              JSR    WRITE2MEM
00001F14  49F9 0000461A           1335              LEA    MESSAGESPACE, A4
00001F1A  4EB9 0000440E           1336              JSR    WRITE2MEM
00001F20  4EB9 000034B8           1337              JSR     EA_Bcc
00001F26  4CDF 7FFF               1338              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001F2A  4E75                    1339              RTS
00001F2C  48E7 FFFE               1340  ISBGT  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001F30  49F9 0000478C           1341              LEA MESSAGEBGT, A4
00001F36  4EB9 0000440E           1342              JSR    WRITE2MEM
00001F3C  49F9 0000461A           1343              LEA    MESSAGESPACE, A4
00001F42  4EB9 0000440E           1344              JSR    WRITE2MEM
00001F48  4EB9 000034B8           1345              JSR     EA_Bcc
00001F4E  4CDF 7FFF               1346              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001F52  4E75                    1347              RTS
00001F54                          1348  
00001F54  48E7 FFFE               1349  ISBLE  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001F58  49F9 00004790           1350              LEA MESSAGEBLE, A4
00001F5E  4EB9 0000440E           1351              JSR    WRITE2MEM
00001F64  49F9 0000461A           1352              LEA    MESSAGESPACE, A4
00001F6A  4EB9 0000440E           1353              JSR    WRITE2MEM
00001F70  4EB9 000034B8           1354              JSR     EA_Bcc
00001F76  4CDF 7FFF               1355              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001F7A  4E75                    1356              RTS
00001F7C                          1357  
00001F7C  48E7 FFFE               1358  ISDIVUW     MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001F80  49F9 00004781           1359              LEA MESSAGEDIVUW, A4
00001F86  4EB9 0000440E           1360              JSR    WRITE2MEM
00001F8C  49F9 0000461A           1361              LEA    MESSAGESPACE, A4
00001F92  4EB9 0000440E           1362              JSR    WRITE2MEM
00001F98  4EB9 000036EA           1363              JSR     EA_DIVU_W
00001F9E  4CDF 7FFF               1364              MOVEM.L (SP)+,  A0-A6/D0-D7         ; Restore registers
00001FA2  4E75                    1365              RTS
00001FA4                          1366  
00001FA4  48E7 FFFE               1367  ISORB   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001FA8  49F9 00004772           1368          LEA         MESSAGEORB, A4
00001FAE  4EB9 0000440E           1369          JSR    WRITE2MEM
00001FB4  49F9 0000461A           1370          LEA    MESSAGESPACE, A4
00001FBA  4EB9 0000440E           1371          JSR    WRITE2MEM
00001FC0  4EB9 00003EFE           1372          JSR         EA_OR
00001FC6  4CDF 7FFF               1373          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00001FCA  4E75                    1374          RTS
00001FCC                          1375  
00001FCC  48E7 FFFE               1376  ISORW   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001FD0  49F9 00004777           1377          LEA         MESSAGEORW, A4
00001FD6  4EB9 0000440E           1378          JSR    WRITE2MEM
00001FDC  49F9 0000461A           1379          LEA    MESSAGESPACE, A4
00001FE2  4EB9 0000440E           1380          JSR    WRITE2MEM
00001FE8  4EB9 00003EFE           1381          JSR         EA_OR
00001FEE  4CDF 7FFF               1382          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00001FF2  4E75                    1383          RTS
00001FF4                          1384  
00001FF4  48E7 FFFE               1385  ISORL   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00001FF8  49F9 0000477C           1386          LEA         MESSAGEORL, A4
00001FFE  4EB9 0000440E           1387          JSR    WRITE2MEM
00002004  49F9 0000461A           1388          LEA    MESSAGESPACE, A4
0000200A  4EB9 0000440E           1389          JSR    WRITE2MEM
00002010  4EB9 00003EFE           1390          JSR         EA_OR
00002016  4CDF 7FFF               1391          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000201A  4E75                    1392          RTS
0000201C                          1393  
0000201C  48E7 FFFE               1394  ISASRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002020  49F9 00004706           1395          LEA         MESSAGEASRB, A4
00002026  4EB9 0000440E           1396          JSR    WRITE2MEM
0000202C  49F9 0000461A           1397          LEA    MESSAGESPACE, A4
00002032  4EB9 0000440E           1398          JSR    WRITE2MEM
00002038  4EB9 00003388           1399          JSR         EA_ASd
0000203E  4CDF 7FFF               1400          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002042  4E75                    1401          RTS
00002044                          1402  
00002044  48E7 FFFE               1403  ISASRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002048  49F9 0000470C           1404          LEA         MESSAGEASRW, A4
0000204E  4EB9 0000440E           1405          JSR    WRITE2MEM
00002054  49F9 0000461A           1406          LEA    MESSAGESPACE, A4
0000205A  4EB9 0000440E           1407          JSR    WRITE2MEM
00002060  4EB9 00003388           1408          JSR         EA_ASd
00002066  4CDF 7FFF               1409          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000206A  4E75                    1410          RTS
0000206C                          1411  
0000206C  48E7 FFFE               1412  ISASRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002070  49F9 00004712           1413          LEA         MESSAGEASRL, A4
00002076  4EB9 0000440E           1414          JSR    WRITE2MEM
0000207C  49F9 0000461A           1415          LEA    MESSAGESPACE, A4
00002082  4EB9 0000440E           1416          JSR    WRITE2MEM
00002088  4EB9 00003388           1417          JSR         EA_ASd
0000208E  4CDF 7FFF               1418          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002092  4E75                    1419          RTS
00002094                          1420  
00002094  48E7 FFFE               1421  ISASLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002098  49F9 00004718           1422          LEA         MESSAGEASLB, A4
0000209E  4EB9 0000440E           1423          JSR    WRITE2MEM
000020A4  49F9 0000461A           1424          LEA    MESSAGESPACE, A4
000020AA  4EB9 0000440E           1425          JSR    WRITE2MEM
000020B0  4EB9 00003388           1426          JSR         EA_ASd
000020B6  4CDF 7FFF               1427          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000020BA  4E75                    1428          RTS
000020BC                          1429  
000020BC  48E7 FFFE               1430  ISASLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000020C0  49F9 0000471E           1431          LEA         MESSAGEASLW, A4
000020C6  4EB9 0000440E           1432          JSR    WRITE2MEM
000020CC  49F9 0000461A           1433          LEA    MESSAGESPACE, A4
000020D2  4EB9 0000440E           1434          JSR    WRITE2MEM
000020D8  4EB9 00003388           1435          JSR         EA_ASd
000020DE  4CDF 7FFF               1436          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000020E2  4E75                    1437          RTS
000020E4                          1438  
000020E4  48E7 FFFE               1439  ISASLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000020E8  49F9 00004724           1440          LEA         MESSAGEASLL, A4
000020EE  4EB9 0000440E           1441          JSR    WRITE2MEM
000020F4  49F9 0000461A           1442          LEA    MESSAGESPACE, A4
000020FA  4EB9 0000440E           1443          JSR    WRITE2MEM
00002100  4EB9 00003388           1444          JSR         EA_ASd
00002106  4CDF 7FFF               1445          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000210A  4E75                    1446          RTS
0000210C                          1447  
0000210C  48E7 FFFE               1448  ISLSRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002110  49F9 0000474E           1449          LEA         MESSAGELSRB, A4
00002116  4EB9 0000440E           1450          JSR    WRITE2MEM
0000211C  49F9 0000461A           1451          LEA    MESSAGESPACE, A4
00002122  4EB9 0000440E           1452          JSR    WRITE2MEM
00002128  4EB9 0000397E           1453          JSR         EA_LSd
0000212E  4CDF 7FFF               1454          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002132  4E75                    1455          RTS
00002134                          1456  
00002134  48E7 FFFE               1457  ISLSRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002138  49F9 00004754           1458          LEA         MESSAGELSRW, A4
0000213E  4EB9 0000440E           1459          JSR    WRITE2MEM
00002144  49F9 0000461A           1460          LEA    MESSAGESPACE, A4
0000214A  4EB9 0000440E           1461          JSR    WRITE2MEM
00002150  4EB9 0000397E           1462          JSR         EA_LSd
00002156  4CDF 7FFF               1463          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000215A  4E75                    1464          RTS
0000215C                          1465  
0000215C  48E7 FFFE               1466  ISLSRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002160  49F9 0000475A           1467          LEA         MESSAGELSRL, A4
00002166  4EB9 0000440E           1468          JSR    WRITE2MEM
0000216C  49F9 0000461A           1469          LEA    MESSAGESPACE, A4
00002172  4EB9 0000440E           1470          JSR    WRITE2MEM
00002178  4EB9 0000397E           1471          JSR         EA_LSd
0000217E  4CDF 7FFF               1472          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002182  4E75                    1473          RTS
00002184                          1474  
00002184  48E7 FFFE               1475  ISLSLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002188  49F9 00004760           1476          LEA         MESSAGELSLB, A4
0000218E  4EB9 0000440E           1477          JSR    WRITE2MEM
00002194  49F9 0000461A           1478          LEA    MESSAGESPACE, A4
0000219A  4EB9 0000440E           1479          JSR    WRITE2MEM
000021A0  4EB9 0000397E           1480          JSR         EA_LSd
000021A6  4CDF 7FFF               1481          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000021AA  4E75                    1482          RTS
000021AC                          1483  
000021AC  48E7 FFFE               1484  ISLSLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000021B0  49F9 00004766           1485          LEA         MESSAGELSLW, A4
000021B6  4EB9 0000440E           1486          JSR    WRITE2MEM
000021BC  49F9 0000461A           1487          LEA    MESSAGESPACE, A4
000021C2  4EB9 0000440E           1488          JSR    WRITE2MEM
000021C8  4EB9 0000397E           1489          JSR         EA_LSd
000021CE  4CDF 7FFF               1490          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000021D2  4E75                    1491          RTS
000021D4                          1492  
000021D4  48E7 FFFE               1493  ISLSLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000021D8  49F9 0000476C           1494          LEA         MESSAGELSLL, A4
000021DE  4EB9 0000440E           1495          JSR    WRITE2MEM
000021E4  49F9 0000461A           1496          LEA    MESSAGESPACE, A4
000021EA  4EB9 0000440E           1497          JSR    WRITE2MEM
000021F0  4EB9 0000397E           1498          JSR         EA_LSd
000021F6  4CDF 7FFF               1499          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000021FA  4E75                    1500          RTS
000021FC                          1501  
000021FC  48E7 FFFE               1502  ISRORB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002200  49F9 0000472A           1503          LEA         MESSAGERORB, A4
00002206  4EB9 0000440E           1504          JSR    WRITE2MEM
0000220C  49F9 0000461A           1505          LEA    MESSAGESPACE, A4
00002212  4EB9 0000440E           1506          JSR    WRITE2MEM
00002218  4EB9 000040C0           1507          JSR         EA_ROd
0000221E  4CDF 7FFF               1508          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002222  4E75                    1509          RTS
00002224                          1510  
00002224  48E7 FFFE               1511  ISRORW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002228  49F9 00004730           1512          LEA         MESSAGERORW, A4
0000222E  4EB9 0000440E           1513          JSR    WRITE2MEM
00002234  49F9 0000461A           1514          LEA    MESSAGESPACE, A4
0000223A  4EB9 0000440E           1515          JSR    WRITE2MEM
00002240  4EB9 000040C0           1516          JSR         EA_ROd
00002246  4CDF 7FFF               1517          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000224A  4E75                    1518          RTS
0000224C                          1519  
0000224C  48E7 FFFE               1520  ISRORL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002250  49F9 00004736           1521          LEA         MESSAGERORL, A4
00002256  4EB9 0000440E           1522          JSR    WRITE2MEM
0000225C  49F9 0000461A           1523          LEA    MESSAGESPACE, A4
00002262  4EB9 0000440E           1524          JSR    WRITE2MEM
00002268  4EB9 000040C0           1525          JSR         EA_ROd
0000226E  4CDF 7FFF               1526          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002272  4E75                    1527          RTS
00002274                          1528  
00002274  48E7 FFFE               1529  ISROLB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002278  49F9 0000473C           1530          LEA         MESSAGEROLB, A4
0000227E  4EB9 0000440E           1531          JSR    WRITE2MEM
00002284  49F9 0000461A           1532          LEA    MESSAGESPACE, A4
0000228A  4EB9 0000440E           1533          JSR    WRITE2MEM
00002290  4EB9 000040C0           1534          JSR         EA_ROd
00002296  4CDF 7FFF               1535          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000229A  4E75                    1536          RTS
0000229C                          1537  
0000229C  48E7 FFFE               1538  ISROLW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022A0  49F9 00004742           1539          LEA         MESSAGEROLW, A4
000022A6  4EB9 0000440E           1540          JSR    WRITE2MEM
000022AC  49F9 0000461A           1541          LEA    MESSAGESPACE, A4
000022B2  4EB9 0000440E           1542          JSR    WRITE2MEM
000022B8  4EB9 000040C0           1543          JSR         EA_ROd
000022BE  4CDF 7FFF               1544          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022C2  4E75                    1545          RTS
000022C4                          1546  
000022C4  48E7 FFFE               1547  ISROLL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022C8  49F9 00004748           1548          LEA         MESSAGEROLL, A4
000022CE  4EB9 0000440E           1549          JSR    WRITE2MEM
000022D4  49F9 0000461A           1550          LEA    MESSAGESPACE, A4
000022DA  4EB9 0000440E           1551          JSR    WRITE2MEM
000022E0  4EB9 000040C0           1552          JSR         EA_ROd
000022E6  4CDF 7FFF               1553          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000022EA  4E75                    1554          RTS
000022EC                          1555  
000022EC  48E7 FFFE               1556  ISMULSW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000022F0  49F9 000046FF           1557          LEA         MESSAGEMULSW, A4
000022F6  4EB9 0000440E           1558          JSR    WRITE2MEM
000022FC  49F9 0000461A           1559          LEA    MESSAGESPACE, A4
00002302  4EB9 0000440E           1560          JSR    WRITE2MEM
00002308  4EB9 00003E0E           1561          JSR         EA_MULS_W
0000230E  4CDF 7FFF               1562          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002312  4E75                    1563          RTS
00002314                          1564  
00002314  48E7 FFFE               1565  ISANDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002318  49F9 000046ED           1566          LEA         MESSAGEANDB, A4
0000231E  4EB9 0000440E           1567          JSR    WRITE2MEM
00002324  49F9 0000461A           1568          LEA    MESSAGESPACE, A4
0000232A  4EB9 0000440E           1569          JSR    WRITE2MEM
00002330  4EB9 000031CC           1570          JSR         EA_AND
00002336  4CDF 7FFF               1571          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000233A  4E75                    1572          RTS
0000233C                          1573  
0000233C  48E7 FFFE               1574  ISANDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002340  49F9 000046F3           1575          LEA         MESSAGEANDW, A4
00002346  4EB9 0000440E           1576          JSR    WRITE2MEM
0000234C  49F9 0000461A           1577          LEA    MESSAGESPACE, A4
00002352  4EB9 0000440E           1578          JSR    WRITE2MEM
00002358  4EB9 000031CC           1579          JSR         EA_AND
0000235E  4CDF 7FFF               1580          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002362  4E75                    1581          RTS
00002364                          1582  
00002364  48E7 FFFE               1583  ISANDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002368  49F9 000046F9           1584          LEA         MESSAGEANDL, A4
0000236E  4EB9 0000440E           1585          JSR    WRITE2MEM
00002374  49F9 0000461A           1586          LEA    MESSAGESPACE, A4
0000237A  4EB9 0000440E           1587          JSR    WRITE2MEM
00002380  4EB9 000031CC           1588          JSR         EA_AND
00002386  4CDF 7FFF               1589          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000238A  4E75                    1590          RTS
0000238C                          1591  
0000238C  48E7 FFFE               1592  ISADDAW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002390  49F9 000046D7           1593          LEA         MESSAGEADDAW, A4
00002396  4EB9 0000440E           1594          JSR    WRITE2MEM
0000239C  49F9 0000461A           1595          LEA    MESSAGESPACE, A4
000023A2  4EB9 0000440E           1596          JSR    WRITE2MEM
000023A8  4EB9 00002EC2           1597          JSR         EA_ADDA
000023AE  4CDF 7FFF               1598          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023B2  4E75                    1599          RTS
000023B4                          1600  
000023B4  48E7 FFFE               1601  ISADDAL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023B8  49F9 000046DE           1602          LEA         MESSAGEADDAL, A4
000023BE  4EB9 0000440E           1603          JSR    WRITE2MEM
000023C4  49F9 0000461A           1604          LEA    MESSAGESPACE, A4
000023CA  4EB9 0000440E           1605          JSR    WRITE2MEM
000023D0  4EB9 00002EC2           1606          JSR         EA_ADDA
000023D6  4CDF 7FFF               1607          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000023DA  4E75                    1608          RTS
000023DC                          1609  
000023DC  48E7 FFFE               1610  ISADDB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000023E0  49F9 000046C5           1611          LEA         MESSAGEADDB, A4
000023E6  4EB9 0000440E           1612          JSR    WRITE2MEM
000023EC  49F9 0000461A           1613          LEA    MESSAGESPACE, A4
000023F2  4EB9 0000440E           1614          JSR    WRITE2MEM
000023F8  4EB9 00002CF8           1615          JSR         EA_ADD
000023FE  4CDF 7FFF               1616          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002402  4E75                    1617          RTS
00002404                          1618  
00002404  48E7 FFFE               1619  ISADDW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002408  49F9 000046CB           1620          LEA         MESSAGEADDW, A4
0000240E  4EB9 0000440E           1621          JSR    WRITE2MEM
00002414  49F9 0000461A           1622          LEA    MESSAGESPACE, A4
0000241A  4EB9 0000440E           1623          JSR    WRITE2MEM
00002420  4EB9 00002CF8           1624          JSR         EA_ADD
00002426  4CDF 7FFF               1625          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000242A  4E75                    1626          RTS
0000242C                          1627  
0000242C  48E7 FFFE               1628  ISADDL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002430  49F9 000046D1           1629          LEA         MESSAGEADDL, A4
00002436  4EB9 0000440E           1630          JSR    WRITE2MEM
0000243C  49F9 0000461A           1631          LEA    MESSAGESPACE, A4
00002442  4EB9 0000440E           1632          JSR    WRITE2MEM
00002448  4EB9 00002CF8           1633          JSR         EA_ADD
0000244E  4CDF 7FFF               1634          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002452  4E75                    1635          RTS
00002454                          1636  
00002454  48E7 FFFE               1637  ISSUBB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002458  49F9 000046B3           1638          LEA         MESSAGESUBB, A4
0000245E  4EB9 0000440E           1639          JSR    WRITE2MEM
00002464  49F9 0000461A           1640          LEA    MESSAGESPACE, A4
0000246A  4EB9 0000440E           1641          JSR    WRITE2MEM
00002470  4EB9 000041F0           1642          JSR         EA_SUB
00002476  4CDF 7FFF               1643          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000247A  4E75                    1644          RTS
0000247C                          1645  
0000247C  48E7 FFFE               1646  ISSUBW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002480  49F9 000046B9           1647          LEA         MESSAGESUBW, A4
00002486  4EB9 0000440E           1648          JSR    WRITE2MEM
0000248C  49F9 0000461A           1649          LEA    MESSAGESPACE, A4
00002492  4EB9 0000440E           1650          JSR    WRITE2MEM
00002498  4EB9 000041F0           1651          JSR         EA_SUB
0000249E  4CDF 7FFF               1652          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024A2  4E75                    1653          RTS
000024A4                          1654  
000024A4  48E7 FFFE               1655  ISSUBL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024A8  49F9 000046BF           1656          LEA         MESSAGESUBL, A4
000024AE  4EB9 0000440E           1657          JSR    WRITE2MEM
000024B4  49F9 0000461A           1658          LEA    MESSAGESPACE, A4
000024BA  4EB9 0000440E           1659          JSR    WRITE2MEM
000024C0  4EB9 000041F0           1660          JSR         EA_SUB
000024C6  4CDF 7FFF               1661          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024CA  4E75                    1662          RTS
000024CC                          1663  
000024CC  48E7 FFFE               1664  ISCMPB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024D0  49F9 000046A1           1665          LEA         MESSAGECMPB, A4
000024D6  4EB9 0000440E           1666          JSR    WRITE2MEM
000024DC  49F9 0000461A           1667          LEA    MESSAGESPACE, A4
000024E2  4EB9 0000440E           1668          JSR    WRITE2MEM
000024E8  4EB9 0000360E           1669          JSR         EA_CMP
000024EE  4CDF 7FFF               1670          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000024F2  4E75                    1671          RTS
000024F4                          1672  
000024F4  48E7 FFFE               1673  ISCMPW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000024F8  49F9 000046A7           1674          LEA         MESSAGECMPW, A4
000024FE  4EB9 0000440E           1675          JSR    WRITE2MEM
00002504  49F9 0000461A           1676          LEA    MESSAGESPACE, A4
0000250A  4EB9 0000440E           1677          JSR    WRITE2MEM
00002510  4EB9 0000360E           1678          JSR         EA_CMP
00002516  4CDF 7FFF               1679          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000251A  4E75                    1680          RTS
0000251C                          1681  
0000251C  48E7 FFFE               1682  ISCMPL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002520  49F9 000046AD           1683          LEA         MESSAGECMPL, A4
00002526  4EB9 0000440E           1684          JSR    WRITE2MEM
0000252C  49F9 0000461A           1685          LEA    MESSAGESPACE, A4
00002532  4EB9 0000440E           1686          JSR    WRITE2MEM
00002538  4EB9 0000360E           1687          JSR         EA_CMP
0000253E  4CDF 7FFF               1688          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002542  4E75                    1689          RTS
00002544                          1690  
00002544  48E7 FFFE               1691  ISADDQB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002548  49F9 0000468C           1692          LEA         MESSAGEADDQB, A4
0000254E  4EB9 0000440E           1693          JSR    WRITE2MEM
00002554  49F9 0000461A           1694          LEA    MESSAGESPACE, A4
0000255A  4EB9 0000440E           1695          JSR    WRITE2MEM
00002560  4EB9 000030CE           1696          JSR         EA_ADDQ
00002566  4CDF 7FFF               1697          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000256A  4E75                    1698          RTS
0000256C                          1699  
0000256C  48E7 FFFE               1700  ISADDQW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002570  49F9 00004693           1701          LEA         MESSAGEADDQW, A4
00002576  4EB9 0000440E           1702          JSR    WRITE2MEM
0000257C  49F9 0000461A           1703          LEA    MESSAGESPACE, A4
00002582  4EB9 0000440E           1704          JSR    WRITE2MEM
00002588  4EB9 000030CE           1705          JSR         EA_ADDQ
0000258E  4CDF 7FFF               1706          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002592  4E75                    1707          RTS
00002594                          1708  
00002594  48E7 FFFE               1709  ISADDQL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002598  43F9 0000469A           1710          LEA         MESSAGEADDQL, A1 *OPCODE is ADDQ.L
0000259E  103C 000E               1711          MOVE.B      #14, D0
000025A2  4E4F                    1712          TRAP        #15
000025A4  4EB9 000030CE           1713          JSR         EA_ADDQ
000025AA  4CDF 7FFF               1714          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025AE  4E75                    1715          RTS
000025B0                          1716  
000025B0  48E7 FFFE               1717  ISMOVEQL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000025B4  49F9 000046E5           1718          LEA         MESSAGEMOVEQL, A4
000025BA  4EB9 0000440E           1719          JSR    WRITE2MEM
000025C0  49F9 0000461A           1720          LEA    MESSAGESPACE, A4
000025C6  4EB9 0000440E           1721          JSR    WRITE2MEM
000025CC  4EB9 00003DAE           1722          JSR         EA_MOVEQ
000025D2  4CDF 7FFF               1723          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025D6  4E75                    1724          RTS
000025D8                          1725  
000025D8  48E7 FFFE               1726  ISCLRB  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000025DC  49F9 0000467A           1727          LEA         MESSAGECLRB, A4
000025E2  4EB9 0000440E           1728          JSR    WRITE2MEM
000025E8  49F9 0000461A           1729          LEA    MESSAGESPACE, A4
000025EE  4EB9 0000440E           1730          JSR    WRITE2MEM
000025F4  4EB9 00003DAE           1731          JSR         EA_MOVEQ
000025FA  4CDF 7FFF               1732          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000025FE  4E75                    1733          RTS
00002600                          1734  
00002600  48E7 FFFE               1735  ISCLRW  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002604  49F9 00004680           1736          LEA         MESSAGECLRW, A4
0000260A  4EB9 0000440E           1737          JSR    WRITE2MEM
00002610  49F9 0000461A           1738          LEA    MESSAGESPACE, A4
00002616  4EB9 0000440E           1739          JSR    WRITE2MEM
0000261C  4EB9 00003546           1740          JSR         EA_CLR
00002622  4CDF 7FFF               1741          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002626  4E75                    1742          RTS
00002628                          1743  
00002628  48E7 FFFE               1744  ISCLRL  MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000262C  49F9 00004686           1745          LEA         MESSAGECLRL, A4
00002632  4EB9 0000440E           1746          JSR    WRITE2MEM
00002638  49F9 0000461A           1747          LEA    MESSAGESPACE, A4
0000263E  4EB9 0000440E           1748          JSR    WRITE2MEM
00002644  4EB9 00003546           1749          JSR         EA_CLR
0000264A  4CDF 7FFF               1750          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000264E  4E75                    1751          RTS
00002650                          1752  
00002650  48E7 FFFE               1753  ISMOVEML MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
00002654  49F9 0000465A           1754          LEA         MESSAGEMOVEML, A4
0000265A  4EB9 0000440E           1755          JSR    WRITE2MEM
00002660  49F9 0000461A           1756          LEA    MESSAGESPACE, A4
00002666  4EB9 0000440E           1757          JSR    WRITE2MEM
0000266C  4EB9 00003DA8           1758          JSR         EA_MOVEM
00002672  4CDF 7FFF               1759          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002676  4E75                    1760          RTS
00002678                          1761  
00002678  48E7 FFFE               1762  ISMOVEMW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
0000267C  49F9 00004662           1763          LEA         MESSAGEMOVEMW, A4
00002682  4EB9 0000440E           1764          JSR    WRITE2MEM
00002688  49F9 0000461A           1765          LEA    MESSAGESPACE, A4
0000268E  4EB9 0000440E           1766          JSR    WRITE2MEM
00002694  4EB9 00003DA8           1767          JSR         EA_MOVEM
0000269A  4CDF 7FFF               1768          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000269E  4E75                    1769          RTS
000026A0                          1770  
000026A0  48E7 FFFE               1771  ISLEA   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026A4  49F9 00004676           1772          LEA         MESSAGELEA, A4
000026AA  4EB9 0000440E           1773          JSR    WRITE2MEM
000026B0  49F9 0000461A           1774          LEA    MESSAGESPACE, A4
000026B6  4EB9 0000440E           1775          JSR    WRITE2MEM
000026BC  4EB9 000038A2           1776          JSR         EA_LEA
000026C2  4CDF 7FFF               1777          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026C6  4E75                    1778          RTS                         ; Exit subroutine
000026C8                          1779  
000026C8  48E7 FFFE               1780  ISJSR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026CC  49F9 0000466A           1781          LEA         MESSAGEJSR, A4
000026D2  4EB9 0000440E           1782          JSR    WRITE2MEM
000026D8  49F9 0000461A           1783          LEA    MESSAGESPACE, A4
000026DE  4EB9 0000440E           1784          JSR    WRITE2MEM
000026E4  4EB9 000037DA           1785          JSR         EA_JSR
000026EA  4CDF 7FFF               1786          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000026EE  4E75                    1787          RTS                         ; Exit subroutine
000026F0                          1788  
000026F0  48E7 FFFE               1789  ISRTS   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000026F4  49F9 00004672           1790          LEA         MESSAGERTS, A4
000026FA  4EB9 0000440E           1791          JSR    WRITE2MEM
00002700  49F9 0000461A           1792          LEA    MESSAGESPACE, A4
00002706  4EB9 0000440E           1793          JSR    WRITE2MEM
0000270C  548E                    1794          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
0000270E  4CDF 7FFF               1795          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002712  4E75                    1796          RTS
00002714                          1797  
00002714  48E7 FFFE               1798  ISCLR   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002718  49F9 0000466E           1799          LEA         MESSAGECLR, A4
0000271E  4EB9 0000440E           1800          JSR    WRITE2MEM
00002724  49F9 0000461A           1801          LEA    MESSAGESPACE, A4
0000272A  4EB9 0000440E           1802          JSR    WRITE2MEM
00002730  4EB9 00003546           1803          JSR         EA_CLR
00002736  4CDF 7FFF               1804          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000273A  4E75                    1805          RTS
0000273C                          1806  
0000273C  48E7 FFFE               1807  ISNOP   MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002740  49F9 0000461C           1808          LEA         MESSAGENOP, A4
00002746  4EB9 0000440E           1809          JSR    WRITE2MEM
0000274C  49F9 0000461A           1810          LEA    MESSAGESPACE, A4
00002752  4EB9 0000440E           1811          JSR    WRITE2MEM
00002758  548E                    1812          ADDA.L      #$00000002, A6      ; increment global pointer past current opcode word
0000275A  4CDF 7FFF               1813          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000275E  4E75                    1814          RTS                         ; Exit subroutine
00002760                          1815  
00002760  48E7 FFFE               1816  ISMOVEW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002764  49F9 00004620           1817          LEA         MESSAGEMOVEW, A4
0000276A  4EB9 0000440E           1818          JSR    WRITE2MEM
00002770  49F9 0000461A           1819          LEA    MESSAGESPACE, A4
00002776  4EB9 0000440E           1820          JSR    WRITE2MEM
0000277C  4EB9 00003AAE           1821          JSR         EA_MOVE
00002782  4CDF 7FFF               1822          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002786  4E75                    1823          RTS                         ; Exit subroutine
00002788                          1824  
00002788  48E7 FFFE               1825  ISMOVEAW MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
0000278C  49F9 00004652           1826          LEA         MESSAGEMOVEAW, A4
00002792  4EB9 0000440E           1827          JSR    WRITE2MEM
00002798  49F9 0000461A           1828          LEA    MESSAGESPACE, A4
0000279E  4EB9 0000440E           1829          JSR    WRITE2MEM
000027A4  4EB9 00003C82           1830          JSR         EA_MOVEA
000027AA  4CDF 7FFF               1831          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027AE  4E75                    1832          RTS                         ; Exit subroutine
000027B0                          1833  
000027B0  48E7 FFFE               1834  ISMOVEL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
000027B4  49F9 00004627           1835          LEA         MESSAGEMOVEL, A4
000027BA  4EB9 0000440E           1836          JSR    WRITE2MEM
000027C0  49F9 0000461A           1837          LEA    MESSAGESPACE, A4
000027C6  4EB9 0000440E           1838          JSR    WRITE2MEM
000027CC  4EB9 00003AAE           1839          JSR         EA_MOVE
000027D2  4CDF 7FFF               1840          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027D6  4E75                    1841          RTS                         ; Exit subroutine
000027D8                          1842  
000027D8  48E7 FFFE               1843  ISMOVEAL MOVEM.L    A0-A6/D0-D7, -(SP) ; Save registers
000027DC  49F9 0000464A           1844          LEA         MESSAGEMOVEAL, A4
000027E2  4EB9 0000440E           1845          JSR    WRITE2MEM
000027E8  49F9 0000461A           1846          LEA    MESSAGESPACE, A4
000027EE  4EB9 0000440E           1847          JSR    WRITE2MEM
000027F4  4EB9 00003C82           1848          JSR         EA_MOVEA
000027FA  4CDF 7FFF               1849          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
000027FE  4E75                    1850          RTS                         ; Exit subroutine
00002800                          1851  
00002800  48E7 FFFE               1852  ISMOVEB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002804  49F9 0000462E           1853          LEA         MESSAGEMOVEB, A4
0000280A  4EB9 0000440E           1854          JSR    WRITE2MEM
00002810  49F9 0000461A           1855          LEA    MESSAGESPACE, A4
00002816  4EB9 0000440E           1856          JSR    WRITE2MEM
0000281C  4EB9 00003AAE           1857          JSR         EA_MOVE
00002822  4CDF 7FFF               1858          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002826  4E75                    1859          RTS                         ; Exit subroutine
00002828                          1860  
00002828  48E7 FFFE               1861  ISADDIW MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000282C  49F9 00004635           1862          LEA         MESSAGEADDIW, A4
00002832  4EB9 0000440E           1863          JSR    WRITE2MEM
00002838  49F9 0000461A           1864          LEA    MESSAGESPACE, A4
0000283E  4EB9 0000440E           1865          JSR    WRITE2MEM
00002844  4EB9 00002FB2           1866          JSR         EA_ADDI
0000284A  4CDF 7FFF               1867          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000284E  4E75                    1868          RTS                         ; Exit subroutine
00002850                          1869  
00002850  48E7 FFFE               1870  ISADDIL MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
00002854  49F9 0000463C           1871          LEA         MESSAGEADDIL, A4
0000285A  4EB9 0000440E           1872          JSR    WRITE2MEM
00002860  49F9 0000461A           1873          LEA    MESSAGESPACE, A4
00002866  4EB9 0000440E           1874          JSR    WRITE2MEM
0000286C  4EB9 00002FB2           1875          JSR         EA_ADDI
00002872  4CDF 7FFF               1876          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
00002876  4E75                    1877          RTS                         ; Exit subroutine
00002878                          1878  
00002878  48E7 FFFE               1879  ISADDIB MOVEM.L     A0-A6/D0-D7, -(SP) ; Save registers
0000287C  49F9 00004643           1880          LEA         MESSAGEADDIB, A4
00002882  4EB9 0000440E           1881          JSR    WRITE2MEM
00002888  49F9 0000461A           1882          LEA    MESSAGESPACE, A4
0000288E  4EB9 0000440E           1883          JSR    WRITE2MEM
00002894  4EB9 00002FB2           1884          JSR         EA_ADDI
0000289A  4CDF 7FFF               1885          MOVEM.L     (SP)+,  A0-A6/D0-D7 ; Restore registers
0000289E  4E75                    1886          RTS                         ; Exit subroutine
000028A0                          1887  
000028A0                          1888  
000028A0                          1889  
000028A0                          1890  
000028A0                          1891  
000028A0                          1892  
000028A0                          1893  
000028A0                          1894  
000028A0                          1895  -------------------- end include --------------------
000028A0                          1896      INCLUDE 'EA.X68'
000028A0                          1897  
000028A0                          1898      INCLUDE 'EA_UTIL.X68'
000028A0                          1899  
000028A0                          1900  
000028A0                          1901  EA_UNIMPLEMENTED:
000028A0  548E                    1902      ADDA.L      #$00000002, A6      ; Increment past current opcode word
000028A2  49F9 000047ED           1903      LEA         EA_MSG_UNIMP, A4
000028A8  4EB9 0000440E           1904      JSR         WRITE2MEM
000028AE  4E75                    1905      RTS
000028B0                          1906  
000028B0                          1907  EA_INVALID:
000028B0  2A4E                    1908      MOVEA.L     A6, A5              ; Copy global pointer
000028B2  548D                    1909      ADDA.L      #$00000002, A5      ; Increment past current opcode word
000028B4  4EB8 1326               1910      JSR         INVALID_DATA        ; Print data error message
000028B8  4E75                    1911      RTS
000028BA                          1912  
000028BA                          1913  EA_PRINT_DATA:
000028BA  49F9 00004807           1914      LEA         EA_MSG_PRINT_DATA, A4
000028C0  4EB9 0000440E           1915      JSR         WRITE2MEM
000028C6  4E75                    1916      RTS
000028C8                          1917  
000028C8                          1918  
000028C8                          1919  EA_UPDATE_POINTER:
000028C8  BDCD                    1920      CMP.L       A5, A6              ; Check if A5==A6
000028CA  6600 0004               1921      BNE         UPDATE_PTR          ; If NOT equal (a.k.a if any extra operands
000028CE                          1922                                      ; were read, and is already up to date),
000028CE                          1923                                      ; update global with current
000028CE  548D                    1924      ADDA.L      #$00000002, A5      ; Else, increment past current opcode word, then update
000028D0                          1925  UPDATE_PTR:
000028D0  2C4D                    1926      MOVEA.L     A5, A6              ; Update global pointer
000028D2  4E75                    1927      RTS
000028D4                          1928  
000028D4                          1929  EA_COPY_PTR:
000028D4  2A4E                    1930      MOVEA.L     A6, A5              ; Save global pointer
000028D6  4E75                    1931      RTS
000028D8                          1932  
000028D8                          1933  EA_DEFAULT_COMBO:
000028D8  4286                    1934      CLR.L       D6                  ; Clear space for mode bits
000028DA  4287                    1935      CLR.L       D7                  ; Clear space for register bits
000028DC  2216                    1936      MOVE.L      (A6), D1            ; Load opcode to data register 1
000028DE  143C 000A               1937      MOVE.B      #10, D2             ; Clear upper 10 bits of opcode word
000028E2  E569                    1938      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000028E4  143C 000D               1939      MOVE.B      #13, D2             ; 'Right-align' bits 3-5 to determine mode bits
000028E8  E469                    1940      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000028EA  1C01                    1941      MOVE.B      D1, D6              ; Save mode bits to D6
000028EC  2216                    1942      MOVE.L      (A6), D1            ; Reload opcode to data register 1
000028EE  143C 000D               1943      MOVE.B      #13, D2             ; Clear upper 13 bits of opcode word
000028F2  E569                    1944      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000028F4  143C 000D               1945      MOVE.B      #13, D2             ; 'Right-align' bits 0-2 to determine register bits
000028F8  E469                    1946      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000028FA  1E01                    1947      MOVE.B      D1, D7              ; Save register bits to D7
000028FC  4E75                    1948      RTS                             ; Return from subroutine
000028FE                          1949  
000028FE                          1950  EA_OPMODE_COMBO:
000028FE  4286                    1951      CLR.L       D6                  ; Clear space for mode bits
00002900  4287                    1952      CLR.L       D7                  ; Clear space for register bits
00002902  2216                    1953      MOVE.L      (A6), D1            ; Load opcode to data register 1
00002904  143C 0007               1954      MOVE.B      #7, D2              ; Clear upper 7 bits of opcode word
00002908  E569                    1955      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
0000290A  143C 000D               1956      MOVE.B      #13, D2             ; 'Right-align' bits 6-8 to determine opmode bits
0000290E  E469                    1957      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002910  1C01                    1958      MOVE.B      D1, D6              ; Save opmode bits to D6
00002912  2216                    1959      MOVE.L      (A6), D1            ; Reload opcode to data register 1
00002914  143C 0004               1960      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00002918  E569                    1961      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
0000291A  143C 000D               1962      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register bits
0000291E  E469                    1963      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00002920  1E01                    1964      MOVE.B      D1, D7              ; Save register bits to D7
00002922  4E75                    1965      RTS                             ; Return from subroutine
00002924                          1966  
00002924                          1967  EA_SIZE_BITS:
00002924  4287                    1968      CLR.L       D7
00002926  2E16                    1969      MOVE.L      (A6), D7            ; Load opcode to data register 1
00002928  143C 0008               1970      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
0000292C  E56F                    1971      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
0000292E  143C 000E               1972      MOVE.B      #14, D2             ; 'Right-align' bits 6-7 to determine size bits
00002932  E46F                    1973      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00002934  4E75                    1974      RTS
00002936                          1975  
00002936                          1976  
00002936                          1977  EA_PRINT_DN:
00002936  41F9 00002944           1978      LEA         EA_PRINT_DN_JMP, A0 ; Set index '0' for jump table
0000293C  CEFC 0006               1979      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002940  4EF0 7000               1980      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002944                          1981  EA_PRINT_DN_JMP:
00002944  4EF9 00002974           1982      JMP         DN_000 ; D0
0000294A  4EF9 00002980           1983      JMP         DN_001 ; D1
00002950  4EF9 0000298C           1984      JMP         DN_010 ; D2
00002956  4EF9 00002998           1985      JMP         DN_011 ; D3
0000295C  4EF9 000029A4           1986      JMP         DN_100 ; D4
00002962  4EF9 000029B0           1987      JMP         DN_101 ; D5
00002968  4EF9 000029BC           1988      JMP         DN_110 ; D6
0000296E  4EF9 000029C8           1989      JMP         DN_111 ; D7
00002974                          1990  DN_000: ; D0
00002974  49F9 000047BD           1991      LEA         EA_MSG_D0, A4
0000297A  4EB9 0000440E           1992      JSR         WRITE2MEM
00002980                          1993  DN_001: ; D1
00002980  49F9 000047C0           1994      LEA         EA_MSG_D1, A4
00002986  4EB9 0000440E           1995      JSR         WRITE2MEM
0000298C                          1996  DN_010: ; D2
0000298C  49F9 000047C3           1997      LEA         EA_MSG_D2, A4
00002992  4EB9 0000440E           1998      JSR         WRITE2MEM
00002998                          1999  DN_011: ; D3
00002998  49F9 000047C6           2000      LEA         EA_MSG_D3, A4
0000299E  4EB9 0000440E           2001      JSR         WRITE2MEM
000029A4                          2002  DN_100: ; D4
000029A4  49F9 000047C9           2003      LEA         EA_MSG_D4, A4
000029AA  4EB9 0000440E           2004      JSR         WRITE2MEM
000029B0                          2005  DN_101: ; D5
000029B0  49F9 000047CC           2006      LEA         EA_MSG_D5, A4
000029B6  4EB9 0000440E           2007      JSR         WRITE2MEM
000029BC                          2008  DN_110: ; D6
000029BC  49F9 000047CF           2009      LEA         EA_MSG_D6, A4
000029C2  4EB9 0000440E           2010      JSR         WRITE2MEM
000029C8                          2011  DN_111: ; D7
000029C8  49F9 000047D2           2012      LEA         EA_MSG_D7, A4
000029CE  4EB9 0000440E           2013      JSR         WRITE2MEM
000029D4                          2014  
000029D4                          2015  EA_PRINT_DN_END:
000029D4  4E75                    2016      RTS
000029D6                          2017  
000029D6                          2018  EA_PRINT_AN:
000029D6  41F9 000029E4           2019      LEA         AN_JMP, A0          ; Set index '0' for jump table
000029DC  CEFC 0006               2020      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000029E0  4EF0 7000               2021      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000029E4                          2022  AN_JMP:
000029E4  4EF9 00002A14           2023      JMP         AN_000 ; A0
000029EA  4EF9 00002A20           2024      JMP         AN_001 ; A1
000029F0  4EF9 00002A2C           2025      JMP         AN_010 ; A2
000029F6  4EF9 00002A38           2026      JMP         AN_011 ; A3
000029FC  4EF9 00002A44           2027      JMP         AN_100 ; A4
00002A02  4EF9 00002A50           2028      JMP         AN_101 ; A5
00002A08  4EF9 00002A5C           2029      JMP         AN_110 ; A6
00002A0E  4EF9 00002A68           2030      JMP         AN_111 ; A7
00002A14                          2031  AN_000: ; A0
00002A14  49F9 000047D5           2032      LEA         EA_MSG_A0, A4
00002A1A  4EB9 0000440E           2033      JSR         WRITE2MEM
00002A20                          2034  AN_001: ; A1
00002A20  49F9 000047D8           2035      LEA         EA_MSG_A1, A4
00002A26  4EB9 0000440E           2036      JSR         WRITE2MEM
00002A2C                          2037  AN_010: ; A2
00002A2C  49F9 000047DB           2038      LEA         EA_MSG_A2, A4
00002A32  4EB9 0000440E           2039      JSR         WRITE2MEM
00002A38                          2040  AN_011: ; A3
00002A38  49F9 000047DE           2041      LEA         EA_MSG_A3, A4
00002A3E  4EB9 0000440E           2042      JSR         WRITE2MEM
00002A44                          2043  AN_100: ; A4
00002A44  49F9 000047E1           2044      LEA         EA_MSG_A4, A4
00002A4A  4EB9 0000440E           2045      JSR         WRITE2MEM
00002A50                          2046  AN_101: ; A5
00002A50  49F9 000047E4           2047      LEA         EA_MSG_A5, A4
00002A56  4EB9 0000440E           2048      JSR         WRITE2MEM
00002A5C                          2049  AN_110: ; A6
00002A5C  49F9 000047E7           2050      LEA         EA_MSG_A6, A4
00002A62  4EB9 0000440E           2051      JSR         WRITE2MEM
00002A68                          2052  AN_111: ; A7
00002A68  49F9 000047EA           2053      LEA         EA_MSG_A7, A4
00002A6E  4EB9 0000440E           2054      JSR         WRITE2MEM
00002A74                          2055  
00002A74                          2056  EA_PRINT_AN_END:
00002A74  4E75                    2057      RTS
00002A76                          2058  EA_PRINT_IND:
00002A76  49F9 000048EB           2059      LEA         OPAREN, A4    ; Print open parentheses
00002A7C  4EB9 0000440E           2060      JSR         WRITE2MEM
00002A82  41F9 00002A90           2061      LEA         IND_JMP, A0         ; Set index '0' for jump table
00002A88  CEFC 0006               2062      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002A8C  4EF0 7000               2063      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002A90                          2064  IND_JMP:
00002A90  4EF9 00002AC0           2065      JMP         IND_000 ; (A0)
00002A96  4EF9 00002ACC           2066      JMP         IND_001 ; (A1)
00002A9C  4EF9 00002AD8           2067      JMP         IND_010 ; (A2)
00002AA2  4EF9 00002AE4           2068      JMP         IND_011 ; (A3)
00002AA8  4EF9 00002AF0           2069      JMP         IND_100 ; (A4)
00002AAE  4EF9 00002AFC           2070      JMP         IND_101 ; (A5)
00002AB4  4EF9 00002B08           2071      JMP         IND_110 ; (A6)
00002ABA  4EF9 00002B14           2072      JMP         IND_111 ; (A7)
00002AC0                          2073  IND_000: ; (A0)
00002AC0  49F9 000047D5           2074      LEA         EA_MSG_A0, A4
00002AC6  4EB9 0000440E           2075      JSR         WRITE2MEM
00002ACC                          2076  IND_001: ; (A1)
00002ACC  49F9 000047D8           2077      LEA         EA_MSG_A1, A4
00002AD2  4EB9 0000440E           2078      JSR         WRITE2MEM
00002AD8                          2079  IND_010: ; (A2)
00002AD8  49F9 000047DB           2080      LEA         EA_MSG_A2, A4
00002ADE  4EB9 0000440E           2081      JSR         WRITE2MEM
00002AE4                          2082  IND_011: ; (A3)
00002AE4  49F9 000047DE           2083      LEA         EA_MSG_A3, A4
00002AEA  4EB9 0000440E           2084      JSR         WRITE2MEM
00002AF0                          2085  IND_100: ; (A4)
00002AF0  49F9 000047E1           2086      LEA         EA_MSG_A4, A4
00002AF6  4EB9 0000440E           2087      JSR         WRITE2MEM
00002AFC                          2088  IND_101: ; (A5)
00002AFC  49F9 000047E4           2089      LEA         EA_MSG_A5, A4
00002B02  4EB9 0000440E           2090      JSR         WRITE2MEM
00002B08                          2091  IND_110: ; (A6)
00002B08  49F9 000047E7           2092      LEA         EA_MSG_A6, A4
00002B0E  4EB9 0000440E           2093      JSR         WRITE2MEM
00002B14                          2094  IND_111: ; (A7)
00002B14  49F9 000047EA           2095      LEA         EA_MSG_A7, A4
00002B1A  4EB9 0000440E           2096      JSR         WRITE2MEM
00002B20                          2097  EA_PRINT_IND_END:
00002B20  49F9 000048ED           2098      LEA         CPAREN, A4   ; Print close parentheses
00002B26  4EB9 0000440E           2099      JSR         WRITE2MEM
00002B2C  4E75                    2100      RTS
00002B2E                          2101  EA_PRINT_IMM:
00002B2E  224D                    2102      MOVEA.L     A5, A1              ; copy pointer to temp
00002B30  5489                    2103      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002B32  BA7C 0003               2104      CMP         #3, D5
00002B36  6700 0010               2105      BEQ         PRINT_IMM_L         ; if L, branch
00002B3A  3011                    2106      MOVE.W      (A1), D0            ; store value in a register (todo, register tbd)
00002B3C  4EB8 28BA               2107      JSR         EA_PRINT_DATA *print value TODO
00002B40  5489                    2108      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002B42  4EF9 00002B4C           2109      JMP         PRINT_IMM_END
00002B48                          2110  PRINT_IMM_L:
00002B48  2011                    2111      MOVE.L      (A1), D0            ; store value in a register (todo, register tbd)
00002B4A                          2112      *print value TODO
00002B4A  5889                    2113      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002B4C                          2114  PRINT_IMM_END:
00002B4C  2A49                    2115      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002B4E  4E75                    2116      RTS
00002B50                          2117  EA_PRINT_POSTINC:
00002B50  49F9 000048EB           2118      LEA         OPAREN, A4    ; Print open parentheses
00002B56  4EB9 0000440E           2119      JSR         WRITE2MEM
00002B5C  41F9 00002B6A           2120      LEA         POSTINC_JMP, A0     ; Set index '0' for jump table
00002B62  CEFC 0006               2121      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002B66  4EF0 7000               2122      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002B6A                          2123  POSTINC_JMP:
00002B6A  4EF9 00002B9A           2124      JMP         POSTINC_000 ; (A0)+
00002B70  4EF9 00002BA6           2125      JMP         POSTINC_001 ; (A1)+
00002B76  4EF9 00002BB2           2126      JMP         POSTINC_010 ; (A2)+
00002B7C  4EF9 00002BBE           2127      JMP         POSTINC_011 ; (A3)+
00002B82  4EF9 00002BCA           2128      JMP         POSTINC_100 ; (A4)+
00002B88  4EF9 00002BD6           2129      JMP         POSTINC_101 ; (A5)+
00002B8E  4EF9 00002BE2           2130      JMP         POSTINC_110 ; (A6)+
00002B94  4EF9 00002BEE           2131      JMP         POSTINC_111 ; (A7)+
00002B9A                          2132  POSTINC_000: ; (A0)+
00002B9A  49F9 000047D5           2133      LEA         EA_MSG_A0, A4
00002BA0  4EB9 0000440E           2134      JSR         WRITE2MEM
00002BA6                          2135  POSTINC_001: ; (A1)+
00002BA6  49F9 000047D8           2136      LEA         EA_MSG_A1, A4
00002BAC  4EB9 0000440E           2137      JSR         WRITE2MEM
00002BB2                          2138  POSTINC_010: ; (A2)+
00002BB2  49F9 000047DB           2139      LEA         EA_MSG_A2, A4
00002BB8  4EB9 0000440E           2140      JSR         WRITE2MEM
00002BBE                          2141  POSTINC_011: ; (A3)+
00002BBE  49F9 000047DE           2142      LEA         EA_MSG_A3, A4
00002BC4  4EB9 0000440E           2143      JSR         WRITE2MEM
00002BCA                          2144  POSTINC_100: ; (A4)+
00002BCA  49F9 000047E1           2145      LEA         EA_MSG_A4, A4
00002BD0  4EB9 0000440E           2146      JSR         WRITE2MEM
00002BD6                          2147  POSTINC_101: ; (A5)+
00002BD6  49F9 000047E4           2148      LEA         EA_MSG_A5, A4
00002BDC  4EB9 0000440E           2149      JSR         WRITE2MEM
00002BE2                          2150  POSTINC_110: ; (A6)+
00002BE2  49F9 000047E7           2151      LEA         EA_MSG_A6, A4
00002BE8  4EB9 0000440E           2152      JSR         WRITE2MEM
00002BEE                          2153  POSTINC_111: ; (A7)+
00002BEE  49F9 000047EA           2154      LEA         EA_MSG_A7, A4
00002BF4  4EB9 0000440E           2155      JSR         WRITE2MEM
00002BFA                          2156  EA_PRINT_PI_END:
00002BFA  49F9 000048ED           2157      LEA         CPAREN, A4   ; Print close parentheses
00002C00  4EB9 0000440E           2158      JSR         WRITE2MEM
00002C06  49F9 000048EF           2159      LEA         PLUS, A4         ; Print plus sign
00002C0C  4EB9 0000440E           2160      JSR         WRITE2MEM
00002C12  4E75                    2161      RTS
00002C14                          2162  EA_PRINT_PREDEC:
00002C14  49F9 000048F1           2163      LEA         MINUS, A4               ; Print minus sign
00002C1A  4EB9 0000440E           2164      JSR         WRITE2MEM
00002C20  49F9 000048EB           2165      LEA         OPAREN, A4              ; Print open parentheses
00002C26  4EB9 0000440E           2166      JSR         WRITE2MEM
00002C2C  41F9 00002C3A           2167      LEA         PREDEC_JMP, A0      ; Set index '0' for jump table
00002C32  CEFC 0006               2168      MULU        #6, D7              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002C36  4EF0 7000               2169      JMP         0(A0, D7)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002C3A                          2170  PREDEC_JMP:
00002C3A  4EF9 00002C6A           2171      JMP         PREDEC_000 ; -(A0)
00002C40  4EF9 00002C76           2172      JMP         PREDEC_001 ; -(A1)
00002C46  4EF9 00002C82           2173      JMP         PREDEC_010 ; -(A2)
00002C4C  4EF9 00002C8E           2174      JMP         PREDEC_011 ; -(A3)
00002C52  4EF9 00002C9A           2175      JMP         PREDEC_100 ; -(A4)
00002C58  4EF9 00002CA6           2176      JMP         PREDEC_101 ; -(A5)
00002C5E  4EF9 00002CB2           2177      JMP         PREDEC_110 ; -(A6)
00002C64  4EF9 00002CBE           2178      JMP         PREDEC_111 ; -(A7)
00002C6A                          2179  
00002C6A                          2180  PREDEC_000: ; -(A0)
00002C6A  49F9 000047D5           2181      LEA         EA_MSG_A0, A4
00002C70  4EB9 0000440E           2182      JSR         WRITE2MEM
00002C76                          2183  PREDEC_001: ; -(A1)
00002C76  49F9 000047D8           2184      LEA         EA_MSG_A1, A4
00002C7C  4EB9 0000440E           2185      JSR         WRITE2MEM
00002C82                          2186  PREDEC_010: ; -(A2)
00002C82  49F9 000047DB           2187      LEA         EA_MSG_A2, A4
00002C88  4EB9 0000440E           2188      JSR         WRITE2MEM
00002C8E                          2189  PREDEC_011: ; -(A3)
00002C8E  49F9 000047DE           2190      LEA         EA_MSG_A3, A4
00002C94  4EB9 0000440E           2191      JSR         WRITE2MEM
00002C9A                          2192  PREDEC_100: ; -(A4)
00002C9A  49F9 000047E1           2193      LEA         EA_MSG_A4, A4
00002CA0  4EB9 0000440E           2194      JSR         WRITE2MEM
00002CA6                          2195  PREDEC_101: ; -(A5)
00002CA6  49F9 000047E4           2196      LEA         EA_MSG_A5, A4
00002CAC  4EB9 0000440E           2197      JSR         WRITE2MEM
00002CB2                          2198  PREDEC_110: ; -(A6)
00002CB2  49F9 000047E7           2199      LEA         EA_MSG_A6, A4
00002CB8  4EB9 0000440E           2200      JSR         WRITE2MEM
00002CBE                          2201  PREDEC_111: ; -(A7)
00002CBE  49F9 000047EA           2202      LEA         EA_MSG_A7, A4
00002CC4  4EB9 0000440E           2203      JSR         WRITE2MEM
00002CCA                          2204  
00002CCA                          2205  EA_PRINT_PD_END:
00002CCA  49F9 000048ED           2206      LEA         CPAREN, A4   ; Print close parentheses
00002CD0  4EB9 0000440E           2207      JSR         WRITE2MEM
00002CD6  4E75                    2208      RTS
00002CD8                          2209  EA_PRINT_ABS_L:
00002CD8  224D                    2210      MOVEA.L     A5, A1              ; copy pointer to temp
00002CDA  5489                    2211      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002CDC  2011                    2212      MOVE.L      (A1), D0            ; store longword address to print TODO
00002CDE  4EB8 28BA               2213      JSR         EA_PRINT_DATA *print value TODO
00002CE2  5889                    2214      ADDA.L      #$00000004, A1      ; move temp pointer past longword that has been read
00002CE4  2A49                    2215      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002CE6  4E75                    2216      RTS
00002CE8                          2217  EA_PRINT_ABS_W:
00002CE8  224D                    2218      MOVEA.L     A5, A1              ; copy pointer to temp
00002CEA  5489                    2219      ADDA.L      #$00000002, A1      ; Advance temp pointer to next word
00002CEC  2011                    2220      MOVE.L      (A1), D0            ; store word address to print in TODO
00002CEE  4EB8 28BA               2221      JSR         EA_PRINT_DATA *print value TODO
00002CF2  5489                    2222      ADDA.L      #$00000002, A1      ; move temp pointer past word that has been read
00002CF4  2A49                    2223      MOVEA.L     A1, A5              ; store new pointer location to pass back
00002CF6  4E75                    2224      RTS
00002CF8                          2225  
00002CF8                          2226  
00002CF8                          2227  -------------------- end include --------------------
00002CF8                          2228  
00002CF8                          2229  EA_ADD:
00002CF8  48E7 FFFC               2230      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002CFC  4EB8 28D4               2231      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002D00  4EB8 28FE               2232      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00002D04  41F9 00002D12           2233      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
00002D0A  CCFC 0006               2234      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002D0E  4EF0 6000               2235      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002D12                          2236  ADD_OPMODE:
00002D12  4EF9 00002D42           2237      JMP         ADD_OPMODE_000      ; mode 1, byte
00002D18  4EF9 00002D4C           2238      JMP         ADD_OPMODE_001      ; mode 1, word
00002D1E  4EF9 00002D56           2239      JMP         ADD_OPMODE_010      ; mode 1, long
00002D24  4EF9 00002D60           2240      JMP         ADD_OPMODE_011      ; Invalid value
00002D2A  4EF9 00002D6A           2241      JMP         ADD_OPMODE_100      ; mode 2, byte
00002D30  4EF9 00002D74           2242      JMP         ADD_OPMODE_101      ; mode 2, word
00002D36  4EF9 00002D7E           2243      JMP         ADD_OPMODE_110      ; mode 2, long
00002D3C  4EF9 00002D88           2244      JMP         ADD_OPMODE_111      ; Invalid value
00002D42                          2245  ADD_OPMODE_000: ; mode 1, byte
00002D42  1A3C 0001               2246      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002D46  4EF9 00002D92           2247      JMP         ADD_MODE_1
00002D4C                          2248  ADD_OPMODE_001: ; mode 1, word
00002D4C  1A3C 0002               2249      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00002D50  4EF9 00002D92           2250      JMP         ADD_MODE_1
00002D56                          2251  ADD_OPMODE_010: ; mode 1, long
00002D56  1A3C 0003               2252      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00002D5A  4EF9 00002D92           2253      JMP         ADD_MODE_1
00002D60                          2254  ADD_OPMODE_011: ; Invalid value
00002D60  4EB8 28B0               2255      JSR         EA_INVALID
00002D64  4EF9 00002EB8           2256      JMP         ADD_END
00002D6A                          2257  ADD_OPMODE_100: ; mode 2, byte
00002D6A  1A3C 0001               2258      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002D6E  4EF9 00002DBC           2259      JMP         ADD_MODE_2
00002D74                          2260  ADD_OPMODE_101: ; mode 2, word
00002D74  1A3C 0001               2261      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002D78  4EF9 00002DBC           2262      JMP         ADD_MODE_2
00002D7E                          2263  ADD_OPMODE_110: ; mode 2, long
00002D7E  1A3C 0001               2264      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00002D82  4EF9 00002DBC           2265      JMP         ADD_MODE_2
00002D88                          2266  ADD_OPMODE_111: ; Invalid value
00002D88  4EB8 28B0               2267      JSR         EA_INVALID
00002D8C  4EF9 00002EB8           2268      JMP         ADD_END
00002D92                          2269  ADD_MODE_1:
00002D92  4280                    2270      CLR.L       D0                  ; Clear data register 0
00002D94  103C 0001               2271      MOVE.B      #1, D0              ; Save mode number to D0
00002D98  3207                    2272      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00002D9A  4EB8 28D8               2273      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002D9E  4EB9 00002DE2           2274      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002DA4  49F9 000048E8           2275      LEA         COMMA, A4        ; Print comma
00002DAA  4EB9 0000440E           2276      JSR         WRITE2MEM
00002DB0  3E01                    2277      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00002DB2  4EB8 2936               2278      JSR         EA_PRINT_DN         ; Print data register
00002DB6  4EF9 00002EB8           2279      JMP         ADD_END
00002DBC                          2280  ADD_MODE_2:
00002DBC  4280                    2281      CLR.L       D0                  ; Clear data register 0
00002DBE  103C 0002               2282      MOVE.B      #2, D0              ; Save mode number to D0
00002DC2  4EB8 2936               2283      JSR         EA_PRINT_DN         ; Print data register
00002DC6  49F9 000048E8           2284      LEA         COMMA, A4        ; Print comma
00002DCC  4EB9 0000440E           2285      JSR         WRITE2MEM
00002DD2  4EB8 28D8               2286      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00002DD6  4EB9 00002DE2           2287      JSR         ADD_EVAL_EA         ; Evaluate the results of subroutine call
00002DDC  4EF9 00002EB8           2288      JMP         ADD_END
00002DE2                          2289  ADD_EVAL_EA:
00002DE2  41F9 00002DF0           2290      LEA         ADD_MODE, A0        ; Set index '0' for jump table
00002DE8  CCFC 0006               2291      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002DEC  4EF0 6000               2292      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002DF0                          2293  ADD_MODE:
00002DF0  4EF9 00002E20           2294      JMP         ADD_MODE_000        ; Dn (invalid if opmode 2)
00002DF6  4EF9 00002E32           2295      JMP         ADD_MODE_001        ; An (invalid if opmode 2)
00002DFC  4EF9 00002E44           2296      JMP         ADD_MODE_010        ; (An)
00002E02  4EF9 00002E4E           2297      JMP         ADD_MODE_011        ; (An)+
00002E08  4EF9 00002E58           2298      JMP         ADD_MODE_100        ; -(An)
00002E0E  4EF9 00002E62           2299      JMP         ADD_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00002E14  4EF9 00002E68           2300      JMP         ADD_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002E1A  4EF9 00002E6E           2301      JMP         ADD_MODE_111        ; The rest (not all valid, validated by register number)
00002E20                          2302  ADD_MODE_000: ; Dn (invalid if opmode 2)
00002E20  B07C 0002               2303      CMP         #2, D0
00002E24  6700 008E               2304      BEQ         ADD_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00002E28  4EB8 2936               2305      JSR         EA_PRINT_DN         ; Print data register direct operand
00002E2C  4EF9 00002EB2           2306      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E32                          2307  ADD_MODE_001: ; An (invalid if opmode 2)
00002E32  B07C 0002               2308      CMP         #2, D0
00002E36  6700 007C               2309      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002E3A  4EB8 29D6               2310      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002E3E  4EF9 00002EB2           2311      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E44                          2312  ADD_MODE_010: ; (An)
00002E44  4EB8 2A76               2313      JSR         EA_PRINT_IND         ; Print address register indirect
00002E48  4EF9 00002EB2           2314      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E4E                          2315  ADD_MODE_011: ; (An)+
00002E4E  4EB8 2B50               2316      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002E52  4EF9 00002EB2           2317      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E58                          2318  ADD_MODE_100: ; -(An)
00002E58  4EB8 2C14               2319      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002E5C  4EF9 00002EB2           2320      JMP         ADD_MODE_END        ; End evaluation of ea mode
00002E62                          2321  ADD_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002E62  4EF9 00002EB4           2322      JMP         ADD_MODE_INVALID
00002E68                          2323  ADD_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002E68  4EF9 00002EB4           2324      JMP         ADD_MODE_INVALID
00002E6E                          2325  ADD_MODE_111: ; The rest (not all valid, validated by register number)
00002E6E  BE3C 0000               2326      CMP.B       #$00, D7            ; Test for absolute word address
00002E72  6700 0018               2327      BEQ         ADD_ABS_W
00002E76  BE3C 0001               2328      CMP.B       #$01, D7            ; Test for absolute long address
00002E7A  6700 001A               2329      BEQ         ADD_ABS_L
00002E7E  BE3C 0004               2330      CMP.B       #$04, D7            ; Test for immediate data
00002E82  6700 001C               2331      BEQ         ADD_IMM
00002E86  4EF9 00002EB4           2332      JMP         ADD_MODE_INVALID    ; else, invalid
00002E8C                          2333  ADD_ABS_W:
00002E8C  4EB8 2CE8               2334      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002E90  4EF9 00002EB2           2335      JMP         ADD_MODE_END
00002E96                          2336  ADD_ABS_L:
00002E96  4EB8 2CD8               2337      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002E9A  4EF9 00002EB2           2338      JMP         ADD_MODE_END
00002EA0                          2339  ADD_IMM: ; invalid if opmode is 2
00002EA0  B07C 0002               2340      CMP         #2, D0
00002EA4  6700 000E               2341      BEQ         ADD_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00002EA8  4EB8 2B2E               2342      JSR         EA_PRINT_IMM        ; Print immediate data
00002EAC  4EF9 00002EB2           2343      JMP         ADD_MODE_END
00002EB2                          2344  ADD_MODE_END:
00002EB2  4E75                    2345      RTS                             ; Finish evaluating EA bits
00002EB4                          2346  ADD_MODE_INVALID:
00002EB4  4EB8 28B0               2347      JSR         EA_INVALID          ; Opcode word is Invalid, then end
00002EB8                          2348  ADD_END:
00002EB8  4EB8 28C8               2349      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00002EBC  4CDF 3FFF               2350      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002EC0  4E75                    2351      RTS
00002EC2                          2352  
00002EC2                          2353  EA_ADDA:
00002EC2  48E7 FFFC               2354      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002EC6  4EB8 28D4               2355      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002ECA  4EB8 28D8               2356      JSR         EA_DEFAULT_COMBO    ; Mode: D6, register: D7
00002ECE  41F9 00002EDC           2357      LEA         ADDA_MODE, A0       ; Set index '0' for jump table
00002ED4  CCFC 0006               2358      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00002ED8  4EF0 6000               2359      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00002EDC                          2360  ADDA_MODE:
00002EDC  4EF9 00002F0C           2361      JMP         ADDA_MODE_000       ; Dn
00002EE2  4EF9 00002F16           2362      JMP         ADDA_MODE_001       ; An
00002EE8  4EF9 00002F20           2363      JMP         ADDA_MODE_010       ; (An)
00002EEE  4EF9 00002F2A           2364      JMP         ADDA_MODE_011       ; (An)+
00002EF4  4EF9 00002F34           2365      JMP         ADDA_MODE_100       ; -(An)
00002EFA  4EF9 00002F3E           2366      JMP         ADDA_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00002F00  4EF9 00002F44           2367      JMP         ADDA_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002F06  4EF9 00002F4A           2368      JMP         ADDA_MODE_111       ; The rest (not all valid, validated by register number)
00002F0C                          2369  ADDA_MODE_000: ; Dn
00002F0C  4EB8 2936               2370      JSR         EA_PRINT_DN         ; Print data register direct operand
00002F10  4EF9 00002F94           2371      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002F16                          2372  ADDA_MODE_001: ; An
00002F16  4EB8 29D6               2373      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00002F1A  4EF9 00002F94           2374      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002F20                          2375  ADDA_MODE_010: ; (An)
00002F20  4EB8 2A76               2376      JSR         EA_PRINT_IND         ; Print address register indirect
00002F24  4EF9 00002F94           2377      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002F2A                          2378  ADDA_MODE_011: ; (An)+
00002F2A  4EB8 2B50               2379      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00002F2E  4EF9 00002F94           2380      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002F34                          2381  ADDA_MODE_100: ; -(An)
00002F34  4EB8 2C14               2382      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00002F38  4EF9 00002F94           2383      JMP         ADDA_MODE_END       ; End evaluation of ea mode
00002F3E                          2384  ADDA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00002F3E  4EF9 00002F8A           2385      JMP         ADDA_MODE_INVALID
00002F44                          2386  ADDA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00002F44  4EF9 00002F8A           2387      JMP         ADDA_MODE_INVALID
00002F4A                          2388  ADDA_MODE_111: ; The rest (not all valid, validated by register number)
00002F4A  BE3C 0000               2389      CMP.B       #$00, D7            ; Test for absolute word address
00002F4E  6700 0018               2390      BEQ         ADDA_ABS_W
00002F52  BE3C 0001               2391      CMP.B       #$01, D7            ; Test for absolute long address
00002F56  6700 001A               2392      BEQ         ADDA_ABS_L
00002F5A  BE3C 0004               2393      CMP.B       #$04, D7            ; Test for immediate data
00002F5E  6700 001C               2394      BEQ         ADDA_IMM
00002F62  4EF9 00002F8A           2395      JMP         ADDA_MODE_INVALID   ; Else, invalid
00002F68                          2396  ADDA_ABS_W:
00002F68  4EB8 2CE8               2397      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00002F6C  4EF9 00002F94           2398      JMP         ADDA_MODE_END
00002F72                          2399  ADDA_ABS_L:
00002F72  4EB8 2CD8               2400      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00002F76  4EF9 00002F94           2401      JMP         ADDA_MODE_END
00002F7C                          2402  ADDA_IMM:
00002F7C  4EB8 28FE               2403      JSR         EA_OPMODE_COMBO     ; Get opmode bits in
00002F80  4EB8 2B2E               2404      JSR         EA_PRINT_IMM        ; Print immediate data
00002F84  4EF9 00002F94           2405      JMP         ADDA_MODE_END
00002F8A                          2406  ADDA_MODE_INVALID:
00002F8A  4EB8 28B0               2407      JSR         EA_INVALID          ; Opcode word is Invalid
00002F8E  4EF9 00002FA8           2408      JMP         ADDA_END
00002F94                          2409  ADDA_MODE_END:
00002F94  49F9 000048E8           2410      LEA         COMMA, A4        ; Print comma
00002F9A  4EB9 0000440E           2411      JSR         WRITE2MEM
00002FA0  4EB8 28FE               2412      JSR         EA_OPMODE_COMBO     ; Opmode: D6, register: D7
00002FA4  4EB8 29D6               2413      JSR         EA_PRINT_AN         ; Print address register
00002FA8                          2414  ADDA_END:
00002FA8  4EB8 28C8               2415      JSR         EA_UPDATE_POINTER   ; Update global pointer
00002FAC  4CDF 3FFF               2416      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00002FB0  4E75                    2417      RTS
00002FB2                          2418  
00002FB2                          2419  EA_ADDI:
00002FB2  48E7 FFFC               2420      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00002FB6  4EB8 28D4               2421      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00002FBA  4EB8 2924               2422      JSR         EA_SIZE_BITS        ; get size bits in D7
00002FBE  BE3C 0000               2423      CMP.B       #$00, D7            ; Test if size: byte
00002FC2  6700 001C               2424      BEQ         ADDI_B
00002FC6  BE3C 0001               2425      CMP.B       #$01, D7            ; Test if size: word
00002FCA  6700 002E               2426      BEQ         ADDI_W
00002FCE  BE3C 0002               2427      CMP.B       #$02, D7            ; Test if size: long
00002FD2  6700 0034               2428      BEQ         ADDI_L
00002FD6  4EB8 28B0               2429      JSR         EA_INVALID          ; Else, invalid
00002FDA  4EF9 000030C4           2430      JMP         ADDI_END
00002FE0                          2431  ADDI_B:
00002FE0  548D                    2432      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002FE2  4280                    2433      CLR.L       D0
00002FE4  3015                    2434      MOVE.W      (A5), D0            ; read next word in memory and save
00002FE6  143C 0008               2435      MOVE.B      #8, D2              ; Clear upper 8 bits of operand word
00002FEA  E568                    2436      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
00002FEC  143C 0008               2437      MOVE.B      #8, D2             ; 'Right-align' bits 0-7 to get value
00002FF0  E468                    2438      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
00002FF2                          2439      *print data
00002FF2  548D                    2440      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
00002FF4  4EF9 0000300E           2441      JMP         ADDI_GET_DEST
00002FFA                          2442  ADDI_W:
00002FFA  548D                    2443      ADDA.L      #$00000002, A5      ; Increment A5 past current word
00002FFC  4280                    2444      CLR.L       D0
00002FFE  3015                    2445      MOVE.W      (A5), D0            ; read next word in memory and save
00003000                          2446      *print data
00003000  548D                    2447      ADDA.L      #$00000002, A5      ; Increment A5 past operand word
00003002  4EF9 0000300E           2448      JMP         ADDI_GET_DEST
00003008                          2449  ADDI_L:
00003008  548D                    2450      ADDA.L      #$00000002, A5      ; Increment A5 past current word
0000300A  2015                    2451      MOVE.L      (A5), D0            ; read next two words in memory and save
0000300C  588D                    2452      ADDA.L      #$00000004, A5      ; Increment A5 past operand longword
0000300E                          2453  ADDI_GET_DEST:
0000300E                          2454      *PRINT COMMA
0000300E  4EB8 28D8               2455      JSR         EA_DEFAULT_COMBO    ; get mode bits in D6, register bits in D7
00003012  41F9 00003020           2456      LEA         ADDI_MODE, A0       ; Set index '0' for jump table
00003018  CCFC 0006               2457      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000301C  4EF0 6000               2458      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003020                          2459  ADDI_MODE:
00003020  4EF9 00003050           2460      JMP         ADDI_MODE_000       ; Dn
00003026  4EF9 0000305A           2461      JMP         ADDI_MODE_001       ; Invalid: An
0000302C  4EF9 00003064           2462      JMP         ADDI_MODE_010       ; (An)
00003032  4EF9 0000306E           2463      JMP         ADDI_MODE_011       ; (An)+
00003038  4EF9 00003078           2464      JMP         ADDI_MODE_100       ; -(An)
0000303E  4EF9 00003082           2465      JMP         ADDI_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00003044  4EF9 0000308C           2466      JMP         ADDI_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000304A  4EF9 00003096           2467      JMP         ADDI_MODE_111       ; The rest (not all valid, validated by register number)
00003050                          2468  ADDI_MODE_000: ; Dn
00003050  4EB8 2936               2469      JSR         EA_PRINT_DN         ; Print data register direct operand
00003054  4EF9 000030C4           2470      JMP         ADDI_END
0000305A                          2471  ADDI_MODE_001: ; Invalid: An
0000305A  4EB8 28B0               2472      JSR         EA_INVALID          ; Opcode word is Invalid
0000305E  4EF9 000030C4           2473      JMP         ADDI_END
00003064                          2474  ADDI_MODE_010: ; (An)
00003064  4EB8 2A76               2475      JSR         EA_PRINT_IND         ; Print address register indirect
00003068  4EF9 000030C4           2476      JMP         ADDI_END            ; End evaluation of ea mode
0000306E                          2477  ADDI_MODE_011: ; (An)+
0000306E  4EB8 2B50               2478      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003072  4EF9 000030C4           2479      JMP         ADDI_END            ; End evaluation of ea mode
00003078                          2480  ADDI_MODE_100: ; -(An)
00003078  4EB8 2C14               2481      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000307C  4EF9 000030C4           2482      JMP         ADDI_END            ; End evaluation of ea mode
00003082                          2483  ADDI_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003082  4EB8 28B0               2484      JSR         EA_INVALID          ; Opcode word is Invalid
00003086  4EF9 000030C4           2485      JMP         ADDI_END
0000308C                          2486  ADDI_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000308C  4EB8 28B0               2487      JSR         EA_INVALID          ; Opcode word is Invalid
00003090  4EF9 000030C4           2488      JMP         ADDI_END
00003096                          2489  ADDI_MODE_111: ; The rest (not all valid, validated by register number)
00003096  BE3C 0000               2490      CMP.B       #$00, D7            ; Test for absolute word address
0000309A  6700 0014               2491      BEQ         ADDI_ABS_W
0000309E  BE3C 0001               2492      CMP.B       #$01, D7            ; Test for absolute long address
000030A2  6700 0016               2493      BEQ         ADDI_ABS_L
000030A6  4EB8 28B0               2494      JSR         EA_INVALID          ; else, invalid
000030AA  4EF9 000030C4           2495      JMP         ADDI_END
000030B0                          2496  ADDI_ABS_W:
000030B0  4EB8 2CE8               2497      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000030B4  4EF9 000030C4           2498      JMP         ADDI_END
000030BA                          2499  ADDI_ABS_L:
000030BA  4EB8 2CD8               2500      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000030BE  4EF9 000030C4           2501      JMP         ADDI_END
000030C4                          2502  ADDI_END:
000030C4  4EB8 28C8               2503      JSR         EA_UPDATE_POINTER   ; Update global pointer
000030C8  4CDF 3FFF               2504      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000030CC  4E75                    2505      RTS
000030CE                          2506  EA_ADDQ:
000030CE  48E7 FFFC               2507      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000030D2  4EB8 28D4               2508      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000030D6  3216                    2509      MOVE.W      (A6), D1            ; Load opcode to data register 1
000030D8  143C 0004               2510      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
000030DC  E569                    2511      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000030DE  143C 000D               2512      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine mode bits
000030E2  E469                    2513      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000030E4  B23C 0000               2514      CMP.B       #$00, D1            ; Check for special case (if imm. data is 0, value is actually 8)
000030E8  6600 0006               2515      BNE         ADDQ_PRINT_IMM      ; If any value other than 0, print the data
000030EC  123C 0008               2516      MOVE.B      #$08, D1            ; Else, the value is 0 and therefore symbolic of the value 8, so replace with the value 8
000030F0                          2517  ADDQ_PRINT_IMM:
000030F0  49F9 000048E2           2518      LEA         POUND, A4         ; Print '#'
000030F6  4EB9 0000440E           2519      JSR         WRITE2MEM
000030FC  4EB8 28BA               2520      JSR         EA_PRINT_DATA
00003100  49F9 000048E8           2521      LEA         COMMA, A4        ; Print comma
00003106  4EB9 0000440E           2522      JSR         WRITE2MEM
0000310C  4EB8 28D8               2523      JSR         EA_DEFAULT_COMBO
00003110  41F9 0000311E           2524      LEA         ADDQ_MODE, A0       ; Set index '0' for jump table
00003116  CCFC 0006               2525      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000311A  4EF0 6000               2526      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000311E                          2527  ADDQ_MODE:
0000311E  4EF9 0000314E           2528      JMP         ADDQ_MODE_000       ; Dn
00003124  4EF9 00003158           2529      JMP         ADDQ_MODE_001       ; An
0000312A  4EF9 00003162           2530      JMP         ADDQ_MODE_010       ; (An)
00003130  4EF9 0000316C           2531      JMP         ADDQ_MODE_011       ; (An)+
00003136  4EF9 00003176           2532      JMP         ADDQ_MODE_100       ; -(An)
0000313C  4EF9 00003180           2533      JMP         ADDQ_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
00003142  4EF9 0000318A           2534      JMP         ADDQ_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003148  4EF9 00003194           2535      JMP         ADDQ_MODE_111       ; The rest (not all valid, validated by register number)
0000314E                          2536  ADDQ_MODE_000: ; Dn
0000314E  4EB8 2936               2537      JSR         EA_PRINT_DN         ; Print data register direct operand
00003152  4EF9 000031C2           2538      JMP         ADDQ_END            ; End evaluation of ea mode
00003158                          2539  ADDQ_MODE_001: ; An
00003158  4EB8 29D6               2540      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
0000315C  4EF9 000031C2           2541      JMP         ADDQ_END            ; End evaluation of ea mode
00003162                          2542  ADDQ_MODE_010: ; (An)
00003162  4EB8 2A76               2543      JSR         EA_PRINT_IND         ; Print address register indirect
00003166  4EF9 000031C2           2544      JMP         ADDQ_END            ; End evaluation of ea mode
0000316C                          2545  ADDQ_MODE_011: ; (An)+
0000316C  4EB8 2B50               2546      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003170  4EF9 000031C2           2547      JMP         ADDQ_END            ; End evaluation of ea mode
00003176                          2548  ADDQ_MODE_100: ; -(An)
00003176  4EB8 2C14               2549      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000317A  4EF9 000031C2           2550      JMP         ADDQ_END            ; End evaluation of ea mode
00003180                          2551  ADDQ_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003180  4EB8 28B0               2552      JSR         EA_INVALID          ; Opcode word is Invalid
00003184  4EF9 000031C2           2553      JMP         ADDQ_END
0000318A                          2554  ADDQ_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000318A  4EB8 28B0               2555      JSR         EA_INVALID          ; Opcode word is Invalid
0000318E  4EF9 000031C2           2556      JMP         ADDQ_END
00003194                          2557  ADDQ_MODE_111: ; The rest (not all valid, validated by register number)
00003194  BE3C 0000               2558      CMP.B       #$00, D7            ; Test for absolute word address
00003198  6700 0014               2559      BEQ         ADDQ_ABS_W
0000319C  BE3C 0001               2560      CMP.B       #$01, D7            ; Test for absolute long address
000031A0  6700 0016               2561      BEQ         ADDQ_ABS_L
000031A4  4EB8 28B0               2562      JSR         EA_INVALID          ; Opcode word is Invalid
000031A8  4EF9 000031C2           2563      JMP         ADDQ_END
000031AE                          2564  ADDQ_ABS_W:
000031AE  4EB8 2CE8               2565      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000031B2  4EF9 000031C2           2566      JMP         ADDQ_END
000031B8                          2567  ADDQ_ABS_L:
000031B8  4EB8 2CD8               2568      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000031BC  4EF9 000031C2           2569      JMP         ADDQ_END
000031C2                          2570  
000031C2                          2571  ADDQ_END:
000031C2  4EB8 28C8               2572      JSR         EA_UPDATE_POINTER   ; Update global pointer
000031C6  4CDF 3FFF               2573      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000031CA  4E75                    2574      RTS
000031CC                          2575  EA_AND:
000031CC  48E7 FFFC               2576      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000031D0  4EB8 28D4               2577      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000031D4  4EB8 28FE               2578      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
000031D8  41F8 2D12               2579      LEA         ADD_OPMODE, A0      ; Set index '0' for jump table
000031DC  CCFC 0006               2580      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000031E0  4EF0 6000               2581      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000031E4                          2582  AND_OPMODE:
000031E4  4EF9 00003214           2583      JMP         AND_OPMODE_000      ; mode 1, byte
000031EA  4EF9 0000321E           2584      JMP         AND_OPMODE_001      ; mode 1, word
000031F0  4EF9 00003228           2585      JMP         AND_OPMODE_010      ; mode 1, long
000031F6  4EF9 00003232           2586      JMP         AND_OPMODE_011      ; Invalid value
000031FC  4EF9 0000323C           2587      JMP         AND_OPMODE_100      ; mode 2, byte
00003202  4EF9 00003246           2588      JMP         AND_OPMODE_101      ; mode 2, word
00003208  4EF9 00003250           2589      JMP         AND_OPMODE_110      ; mode 2, long
0000320E  4EF9 0000325A           2590      JMP         AND_OPMODE_111      ; Invalid value
00003214                          2591  AND_OPMODE_000: ; mode 1, byte
00003214  1A3C 0001               2592      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003218  4EF9 00003264           2593      JMP         AND_MODE_1
0000321E                          2594  AND_OPMODE_001: ; mode 1, word
0000321E  1A3C 0002               2595      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00003222  4EF9 00003264           2596      JMP         AND_MODE_1
00003228                          2597  AND_OPMODE_010: ; mode 1, long
00003228  1A3C 0003               2598      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
0000322C  4EF9 00003264           2599      JMP         AND_MODE_1
00003232                          2600  AND_OPMODE_011: ; Invalid value
00003232  4EB8 28B0               2601      JSR         EA_INVALID
00003236  4EF9 0000337E           2602      JMP         AND_END
0000323C                          2603  AND_OPMODE_100: ; mode 2, byte
0000323C  1A3C 0001               2604      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003240  4EF9 0000328E           2605      JMP         AND_MODE_2
00003246                          2606  AND_OPMODE_101: ; mode 2, word
00003246  1A3C 0001               2607      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000324A  4EF9 0000328E           2608      JMP         AND_MODE_2
00003250                          2609  AND_OPMODE_110: ; mode 2, long
00003250  1A3C 0001               2610      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003254  4EF9 0000328E           2611      JMP         AND_MODE_2
0000325A                          2612  AND_OPMODE_111: ; Invalid value
0000325A  4EB8 28B0               2613      JSR         EA_INVALID
0000325E  4EF9 0000337E           2614      JMP         AND_END
00003264                          2615  AND_MODE_1:
00003264  4280                    2616      CLR.L       D0                  ; Clear data register 0
00003266  103C 0001               2617      MOVE.B      #1, D0              ; Save mode number to D0
0000326A  3207                    2618      MOVE.W      D7, D1              ; Save register value for printing dest. operand
0000326C  4EB8 28D8               2619      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003270  4EB9 000032B4           2620      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
00003276  49F9 000048E8           2621      LEA         COMMA, A4        ; Print comma
0000327C  4EB9 0000440E           2622      JSR         WRITE2MEM
00003282  3E01                    2623      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003284  4EB8 2936               2624      JSR         EA_PRINT_DN         ; Print data register
00003288  4EF9 0000337E           2625      JMP         AND_END
0000328E                          2626  AND_MODE_2:
0000328E  4280                    2627      CLR.L       D0                  ; Clear data register 0
00003290  103C 0002               2628      MOVE.B      #2, D0              ; Save mode number to D0
00003294  4EB8 2936               2629      JSR         EA_PRINT_DN         ; Print data register
00003298  49F9 000048E8           2630      LEA         COMMA, A4        ; Print comma
0000329E  4EB9 0000440E           2631      JSR         WRITE2MEM
000032A4  4EB8 28D8               2632      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
000032A8  4EB9 000032B4           2633      JSR         AND_EVAL_EA         ; Evaluate the results of subroutine call
000032AE  4EF9 0000337E           2634      JMP         AND_END
000032B4                          2635  AND_EVAL_EA:
000032B4  41F9 000032C2           2636      LEA         AND_MODE, A0        ; Set index '0' for jump table
000032BA  CCFC 0006               2637      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000032BE  4EF0 6000               2638      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000032C2                          2639  AND_MODE:
000032C2  4EF9 000032F2           2640      JMP         AND_MODE_000        ; Dn (invalid if opmode 2)
000032C8  4EF9 00003304           2641      JMP         AND_MODE_001        ; Invalid: An
000032CE  4EF9 0000330A           2642      JMP         AND_MODE_010        ; (An)
000032D4  4EF9 00003314           2643      JMP         AND_MODE_011        ; (An)+
000032DA  4EF9 0000331E           2644      JMP         AND_MODE_100        ; -(An)
000032E0  4EF9 00003328           2645      JMP         AND_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000032E6  4EF9 0000332E           2646      JMP         AND_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000032EC  4EF9 00003334           2647      JMP         AND_MODE_111        ; The rest (not all valid, validated by register number)
000032F2                          2648  AND_MODE_000: ; Dn (invalid if opmode 2)
000032F2  B07C 0002               2649      CMP         #2, D0
000032F6  6700 0082               2650      BEQ         AND_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
000032FA  4EB8 2936               2651      JSR         EA_PRINT_DN         ; Print data register direct operand
000032FE  4EF9 00003378           2652      JMP         AND_MODE_END        ; End evaluation of ea mode
00003304                          2653  AND_MODE_001: ; Invalid: An
00003304  4EF9 0000337A           2654      JMP         AND_MODE_INVALID
0000330A                          2655  AND_MODE_010: ; (An)
0000330A  4EB8 2A76               2656      JSR         EA_PRINT_IND         ; Print address register indirect
0000330E  4EF9 00003378           2657      JMP         AND_MODE_END        ; End evaluation of ea mode
00003314                          2658  AND_MODE_011: ; (An)+
00003314  4EB8 2B50               2659      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003318  4EF9 00003378           2660      JMP         AND_MODE_END        ; End evaluation of ea mode
0000331E                          2661  AND_MODE_100: ; -(An)
0000331E  4EB8 2C14               2662      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003322  4EF9 00003378           2663      JMP         AND_MODE_END        ; End evaluation of ea mode
00003328                          2664  AND_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003328  4EF9 0000337A           2665      JMP         AND_MODE_INVALID
0000332E                          2666  AND_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000332E  4EF9 0000337A           2667      JMP         AND_MODE_INVALID
00003334                          2668  AND_MODE_111: ; The rest (not all valid, validated by register number)
00003334  BE3C 0000               2669      CMP.B       #$00, D7            ; Test for absolute word address
00003338  6700 0018               2670      BEQ         AND_ABS_W
0000333C  BE3C 0001               2671      CMP.B       #$01, D7            ; Test for absolute long address
00003340  6700 001A               2672      BEQ         AND_ABS_L
00003344  BE3C 0004               2673      CMP.B       #$04, D7            ; Test for immediate data
00003348  6700 001C               2674      BEQ         AND_IMM
0000334C  4EF9 0000337A           2675      JMP         AND_MODE_INVALID    ; else, invalid
00003352                          2676  AND_ABS_W:
00003352  4EB8 2CE8               2677      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003356  4EF9 00003378           2678      JMP         AND_MODE_END
0000335C                          2679  AND_ABS_L:
0000335C  4EB8 2CD8               2680      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003360  4EF9 00003378           2681      JMP         AND_MODE_END
00003366                          2682  AND_IMM: ; invalid if opmode is 2
00003366  B07C 0002               2683      CMP         #2, D0
0000336A  6700 000E               2684      BEQ         AND_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
0000336E  4EB8 2B2E               2685      JSR         EA_PRINT_IMM        ; Print immediate data
00003372  4EF9 00003378           2686      JMP         AND_MODE_END
00003378                          2687  AND_MODE_END:
00003378  4E75                    2688      RTS                             ; Finish evaluating EA bits
0000337A                          2689  AND_MODE_INVALID:
0000337A  4EB8 28B0               2690      JSR         EA_INVALID          ; Opcode word is Invalid, continue to end
0000337E                          2691  AND_END:
0000337E  4EB8 28C8               2692      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003382  4CDF 3FFF               2693      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003386  4E75                    2694      RTS
00003388                          2695  EA_ASd:
00003388  48E7 FFFC               2696      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000338C  4EB8 28D4               2697      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003390  4EB8 2924               2698      JSR         EA_SIZE_BITS        ; get size bits in D7
00003394  BE3C 0003               2699      CMP.B       #$03, D7            ; test if memory shift
00003398  6700 005E               2700      BEQ         ASd_MEM
0000339C  6000 0002               2701      BRA         ASd_REG             ; else, register shfit
000033A0                          2702  ASd_REG:
000033A0  3E16                    2703      MOVE.W      (A6), D7            ; read opcode word in memory and save,
000033A2                          2704                                      ; (using D7 because EA_PRINT_DN uses D7)
000033A2  143C 0004               2705      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
000033A6  E56F                    2706      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000033A8  143C 000D               2707      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
000033AC  E46F                    2708      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000033AE  3016                    2709      MOVE.W      (A6), D0            ; read opcode word in memory and save
000033B0  143C 000A               2710      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
000033B4  E568                    2711      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
000033B6  143C 000F               2712      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
000033BA  E468                    2713      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
000033BC  B03C 0000               2714      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
000033C0  6700 000C               2715      BEQ         ASd_REG_COUNT
000033C4                          2716  ASd_REG_REG:                        ; Else, count/register field contains register number
000033C4  4EB8 2936               2717      JSR         EA_PRINT_DN         ; Print register value, stored in D7
000033C8  4EF9 000033DE           2718      JMP         ASd_REG_END         ; Jump to end of ASd_REG
000033CE                          2719  ASd_REG_COUNT:
000033CE  49F9 000048E2           2720      LEA         POUND, A4        ; Print '#'
000033D4  4EB9 0000440E           2721      JSR         WRITE2MEM
000033DA  4EB8 28BA               2722      JSR         EA_PRINT_DATA *print hex value in D7 as byte todo, continue on to ASd_REG_END
000033DE                          2723  ASd_REG_END:
000033DE  49F9 000048E8           2724      LEA         COMMA, A4        ; Print comma
000033E4  4EB9 0000440E           2725      JSR         WRITE2MEM
000033EA  4EB8 28D8               2726      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
000033EE  4EB8 2936               2727      JSR         EA_PRINT_DN         ; Print register value in D7
000033F2  4EF9 000034AE           2728      JMP         ASd_END
000033F8                          2729  ASd_MEM:
000033F8  4EB8 28D8               2730      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000033FC  41F9 0000340A           2731      LEA         ASd_MEM_MODE, A0    ; Set index '0' for jump table
00003402  CCFC 0006               2732      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003406  4EF0 6000               2733      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
0000340A                          2734  ASd_MEM_MODE:
0000340A  4EF9 0000343A           2735      JMP         ASd_MEM_MODE_000     ; Invalid: Dn
00003410  4EF9 00003444           2736      JMP         ASd_MEM_MODE_001     ; Invalid: An
00003416  4EF9 0000344E           2737      JMP         ASd_MEM_MODE_010     ; (An)
0000341C  4EF9 00003458           2738      JMP         ASd_MEM_MODE_011     ; (An)+
00003422  4EF9 00003462           2739      JMP         ASd_MEM_MODE_100     ; -(An)
00003428  4EF9 0000346C           2740      JMP         ASd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
0000342E  4EF9 00003476           2741      JMP         ASd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003434  4EF9 00003480           2742      JMP         ASd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
0000343A                          2743  ASd_MEM_MODE_000: ; Invalid: Dn
0000343A  4EB8 28B0               2744      JSR         EA_INVALID          ; Data register direct is invalid mode
0000343E  4EF9 000034AE           2745      JMP         ASd_END
00003444                          2746  ASd_MEM_MODE_001: ; Invalid: An
00003444  4EB8 28B0               2747      JSR         EA_INVALID          ; Address register direct is invalid mode
00003448  4EF9 000034AE           2748      JMP         ASd_END
0000344E                          2749  ASd_MEM_MODE_010: ; (An)
0000344E  4EB8 2A76               2750      JSR         EA_PRINT_IND         ; Print address register indirect
00003452  4EF9 000034AE           2751      JMP         ASd_END
00003458                          2752  ASd_MEM_MODE_011: ; (An)+
00003458  4EB8 2B50               2753      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000345C  4EF9 000034AE           2754      JMP         ASd_END
00003462                          2755  ASd_MEM_MODE_100: ; -(An)
00003462  4EB8 2C14               2756      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003466  4EF9 000034AE           2757      JMP         ASd_END         ; Continue with parsing destination operand
0000346C                          2758  ASd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000346C  4EB8 28B0               2759      JSR         EA_INVALID          ; Opcode word is Invalid
00003470  4EF9 000034AE           2760      JMP         ASd_END
00003476                          2761  ASd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003476  4EB8 28B0               2762      JSR         EA_INVALID          ; Opcode word is Invalid
0000347A  4EF9 000034AE           2763      JMP         ASd_END
00003480                          2764  ASd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
00003480  BE3C 0000               2765      CMP.B       #$00, D7            ; Test for absolute word address
00003484  6700 0014               2766      BEQ         ASd_MEM_ABS_W
00003488  BE3C 0001               2767      CMP.B       #$01, D7            ; Test for absolute long address
0000348C  6700 0016               2768      BEQ         ASd_MEM_ABS_L
00003490  4EB8 28B0               2769      JSR         EA_INVALID          ; Else: invalid
00003494  4EF9 000034AE           2770      JMP         ASd_END
0000349A                          2771  ASd_MEM_ABS_W:
0000349A  4EB8 2CE8               2772      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000349E  4EF9 000034AE           2773      JMP         ASd_END
000034A4                          2774  ASd_MEM_ABS_L:
000034A4  4EB8 2CD8               2775      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000034A8  4EF9 000034AE           2776      JMP         ASd_END
000034AE                          2777  ASd_END:
000034AE  4EB8 28C8               2778      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000034B2  4CDF 3FFF               2779      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000034B6  4E75                    2780      RTS
000034B8                          2781  EA_Bcc:
000034B8  48E7 FFFC               2782      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000034BC  4EB8 28D4               2783      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000034C0  3216                    2784      MOVE.W      (A6), D1            ; Load opcode to data register 1
000034C2  143C 0008               2785      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
000034C6  E569                    2786      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
000034C8  143C 0008               2787      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine condition
000034CC  E469                    2788      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
000034CE                          2789      *save ultimate address to be printed
000034CE  284E                    2790      MOVEA.L     A6, A4              ; Copy global pointer for dislay
000034D0  B23C 0000               2791      CMP.B       #$00, D1            ; If value is zero, real value is next word in memory
000034D4  6700 0034               2792      BEQ         BCC_W
000034D8  B23C 00FF               2793      CMP.B       #$FF, D1            ; If value is FF, real value is next longword
000034DC  6700 004E               2794      BEQ         BCC_L
000034E0  4EF9 000034E6           2795      JMP         BCC_B               ; Else, parse lower-order byte of opcode word
000034E6                          2796  BCC_B:
000034E6  548C                    2797      ADDA.L      #$00000002, A4      ; Increment display pointer past opcode word
000034E8  3616                    2798      MOVE.W      (A6), D3            ; Save opcode word
000034EA  143C 0008               2799      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
000034EE  E56B                    2800      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
000034F0  143C 000F               2801      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
000034F4  E46B                    2802      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
000034F6  B63C 0000               2803      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
000034FA  6700 003E               2804      BEQ         BCC_DISPLAY
000034FE  0681 FFFFFF00           2805      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
00003504  4EF9 0000353A           2806      JMP         BCC_DISPLAY
0000350A                          2807  BCC_W:
0000350A  588C                    2808      ADDA.L      #$00000004, A4      ; Increment display pointer past opcode word
0000350C                          2809                                      ; and displacement word in memory
0000350C  548D                    2810      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
0000350E  3615                    2811      MOVE.W      (A5), D3            ; Read word displacement from memory
00003510  548D                    2812      ADDA.L      #$00000002, A5      ; Increment A5 past word read
00003512  143C 000F               2813      MOVE.B      #15, D2             ; 'Right-align' bit 15 to determine MSB
00003516  E46B                    2814      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003518  B63C 0000               2815      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
0000351C  6700 001C               2816      BEQ         BCC_DISPLAY
00003520  0681 FFFF0000           2817      ADD.L       #$FFFF0000, D1      ; Else, sign extend data with F
00003526  4EF9 0000353A           2818      JMP         BCC_DISPLAY
0000352C                          2819  BCC_L:
0000352C  5C8C                    2820      ADDA.L      #$00000006, A4      ; Increment display pointer past opcode word
0000352E                          2821                                      ; and displacement longword in memory
0000352E  548D                    2822      ADDA.L      #$00000002, A5      ; Increment A5 past opcode word
00003530  2215                    2823      MOVE.L      (A5), D1            ; Read longword displacement from memory
00003532  588D                    2824      ADDA.L      #$00000004, A5      ; Increment A5 past longword read
00003534  4EF9 0000353A           2825      JMP         BCC_DISPLAY
0000353A                          2826  BCC_DISPLAY:
0000353A  D9C1                    2827      ADDA.L      D1, A4              ; add displacement to current addressing
0000353C                          2828      *print address in A4
0000353C  4EB8 28C8               2829      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003540  4CDF 3FFF               2830      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003544  4E75                    2831      RTS
00003546                          2832  EA_CLR:
00003546  48E7 FFFC               2833      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
0000354A  4EB8 28D4               2834      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
0000354E  4EB8 28D8               2835      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003552  41F9 00003560           2836      LEA         CLR_MODE, A0        ; Set index '0' for jump table
00003558  CCFC 0006               2837      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000355C  4EF0 6000               2838      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003560                          2839  CLR_MODE:
00003560  4EF9 00003590           2840      JMP         CLR_MODE_000        ; Dn
00003566  4EF9 0000359A           2841      JMP         CLR_MODE_001        ; Invalid: An
0000356C  4EF9 000035A4           2842      JMP         CLR_MODE_010        ; (An)
00003572  4EF9 000035AE           2843      JMP         CLR_MODE_011        ; (An)+
00003578  4EF9 000035B8           2844      JMP         CLR_MODE_100        ; -(An)
0000357E  4EF9 000035C2           2845      JMP         CLR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003584  4EF9 000035CC           2846      JMP         CLR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000358A  4EF9 000035D6           2847      JMP         CLR_MODE_111        ; The rest (not all valid, validated by register number)
00003590                          2848  CLR_MODE_000: ; Dn
00003590  4EB8 2936               2849      JSR         EA_PRINT_DN
00003594  4EF9 00003604           2850      JMP         CLR_END
0000359A                          2851  CLR_MODE_001: ; Invalid: An
0000359A  4EB8 28B0               2852      JSR         EA_INVALID          ; Address register direct is invalid mode
0000359E  4EF9 00003604           2853      JMP         CLR_END
000035A4                          2854  CLR_MODE_010: ; (An)
000035A4  4EB8 2A76               2855      JSR         EA_PRINT_IND         ; Print address register indirect
000035A8  4EF9 00003604           2856      JMP         CLR_END
000035AE                          2857  CLR_MODE_011: ; (An)+
000035AE  4EB8 2B50               2858      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
000035B2  4EF9 00003604           2859      JMP         CLR_END
000035B8                          2860  CLR_MODE_100: ; -(An)
000035B8  4EB8 2C14               2861      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
000035BC  4EF9 00003604           2862      JMP         CLR_END             ; Continue with parsing destination operand
000035C2                          2863  CLR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000035C2  4EB8 28B0               2864      JSR         EA_INVALID          ; Opcode word is Invalid
000035C6  4EF9 00003604           2865      JMP         CLR_END
000035CC                          2866  CLR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000035CC  4EB8 28B0               2867      JSR         EA_INVALID          ; Opcode word is Invalid
000035D0  4EF9 00003604           2868      JMP         CLR_END
000035D6                          2869  CLR_MODE_111: ; The rest (not all valid, validated by register number)
000035D6  BE3C 0000               2870      CMP.B       #$00, D7            ; Test for absolute word address
000035DA  6700 0014               2871      BEQ         CLR_ABS_W
000035DE  BE3C 0001               2872      CMP.B       #$01, D7            ; Test for absolute long address
000035E2  6700 0016               2873      BEQ         CLR_ABS_L
000035E6  4EB8 28B0               2874      JSR         EA_INVALID          ; Else: invalid
000035EA  4EF9 00003604           2875      JMP         CLR_END
000035F0                          2876  CLR_ABS_W:
000035F0  4EB8 2CE8               2877      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000035F4  4EF9 00003604           2878      JMP         CLR_END
000035FA                          2879  CLR_ABS_L:
000035FA  4EB8 2CD8               2880      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000035FE  4EF9 00003604           2881      JMP         CLR_END
00003604                          2882  CLR_END:
00003604  4EB8 28C8               2883      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003608  4CDF 3FFF               2884      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000360C  4E75                    2885      RTS
0000360E                          2886  EA_CMP:
0000360E  48E7 FFFC               2887      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003612  4EB8 28D4               2888      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003616  4EB8 28D8               2889      JSR         EA_DEFAULT_COMBO
0000361A  41F9 00003628           2890      LEA         CMP_MODE, A0       ; Set index '0' for jump table
00003620  CCFC 0006               2891      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003624  4EF0 6000               2892      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003628                          2893  CMP_MODE:
00003628  4EF9 00003658           2894      JMP         CMP_MODE_000       ; Dn
0000362E  4EF9 00003662           2895      JMP         CMP_MODE_001       ; An
00003634  4EF9 0000366C           2896      JMP         CMP_MODE_010       ; (An)
0000363A  4EF9 00003676           2897      JMP         CMP_MODE_011       ; (An)+
00003640  4EF9 00003680           2898      JMP         CMP_MODE_100       ; -(An)
00003646  4EF9 0000368A           2899      JMP         CMP_MODE_101       ; Invalid: Address Register Indirect with Displacement Mode
0000364C  4EF9 00003694           2900      JMP         CMP_MODE_110       ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003652  4EF9 0000369E           2901      JMP         CMP_MODE_111       ; The rest (not all valid, validated by register number)
00003658                          2902  CMP_MODE_000: ; Dn
00003658  4EB8 2936               2903      JSR         EA_PRINT_DN         ; Print data register direct operand
0000365C  4EF9 000036CC           2904      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003662                          2905  CMP_MODE_001: ; An
00003662  4EB8 29D6               2906      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
00003666  4EF9 000036CC           2907      JMP         CMP_MODE_END        ; End evaluation of ea mode
0000366C                          2908  CMP_MODE_010: ; (An)
0000366C  4EB8 2A76               2909      JSR         EA_PRINT_IND        ; Print address register indirect
00003670  4EF9 000036CC           2910      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003676                          2911  CMP_MODE_011: ; (An)+
00003676  4EB8 2B50               2912      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
0000367A  4EF9 000036CC           2913      JMP         CMP_MODE_END        ; End evaluation of ea mode
00003680                          2914  CMP_MODE_100: ; -(An)
00003680  4EB8 2C14               2915      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003684  4EF9 000036CC           2916      JMP         CMP_MODE_END        ; End evaluation of ea mode
0000368A                          2917  CMP_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000368A  4EB8 28B0               2918      JSR         EA_INVALID          ; Opcode word is Invalid
0000368E  4EF9 000036E0           2919      JMP         CMP_END
00003694                          2920  CMP_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003694  4EB8 28B0               2921      JSR         EA_INVALID          ; Opcode word is Invalid
00003698  4EF9 000036E0           2922      JMP         CMP_END
0000369E                          2923  CMP_MODE_111: ; The rest (not all valid, validated by register number)
0000369E  BE3C 0000               2924      CMP.B       #$00, D7            ; Test for absolute word address
000036A2  6700 0014               2925      BEQ         CMP_ABS_W
000036A6  BE3C 0001               2926      CMP.B       #$01, D7            ; Test for absolute long address
000036AA  6700 0016               2927      BEQ         CMP_ABS_L
000036AE  4EB8 28B0               2928      JSR         EA_INVALID          ; Opcode word is Invalid
000036B2  4EF9 000036E0           2929      JMP         CMP_END
000036B8                          2930  CMP_ABS_W:
000036B8  4EB8 2CE8               2931      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000036BC  4EF9 000036CC           2932      JMP         CMP_MODE_END
000036C2                          2933  CMP_ABS_L:
000036C2  4EB8 2CD8               2934      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000036C6  4EF9 000036CC           2935      JMP         CMP_MODE_END
000036CC                          2936  CMP_MODE_END:
000036CC  49F9 000048E8           2937      LEA         COMMA, A4        ; Print comma
000036D2  4EB9 0000440E           2938      JSR         WRITE2MEM
000036D8  4EB8 28FE               2939      JSR         EA_OPMODE_COMBO     ; get register bits in D7, opmode bits not used
000036DC  4EB8 2936               2940      JSR         EA_PRINT_DN         ; print register
000036E0                          2941  CMP_END:
000036E0  4EB8 28C8               2942      JSR         EA_UPDATE_POINTER   ; Update global pointer
000036E4  4CDF 3FFF               2943      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000036E8  4E75                    2944      RTS
000036EA                          2945  EA_DIVU_W:
000036EA  48E7 FFFC               2946      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000036EE  4EB8 28D4               2947      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000036F2  4EB8 28D8               2948      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000036F6  41F9 00003704           2949      LEA         DIVU_W_MODE, A0       ; Set index '0' for jump table
000036FC  CCFC 0006               2950      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003700  4EF0 6000               2951      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003704                          2952  DIVU_W_MODE:
00003704  4EF9 00003734           2953      JMP         DIVU_W_MODE_000     ; Dn
0000370A  4EF9 0000373E           2954      JMP         DIVU_W_MODE_001     ; Invalid: An
00003710  4EF9 00003748           2955      JMP         DIVU_W_MODE_010     ; (An)
00003716  4EF9 00003752           2956      JMP         DIVU_W_MODE_011     ; (An)+
0000371C  4EF9 0000375C           2957      JMP         DIVU_W_MODE_100     ; -(An)
00003722  4EF9 00003766           2958      JMP         DIVU_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003728  4EF9 00003770           2959      JMP         DIVU_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000372E  4EF9 0000377A           2960      JMP         DIVU_W_MODE_111     ; The rest (not all valid, validated by register number)
00003734                          2961  DIVU_W_MODE_000: ; Dn
00003734  4EB8 2936               2962      JSR         EA_PRINT_DN         ; Print data register direct operand
00003738  4EF9 000037BE           2963      JMP         DIVU_W_DEST         ; Go to: print destination operand
0000373E                          2964  DIVU_W_MODE_001: ; Invalid: An
0000373E  4EB8 28B0               2965      JSR         EA_INVALID          ; Address register direct is invalid mode
00003742  4EF9 000037D0           2966      JMP         DIVU_W_END
00003748                          2967  DIVU_W_MODE_010: ; (An)
00003748  4EB8 2A76               2968      JSR         EA_PRINT_IND         ; Print address register indirect
0000374C  4EF9 000037BE           2969      JMP         DIVU_W_DEST
00003752                          2970  DIVU_W_MODE_011: ; (An)+
00003752  4EB8 2B50               2971      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003756  4EF9 000037BE           2972      JMP         DIVU_W_DEST
0000375C                          2973  DIVU_W_MODE_100: ; -(An)
0000375C  4EB8 2C14               2974      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003760  4EF9 000037BE           2975      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
00003766                          2976  DIVU_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003766  4EB8 28B0               2977      JSR         EA_INVALID          ; Opcode word is Invalid
0000376A  4EF9 000037D0           2978      JMP         DIVU_W_END
00003770                          2979  DIVU_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003770  4EB8 28B0               2980      JSR         EA_INVALID          ; Opcode word is Invalid
00003774  4EF9 000037D0           2981      JMP         DIVU_W_END
0000377A                          2982  DIVU_W_MODE_111: ; The rest (not all valid, validated by register number)
0000377A  BE3C 0000               2983      CMP.B       #$00, D7            ; Test for absolute word address
0000377E  6700 001C               2984      BEQ         DIVU_W_ABS_W
00003782  BE3C 0001               2985      CMP.B       #$01, D7            ; Test for absolute long address
00003786  6700 001E               2986      BEQ         DIVU_W_ABS_L
0000378A  BE3C 0004               2987      CMP.B       #$04, D7            ; Test for immediate data
0000378E  6700 0020               2988      BEQ         DIVU_W_IMM
00003792  4EB8 28B0               2989      JSR         EA_INVALID          ; Else: invalid
00003796  4EF9 000037D0           2990      JMP         DIVU_W_END
0000379C                          2991  DIVU_W_ABS_W:
0000379C  4EB8 2CE8               2992      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000037A0  4EF9 000037BE           2993      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000037A6                          2994  DIVU_W_ABS_L:
000037A6  4EB8 2CD8               2995      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000037AA  4EF9 000037BE           2996      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000037B0                          2997  DIVU_W_IMM:
000037B0  1A3C 0002               2998      MOVE.B      #2, D5              ; Size is word
000037B4  4EB8 2B2E               2999      JSR         EA_PRINT_IMM        ; Print immediate data
000037B8  4EF9 000037BE           3000      JMP         DIVU_W_DEST         ; Continue with parsing destination operand
000037BE                          3001  DIVU_W_DEST:
000037BE                          3002      *print COMMA
000037BE                          3003      *Get destination register
000037BE  3E16                    3004      MOVE.W      (A6), D7            ; Load word at current pointer to D1
000037C0  143C 0004               3005      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
000037C4  E56F                    3006      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000037C6  143C 000D               3007      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
000037CA  E46F                    3008      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000037CC  4EB8 2936               3009      JSR         EA_PRINT_DN         ; Print data register direct operand
000037D0                          3010  DIVU_W_END:
000037D0  4EB8 28C8               3011      JSR         EA_UPDATE_POINTER   ; Update global pointer
000037D4  4CDF 3FFF               3012      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000037D8  4E75                    3013      RTS
000037DA                          3014  EA_JSR:
000037DA  48E7 FFFC               3015      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000037DE  4EB8 28D4               3016      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000037E2  4EB8 28D8               3017      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000037E6  41F9 000037F4           3018      LEA         JSR_MODE, A0        ; Set index '0' for jump table
000037EC  CCFC 0006               3019      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000037F0  4EF0 6000               3020      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000037F4                          3021  JSR_MODE:
000037F4  4EF9 00003824           3022      JMP         JSR_MODE_000        ; Invalid: Dn
000037FA  4EF9 0000382E           3023      JMP         JSR_MODE_001        ; Invalid: An
00003800  4EF9 00003838           3024      JMP         JSR_MODE_010        ; (An)
00003806  4EF9 00003842           3025      JMP         JSR_MODE_011        ; Invalid: (An)+
0000380C  4EF9 0000384C           3026      JMP         JSR_MODE_100        ; Invalid: -(An)
00003812  4EF9 00003856           3027      JMP         JSR_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00003818  4EF9 00003860           3028      JMP         JSR_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000381E  4EF9 0000386A           3029      JMP         JSR_MODE_111        ; The rest (not all valid, validated by register number)
00003824                          3030  JSR_MODE_000: ; Invalid: Dn
00003824  4EB8 28B0               3031      JSR         EA_INVALID          ; Data register direct is invalid mode
00003828  4EF9 00003898           3032      JMP         JSR_END
0000382E                          3033  JSR_MODE_001: ; Invalid: An
0000382E  4EB8 28B0               3034      JSR         EA_INVALID          ; Address register direct is invalid mode
00003832  4EF9 00003898           3035      JMP         JSR_END
00003838                          3036  JSR_MODE_010: ; (An)
00003838  4EB8 2A76               3037      JSR         EA_PRINT_IND         ; Print address register indirect
0000383C  4EF9 00003898           3038      JMP         JSR_END
00003842                          3039  JSR_MODE_011: ; (An)+
00003842  4EB8 28B0               3040      JSR         EA_INVALID          ; Address register indirect w/ post increment is invalid mode
00003846  4EF9 00003898           3041      JMP         JSR_END
0000384C                          3042  JSR_MODE_100: ; -(An)
0000384C  4EB8 28B0               3043      JSR         EA_INVALID          ; Address register indirect w/ pre decrement is invalid mode
00003850  4EF9 00003898           3044      JMP         JSR_END
00003856                          3045  JSR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003856  4EB8 28B0               3046      JSR         EA_INVALID          ; Opcode word is Invalid
0000385A  4EF9 00003898           3047      JMP         JSR_END
00003860                          3048  JSR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003860  4EB8 28B0               3049      JSR         EA_INVALID          ; Opcode word is Invalid
00003864  4EF9 00003898           3050      JMP         JSR_END
0000386A                          3051  JSR_MODE_111: ; The rest (not all valid, validated by register number)
0000386A  BE3C 0000               3052      CMP.B       #$00, D7            ; Test for absolute word address
0000386E  6700 0014               3053      BEQ         JSR_ABS_W
00003872  BE3C 0001               3054      CMP.B       #$01, D7            ; Test for absolute long address
00003876  6700 0016               3055      BEQ         JSR_ABS_L
0000387A  4EB8 28B0               3056      JSR         EA_INVALID          ; Else: invalid
0000387E  4EF9 00003898           3057      JMP         JSR_END
00003884                          3058  JSR_ABS_W:
00003884  4EB8 2CE8               3059      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003888  4EF9 00003898           3060      JMP         JSR_END
0000388E                          3061  JSR_ABS_L:
0000388E  4EB8 2CD8               3062      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003892  4EF9 00003898           3063      JMP         JSR_END
00003898                          3064  JSR_END:
00003898  4EB8 28C8               3065      JSR         EA_UPDATE_POINTER   ; Updates global pointer
0000389C  4CDF 3FFF               3066      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000038A0  4E75                    3067      RTS
000038A2                          3068  EA_LEA:
000038A2  48E7 FFFC               3069      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000038A6  4EB8 28D4               3070      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
000038AA  4EB8 28D8               3071      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000038AE  41F9 000038BC           3072      LEA         LEA_MODE, A0        ; Set index '0' for jump table
000038B4  CCFC 0006               3073      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000038B8  4EF0 6000               3074      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000038BC                          3075  LEA_MODE:
000038BC  4EF9 000038EC           3076      JMP         LEA_MODE_000        ; Dn
000038C2  4EF9 000038F6           3077      JMP         LEA_MODE_001        ; Invalid: An
000038C8  4EF9 00003900           3078      JMP         LEA_MODE_010        ; (An)
000038CE  4EF9 0000390A           3079      JMP         LEA_MODE_011        ; (An)+
000038D4  4EF9 00003914           3080      JMP         LEA_MODE_100        ; -(An)
000038DA  4EF9 0000391E           3081      JMP         LEA_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
000038E0  4EF9 00003928           3082      JMP         LEA_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000038E6  4EF9 00003932           3083      JMP         LEA_MODE_111        ; The rest (not all valid, validated by register number)
000038EC                          3084  LEA_MODE_000: ; Invalid: Dn
000038EC  4EB8 28B0               3085      JSR         EA_INVALID          ; Data register direct is invalid mode
000038F0  4EF9 00003974           3086      JMP         LEA_END
000038F6                          3087  LEA_MODE_001: ; Invalid: An
000038F6  4EB8 28B0               3088      JSR         EA_INVALID          ; Address register direct is invalid mode
000038FA  4EF9 00003974           3089      JMP         LEA_END
00003900                          3090  LEA_MODE_010: ; (An)
00003900  4EB8 2A76               3091      JSR         EA_PRINT_IND         ; Print address register indirect
00003904  4EF9 00003960           3092      JMP         LEA_DEST
0000390A                          3093  LEA_MODE_011: ; (An)+
0000390A  4EB8 28B0               3094      JSR         EA_INVALID          ; Address register indirect with post increment is invalid
0000390E  4EF9 00003974           3095      JMP         LEA_END
00003914                          3096  LEA_MODE_100: ; -(An)
00003914  4EB8 28B0               3097      JSR         EA_INVALID          ; Adress register indirect with pre decrement is invalid
00003918  4EF9 00003974           3098      JMP         LEA_END             ; Continue with parsing destination operand
0000391E                          3099  LEA_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
0000391E  4EB8 28B0               3100      JSR         EA_INVALID          ; Opcode word is Invalid
00003922  4EF9 00003974           3101      JMP         LEA_END
00003928                          3102  LEA_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003928  4EB8 28B0               3103      JSR         EA_INVALID          ; Opcode word is Invalid
0000392C  4EF9 00003974           3104      JMP         LEA_END
00003932                          3105  LEA_MODE_111: ; The rest (not all valid, validated by register number)
00003932  BE3C 0000               3106      CMP.B       #$00, D7            ; Test for absolute word address
00003936  6700 0014               3107      BEQ         LEA_ABS_W
0000393A  BE3C 0001               3108      CMP.B       #$01, D7            ; Test for absolute long address
0000393E  6700 0016               3109      BEQ         LEA_ABS_L
00003942  4EB8 28B0               3110      JSR         EA_INVALID          ; Else: invalid
00003946  4EF9 00003960           3111      JMP         LEA_DEST
0000394C                          3112  LEA_ABS_W:
0000394C  4EB8 2CE8               3113      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003950  4EF9 00003960           3114      JMP         LEA_DEST
00003956                          3115  LEA_ABS_L:
00003956  4EB8 2CD8               3116      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000395A  4EF9 00003960           3117      JMP         LEA_DEST
00003960                          3118  LEA_DEST:
00003960  49F9 000048E8           3119      LEA         COMMA, A4        ; Print comma
00003966  4EB9 0000440E           3120      JSR         WRITE2MEM
0000396C  4EB8 28FE               3121      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, opmode bits unused
00003970  4EB8 29D6               3122      JSR         EA_PRINT_AN         ; Print address register
00003974                          3123  LEA_END:
00003974  4EB8 28C8               3124      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003978  4CDF 3FFF               3125      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
0000397C  4E75                    3126      RTS
0000397E                          3127  EA_LSd:
0000397E  48E7 FFFC               3128      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003982  4EB8 28D4               3129      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003986  4EB8 2924               3130      JSR         EA_SIZE_BITS        ; get size bits in D7
0000398A  BE3C 0003               3131      CMP.B       #$03, D7            ; test if memory shift
0000398E  6700 005E               3132      BEQ         LSd_MEM
00003992  6000 0002               3133      BRA         LSd_REG             ; else, register shfit
00003996                          3134  LSd_REG:
00003996  3E16                    3135      MOVE.W      (A6), D7            ; read opcode word in memory and save,
00003998                          3136                                      ; (using D7 because EA_PRINT_DN uses D7)
00003998  143C 0004               3137      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
0000399C  E56F                    3138      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
0000399E  143C 000D               3139      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
000039A2  E46F                    3140      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000039A4  3016                    3141      MOVE.W      (A6), D0            ; read opcode word in memory and save
000039A6  143C 000A               3142      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
000039AA  E568                    3143      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
000039AC  143C 000F               3144      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
000039B0  E468                    3145      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
000039B2  B03C 0000               3146      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
000039B6  6700 000C               3147      BEQ         LSd_REG_COUNT
000039BA                          3148  LSd_REG_REG:                        ; Else, count/register field contains register number
000039BA  4EB8 2936               3149      JSR         EA_PRINT_DN         ; Print register value, stored in D7
000039BE  4EF9 000039D4           3150      JMP         LSd_REG_END         ; Jump to end of LSd_REG
000039C4                          3151  LSd_REG_COUNT:
000039C4  49F9 000048E2           3152      LEA         POUND, A4         ; Print '#'
000039CA  4EB9 0000440E           3153      JSR         WRITE2MEM
000039D0  4EB8 28BA               3154      JSR         EA_PRINT_DATA  *print hex value in D7 as byte todo, continue on to LSd_REG_END
000039D4                          3155  LSd_REG_END:
000039D4  49F9 000048E8           3156      LEA         COMMA, A4        ; Print comma
000039DA  4EB9 0000440E           3157      JSR         WRITE2MEM
000039E0  4EB8 28D8               3158      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
000039E4  4EB8 2936               3159      JSR         EA_PRINT_DN         ; Print register value in D7
000039E8  4EF9 00003AA4           3160      JMP         LSd_END
000039EE                          3161  LSd_MEM:
000039EE  4EB8 28D8               3162      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
000039F2  41F9 00003A00           3163      LEA         LSd_MEM_MODE, A0    ; Set index '0' for jump table
000039F8  CCFC 0006               3164      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000039FC  4EF0 6000               3165      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003A00                          3166  LSd_MEM_MODE:
00003A00  4EF9 00003A30           3167      JMP         LSd_MEM_MODE_000     ; Invalid: Dn
00003A06  4EF9 00003A3A           3168      JMP         LSd_MEM_MODE_001     ; Invalid: An
00003A0C  4EF9 00003A44           3169      JMP         LSd_MEM_MODE_010     ; (An)
00003A12  4EF9 00003A4E           3170      JMP         LSd_MEM_MODE_011     ; (An)+
00003A18  4EF9 00003A58           3171      JMP         LSd_MEM_MODE_100     ; -(An)
00003A1E  4EF9 00003A62           3172      JMP         LSd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003A24  4EF9 00003A6C           3173      JMP         LSd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A2A  4EF9 00003A76           3174      JMP         LSd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00003A30                          3175  LSd_MEM_MODE_000: ; Invalid: Dn
00003A30  4EB8 28B0               3176      JSR         EA_INVALID          ; Data register direct is invalid mode
00003A34  4EF9 00003AA4           3177      JMP         LSd_END
00003A3A                          3178  LSd_MEM_MODE_001: ; Invalid: An
00003A3A  4EB8 28B0               3179      JSR         EA_INVALID          ; Address register direct is invalid mode
00003A3E  4EF9 00003AA4           3180      JMP         LSd_END
00003A44                          3181  LSd_MEM_MODE_010: ; (An)
00003A44  4EB8 2A76               3182      JSR         EA_PRINT_IND         ; Print address register indirect
00003A48  4EF9 00003AA4           3183      JMP         LSd_END
00003A4E                          3184  LSd_MEM_MODE_011: ; (An)+
00003A4E  4EB8 2B50               3185      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003A52  4EF9 00003AA4           3186      JMP         LSd_END
00003A58                          3187  LSd_MEM_MODE_100: ; -(An)
00003A58  4EB8 2C14               3188      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003A5C  4EF9 00003AA4           3189      JMP         LSd_END         ; Continue with parsing destination operand
00003A62                          3190  LSd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003A62  4EB8 28B0               3191      JSR         EA_INVALID          ; Opcode word is Invalid
00003A66  4EF9 00003AA4           3192      JMP         LSd_END
00003A6C                          3193  LSd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003A6C  4EB8 28B0               3194      JSR         EA_INVALID          ; Opcode word is Invalid
00003A70  4EF9 00003AA4           3195      JMP         LSd_END
00003A76                          3196  LSd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
00003A76  BE3C 0000               3197      CMP.B       #$00, D7            ; Test for absolute word address
00003A7A  6700 0014               3198      BEQ         LSd_MEM_ABS_W
00003A7E  BE3C 0001               3199      CMP.B       #$01, D7            ; Test for absolute long address
00003A82  6700 0016               3200      BEQ         LSd_MEM_ABS_L
00003A86  4EB8 28B0               3201      JSR         EA_INVALID          ; Else: invalid
00003A8A  4EF9 00003AA4           3202      JMP         LSd_END
00003A90                          3203  LSd_MEM_ABS_W:
00003A90  4EB8 2CE8               3204      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003A94  4EF9 00003AA4           3205      JMP         LSd_END
00003A9A                          3206  LSd_MEM_ABS_L:
00003A9A  4EB8 2CD8               3207      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003A9E  4EF9 00003AA4           3208      JMP         LSd_END
00003AA4                          3209  LSd_END:
00003AA4  4EB8 28C8               3210      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003AA8  4CDF 3FFF               3211      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003AAC  4E75                    3212      RTS
00003AAE                          3213  EA_MOVE:
00003AAE  48E7 FFFC               3214      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003AB2  4EB8 28D4               3215      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003AB6  3A16                    3216      MOVE.W      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
00003AB8  143C 0002               3217      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
00003ABC  E56D                    3218      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
00003ABE  143C 000E               3219      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
00003AC2  E46D                    3220      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
00003AC4  BA3C 0003               3221      CMP.B       #$03, D5            ; if size bits are 11, correct D5
00003AC8                          3222                                      ; to 10 for use with immediate data subroutine
00003AC8  6700 0010               3223      BEQ         MOVE_ADJUST_W
00003ACC  BA3C 0002               3224      CMP.B       #$02, D5            ; if size bits are 10, correct D5
00003AD0                          3225                                      ; to 11 for use with immediate data subroutine
00003AD0  6700 0012               3226      BEQ         MOVE_ADJUST_L
00003AD4  4EF9 00003AEE           3227      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003ADA                          3228  MOVE_ADJUST_W:
00003ADA  1A3C 0002               3229      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
00003ADE  4EF9 00003AEE           3230      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003AE4                          3231  MOVE_ADJUST_L:
00003AE4  1A3C 0003               3232      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
00003AE8  4EF9 00003AEE           3233      JMP         MOVE_SOURCE         ; Jump to evaluating source operand
00003AEE                          3234  MOVE_SOURCE:
00003AEE  4EB8 28D8               3235      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003AF2  41F9 00003B00           3236      LEA         MOVE_SRC_MODE, A0   ; Set index '0' for jump table
00003AF8  CCFC 0006               3237      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003AFC  4EF0 6000               3238      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003B00                          3239  MOVE_SRC_MODE:
00003B00  4EF9 00003B30           3240      JMP         MOVE_SRC_MODE_000   ; Dn
00003B06  4EF9 00003B3A           3241      JMP         MOVE_SRC_MODE_001   ; An
00003B0C  4EF9 00003B44           3242      JMP         MOVE_SRC_MODE_010   ; (An)
00003B12  4EF9 00003B4E           3243      JMP         MOVE_SRC_MODE_011   ; (An)+
00003B18  4EF9 00003B58           3244      JMP         MOVE_SRC_MODE_100   ; -(An)
00003B1E  4EF9 00003B62           3245      JMP         MOVE_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003B24  4EF9 00003B6C           3246      JMP         MOVE_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003B2A  4EF9 00003B76           3247      JMP         MOVE_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003B30                          3248  MOVE_SRC_MODE_000: ; Dn
00003B30  4EB8 2936               3249      JSR         EA_PRINT_DN         ; Print data register in D7
00003B34  4EF9 00003BB6           3250      JMP         MOVE_DESTINATION
00003B3A                          3251  MOVE_SRC_MODE_001: ; Invalid: An
00003B3A  4EB8 29D6               3252      JSR         EA_PRINT_AN         ; Print address register in D7
00003B3E  4EF9 00003BB6           3253      JMP         MOVE_DESTINATION
00003B44                          3254  MOVE_SRC_MODE_010: ; (An)
00003B44  4EB8 2A76               3255      JSR         EA_PRINT_IND         ; Print address register indirect
00003B48  4EF9 00003BB6           3256      JMP         MOVE_DESTINATION
00003B4E                          3257  MOVE_SRC_MODE_011: ; (An)+
00003B4E  4EB8 2B50               3258      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003B52  4EF9 00003BB6           3259      JMP         MOVE_DESTINATION
00003B58                          3260  MOVE_SRC_MODE_100: ; -(An)
00003B58  4EB8 2C14               3261      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003B5C  4EF9 00003BB6           3262      JMP         MOVE_DESTINATION    ; Continue with parsing destination operand
00003B62                          3263  MOVE_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003B62  4EB8 28B0               3264      JSR         EA_INVALID          ; Opcode word is Invalid
00003B66  4EF9 00003C78           3265      JMP         MOVE_END
00003B6C                          3266  MOVE_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003B6C  4EB8 28B0               3267      JSR         EA_INVALID          ; Opcode word is Invalid
00003B70  4EF9 00003C78           3268      JMP         MOVE_END
00003B76                          3269  MOVE_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003B76  BE3C 0000               3270      CMP.B       #$00, D7            ; Test for absolute word address
00003B7A  6700 001C               3271      BEQ         MOVE_SRC_ABS_W
00003B7E  BE3C 0001               3272      CMP.B       #$01, D7            ; Test for absolute long address
00003B82  6700 001E               3273      BEQ         MOVE_SRC_ABS_L
00003B86  BE3C 0004               3274      CMP.B       #$04, D7            ; Test for immediate data
00003B8A  6700 0020               3275      BEQ         MOVE_SRC_IMM
00003B8E  4EB8 28B0               3276      JSR         EA_INVALID          ; Else: invalid
00003B92  4EF9 00003C78           3277      JMP         MOVE_END
00003B98                          3278  MOVE_SRC_ABS_W:
00003B98  4EB8 2CE8               3279      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003B9C  4EF9 00003BB6           3280      JMP         MOVE_DESTINATION
00003BA2                          3281  MOVE_SRC_ABS_L:
00003BA2  4EB8 2CD8               3282      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003BA6  4EF9 00003BB6           3283      JMP         MOVE_DESTINATION
00003BAC                          3284  MOVE_SRC_IMM:
00003BAC  4EB8 2B2E               3285      JSR         EA_PRINT_IMM        ; Print immediate data
00003BB0  4EF9 00003BB6           3286      JMP         MOVE_DESTINATION
00003BB6                          3287  MOVE_DESTINATION:
00003BB6  49F9 000048E8           3288      LEA         COMMA, A4        ; Print comma
00003BBC  4EB9 0000440E           3289      JSR         WRITE2MEM
00003BC2  4EB8 28FE               3290      JSR         EA_OPMODE_COMBO     ; mode: D6, register: D7 (destination bits)
00003BC6  41F9 00003BD4           3291      LEA         MOVE_DST_MODE, A0   ; Set index '0' for jump table
00003BCC  CCFC 0006               3292      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003BD0  4EF0 6000               3293      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003BD4                          3294  MOVE_DST_MODE:
00003BD4  4EF9 00003C04           3295      JMP         MOVE_DST_MODE_000   ; Dn
00003BDA  4EF9 00003C0E           3296      JMP         MOVE_DST_MODE_001   ; Invalid: An
00003BE0  4EF9 00003C18           3297      JMP         MOVE_DST_MODE_010   ; (An)
00003BE6  4EF9 00003C22           3298      JMP         MOVE_DST_MODE_011   ; (An)+
00003BEC  4EF9 00003C2C           3299      JMP         MOVE_DST_MODE_100   ; -(An)
00003BF2  4EF9 00003C36           3300      JMP         MOVE_DST_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003BF8  4EF9 00003C40           3301      JMP         MOVE_DST_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003BFE  4EF9 00003C4A           3302      JMP         MOVE_DST_MODE_111   ; The rest (not all valid, validated by register number)
00003C04                          3303  MOVE_DST_MODE_000: ; Dn
00003C04  4EB8 2936               3304      JSR         EA_PRINT_DN         ; Print data register in D7
00003C08  4EF9 00003C78           3305      JMP         MOVE_END
00003C0E                          3306  MOVE_DST_MODE_001: ; Invalid: An
00003C0E  4EB8 28B0               3307      JSR         EA_INVALID          ; Print address register in D7
00003C12  4EF9 00003C78           3308      JMP         MOVE_END
00003C18                          3309  MOVE_DST_MODE_010: ; (An)
00003C18  4EB8 2A76               3310      JSR         EA_PRINT_IND         ; Print address register indirect
00003C1C  4EF9 00003C78           3311      JMP         MOVE_END
00003C22                          3312  MOVE_DST_MODE_011: ; (An)+
00003C22  4EB8 2B50               3313      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003C26  4EF9 00003C78           3314      JMP         MOVE_END
00003C2C                          3315  MOVE_DST_MODE_100: ; -(An)
00003C2C  4EB8 2C14               3316      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003C30  4EF9 00003C78           3317      JMP         MOVE_END    ; Continue with parsing destination operand
00003C36                          3318  MOVE_DST_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003C36  4EB8 28B0               3319      JSR         EA_INVALID          ; Opcode word is Invalid
00003C3A  4EF9 00003C78           3320      JMP         MOVE_END
00003C40                          3321  MOVE_DST_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003C40  4EB8 28B0               3322      JSR         EA_INVALID          ; Opcode word is Invalid
00003C44  4EF9 00003C78           3323      JMP         MOVE_END
00003C4A                          3324  MOVE_DST_MODE_111: ; The rest (not all valid, validated by register number)
00003C4A  BE3C 0000               3325      CMP.B       #$00, D7            ; Test for absolute word address
00003C4E  6700 0014               3326      BEQ         MOVE_DST_ABS_W
00003C52  BE3C 0001               3327      CMP.B       #$01, D7            ; Test for absolute long address
00003C56  6700 0016               3328      BEQ         MOVE_DST_ABS_L
00003C5A  4EB8 28B0               3329      JSR         EA_INVALID          ; Else: invalid
00003C5E  4EF9 00003C78           3330      JMP         MOVE_END
00003C64                          3331  MOVE_DST_ABS_W:
00003C64  4EB8 2CE8               3332      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003C68  4EF9 00003C78           3333      JMP         MOVE_END
00003C6E                          3334  MOVE_DST_ABS_L:
00003C6E  4EB8 2CD8               3335      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003C72  4EF9 00003C78           3336      JMP         MOVE_END
00003C78                          3337  MOVE_END:
00003C78  4EB8 28C8               3338      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003C7C  4CDF 3FFF               3339      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003C80  4E75                    3340      RTS
00003C82                          3341  EA_MOVEA:
00003C82  48E7 FFFC               3342      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003C86  4EB8 28D4               3343      JSR         EA_COPY_PTR         ; Copy global pointer to ASd
00003C8A  3A16                    3344      MOVE.W      (A6), D5            ; Load opcode to data register 5 (for using size bits in immediate data)
00003C8C  143C 0002               3345      MOVE.B      #2, D2              ; Clear upper 10 bits of opcode word
00003C90  E56D                    3346      LSL.W       D2, D5              ; Perform shift (zeros shifted in)
00003C92  143C 000E               3347      MOVE.B      #14, D2             ; 'Right-align' bits 12-13 to determine mode bits
00003C96  E46D                    3348      LSR.W       D2, D5              ; Perform shift (zeros shifted in)
00003C98  BA3C 0003               3349      CMP.B       #$03, D5            ; if size bits are 11, correct D5
00003C9C                          3350                                      ; to 10 for use with immediate data subroutine
00003C9C  6700 0010               3351      BEQ         MOVEA_ADJUST_W
00003CA0  BA3C 0002               3352      CMP.B       #$02, D5            ; if size bits are 10, correct D5
00003CA4                          3353                                      ; to 11 for use with immediate data subroutine
00003CA4  6700 0012               3354      BEQ         MOVEA_ADJUST_L
00003CA8  4EF9 00003CC2           3355      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003CAE                          3356  MOVEA_ADJUST_W:
00003CAE  1A3C 0002               3357      MOVE.B      #$02, D5            ; Correct for weird sizing in MOVE
00003CB2  4EF9 00003CC2           3358      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003CB8                          3359  MOVEA_ADJUST_L:
00003CB8  1A3C 0003               3360      MOVE.B      #$03, D5            ; Correct for weird sizing in MOVE
00003CBC  4EF9 00003CC2           3361      JMP         MOVEA_SOURCE         ; Jump to evaluating source operand
00003CC2                          3362  MOVEA_SOURCE:
00003CC2  4EB8 28D8               3363      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003CC6  41F9 00003CD4           3364      LEA         MOVEA_SRC_MODE, A0   ; Set index '0' for jump table
00003CCC  CCFC 0006               3365      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003CD0  4EF0 6000               3366      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003CD4                          3367  MOVEA_SRC_MODE:
00003CD4  4EF9 00003D04           3368      JMP         MOVEA_SRC_MODE_000   ; Dn
00003CDA  4EF9 00003D0E           3369      JMP         MOVEA_SRC_MODE_001   ; An
00003CE0  4EF9 00003D18           3370      JMP         MOVEA_SRC_MODE_010   ; (An)
00003CE6  4EF9 00003D22           3371      JMP         MOVEA_SRC_MODE_011   ; (An)+
00003CEC  4EF9 00003D2C           3372      JMP         MOVEA_SRC_MODE_100   ; -(An)
00003CF2  4EF9 00003D36           3373      JMP         MOVEA_SRC_MODE_101   ; Invalid: Address Register Indirect with Displacement Mode
00003CF8  4EF9 00003D40           3374      JMP         MOVEA_SRC_MODE_110   ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003CFE  4EF9 00003D4A           3375      JMP         MOVEA_SRC_MODE_111   ; The rest (not all valid, validated by register number)
00003D04                          3376  MOVEA_SRC_MODE_000: ; Dn
00003D04  4EB8 2936               3377      JSR         EA_PRINT_DN         ; Print data register in D7
00003D08  4EF9 00003D8A           3378      JMP         MOVEA_DESTINATION
00003D0E                          3379  MOVEA_SRC_MODE_001: ; Invalid: An
00003D0E  4EB8 29D6               3380      JSR         EA_PRINT_AN         ; Print address register in D7
00003D12  4EF9 00003D8A           3381      JMP         MOVEA_DESTINATION
00003D18                          3382  MOVEA_SRC_MODE_010: ; (An)
00003D18  4EB8 2A76               3383      JSR         EA_PRINT_IND         ; Print address register indirect
00003D1C  4EF9 00003D8A           3384      JMP         MOVEA_DESTINATION
00003D22                          3385  MOVEA_SRC_MODE_011: ; (An)+
00003D22  4EB8 2B50               3386      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003D26  4EF9 00003D8A           3387      JMP         MOVEA_DESTINATION
00003D2C                          3388  MOVEA_SRC_MODE_100: ; -(An)
00003D2C  4EB8 2C14               3389      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003D30  4EF9 00003D8A           3390      JMP         MOVEA_DESTINATION    ; Continue with parsing destination operand
00003D36                          3391  MOVEA_SRC_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003D36  4EB8 28B0               3392      JSR         EA_INVALID          ; Opcode word is Invalid
00003D3A  4EF9 00003D9E           3393      JMP         MOVEA_END
00003D40                          3394  MOVEA_SRC_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003D40  4EB8 28B0               3395      JSR         EA_INVALID          ; Opcode word is Invalid
00003D44  4EF9 00003D9E           3396      JMP         MOVEA_END
00003D4A                          3397  MOVEA_SRC_MODE_111: ; The rest (not all valid, validated by register number)
00003D4A  BE3C 0000               3398      CMP.B       #$00, D7            ; Test for absolute word address
00003D4E  6700 001C               3399      BEQ         MOVEA_SRC_ABS_W
00003D52  BE3C 0001               3400      CMP.B       #$01, D7            ; Test for absolute long address
00003D56  6700 001E               3401      BEQ         MOVEA_SRC_ABS_L
00003D5A  BE3C 0004               3402      CMP.B       #$04, D7            ; Test for immediate data
00003D5E  6700 0020               3403      BEQ         MOVEA_SRC_IMM
00003D62  4EB8 28B0               3404      JSR         EA_INVALID          ; Else: invalid
00003D66  4EF9 00003D9E           3405      JMP         MOVEA_END
00003D6C                          3406  MOVEA_SRC_ABS_W:
00003D6C  4EB8 2CE8               3407      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003D70  4EF9 00003D8A           3408      JMP         MOVEA_DESTINATION
00003D76                          3409  MOVEA_SRC_ABS_L:
00003D76  4EB8 2CD8               3410      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003D7A  4EF9 00003D8A           3411      JMP         MOVEA_DESTINATION
00003D80                          3412  MOVEA_SRC_IMM:
00003D80  4EB8 2B2E               3413      JSR         EA_PRINT_IMM        ; Print immediate data
00003D84  4EF9 00003D8A           3414      JMP         MOVEA_DESTINATION
00003D8A                          3415  MOVEA_DESTINATION:
00003D8A  49F9 000048E8           3416      LEA         COMMA, A4        ; Print comma
00003D90  4EB9 0000440E           3417      JSR         WRITE2MEM
00003D96  4EB8 28FE               3418      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003D9A  4EB8 29D6               3419      JSR         EA_PRINT_AN         ; Print address register, continue to end
00003D9E                          3420  MOVEA_END:
00003D9E  4EB8 28C8               3421      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003DA2  4CDF 3FFF               3422      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003DA6  4E75                    3423      RTS
00003DA8                          3424  EA_MOVEM:
00003DA8                          3425      *seems complicated, todo
00003DA8  4EB8 28A0               3426      JSR         EA_UNIMPLEMENTED
00003DAC  4E75                    3427      RTS
00003DAE                          3428  EA_MOVEQ:
00003DAE  48E7 FFFC               3429      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003DB2  4EB8 28D4               3430      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003DB6  3216                    3431      MOVE.W      (A6), D1            ; Load opcode to data register 1
00003DB8  143C 0008               3432      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003DBC  E569                    3433      LSL.W       D2, D1              ; Perform shift (zeros shifted in)
00003DBE  143C 0008               3434      MOVE.B      #8, D2              ; 'Right-align' bits 0-7 to determine data bits
00003DC2  E469                    3435      LSR.W       D2, D1              ; Perform shift (zeros shifted in)
00003DC4  3616                    3436      MOVE.W      (A6), D3            ; load opcode word
00003DC6  143C 0008               3437      MOVE.B      #8, D2              ; Clear upper 8 bits of opcode word
00003DCA  E56B                    3438      LSL.W       D2, D3              ; Perform shift (zeros shifted in)
00003DCC  143C 000F               3439      MOVE.B      #15, D2             ; 'Right-align' bit 7 to determine MSB
00003DD0  E46B                    3440      LSR.W       D2, D3              ; Perform shift (zeros shifted in)
00003DD2  B63C 0000               3441      CMP.B       #$00, D3            ; If 0, sign extend with 0 (already done by isolation code)
00003DD6  6700 0008               3442      BEQ         MOVEQ_PRINT_DATA
00003DDA  0681 FFFFFF00           3443      ADD.L       #$FFFFFF00, D1      ; Else, sign extend data with F
00003DE0                          3444  MOVEQ_PRINT_DATA:
00003DE0  49F9 000048E2           3445      LEA         POUND, A4         ; Print '#'
00003DE6  4EB9 0000440E           3446      JSR         WRITE2MEM
00003DEC  4EB8 28BA               3447      JSR         EA_PRINT_DATA *print data todo
00003DF0  49F9 000048E8           3448      LEA         COMMA, A4        ; Print comma
00003DF6  4EB9 0000440E           3449      JSR         WRITE2MEM
00003DFC  4EB8 28FE               3450      JSR         EA_OPMODE_COMBO     ; Get register bits in D7, mode bits not used
00003E00  4EB8 2936               3451      JSR         EA_PRINT_DN         ; Print data register
00003E04  4EB8 28C8               3452      JSR         EA_UPDATE_POINTER   ; Updates global pointer
00003E08  4CDF 3FFF               3453      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003E0C  4E75                    3454      RTS
00003E0E                          3455  EA_MULS_W:
00003E0E  48E7 FFFC               3456      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003E12  4EB8 28D4               3457      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003E16  4EB8 28D8               3458      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00003E1A  41F9 00003E28           3459      LEA         MULS_W_MODE, A0     ; Set index '0' for jump table
00003E20  CCFC 0006               3460      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003E24  4EF0 6000               3461      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003E28                          3462  MULS_W_MODE:
00003E28  4EF9 00003E58           3463      JMP         MULS_W_MODE_000     ; Dn
00003E2E  4EF9 00003E62           3464      JMP         MULS_W_MODE_001     ; Invalid: An
00003E34  4EF9 00003E6C           3465      JMP         MULS_W_MODE_010     ; (An)
00003E3A  4EF9 00003E76           3466      JMP         MULS_W_MODE_011     ; (An)+
00003E40  4EF9 00003E80           3467      JMP         MULS_W_MODE_100     ; -(An)
00003E46  4EF9 00003E8A           3468      JMP         MULS_W_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00003E4C  4EF9 00003E94           3469      JMP         MULS_W_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E52  4EF9 00003E9E           3470      JMP         MULS_W_MODE_111     ; The rest (not all valid, validated by register number)
00003E58                          3471  MULS_W_MODE_000: ; Dn
00003E58  4EB8 2936               3472      JSR         EA_PRINT_DN         ; Print data register direct operand
00003E5C  4EF9 00003EE2           3473      JMP         MULS_W_DEST         ; Go to: print destination operand
00003E62                          3474  MULS_W_MODE_001: ; Invalid: An
00003E62  4EB8 28B0               3475      JSR         EA_INVALID          ; Address register direct is invalid mode
00003E66  4EF9 00003EF4           3476      JMP         MULS_W_END
00003E6C                          3477  MULS_W_MODE_010: ; (An)
00003E6C  4EB8 2A76               3478      JSR         EA_PRINT_IND         ; Print address register indirect
00003E70  4EF9 00003EE2           3479      JMP         MULS_W_DEST
00003E76                          3480  MULS_W_MODE_011: ; (An)+
00003E76  4EB8 2B50               3481      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00003E7A  4EF9 00003EE2           3482      JMP         MULS_W_DEST
00003E80                          3483  MULS_W_MODE_100: ; -(An)
00003E80  4EB8 2C14               3484      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
00003E84  4EF9 00003EE2           3485      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003E8A                          3486  MULS_W_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00003E8A  4EB8 28B0               3487      JSR         EA_INVALID          ; Opcode word is Invalid
00003E8E  4EF9 00003EF4           3488      JMP         MULS_W_END
00003E94                          3489  MULS_W_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00003E94  4EB8 28B0               3490      JSR         EA_INVALID          ; Opcode word is Invalid
00003E98  4EF9 00003EF4           3491      JMP         MULS_W_END
00003E9E                          3492  MULS_W_MODE_111: ; The rest (not all valid, validated by register number)
00003E9E  BE3C 0000               3493      CMP.B       #$00, D7            ; Test for absolute word address
00003EA2  6700 001C               3494      BEQ         MULS_W_ABS_W
00003EA6  BE3C 0001               3495      CMP.B       #$01, D7            ; Test for absolute long address
00003EAA  6700 001E               3496      BEQ         MULS_W_ABS_L
00003EAE  BE3C 0004               3497      CMP.B       #$04, D7            ; Test for immediate data
00003EB2  6700 0020               3498      BEQ         MULS_W_IMM
00003EB6  4EB8 28B0               3499      JSR         EA_INVALID          ; Else: invalid
00003EBA  4EF9 00003EF4           3500      JMP         MULS_W_END
00003EC0                          3501  MULS_W_ABS_W:
00003EC0  4EB8 2CE8               3502      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00003EC4  4EF9 00003EE2           3503      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003ECA                          3504  MULS_W_ABS_L:
00003ECA  4EB8 2CD8               3505      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00003ECE  4EF9 00003EE2           3506      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003ED4                          3507  MULS_W_IMM:
00003ED4  1A3C 0002               3508      MOVE.B      #2, D5              ; Size is word
00003ED8  4EB8 2B2E               3509      JSR         EA_PRINT_IMM        ; Print immediate data
00003EDC  4EF9 00003EE2           3510      JMP         MULS_W_DEST         ; Continue with parsing destination operand
00003EE2                          3511  MULS_W_DEST:
00003EE2                          3512      *print COMMA
00003EE2                          3513      *Get destination register
00003EE2  3E16                    3514      MOVE.W      (A6), D7            ; Load word at current pointer to D1
00003EE4  143C 0004               3515      MOVE.B      #4, D2              ; Clear upper 4 bits of opcode word
00003EE8  E56F                    3516      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
00003EEA  143C 000D               3517      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to determine register
00003EEE  E46F                    3518      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
00003EF0  4EB8 2936               3519      JSR         EA_PRINT_DN         ; Print data register direct operand
00003EF4                          3520  MULS_W_END:
00003EF4  4EB8 28C8               3521      JSR         EA_UPDATE_POINTER   ; Update global pointer
00003EF8  4CDF 3FFF               3522      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
00003EFC  4E75                    3523      RTS
00003EFE                          3524  
00003EFE                          3525  EA_OR:
00003EFE  48E7 FFFC               3526      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
00003F02  4EB8 28D4               3527      JSR         EA_COPY_PTR         ; Copy global pointer to A5
00003F06  4EB8 28FE               3528      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
00003F0A  41F9 00003F18           3529      LEA         OR_OPMODE, A0       ; Set index '0' for jump table
00003F10  CCFC 0006               3530      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003F14  4EF0 6000               3531      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003F18                          3532  OR_OPMODE:
00003F18  4EF9 00003F48           3533      JMP         OR_OPMODE_000       ; mode 1, byte
00003F1E  4EF9 00003F52           3534      JMP         OR_OPMODE_001       ; mode 1, word
00003F24  4EF9 00003F5C           3535      JMP         OR_OPMODE_010       ; mode 1, long
00003F2A  4EF9 00003F66           3536      JMP         OR_OPMODE_011       ; Invalid value
00003F30  4EF9 00003F70           3537      JMP         OR_OPMODE_100       ; mode 2, byte
00003F36  4EF9 00003F7A           3538      JMP         OR_OPMODE_101       ; mode 2, word
00003F3C  4EF9 00003F84           3539      JMP         OR_OPMODE_110       ; mode 2, long
00003F42  4EF9 00003F8E           3540      JMP         OR_OPMODE_111       ; Invalid value
00003F48                          3541  OR_OPMODE_000: ; mode 1, byte
00003F48  1A3C 0001               3542      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F4C  4EF9 00003F98           3543      JMP         OR_MODE_1
00003F52                          3544  OR_OPMODE_001: ; mode 1, word
00003F52  1A3C 0002               3545      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00003F56  4EF9 00003F98           3546      JMP         OR_MODE_1
00003F5C                          3547  OR_OPMODE_010: ; mode 1, long
00003F5C  1A3C 0003               3548      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
00003F60  4EF9 00003F98           3549      JMP         OR_MODE_1
00003F66                          3550  OR_OPMODE_011: ; Invalid value
00003F66  4EB8 28B0               3551      JSR         EA_INVALID
00003F6A  4EF9 000040B6           3552      JMP         OR_END
00003F70                          3553  OR_OPMODE_100: ; mode 2, byte
00003F70  1A3C 0001               3554      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F74  4EF9 00003FC2           3555      JMP         OR_MODE_2
00003F7A                          3556  OR_OPMODE_101: ; mode 2, word
00003F7A  1A3C 0001               3557      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F7E  4EF9 00003FC2           3558      JMP         OR_MODE_2
00003F84                          3559  OR_OPMODE_110: ; mode 2, long
00003F84  1A3C 0001               3560      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00003F88  4EF9 00003FC2           3561      JMP         OR_MODE_2
00003F8E                          3562  OR_OPMODE_111: ; Invalid value
00003F8E  4EB8 28B0               3563      JSR         EA_INVALID
00003F92  4EF9 000040B6           3564      JMP         OR_END
00003F98                          3565  OR_MODE_1:
00003F98  4280                    3566      CLR.L       D0                  ; Clear data register 0
00003F9A  103C 0001               3567      MOVE.B      #1, D0              ; Save mode number to D0
00003F9E  3207                    3568      MOVE.W      D7, D1              ; Save register value for printing dest. operand
00003FA0  4EB8 28D8               3569      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003FA4  4EB9 00003FE8           3570      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
00003FAA  49F9 000048E8           3571      LEA         COMMA, A4        ; Print comma
00003FB0  4EB9 0000440E           3572      JSR         WRITE2MEM
00003FB6  3E01                    3573      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
00003FB8  4EB8 2936               3574      JSR         EA_PRINT_DN         ; Print data register
00003FBC  4EF9 000040B6           3575      JMP         OR_END
00003FC2                          3576  OR_MODE_2:
00003FC2  4280                    3577      CLR.L       D0                  ; Clear data register 0
00003FC4  103C 0002               3578      MOVE.B      #2, D0              ; Save mode number to D0
00003FC8  4EB8 2936               3579      JSR         EA_PRINT_DN         ; Print data register
00003FCC  49F9 000048E8           3580      LEA         COMMA, A4        ; Print comma
00003FD2  4EB9 0000440E           3581      JSR         WRITE2MEM
00003FD8  4EB8 28D8               3582      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
00003FDC  4EB9 00003FE8           3583      JSR         OR_EVAL_EA          ; Evaluate the results of subroutine call
00003FE2  4EF9 000040B6           3584      JMP         OR_END
00003FE8                          3585  OR_EVAL_EA:
00003FE8  41F9 00003FF6           3586      LEA         OR_MODE, A0         ; Set index '0' for jump table
00003FEE  CCFC 0006               3587      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
00003FF2  4EF0 6000               3588      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00003FF6                          3589  OR_MODE:
00003FF6  4EF9 00004026           3590      JMP         OR_MODE_000         ; Invalid: Dn
00003FFC  4EF9 00004030           3591      JMP         OR_MODE_001         ; An (invalid if opmode 2)
00004002  4EF9 00004042           3592      JMP         OR_MODE_010         ; (An)
00004008  4EF9 0000404C           3593      JMP         OR_MODE_011         ; (An)+
0000400E  4EF9 00004056           3594      JMP         OR_MODE_100         ; -(An)
00004014  4EF9 00004060           3595      JMP         OR_MODE_101         ; Invalid: Address Register Indirect with Displacement Mode
0000401A  4EF9 00004066           3596      JMP         OR_MODE_110         ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004020  4EF9 0000406C           3597      JMP         OR_MODE_111         ; The rest (not all valid, validated by register number)
00004026                          3598  OR_MODE_000: ; Invalid: Dn
00004026  4EB8 28B0               3599      JSR         EA_INVALID          ; Invalid for both opmodes
0000402A  4EF9 000040B0           3600      JMP         OR_MODE_END         ; End evaluation of ea mode
00004030                          3601  OR_MODE_001: ; An (invalid if opmode 2)
00004030  B07C 0002               3602      CMP         #2, D0
00004034  6700 007C               3603      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
00004038  4EB8 29D6               3604      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
0000403C  4EF9 000040B0           3605      JMP         OR_MODE_END         ; End evaluation of ea mode
00004042                          3606  OR_MODE_010: ; (An)
00004042  4EB8 2A76               3607      JSR         EA_PRINT_IND         ; Print address register indirect
00004046  4EF9 000040B0           3608      JMP         OR_MODE_END         ; End evaluation of ea mode
0000404C                          3609  OR_MODE_011: ; (An)+
0000404C  4EB8 2B50               3610      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00004050  4EF9 000040B0           3611      JMP         OR_MODE_END         ; End evaluation of ea mode
00004056                          3612  OR_MODE_100: ; -(An)
00004056  4EB8 2C14               3613      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000405A  4EF9 000040B0           3614      JMP         OR_MODE_END         ; End evaluation of ea mode
00004060                          3615  OR_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00004060  4EF9 000040B2           3616      JMP         OR_MODE_INVALID
00004066                          3617  OR_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004066  4EF9 000040B2           3618      JMP         OR_MODE_INVALID
0000406C                          3619  OR_MODE_111: ; The rest (not all valid, validated by register number)
0000406C  BE3C 0000               3620      CMP.B       #$00, D7            ; Test for absolute word address
00004070  6700 0018               3621      BEQ         OR_ABS_W
00004074  BE3C 0001               3622      CMP.B       #$01, D7            ; Test for absolute long address
00004078  6700 001A               3623      BEQ         OR_ABS_L
0000407C  BE3C 0004               3624      CMP.B       #$04, D7            ; Test for immediate data
00004080  6700 001C               3625      BEQ         OR_IMM
00004084  4EF9 000040B2           3626      JMP         OR_MODE_INVALID     ; else, invalid
0000408A                          3627  OR_ABS_W:
0000408A  4EB8 2CE8               3628      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
0000408E  4EF9 000040B0           3629      JMP         OR_MODE_END
00004094                          3630  OR_ABS_L:
00004094  4EB8 2CD8               3631      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
00004098  4EF9 000040B0           3632      JMP         OR_MODE_END
0000409E                          3633  OR_IMM: ; invalid if opmode is 2
0000409E  B07C 0002               3634      CMP         #2, D0
000040A2  6700 000E               3635      BEQ         OR_MODE_INVALID     ; If opmode 2, An is invalid addressing mode
000040A6  4EB8 2B2E               3636      JSR         EA_PRINT_IMM        ; Print immediate data
000040AA  4EF9 000040B0           3637      JMP         OR_MODE_END
000040B0                          3638  OR_MODE_END:
000040B0  4E75                    3639      RTS                             ; Finish evaluating EA bits
000040B2                          3640  OR_MODE_INVALID:
000040B2  4EB8 28B0               3641      JSR         EA_INVALID          ; Opcode word is Invalid, continue to end
000040B6                          3642  OR_END:
000040B6  4EB8 28C8               3643      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000040BA  4CDF 3FFF               3644      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000040BE  4E75                    3645      RTS
000040C0                          3646  EA_ROd:
000040C0  48E7 FFFC               3647      MOVEM.L     A0-A5/D0-D7, -(SP)  ; Save registers (except A6, global pointer to word to read)
000040C4  4EB8 28D4               3648      JSR         EA_COPY_PTR         ; Copy global pointer to A5
000040C8  4EB8 2924               3649      JSR         EA_SIZE_BITS        ; get size bits in D7
000040CC  BE3C 0003               3650      CMP.B       #$03, D7            ; test if memory shift
000040D0  6700 005E               3651      BEQ         ROd_MEM
000040D4  6000 0002               3652      BRA         ROd_REG             ; else, register shfit
000040D8                          3653  ROd_REG:
000040D8  3E16                    3654      MOVE.W      (A6), D7            ; read opcode word in memory and save,
000040DA                          3655                                      ; (using D7 because EA_PRINT_DN uses D7)
000040DA  143C 0004               3656      MOVE.B      #4, D2              ; Clear upper 4 bits of operand word
000040DE  E56F                    3657      LSL.W       D2, D7              ; Perform shift (zeros shifted in)
000040E0  143C 000D               3658      MOVE.B      #13, D2             ; 'Right-align' bits 9-11 to get count/register field
000040E4  E46F                    3659      LSR.W       D2, D7              ; Perform shift (zeros shifted in)
000040E6  3016                    3660      MOVE.W      (A6), D0            ; read opcode word in memory and save
000040E8  143C 000A               3661      MOVE.B      #10, D2             ; Clear upper 10 bits of operand word
000040EC  E568                    3662      LSL.W       D2, D0              ; Perform shift (zeros shifted in)
000040EE  143C 000F               3663      MOVE.B      #15, D2             ; 'Right-align' bit 5 to get value
000040F2  E468                    3664      LSR.W       D2, D0              ; Perform shift (zeros shifted in)
000040F4  B03C 0000               3665      CMP.B       #$00, D0            ; If i/r bit is 0, count/register field contains shift count (modulo 64)
000040F8  6700 000C               3666      BEQ         ROd_REG_COUNT
000040FC                          3667  ROd_REG_REG:                        ; Else, count/register field contains register number
000040FC  4EB8 2936               3668      JSR         EA_PRINT_DN         ; Print register value, stored in D7
00004100  4EF9 00004116           3669      JMP         ROd_REG_END         ; Jump to end of ROd_REG
00004106                          3670  ROd_REG_COUNT:
00004106  49F9 000048E2           3671      LEA         POUND, A4         ; Print '#'''
0000410C  4EB9 0000440E           3672      JSR         WRITE2MEM
00004112  4EB8 28BA               3673      JSR         EA_PRINT_DATA       *print hex value in D7 as byte todo, continue on to ROd_REG_END
00004116                          3674  ROd_REG_END:
00004116  49F9 000048E8           3675      LEA         COMMA, A4        ; Print comma
0000411C  4EB9 0000440E           3676      JSR         WRITE2MEM
00004122  4EB8 28D8               3677      JSR         EA_DEFAULT_COMBO    ; To get register bits in D7, 'mode' bits are not used
00004126  4EB8 2936               3678      JSR         EA_PRINT_DN         ; Print register value in D7
0000412A  4EF9 000041E6           3679      JMP         ROd_END
00004130                          3680  ROd_MEM:
00004130  4EB8 28D8               3681      JSR         EA_DEFAULT_COMBO    ; mode: D6, register: D7
00004134  41F9 00004142           3682      LEA         ROd_MEM_MODE, A0    ; Set index '0' for jump table
0000413A  CCFC 0006               3683      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
0000413E  4EF0 6000               3684      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00004142                          3685  ROd_MEM_MODE:
00004142  4EF9 00004172           3686      JMP         ROd_MEM_MODE_000     ; Invalid: Dn
00004148  4EF9 0000417C           3687      JMP         ROd_MEM_MODE_001     ; Invalid: An
0000414E  4EF9 00004186           3688      JMP         ROd_MEM_MODE_010     ; (An)
00004154  4EF9 00004190           3689      JMP         ROd_MEM_MODE_011     ; (An)+
0000415A  4EF9 0000419A           3690      JMP         ROd_MEM_MODE_100     ; -(An)
00004160  4EF9 000041A4           3691      JMP         ROd_MEM_MODE_101     ; Invalid: Address Register Indirect with Displacement Mode
00004166  4EF9 000041AE           3692      JMP         ROd_MEM_MODE_110     ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000416C  4EF9 000041B8           3693      JMP         ROd_MEM_MODE_111     ; The rest (not all valid, validated by register number)
00004172                          3694  ROd_MEM_MODE_000: ; Invalid: Dn
00004172  4EB8 28B0               3695      JSR         EA_INVALID          ; Data register direct is invalid mode
00004176  4EF9 000041E6           3696      JMP         ROd_END
0000417C                          3697  ROd_MEM_MODE_001: ; Invalid: An
0000417C  4EB8 28B0               3698      JSR         EA_INVALID          ; Address register direct is invalid mode
00004180  4EF9 000041E6           3699      JMP         ROd_END
00004186                          3700  ROd_MEM_MODE_010: ; (An)
00004186  4EB8 2A76               3701      JSR         EA_PRINT_IND         ; Print address register indirect
0000418A  4EF9 000041E6           3702      JMP         ROd_END
00004190                          3703  ROd_MEM_MODE_011: ; (An)+
00004190  4EB8 2B50               3704      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00004194  4EF9 000041E6           3705      JMP         ROd_END
0000419A                          3706  ROd_MEM_MODE_100: ; -(An)
0000419A  4EB8 2C14               3707      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000419E  4EF9 000041E6           3708      JMP         ROd_END         ; Continue with parsing destination operand
000041A4                          3709  ROd_MEM_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
000041A4  4EB8 28B0               3710      JSR         EA_INVALID          ; Opcode word is Invalid
000041A8  4EF9 000041E6           3711      JMP         ROd_END
000041AE                          3712  ROd_MEM_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
000041AE  4EB8 28B0               3713      JSR         EA_INVALID          ; Opcode word is Invalid
000041B2  4EF9 000041E6           3714      JMP         ROd_END
000041B8                          3715  ROd_MEM_MODE_111: ; The rest (not all valid, validated by register number)
000041B8  BE3C 0000               3716      CMP.B       #$00, D7            ; Test for absolute word address
000041BC  6700 0014               3717      BEQ         ROd_MEM_ABS_W
000041C0  BE3C 0001               3718      CMP.B       #$01, D7            ; Test for absolute long address
000041C4  6700 0016               3719      BEQ         ROd_MEM_ABS_L
000041C8  4EB8 28B0               3720      JSR         EA_INVALID          ; Else: invalid
000041CC  4EF9 000041E6           3721      JMP         ROd_END
000041D2                          3722  ROd_MEM_ABS_W:
000041D2  4EB8 2CE8               3723      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
000041D6  4EF9 000041E6           3724      JMP         ROd_END
000041DC                          3725  ROd_MEM_ABS_L:
000041DC  4EB8 2CD8               3726      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
000041E0  4EF9 000041E6           3727      JMP         ROd_END
000041E6                          3728  ROd_END:
000041E6  4EB8 28C8               3729      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000041EA  4CDF 3FFF               3730      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000041EE  4E75                    3731      RTS
000041F0                          3732  EA_SUB:
000041F0  4EB8 28FE               3733      JSR         EA_OPMODE_COMBO     ; opmode: D6, register: D7
000041F4  41F9 00004202           3734      LEA         SUB_OPMODE, A0      ; Set index '0' for jump table
000041FA  CCFC 0006               3735      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000041FE  4EF0 6000               3736      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
00004202                          3737  SUB_OPMODE:
00004202  4EF9 00004232           3738      JMP         SUB_OPMODE_000      ; mode 1, byte
00004208  4EF9 0000423C           3739      JMP         SUB_OPMODE_001      ; mode 1, word
0000420E  4EF9 00004246           3740      JMP         SUB_OPMODE_010      ; mode 1, long
00004214  4EF9 00004250           3741      JMP         SUB_OPMODE_011      ; Invalid value
0000421A  4EF9 0000425A           3742      JMP         SUB_OPMODE_100      ; mode 2, byte
00004220  4EF9 00004264           3743      JMP         SUB_OPMODE_101      ; mode 2, word
00004226  4EF9 0000426E           3744      JMP         SUB_OPMODE_110      ; mode 2, long
0000422C  4EF9 00004278           3745      JMP         SUB_OPMODE_111      ; Invalid value
00004232                          3746  SUB_OPMODE_000: ; mode 1, byte
00004232  1A3C 0001               3747      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004236  4EF9 00004282           3748      JMP         SUB_MODE_1
0000423C                          3749  SUB_OPMODE_001: ; mode 1, word
0000423C  1A3C 0002               3750      MOVE.B      #2, D5              ; Store size in the case of an immediate operand
00004240  4EF9 00004282           3751      JMP         SUB_MODE_1
00004246                          3752  SUB_OPMODE_010: ; mode 1, long
00004246  1A3C 0003               3753      MOVE.B      #3, D5              ; Store size in the case of an immediate operand
0000424A  4EF9 00004282           3754      JMP         SUB_MODE_1
00004250                          3755  SUB_OPMODE_011: ; Invalid value
00004250  4EB8 28B0               3756      JSR         EA_INVALID
00004254  4EF9 000043A8           3757      JMP         SUB_END
0000425A                          3758  SUB_OPMODE_100: ; mode 2, byte
0000425A  1A3C 0001               3759      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
0000425E  4EF9 000042AC           3760      JMP         SUB_MODE_2
00004264                          3761  SUB_OPMODE_101: ; mode 2, word
00004264  1A3C 0001               3762      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004268  4EF9 000042AC           3763      JMP         SUB_MODE_2
0000426E                          3764  SUB_OPMODE_110: ; mode 2, long
0000426E  1A3C 0001               3765      MOVE.B      #1, D5              ; Store size in the case of an immediate operand
00004272  4EF9 000042AC           3766      JMP         SUB_MODE_2
00004278                          3767  SUB_OPMODE_111: ; Invalid value
00004278  4EB8 28B0               3768      JSR         EA_INVALID
0000427C  4EF9 000043A8           3769      JMP         SUB_END
00004282                          3770  SUB_MODE_1:
00004282  4280                    3771      CLR.L       D0                  ; Clear data register 0
00004284  103C 0001               3772      MOVE.B      #1, D0              ; Save mode number to D0
00004288  3207                    3773      MOVE.W      D7, D1              ; Save register value for printing dest. operand
0000428A  4EB8 28D8               3774      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
0000428E  4EB9 000042D2           3775      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
00004294  49F9 000048E8           3776      LEA         COMMA, A4        ; Print comma
0000429A  4EB9 0000440E           3777      JSR         WRITE2MEM
000042A0  3E01                    3778      MOVE.W      D1, D7              ; Return register value to D7 for use by subroutine
000042A2  4EB8 2936               3779      JSR         EA_PRINT_DN         ; Print data register
000042A6  4EF9 000043A8           3780      JMP         SUB_END
000042AC                          3781  SUB_MODE_2:
000042AC  4280                    3782      CLR.L       D0                  ; Clear data register 0
000042AE  103C 0002               3783      MOVE.B      #2, D0              ; Save mode number to D0
000042B2  4EB8 2936               3784      JSR         EA_PRINT_DN         ; Print data register
000042B6  49F9 000048E8           3785      LEA         COMMA, A4        ; Print comma
000042BC  4EB9 0000440E           3786      JSR         WRITE2MEM
000042C2  4EB8 28D8               3787      JSR         EA_DEFAULT_COMBO    ; Stores mode bits in D6, register bits in D7
000042C6  4EB9 000042D2           3788      JSR         SUB_EVAL_EA         ; Evaluate the results of subroutine call
000042CC  4EF9 000043A8           3789      JMP         SUB_END
000042D2                          3790  SUB_EVAL_EA:
000042D2  41F9 000042E0           3791      LEA         SUB_MODE, A0        ; Set index '0' for jump table
000042D8  CCFC 0006               3792      MULU        #6, D6              ; Form offset (move 6 bytes in memory for every 'JMP' command)
000042DC  4EF0 6000               3793      JMP         0(A0, D6)           ; Jump indirect with index, i.e. jump to 'table' + displacement
000042E0                          3794  SUB_MODE:
000042E0  4EF9 00004310           3795      JMP         SUB_MODE_000        ; Dn (invalid if opmode 2)
000042E6  4EF9 00004322           3796      JMP         SUB_MODE_001        ; An (invalid if opmode 2)
000042EC  4EF9 00004334           3797      JMP         SUB_MODE_010        ; (An)
000042F2  4EF9 0000433E           3798      JMP         SUB_MODE_011        ; (An)+
000042F8  4EF9 00004348           3799      JMP         SUB_MODE_100        ; -(An)
000042FE  4EF9 00004352           3800      JMP         SUB_MODE_101        ; Invalid: Address Register Indirect with Displacement Mode
00004304  4EF9 00004358           3801      JMP         SUB_MODE_110        ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
0000430A  4EF9 0000435E           3802      JMP         SUB_MODE_111        ; The rest (not all valid, validated by register number)
00004310                          3803  SUB_MODE_000: ; Dn (invalid if opmode 2)
00004310  B07C 0002               3804      CMP         #2, D0
00004314  6700 008E               3805      BEQ         SUB_MODE_INVALID    ; If opmode 2, Dn is invalid addressing mode
00004318  4EB8 2936               3806      JSR         EA_PRINT_DN         ; Print data register direct operand
0000431C  4EF9 000043A2           3807      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004322                          3808  SUB_MODE_001: ; An (invalid if opmode 2)
00004322  B07C 0002               3809      CMP         #2, D0
00004326  6700 007C               3810      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
0000432A  4EB8 29D6               3811      JSR         EA_PRINT_AN         ; Address register direct is invalid mode
0000432E  4EF9 000043A2           3812      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004334                          3813  SUB_MODE_010: ; (An)
00004334  4EB8 2A76               3814      JSR         EA_PRINT_IND         ; Print address register indirect
00004338  4EF9 000043A2           3815      JMP         SUB_MODE_END        ; End evaluation of ea mode
0000433E                          3816  SUB_MODE_011: ; (An)+
0000433E  4EB8 2B50               3817      JSR         EA_PRINT_POSTINC    ; Print address register indirect with post increment
00004342  4EF9 000043A2           3818      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004348                          3819  SUB_MODE_100: ; -(An)
00004348  4EB8 2C14               3820      JSR         EA_PRINT_PREDEC     ; Print address register indirect with pre decrement
0000434C  4EF9 000043A2           3821      JMP         SUB_MODE_END        ; End evaluation of ea mode
00004352                          3822  SUB_MODE_101: ; Invalid: Address Register Indirect with Displacement Mode
00004352  4EF9 000043A4           3823      JMP         SUB_MODE_INVALID
00004358                          3824  SUB_MODE_110: ; Invalid: Address Register Indirect with Index (8-Bit Displacement)
00004358  4EF9 000043A4           3825      JMP         SUB_MODE_INVALID
0000435E                          3826  SUB_MODE_111: ; The rest (not all valid, validated by register number)
0000435E  BE3C 0000               3827      CMP.B       #$00, D7            ; Test for absolute word address
00004362  6700 0018               3828      BEQ         SUB_ABS_W
00004366  BE3C 0001               3829      CMP.B       #$01, D7            ; Test for absolute long address
0000436A  6700 001A               3830      BEQ         SUB_ABS_L
0000436E  BE3C 0004               3831      CMP.B       #$04, D7            ; Test for immediate data
00004372  6700 001C               3832      BEQ         SUB_IMM
00004376  4EF9 000043A4           3833      JMP         SUB_MODE_INVALID    ; else, invalid
0000437C                          3834  SUB_ABS_W:
0000437C  4EB8 2CE8               3835      JSR         EA_PRINT_ABS_W      ; Print absolute word address operand
00004380  4EF9 000043A2           3836      JMP         SUB_MODE_END
00004386                          3837  SUB_ABS_L:
00004386  4EB8 2CD8               3838      JSR         EA_PRINT_ABS_L      ; Print absolute long address operand
0000438A  4EF9 000043A2           3839      JMP         SUB_MODE_END
00004390                          3840  SUB_IMM: ; invalid if opmode is 2
00004390  B07C 0002               3841      CMP         #2, D0
00004394  6700 000E               3842      BEQ         SUB_MODE_INVALID    ; If opmode 2, An is invalid addressing mode
00004398  4EB8 2B2E               3843      JSR         EA_PRINT_IMM        ; Print immediate data
0000439C  4EF9 000043A2           3844      JMP         SUB_MODE_END
000043A2                          3845  SUB_MODE_END:
000043A2  4E75                    3846      RTS                             ; Finish evaluating EA bits
000043A4                          3847  SUB_MODE_INVALID:
000043A4  4EB8 28B0               3848      JSR         EA_INVALID          ; Opcode word is Invalid, continue to end
000043A8                          3849  SUB_END:
000043A8  4EB8 28C8               3850      JSR         EA_UPDATE_POINTER   ; Updates global pointer
000043AC  4CDF 3FFF               3851      MOVEM.L     (SP)+, A0-A5/D0-D7  ; Restore registers (except A6, global pointer to word to read)
000043B0  4E75                    3852      RTS
000043B2                          3853  
000043B2                          3854  
000043B2                          3855  
000043B2                          3856  -------------------- end include --------------------
000043B2                          3857      INCLUDE 'EndProgram.X68'
000043B2                          3858  
000043B2                          3859  
000043B2                          3860  
000043B2  =00000059               3861  UPYES     EQU   'Y'
000043B2  =00000079               3862  LOWYES    EQU   'y'
000043B2                          3863  
000043B2                          3864  
000043B2                          3865  
000043B2                          3866  KEEP_RUNNING
000043B2  6100 0004               3867      BSR.W       RERUN               * Run welcome subroutine
000043B6  4E75                    3868      RTS                             * Return to Disassembler
000043B8                          3869  
000043B8                          3870  
000043B8                          3871  
000043B8                          3872  
000043B8                          3873  
000043B8                          3874  RERUN
000043B8  43F9 00004827           3875      LEA         ENDQUESTION,A1      * Loads message into A1
000043BE  103C 000E               3876      MOVE.B      #14,D0              * Moves the Task 14 into D0
000043C2  4E4F                    3877      TRAP        #15                 * Displays Intro Message
000043C4                          3878  
000043C4  103C 0005               3879      MOVE.B      #5,D0               * Move task 5 to read one char
000043C8  4E4F                    3880      TRAP        #15                 * Trap 15 for IO
000043CA                          3881  
000043CA  0C01 0059               3882      CMPI.B      #UPYES,D1           * Is char = Y
000043CE  6700 0012               3883      BEQ         NOTDONE             * If yes, notdone
000043D2  0C01 0079               3884      CMPI.B      #LOWYES,D1          * Is char = y
000043D6  6700 000A               3885      BEQ         NOTDONE             * If yes, notdone
000043DA  11FC 0000 6000          3886      MOVE.B      #0,(RUNAGAIN)       * 0 for false to end program
000043E0  4E75                    3887      RTS
000043E2                          3888  
000043E2                          3889  NOTDONE
000043E2  11FC 0001 6000          3890      MOVE.B      #1,(RUNAGAIN)       * 1 for true to rerun program
000043E8  6100 CCF0               3891      BSR.W       CLEAR               * Clear all values
000043EC  6100 CF1A               3892      BSR.W       CLEARSCRN           * Clear screen and return from subroutine
000043F0  4E75                    3893      RTS
000043F2                          3894  
000043F2                          3895  
000043F2                          3896  
000043F2                          3897  
000043F2                          3898  
000043F2                          3899  
000043F2                          3900  
000043F2                          3901  
000043F2                          3902  -------------------- end include --------------------
000043F2                          3903      INCLUDE 'WriteBuffer.X68'
000043F2                          3904  
000043F2  =0000000D               3905  CR      EQU     $0D                 * Carriage return
000043F2  =0000000A               3906  LF      EQU     $0A                 * Line feed
000043F2                          3907  
000043F2  =00002000               3908  BUFFER  EQU     $2000               * Buffer address for string
000043F2  =0000001E               3909  RCOUNT  EQU     30                  * Counters
000043F2                          3910  
000043F2                          3911  WRITE_LINE
000043F2  163C 001E               3912      MOVE.B      #RCOUNT,D3          * Move row counter to D3
000043F6  45F8 2000               3913      LEA         BUFFER,A2           * Load BUFFER address to A2 for use
000043FA                          3914  
000043FA  6112                    3915      BSR.S       WRITE2MEM
000043FC  4E75                    3916      RTS
000043FE                          3917  
000043FE                          3918  
000043FE                          3919  
000043FE                          3920      *BSR.S       PRINTLN             * Subroutine to print buffer
000043FE                          3921  
000043FE                          3922      *LEA         BUFFER,A2           * Reset A2 for buffer cleaning
000043FE                          3923      *BSR.S       CLEAN_BUFF          * Subroutine to reset buffer to all F's
000043FE                          3924  
000043FE  5303                    3925      SUBI.B      #1,D3               * Decrement RCOUNT by 1
00004400  0C03 0000               3926      CMPI.B      #0,D3               * Is RCOUNT = 0
00004404  6700 004C               3927      BEQ         NEW_PAGE            * If yes, prompt user and make new page
00004408  61E8                    3928      BSR.S       WRITE_LINE          * If no, keep writing lines
0000440A                          3929  
0000440A  6000 005E               3930      BRA         PAUSE               * Pause program (SIMHALT)
0000440E                          3931  
0000440E                          3932  WRITE2MEM
0000440E  0C14 0000               3933      CMP.B       #$00,(A4)           * Check if byte is string terminator
00004412  6700 0006               3934      BEQ         SKIP_WRITE          * If yes, skip write and return
00004416  14DC                    3935      MOVE.B      (A4)+,(A2)+         * If no, write byte to memory
00004418  60F4                    3936      BRA         WRITE2MEM           * Keep writing, not end of string
0000441A                          3937  SKIP_WRITE
0000441A  287C 00000000           3938      MOVEA.L     #$00000000,A4       * Clean up A4
00004420  4E75                    3939      RTS                             * Return to main
00004422                          3940  
00004422                          3941  WRITE_ENDL
00004422  14FC 000D               3942      MOVE.B      #CR,(A2)+           * Move carriage return into memory
00004426  14FC 000A               3943      MOVE.B      #LF,(A2)+           * Move line feed into memory
0000442A  14FC 0000               3944      MOVE.B      #$00,(A2)+          * Move string terminator into memory
0000442E  4E75                    3945      RTS
00004430                          3946  
00004430                          3947  PRINTLN
00004430  45F8 2000               3948      LEA         BUFFER,A2           * Reset A2 to BUFFER address beginning
00004434  43D2                    3949      LEA         (A2),A1             * Load BUFFER address into A1
00004436  103C 000E               3950      MOVE.B      #14,D0              * Task 14, no CR or LF
0000443A  4E4F                    3951      TRAP        #15                 * Display string held in BUFFER
0000443C  4E75                    3952      RTS                             * Return to main
0000443E                          3953  
0000443E                          3954  CLEAN_BUFF
0000443E  0C92 FFFFFFFF           3955      CMPI.L      #$FFFFFFFF,(A2)     *
00004444  6700 000A               3956      BEQ         BUFFDONE            * Buffer has been cleaned
00004448  24FC FFFFFFFF           3957      MOVE.L      #$FFFFFFFF,(A2)+    * Fill with F's
0000444E  60EE                    3958      BRA         CLEAN_BUFF          * Continue cleaning buffer
00004450                          3959  BUFFDONE
00004450  4E75                    3960      RTS                             * Return to main
00004452                          3961  
00004452                          3962  NEW_PAGE
00004452  4283                    3963      CLR.L       D3                  * Clear counter
00004454  43F9 00004857           3964      LEA         ENTER,A1            * Load enter message into A1
0000445A  103C 000E               3965      MOVE.B      #14,D0              * Moves the Task 14 into D0
0000445E  4E4F                    3966      TRAP        #15                 * Displays contents of A1
00004460  103C 0005               3967      MOVE.B      #5,D0               * Read single character from
00004464  4E4F                    3968      TRAP        #15                 * The keyboard into D1.B
00004466  6000 CEA0               3969      BRA.W       CLEARSCRN           * Clear the screen.
0000446A                          3970  
0000446A                          3971  PAUSE
0000446A  FFFF FFFF               3972          SIMHALT                     * Halt simulator
0000446E  6000 0002               3973          BRA     QUIT                * End program
00004472                          3974  
00004472                          3975  QUIT
00004472                          3976          *END     START        ; last line of source
00004472                          3977  
00004472                          3978  
00004472                          3979  -------------------- end include --------------------
00004472                          3980  
00004472                          3981      INCLUDE 'IOMessages.X68'
00004472                          3982  
00004472= 57 45 4C 43 4F 4D ...   3983  INTRO           DC.B 'WELCOME!',CR,LF,'THIS IS A 68K DISASSEMBLER.',CR,LF,0
0000449A= 50 4C 45 41 53 45 ...   3984  PS1             DC.B 'PLEASE ENTER THE STARTING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000044E4= 50 4C 45 41 53 45 ...   3985  PS2             DC.B 'PLEASE ENTER THE ENDING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
0000452C= 0D 0A 42 45 47 49 ...   3986  BMESSAGE        DC.B CR,LF,'BEGINNING ADDRESS GIVEN IS: ',0
0000454B= 0D 0A 45 4E 44 49 ...   3987  EMESSAGE        DC.B CR,LF,'ENDING ADDRESS GIVEN IS   : ',0
0000456A                          3988  
0000456A= 54 48 45 20 42 45 ...   3989  ADR_ERR_NOTLT   DC.B 'THE BEGINNING ADDRESS MUST BE LESS THAN THE ENDING ADDRESS.',CR,LF,'PRESS ANY KEY TO TRY AGAIN...',0
000045C5                          3990  
000045C5                          3991  HEXSTRING       DS.B 80             * Var for hex string
00004615                          3992  
00004615= 44 41 54 41 00          3993  DATA            DC.B 'DATA',0
00004615= 44 41 54 41 00          3994  -------------------- end include --------------------
0000461A                          3995      INCLUDE 'OCMessages.X68'
0000461A                          3996  
0000461A                          3997  
0000461A  =0000000D               3998  CR      EQU     $0D
0000461A  =0000000A               3999  LF      EQU     $0A
0000461A= 20 00                   4000  MESSAGESPACE DC.B  ' ',0
0000461C= 4E 4F 50 00             4001  MESSAGENOP DC.B    'NOP',0
00004620                          4002  
00004620= 4D 4F 56 45 2E 57 00    4003  MESSAGEMOVEW DC.B    'MOVE.W',0
00004627= 4D 4F 56 45 2E 4C 00    4004  MESSAGEMOVEL DC.B    'MOVE.L',0
0000462E= 4D 4F 56 45 2E 42 00    4005  MESSAGEMOVEB DC.B    'MOVE.B',0
00004635                          4006  
00004635= 41 44 44 49 2E 57 00    4007  MESSAGEADDIW DC.B    'ADDI.W',0
0000463C= 41 44 44 49 2E 4C 00    4008  MESSAGEADDIL DC.B    'ADDI.L',0
00004643= 41 44 44 49 2E 42 00    4009  MESSAGEADDIB DC.B    'ADDI.B',0
0000464A                          4010  
0000464A= 4D 4F 56 45 41 2E ...   4011  MESSAGEMOVEAL DC.B    'MOVEA.L',0
00004652= 4D 4F 56 45 41 2E ...   4012  MESSAGEMOVEAW DC.B    'MOVEA.W',0
0000465A                          4013  
0000465A= 4D 4F 56 45 4D 2E ...   4014  MESSAGEMOVEML DC.B    'MOVEM.L',0
00004662= 4D 4F 56 45 4D 2E ...   4015  MESSAGEMOVEMW DC.B    'MOVEM.W',0
0000466A                          4016  
0000466A= 4A 53 52 00             4017  MESSAGEJSR DC.B    'JSR',0
0000466E                          4018  
0000466E= 43 4C 52 00             4019  MESSAGECLR DC.B    'CLR',0
00004672                          4020  
00004672= 52 54 53 00             4021  MESSAGERTS DC.B    'RTS',0
00004676                          4022  
00004676= 4C 45 41 00             4023  MESSAGELEA DC.B    'LEA',0
0000467A                          4024  
0000467A= 43 4C 52 2E 42 00       4025  MESSAGECLRB DC.B    'CLR.B',0
00004680= 43 4C 52 2E 57 00       4026  MESSAGECLRW DC.B    'CLR.W',0
00004686= 43 4C 52 2E 4C 00       4027  MESSAGECLRL DC.B    'CLR.L',0
0000468C                          4028  
0000468C= 41 44 44 51 2E 42 00    4029  MESSAGEADDQB DC.B    'ADDQ.B',0
00004693= 41 44 44 51 2E 57 00    4030  MESSAGEADDQW DC.B    'ADDQ.W',0
0000469A= 41 44 44 51 2E 4C 00    4031  MESSAGEADDQL DC.B    'ADDQ.L',0
000046A1                          4032  
000046A1= 43 4D 50 2E 42 00       4033  MESSAGECMPB DC.B    'CMP.B',0
000046A7= 43 4D 50 2E 57 00       4034  MESSAGECMPW DC.B    'CMP.W',0
000046AD= 43 4D 50 2E 4C 00       4035  MESSAGECMPL DC.B    'CMP.L',0
000046B3                          4036  
000046B3= 53 55 42 2E 42 00       4037  MESSAGESUBB DC.B    'SUB.B',0
000046B9= 53 55 42 2E 57 00       4038  MESSAGESUBW DC.B    'SUB.W',0
000046BF= 53 55 42 2E 4C 00       4039  MESSAGESUBL DC.B    'SUB.L',0
000046C5                          4040  
000046C5= 41 44 44 2E 42 00       4041  MESSAGEADDB DC.B    'ADD.B',0
000046CB= 41 44 44 2E 57 00       4042  MESSAGEADDW DC.B    'ADD.W',0
000046D1= 41 44 44 2E 4C 00       4043  MESSAGEADDL DC.B    'ADD.L',0
000046D7                          4044  
000046D7= 41 44 44 41 2E 57 00    4045  MESSAGEADDAW DC.B    'ADDA.W',0
000046DE= 41 44 44 41 2E 4C 00    4046  MESSAGEADDAL DC.B    'ADDA.L',0
000046E5                          4047  
000046E5= 4D 4F 56 45 51 2E ...   4048  MESSAGEMOVEQL DC.B    'MOVEQ.L',0
000046ED                          4049  
000046ED= 41 4E 44 2E 42 00       4050  MESSAGEANDB DC.B    'AND.B',0
000046F3= 41 4E 44 2E 57 00       4051  MESSAGEANDW DC.B    'AND.W',0
000046F9= 41 4E 44 2E 4C 00       4052  MESSAGEANDL DC.B    'AND.L',0
000046FF                          4053  
000046FF= 4D 55 4C 53 2E 57 00    4054  MESSAGEMULSW DC.B    'MULS.W',0
00004706                          4055  
00004706= 41 53 52 2E 42 00       4056  MESSAGEASRB DC.B    'ASR.B',0
0000470C= 41 53 52 2E 57 00       4057  MESSAGEASRW DC.B    'ASR.W',0
00004712= 41 53 52 2E 4C 00       4058  MESSAGEASRL DC.B    'ASR.L',0
00004718                          4059  
00004718= 41 53 4C 2E 42 00       4060  MESSAGEASLB DC.B    'ASL.B',0
0000471E= 41 53 4C 2E 57 00       4061  MESSAGEASLW DC.B    'ASL.W',0
00004724= 41 53 4C 2E 4C 00       4062  MESSAGEASLL DC.B    'ASL.L',0
0000472A                          4063  
0000472A= 52 4F 52 2E 42 00       4064  MESSAGERORB DC.B    'ROR.B',0
00004730= 52 4F 52 2E 57 00       4065  MESSAGERORW DC.B    'ROR.W',0
00004736= 52 4F 52 2E 4C 00       4066  MESSAGERORL DC.B    'ROR.L',0
0000473C                          4067  
0000473C= 52 4F 4C 2E 42 00       4068  MESSAGEROLB DC.B    'ROL.B',0
00004742= 52 4F 4C 2E 57 00       4069  MESSAGEROLW DC.B    'ROL.W',0
00004748= 52 4F 4C 2E 4C 00       4070  MESSAGEROLL DC.B    'ROL.L',0
0000474E                          4071  
0000474E= 4C 53 52 2E 42 00       4072  MESSAGELSRB DC.B    'LSR.B',0
00004754= 4C 53 52 2E 57 00       4073  MESSAGELSRW DC.B    'LSR.W',0
0000475A= 4C 53 52 2E 4C 00       4074  MESSAGELSRL DC.B    'LSR.L',0
00004760                          4075  
00004760= 4C 53 4C 2E 42 00       4076  MESSAGELSLB DC.B    'LSL.B',0
00004766= 4C 53 4C 2E 57 00       4077  MESSAGELSLW DC.B    'LSL.W',0
0000476C= 4C 53 4C 2E 4C 00       4078  MESSAGELSLL DC.B    'LSL.L',0
00004772                          4079  
00004772= 4F 52 2E 42 00          4080  MESSAGEORB DC.B    'OR.B',0
00004777= 4F 52 2E 57 00          4081  MESSAGEORW DC.B    'OR.W',0
0000477C= 4F 52 2E 4C 00          4082  MESSAGEORL DC.B    'OR.L',0
00004781                          4083  
00004781= 44 49 56 55 2E 57 00    4084  MESSAGEDIVUW DC.B    'DIVU.W',0
00004788                          4085  
00004788= 42 43 43 00             4086  MESSAGEBCC DC.B    'BCC',0
0000478C= 42 47 54 00             4087  MESSAGEBGT DC.B    'BGT',0
00004790= 42 4C 45 00             4088  MESSAGEBLE DC.B    'BLE',0
00004794                          4089  
00004794= 54 68 61 74 20 69 ...   4090  MESSAGEOPCODE_INVALID DC.B    'That is not an opcode!', 0
000047AB                          4091  
000047AB                          4092  
000047AB                          4093  
000047AB                          4094  
000047AB                          4095  -------------------- end include --------------------
000047AB                          4096      INCLUDE 'EAMessages.X68'
000047AB                          4097  
000047AB= 00                      4098  EA_MSG_NULL         DC.B    0
000047AC= 20 00                   4099  EA_MSG_SPACE        DC.B    ' ',0
000047AE= 2C 20 00                4100  EA_MSG_COMMA        DC.B    ', ',0
000047B1= 28 00                   4101  EA_MSG_OPENPAREN    DC.B    '(',0
000047B3= 29 00                   4102  EA_MSG_CLOSEPAREN   DC.B    ')',0
000047B5= 2D 00                   4103  EA_MSG_MIN          DC.B    '-',0
000047B7= 2B 00                   4104  EA_MSG_PLUS         DC.B    '+',0
000047B9= 23 00                   4105  EA_MSG_HASH         DC.B    '#',0
000047BB= 24 00                   4106  EA_MSG_HEX          DC.B    '$',0
000047BD                          4107  
000047BD= 44 30 00                4108  EA_MSG_D0           DC.B    'D0',0
000047C0= 44 31 00                4109  EA_MSG_D1           DC.B    'D1',0
000047C3= 44 32 00                4110  EA_MSG_D2           DC.B    'D2',0
000047C6= 44 33 00                4111  EA_MSG_D3           DC.B    'D3',0
000047C9= 44 34 00                4112  EA_MSG_D4           DC.B    'D4',0
000047CC= 44 35 00                4113  EA_MSG_D5           DC.B    'D5',0
000047CF= 44 36 00                4114  EA_MSG_D6           DC.B    'D6',0
000047D2= 44 37 00                4115  EA_MSG_D7           DC.B    'D7',0
000047D5                          4116  
000047D5= 41 30 00                4117  EA_MSG_A0           DC.B    'A0',0
000047D8= 41 31 00                4118  EA_MSG_A1           DC.B    'A1',0
000047DB= 41 32 00                4119  EA_MSG_A2           DC.B    'A2',0
000047DE= 41 33 00                4120  EA_MSG_A3           DC.B    'A3',0
000047E1= 41 34 00                4121  EA_MSG_A4           DC.B    'A4',0
000047E4= 41 35 00                4122  EA_MSG_A5           DC.B    'A5',0
000047E7= 41 36 00                4123  EA_MSG_A6           DC.B    'A6',0
000047EA= 41 37 00                4124  EA_MSG_A7           DC.B    'A7',0
000047ED                          4125  
000047ED= 5B 45 41 20 43 4F ...   4126  EA_MSG_UNIMP        DC.B    '[EA CODE NOT IMPLEMENTED]',0
00004807= 5B 50 52 49 4E 54 ...   4127  EA_MSG_PRINT_DATA   DC.B    '[PRINTING DATA NOT IMPLEMENTED]',0
00004827                          4128  
00004827                          4129  -------------------- end include --------------------
00004827                          4130      INCLUDE 'EPMessages.X68'        ; EndProgram messages
00004827                          4131  
00004827= 57 4F 55 4C 44 20 ...   4132  ENDQUESTION     DC.B 'WOULD YOU LIKE TO RUN THE PROGRAM AGAIN (Y/N)? ',0
00004827= 57 4F 55 4C 44 20 ...   4133  -------------------- end include --------------------
00004857                          4134      INCLUDE 'WBMessages.X68'        ; WriteBuffer messages
00004857                          4135  
00004857= 2D 2D 2D 2D 2D 2D ...   4136  ENTER           DC.B '------------------------- Press Enter ------------------------',0
00004896                          4137  
00004896                          4138  
00004896= 4D 4F 56 45 00          4139  MV              DC.B 'MOVE',0
0000489B= 41 44 44 20 00          4140  AD              DC.B 'ADD ',0
000048A0                          4141  
000048A0= 2E 42 20 20 00          4142  BYTE            DC.B '.B  ',0
000048A5= 2E 57 20 20 00          4143  WORD            DC.B '.W  ',0
000048AA= 2E 4C 20 20 00          4144  LONG            DC.B '.L  ',0
000048AF= 0D 0A 00                4145  ENDL            DC.B CR,LF,0
000048B2                          4146  
000048B2= 44 30 00                4147  DREG0           DC.B 'D0',0
000048B5= 44 31 00                4148  DREG1           DC.B 'D1',0
000048B8= 44 32 00                4149  DREG2           DC.B 'D2',0
000048BB= 44 33 00                4150  DREG3           DC.B 'D3',0
000048BE= 44 34 00                4151  DREG4           DC.B 'D4',0
000048C1= 44 35 00                4152  DREG5           DC.B 'D5',0
000048C4= 44 36 00                4153  DREG6           DC.B 'D6',0
000048C7= 44 37 00                4154  DREG7           DC.B 'D7',0
000048CA= 41 30 00                4155  AREG0           DC.B 'A0',0
000048CD= 41 31 00                4156  AREG1           DC.B 'A1',0
000048D0= 41 32 00                4157  AREG2           DC.B 'A2',0
000048D3= 41 33 00                4158  AREG3           DC.B 'A3',0
000048D6= 41 34 00                4159  AREG4           DC.B 'A4',0
000048D9= 41 35 00                4160  AREG5           DC.B 'A5',0
000048DC= 41 36 00                4161  AREG6           DC.B 'A6',0
000048DF= 41 37 00                4162  AREG7           DC.B 'A7',0
000048E2                          4163  
000048E2= 23 00                   4164  POUND           DC.B '#',0
000048E4= 24 00                   4165  DOLLAR          DC.B '$',0
000048E6= 25 00                   4166  PERCENT         DC.B '%',0
000048E8= 2C 20 00                4167  COMMA           DC.B ', ',0
000048EB= 28 00                   4168  OPAREN          DC.B '(',0
000048ED= 29 00                   4169  CPAREN          DC.B ')',0
000048EF= 2B 00                   4170  PLUS            DC.B '+',0
000048F1= 2D 00                   4171  MINUS           DC.B '-',0
000048F3                          4172  
000048F3= 20 20 20 20 00          4173  TAB             DC.B '    ',0
000048F3= 20 20 20 20 00          4174  -------------------- end include --------------------
000048F8                          4175  
000048F8                          4176  *********** END INCLUDES *****************************************************
000048F8                          4177  
000048F8                          4178  *---------- Reserved Registers -----------------------------
000048F8                          4179  *   A7: stack pointer
000048F8                          4180  *   A6: current address (updated by subroutines)
000048F8                          4181  *   D0: instruction validity flag (reset by main control
000048F8                          4182  *       code, can be set to false by subroutines)
000048F8                          4183  *-----------------------------------------------------------
000048F8                          4184  
000048F8                          4185  *---------- End --------------------------------------------
000048F8                          4186                 END  START          * Last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AD                  489B
ADDA_ABS_L          2F72
ADDA_ABS_W          2F68
ADDA_END            2FA8
ADDA_IMM            2F7C
ADDA_MODE           2EDC
ADDA_MODE_000       2F0C
ADDA_MODE_001       2F16
ADDA_MODE_010       2F20
ADDA_MODE_011       2F2A
ADDA_MODE_100       2F34
ADDA_MODE_101       2F3E
ADDA_MODE_110       2F44
ADDA_MODE_111       2F4A
ADDA_MODE_END       2F94
ADDA_MODE_INVALID   2F8A
ADDCODE000          195A
ADDCODE001          1962
ADDCODE010          196A
ADDCODE011          1972
ADDCODE100          197A
ADDCODE101          1982
ADDCODE110          198A
ADDCODE111          1992
ADDIBCODE00         1DB8
ADDILCODE10         1DC8
ADDILCODE11         1DD0
ADDIWCODE01         1DC0
ADDI_ABS_L          30BA
ADDI_ABS_W          30B0
ADDI_B              2FE0
ADDI_BORADDI_WORADDI_L  1D82
ADDI_END            30C4
ADDI_GET_DEST       300E
ADDI_L              3008
ADDI_MODE           3020
ADDI_MODE_000       3050
ADDI_MODE_001       305A
ADDI_MODE_010       3064
ADDI_MODE_011       306E
ADDI_MODE_100       3078
ADDI_MODE_101       3082
ADDI_MODE_110       308C
ADDI_MODE_111       3096
ADDI_W              2FFA
ADDQCODE00          1AB4
ADDQCODE01          1ABC
ADDQCODE10          1AC4
ADDQCODE11          1ACC
ADDQ_ABS_L          31B8
ADDQ_ABS_W          31AE
ADDQ_BORADDQ_WORADDQ_L  1A7E
ADDQ_END            31C2
ADDQ_MODE           311E
ADDQ_MODE_000       314E
ADDQ_MODE_001       3158
ADDQ_MODE_010       3162
ADDQ_MODE_011       316C
ADDQ_MODE_100       3176
ADDQ_MODE_101       3180
ADDQ_MODE_110       318A
ADDQ_MODE_111       3194
ADDQ_PRINT_IMM      30F0
ADDRESS_ERR         1314
ADD_ABS_L           2E96
ADD_ABS_W           2E8C
ADD_BORADD_WORADD_L  190C
ADD_END             2EB8
ADD_EVAL_EA         2DE2
ADD_IMM             2EA0
ADD_MODE            2DF0
ADD_MODE_000        2E20
ADD_MODE_001        2E32
ADD_MODE_010        2E44
ADD_MODE_011        2E4E
ADD_MODE_1          2D92
ADD_MODE_100        2E58
ADD_MODE_101        2E62
ADD_MODE_110        2E68
ADD_MODE_111        2E6E
ADD_MODE_2          2DBC
ADD_MODE_END        2EB2
ADD_MODE_INVALID    2EB4
ADD_OPMODE          2D12
ADD_OPMODE_000      2D42
ADD_OPMODE_001      2D4C
ADD_OPMODE_010      2D56
ADD_OPMODE_011      2D60
ADD_OPMODE_100      2D6A
ADD_OPMODE_101      2D74
ADD_OPMODE_110      2D7E
ADD_OPMODE_111      2D88
ADR_ERR_NOTLT       456A
ANDCODE000          18CC
ANDCODE001          18D4
ANDCODE010          18DC
ANDCODE011          18E4
ANDCODE100          18EC
ANDCODE101          18F4
ANDCODE110          18FC
ANDCODE111          1904
AND_ABS_L           335C
AND_ABS_W           3352
AND_BORAND_WORAND_LORMULS_W  187E
AND_END             337E
AND_EVAL_EA         32B4
AND_IMM             3366
AND_MODE            32C2
AND_MODE_000        32F2
AND_MODE_001        3304
AND_MODE_010        330A
AND_MODE_011        3314
AND_MODE_1          3264
AND_MODE_100        331E
AND_MODE_101        3328
AND_MODE_110        332E
AND_MODE_111        3334
AND_MODE_2          328E
AND_MODE_END        3378
AND_MODE_INVALID    337A
AND_OPMODE          31E4
AND_OPMODE_000      3214
AND_OPMODE_001      321E
AND_OPMODE_010      3228
AND_OPMODE_011      3232
AND_OPMODE_100      323C
AND_OPMODE_101      3246
AND_OPMODE_110      3250
AND_OPMODE_111      325A
AN_000              2A14
AN_001              2A20
AN_010              2A2C
AN_011              2A38
AN_100              2A44
AN_101              2A50
AN_110              2A5C
AN_111              2A68
AN_JMP              29E4
AREG0               48CA
AREG1               48CD
AREG2               48D0
AREG3               48D3
AREG4               48D6
AREG5               48D9
AREG6               48DC
AREG7               48DF
ASCII_TO_HEX        112E
ASD_END             34AE
ASD_MEM             33F8
ASD_MEM_ABS_L       34A4
ASD_MEM_ABS_W       349A
ASD_MEM_MODE        340A
ASD_MEM_MODE_000    343A
ASD_MEM_MODE_001    3444
ASD_MEM_MODE_010    344E
ASD_MEM_MODE_011    3458
ASD_MEM_MODE_100    3462
ASD_MEM_MODE_101    346C
ASD_MEM_MODE_110    3476
ASD_MEM_MODE_111    3480
ASD_REG             33A0
ASD_REG_COUNT       33CE
ASD_REG_END         33DE
ASD_REG_REG         33C4
ASLCODE00           1614
ASLCODE01           161C
ASLCODE10           1624
ASLCODE11           162C
ASL_ASR             17F8
ASL_ASRCODE0        1822
ASL_ASRCODE1        1828
ASRCODE00           15BE
ASRCODE01           15C6
ASRCODE10           15CE
ASRCODE11           15D6
BAD_CHECK           12EA
BAD_LENGTH          1126
BCCORBGTORBLE       14A4
BCCORBGTORBLECODE00  14DA
BCCORBGTORBLECODE01  14E2
BCCORBGTORBLECODE10  14EA
BCCORBGTORBLECODE11  14F2
BCC_B               34E6
BCC_DISPLAY         353A
BCC_L               352C
BCC_W               350A
BEGINADDR           5000
BMESSAGE            452C
BUFFDONE            4450
BUFFER              2000
BYTE                48A0
CHECK_BADDR_IS_LESS_THAN_EADDR  10A6
CLEAN_BUFF          443E
CLEAR               10DA
CLEARSCRN           1308
CLRCODE00           1B0A
CLRCODE01           1B12
CLRCODE10           1B1A
CLRCODE11           1B22
CLR_ABS_L           35FA
CLR_ABS_W           35F0
CLR_END             3604
CLR_MODE            3560
CLR_MODE_000        3590
CLR_MODE_001        359A
CLR_MODE_010        35A4
CLR_MODE_011        35AE
CLR_MODE_100        35B8
CLR_MODE_101        35C2
CLR_MODE_110        35CC
CLR_MODE_111        35D6
CMPCODE00           1A5E
CMPCODE01           1A66
CMPCODE10           1A6E
CMPCODE11           1A76
CMP_ABS_L           36C2
CMP_ABS_W           36B8
CMP_BORCMP_WORCMP_L  1A28
CMP_END             36E0
CMP_MODE            3628
CMP_MODE_000        3658
CMP_MODE_001        3662
CMP_MODE_010        366C
CMP_MODE_011        3676
CMP_MODE_100        3680
CMP_MODE_101        368A
CMP_MODE_110        3694
CMP_MODE_111        369E
CMP_MODE_END        36CC
CODE0000            13F8
CODE0001            13FE
CODE0010            140A
CODE0011            1410
CODE0100            1416
CODE0101            1422
CODE0110            142E
CODE0111            143A
CODE1000            1446
CODE1001            1452
CODE1010            145E
CODE1011            1466
CODE1100            1472
CODE1101            147E
CODE1110            148A
CODE1111            1496
COMMA               48E8
CPAREN              48ED
CR                  D
DATA                4615
DIVU_W_ABS_L        37A6
DIVU_W_ABS_W        379C
DIVU_W_DEST         37BE
DIVU_W_END          37D0
DIVU_W_IMM          37B0
DIVU_W_MODE         3704
DIVU_W_MODE_000     3734
DIVU_W_MODE_001     373E
DIVU_W_MODE_010     3748
DIVU_W_MODE_011     3752
DIVU_W_MODE_100     375C
DIVU_W_MODE_101     3766
DIVU_W_MODE_110     3770
DIVU_W_MODE_111     377A
DN_000              2974
DN_001              2980
DN_010              298C
DN_011              2998
DN_100              29A4
DN_101              29B0
DN_110              29BC
DN_111              29C8
DOLLAR              48E4
DONE                149E
DREG0               48B2
DREG1               48B5
DREG2               48B8
DREG3               48BB
DREG4               48BE
DREG5               48C1
DREG6               48C4
DREG7               48C7
EA_ADD              2CF8
EA_ADDA             2EC2
EA_ADDI             2FB2
EA_ADDQ             30CE
EA_AND              31CC
EA_ASD              3388
EA_BCC              34B8
EA_CLR              3546
EA_CMP              360E
EA_COPY_PTR         28D4
EA_DEFAULT_COMBO    28D8
EA_DIVU_W           36EA
EA_INVALID          28B0
EA_JSR              37DA
EA_LEA              38A2
EA_LSD              397E
EA_MOVE             3AAE
EA_MOVEA            3C82
EA_MOVEM            3DA8
EA_MOVEQ            3DAE
EA_MSG_A0           47D5
EA_MSG_A1           47D8
EA_MSG_A2           47DB
EA_MSG_A3           47DE
EA_MSG_A4           47E1
EA_MSG_A5           47E4
EA_MSG_A6           47E7
EA_MSG_A7           47EA
EA_MSG_CLOSEPAREN   47B3
EA_MSG_COMMA        47AE
EA_MSG_D0           47BD
EA_MSG_D1           47C0
EA_MSG_D2           47C3
EA_MSG_D3           47C6
EA_MSG_D4           47C9
EA_MSG_D5           47CC
EA_MSG_D6           47CF
EA_MSG_D7           47D2
EA_MSG_HASH         47B9
EA_MSG_HEX          47BB
EA_MSG_MIN          47B5
EA_MSG_NULL         47AB
EA_MSG_OPENPAREN    47B1
EA_MSG_PLUS         47B7
EA_MSG_PRINT_DATA   4807
EA_MSG_SPACE        47AC
EA_MSG_UNIMP        47ED
EA_MULS_W           3E0E
EA_OPMODE_COMBO     28FE
EA_OR               3EFE
EA_PRINT_ABS_L      2CD8
EA_PRINT_ABS_W      2CE8
EA_PRINT_AN         29D6
EA_PRINT_AN_END     2A74
EA_PRINT_DATA       28BA
EA_PRINT_DN         2936
EA_PRINT_DN_END     29D4
EA_PRINT_DN_JMP     2944
EA_PRINT_IMM        2B2E
EA_PRINT_IND        2A76
EA_PRINT_IND_END    2B20
EA_PRINT_PD_END     2CCA
EA_PRINT_PI_END     2BFA
EA_PRINT_POSTINC    2B50
EA_PRINT_PREDEC     2C14
EA_ROD              40C0
EA_SIZE_BITS        2924
EA_SUB              41F0
EA_UNIMPLEMENTED    28A0
EA_UPDATE_POINTER   28C8
EMESSAGE            454B
ENDADDR             5010
ENDL                48AF
ENDQUESTION         4827
END_LOOP            103C
ENTER               4857
FINISHED            10C4
FOUND               11EA
GET_ADDRESSES       104E
GET_FIRST_ADDRESS   105A
GET_HEXSTRING       10F4
GET_SECOND_ADDRESS  1080
HEXA                123A
HEXB                1242
HEXC                124A
HEXD                1252
HEXE                125A
HEXEIGHT            122E
HEXF                1262
HEXFIVE             1222
HEXFLAG             5021
HEXFOUR             121E
HEXNINE             1232
HEXONE              1212
HEXSEVEN            122A
HEXSIX              1226
HEXSTRING           45C5
HEXTHREE            121A
HEXTWO              1216
HEXVALUE            5030
HEXZERO             120A
IND_000             2AC0
IND_001             2ACC
IND_010             2AD8
IND_011             2AE4
IND_100             2AF0
IND_101             2AFC
IND_110             2B08
IND_111             2B14
IND_JMP             2A90
INITIAL_TABLE       1398
INTRO               4472
INVALID_DATA        1326
IO_WELCOME          10C6
ISADDAL             23B4
ISADDAW             238C
ISADDB              23DC
ISADDIB             2878
ISADDIL             2850
ISADDIW             2828
ISADDL              242C
ISADDQB             2544
ISADDQL             2594
ISADDQW             256C
ISADDW              2404
ISANDB              2314
ISANDL              2364
ISANDW              233C
ISASLB              2094
ISASLL              20E4
ISASLW              20BC
ISASRB              201C
ISASRL              206C
ISASRW              2044
ISBCC               1F04
ISBGT               1F2C
ISBLE               1F54
ISCLR               2714
ISCLRB              25D8
ISCLRL              2628
ISCLRW              2600
ISCMPB              24CC
ISCMPL              251C
ISCMPW              24F4
ISDIVUW             1F7C
ISJSR               26C8
ISLEA               26A0
ISLSLB              2184
ISLSLL              21D4
ISLSLW              21AC
ISLSRB              210C
ISLSRL              215C
ISLSRW              2134
ISMOVEAL            27D8
ISMOVEAW            2788
ISMOVEB             2800
ISMOVEL             27B0
ISMOVEML            2650
ISMOVEMW            2678
ISMOVEQL            25B0
ISMOVEW             2760
ISMULSW             22EC
ISNOP               273C
ISORB               1FA4
ISORL               1FF4
ISORW               1FCC
ISROLB              2274
ISROLL              22C4
ISROLW              229C
ISRORB              21FC
ISRORL              224C
ISRORW              2224
ISRTS               26F0
ISSUBB              2454
ISSUBL              24A4
ISSUBW              247C
IS_HEX_EVEN         128A
IS_LESSTHAN         126A
JSRORCLRCODE0000    1BCC
JSRORCLRCODE0001    1BD4
JSRORCLRCODE0010    1BDC
JSRORCLRCODE0011    1BE2
JSRORCLRCODE0100    1BEA
JSRORCLRCODE0101    1BF2
JSRORCLRCODE0110    1BFA
JSRORCLRCODE0111    1C02
JSRORCLRCODE1000    1C0A
JSRORCLRCODE1001    1C12
JSRORCLRCODE1010    1C1A
JSRORCLRCODE1011    1C22
JSRORCLRCODE1100    1C2A
JSRORCLRCODE1101    1C32
JSRORCLRCODE1110    1C3A
JSRORCLRCODE1111    1C42
JSR_ABS_L           388E
JSR_ABS_W           3884
JSR_END             3898
JSR_MODE            37F4
JSR_MODE_000        3824
JSR_MODE_001        382E
JSR_MODE_010        3838
JSR_MODE_011        3842
JSR_MODE_100        384C
JSR_MODE_101        3856
JSR_MODE_110        3860
JSR_MODE_111        386A
KEEP_RUNNING        43B2
LEA_ABS_L           3956
LEA_ABS_W           394C
LEA_DEST            3960
LEA_END             3974
LEA_MODE            38BC
LEA_MODE_000        38EC
LEA_MODE_001        38F6
LEA_MODE_010        3900
LEA_MODE_011        390A
LEA_MODE_100        3914
LEA_MODE_101        391E
LEA_MODE_110        3928
LEA_MODE_111        3932
LF                  A
LONG                48AA
LOOP                100E
LOOP_CHECK          1032
LOTSCODE0000        1D08
LOTSCODE0001        1D10
LOTSCODE0010        1D18
LOTSCODE0011        1D1E
LOTSCODE0100        1D26
LOTSCODE0101        1D2E
LOTSCODE0110        1D36
LOTSCODE0111        1D3E
LOTSCODE1000        1D46
LOTSCODE1001        1D4C
LOTSCODE1010        1D54
LOTSCODE1011        1D5A
LOTSCODE1100        1D62
LOTSCODE1101        1D6A
LOTSCODE1110        1D72
LOTSCODE1111        1D7A
LOWYES              79
LSD_END             3AA4
LSD_MEM             39EE
LSD_MEM_ABS_L       3A9A
LSD_MEM_ABS_W       3A90
LSD_MEM_MODE        3A00
LSD_MEM_MODE_000    3A30
LSD_MEM_MODE_001    3A3A
LSD_MEM_MODE_010    3A44
LSD_MEM_MODE_011    3A4E
LSD_MEM_MODE_100    3A58
LSD_MEM_MODE_101    3A62
LSD_MEM_MODE_110    3A6C
LSD_MEM_MODE_111    3A76
LSD_REG             3996
LSD_REG_COUNT       39C4
LSD_REG_END         39D4
LSD_REG_REG         39BA
LSLCODE00           16C0
LSLCODE01           16C8
LSLCODE10           16D0
LSLCODE11           16D8
LSL_LSR             17C2
LSL_LSRCODE0        17EC
LSL_LSRCODE1        17F2
LSRCODE00           166A
LSRCODE01           1672
LSRCODE10           167A
LSRCODE11           1682
LT                  1282
MAKE_CHECKS         12BE
MESSAGEADDAL        46DE
MESSAGEADDAW        46D7
MESSAGEADDB         46C5
MESSAGEADDIB        4643
MESSAGEADDIL        463C
MESSAGEADDIW        4635
MESSAGEADDL         46D1
MESSAGEADDQB        468C
MESSAGEADDQL        469A
MESSAGEADDQW        4693
MESSAGEADDW         46CB
MESSAGEANDB         46ED
MESSAGEANDL         46F9
MESSAGEANDW         46F3
MESSAGEASLB         4718
MESSAGEASLL         4724
MESSAGEASLW         471E
MESSAGEASRB         4706
MESSAGEASRL         4712
MESSAGEASRW         470C
MESSAGEBCC          4788
MESSAGEBGT          478C
MESSAGEBLE          4790
MESSAGECLR          466E
MESSAGECLRB         467A
MESSAGECLRL         4686
MESSAGECLRW         4680
MESSAGECMPB         46A1
MESSAGECMPL         46AD
MESSAGECMPW         46A7
MESSAGEDIVUW        4781
MESSAGEJSR          466A
MESSAGELEA          4676
MESSAGELSLB         4760
MESSAGELSLL         476C
MESSAGELSLW         4766
MESSAGELSRB         474E
MESSAGELSRL         475A
MESSAGELSRW         4754
MESSAGEMOVEAL       464A
MESSAGEMOVEAW       4652
MESSAGEMOVEB        462E
MESSAGEMOVEL        4627
MESSAGEMOVEML       465A
MESSAGEMOVEMW       4662
MESSAGEMOVEQL       46E5
MESSAGEMOVEW        4620
MESSAGEMULSW        46FF
MESSAGENOP          461C
MESSAGEOPCODE_INVALID  4794
MESSAGEORB          4772
MESSAGEORL          477C
MESSAGEORW          4777
MESSAGEROLB         473C
MESSAGEROLL         4748
MESSAGEROLW         4742
MESSAGERORB         472A
MESSAGERORL         4736
MESSAGERORW         4730
MESSAGERTS          4672
MESSAGESPACE        461A
MESSAGESUBB         46B3
MESSAGESUBL         46BF
MESSAGESUBW         46B9
MINUS               48F1
MOD                 2
MOVEACODE001        1E2E
MOVEAWCODE001       1EBC
MOVEA_ADJUST_L      3CB8
MOVEA_ADJUST_W      3CAE
MOVEA_DESTINATION   3D8A
MOVEA_END           3D9E
MOVEA_LORMOVE_L     1DD8
MOVEA_SOURCE        3CC2
MOVEA_SRC_ABS_L     3D76
MOVEA_SRC_ABS_W     3D6C
MOVEA_SRC_IMM       3D80
MOVEA_SRC_MODE      3CD4
MOVEA_SRC_MODE_000  3D04
MOVEA_SRC_MODE_001  3D0E
MOVEA_SRC_MODE_010  3D18
MOVEA_SRC_MODE_011  3D22
MOVEA_SRC_MODE_100  3D2C
MOVEA_SRC_MODE_101  3D36
MOVEA_SRC_MODE_110  3D40
MOVEA_SRC_MODE_111  3D4A
MOVEA_WORMOVE_W     1E66
MOVECODE000         1E26
MOVECODE010         1E36
MOVECODE011         1E3E
MOVECODE100         1E46
MOVECODE101         1E4E
MOVECODE110         1E56
MOVECODE111         1E5E
MOVEMCODE0          1C74
MOVEMCODE1          1C7C
MOVEQ_PRINT_DATA    3DE0
MOVEWCODE000        1EB4
MOVEWCODE010        1EC4
MOVEWCODE011        1ECC
MOVEWCODE100        1ED4
MOVEWCODE101        1EDC
MOVEWCODE110        1EE4
MOVEWCODE111        1EEC
MOVE_ADJUST_L       3AE4
MOVE_ADJUST_W       3ADA
MOVE_DESTINATION    3BB6
MOVE_DST_ABS_L      3C6E
MOVE_DST_ABS_W      3C64
MOVE_DST_MODE       3BD4
MOVE_DST_MODE_000   3C04
MOVE_DST_MODE_001   3C0E
MOVE_DST_MODE_010   3C18
MOVE_DST_MODE_011   3C22
MOVE_DST_MODE_100   3C2C
MOVE_DST_MODE_101   3C36
MOVE_DST_MODE_110   3C40
MOVE_DST_MODE_111   3C4A
MOVE_END            3C78
MOVE_SOURCE         3AEE
MOVE_SRC_ABS_L      3BA2
MOVE_SRC_ABS_W      3B98
MOVE_SRC_IMM        3BAC
MOVE_SRC_MODE       3B00
MOVE_SRC_MODE_000   3B30
MOVE_SRC_MODE_001   3B3A
MOVE_SRC_MODE_010   3B44
MOVE_SRC_MODE_011   3B4E
MOVE_SRC_MODE_100   3B58
MOVE_SRC_MODE_101   3B62
MOVE_SRC_MODE_110   3B6C
MOVE_SRC_MODE_111   3B76
MULS_W_ABS_L        3ECA
MULS_W_ABS_W        3EC0
MULS_W_DEST         3EE2
MULS_W_END          3EF4
MULS_W_IMM          3ED4
MULS_W_MODE         3E28
MULS_W_MODE_000     3E58
MULS_W_MODE_001     3E62
MULS_W_MODE_010     3E6C
MULS_W_MODE_011     3E76
MULS_W_MODE_100     3E80
MULS_W_MODE_101     3E8A
MULS_W_MODE_110     3E94
MULS_W_MODE_111     3E9E
MV                  4896
NEW_LINE            12FA
NEW_PAGE            4452
NOPCOMMAND          1BC4
NOPORCLRORRTSORJSR  1B2A
NOP_MOVEM_LEA_JSR_CLR_RTS  1C84
NOTDONE             43E2
NOTEVEN             12B4
OC_PARSE            137C
OPAREN              48EB
OPCODE_INVALID      1EF4
OR_ABS_L            4094
OR_ABS_W            408A
OR_BOROR_WOROR_LORDIVU  14FA
OR_DIVUCODE000      1548
OR_DIVUCODE001      1550
OR_DIVUCODE010      1558
OR_DIVUCODE011      1560
OR_DIVUCODE100      1568
OR_DIVUCODE101      1570
OR_DIVUCODE110      1578
OR_DIVUCODE111      1580
OR_END              40B6
OR_EVAL_EA          3FE8
OR_IMM              409E
OR_MODE             3FF6
OR_MODE_000         4026
OR_MODE_001         4030
OR_MODE_010         4042
OR_MODE_011         404C
OR_MODE_1           3F98
OR_MODE_100         4056
OR_MODE_101         4060
OR_MODE_110         4066
OR_MODE_111         406C
OR_MODE_2           3FC2
OR_MODE_END         40B0
OR_MODE_INVALID     40B2
OR_OPMODE           3F18
OR_OPMODE_000       3F48
OR_OPMODE_001       3F52
OR_OPMODE_010       3F5C
OR_OPMODE_011       3F66
OR_OPMODE_100       3F70
OR_OPMODE_101       3F7A
OR_OPMODE_110       3F84
OR_OPMODE_111       3F8E
PAUSE               446A
PERCENT             48E6
PLUS                48EF
POSTINC_000         2B9A
POSTINC_001         2BA6
POSTINC_010         2BB2
POSTINC_011         2BBE
POSTINC_100         2BCA
POSTINC_101         2BD6
POSTINC_110         2BE2
POSTINC_111         2BEE
POSTINC_JMP         2B6A
POUND               48E2
PREDEC_000          2C6A
PREDEC_001          2C76
PREDEC_010          2C82
PREDEC_011          2C8E
PREDEC_100          2C9A
PREDEC_101          2CA6
PREDEC_110          2CB2
PREDEC_111          2CBE
PREDEC_JMP          2C3A
PRINTLN             4430
PRINT_HEXVALUE      12EC
PRINT_IMM_END       2B4C
PRINT_IMM_L         2B48
PS1                 449A
PS2                 44E4
QUIT                4472
RCOUNT              1E
REMAINDER           5050
REPEAT              1296
RERUN               43B8
ROD_END             41E6
ROD_LSD_ASD         182E
ROD_LSD_ASDCODE00   1864
ROD_LSD_ASDCODE01   186A
ROD_LSD_ASDCODE10   1870
ROD_LSD_ASDCODE11   1878
ROD_MEM             4130
ROD_MEM_ABS_L       41DC
ROD_MEM_ABS_W       41D2
ROD_MEM_MODE        4142
ROD_MEM_MODE_000    4172
ROD_MEM_MODE_001    417C
ROD_MEM_MODE_010    4186
ROD_MEM_MODE_011    4190
ROD_MEM_MODE_100    419A
ROD_MEM_MODE_101    41A4
ROD_MEM_MODE_110    41AE
ROD_MEM_MODE_111    41B8
ROD_REG             40D8
ROD_REG_COUNT       4106
ROD_REG_END         4116
ROD_REG_REG         40FC
ROLCODE00           1716
ROLCODE01           171E
ROLCODE10           1726
ROLCODE11           172E
ROL_ROR             178C
ROL_RORCODE0        17B6
ROL_RORCODE1        17BC
RORCODE00           176C
RORCODE01           1774
RORCODE10           177C
RORCODE11           1784
RTSCOMMAND          1BBC
RUNAGAIN            6000
SHIFTLEFT           1204
SKIP_WRITE          441A
SOMEASL             15DE
SOMEASR             1588
SOMECLR             1AD4
SOMELSL             168A
SOMELSR             1634
SOMEMOVEM           1C4A
SOMEROL             16E0
SOMEROR             1736
STACK               7000
START               1000
STR_LEN             5020
SUBCODE000          19E8
SUBCODE001          19F0
SUBCODE010          19F8
SUBCODE011          1A00
SUBCODE100          1A08
SUBCODE101          1A10
SUBCODE110          1A18
SUBCODE111          1A20
SUB_ABS_L           4386
SUB_ABS_W           437C
SUB_BORSUB_WORSUB_L  199A
SUB_END             43A8
SUB_EVAL_EA         42D2
SUB_IMM             4390
SUB_MODE            42E0
SUB_MODE_000        4310
SUB_MODE_001        4322
SUB_MODE_010        4334
SUB_MODE_011        433E
SUB_MODE_1          4282
SUB_MODE_100        4348
SUB_MODE_101        4352
SUB_MODE_110        4358
SUB_MODE_111        435E
SUB_MODE_2          42AC
SUB_MODE_END        43A2
SUB_MODE_INVALID    43A4
SUB_OPMODE          4202
SUB_OPMODE_000      4232
SUB_OPMODE_001      423C
SUB_OPMODE_010      4246
SUB_OPMODE_011      4250
SUB_OPMODE_100      425A
SUB_OPMODE_101      4264
SUB_OPMODE_110      426E
SUB_OPMODE_111      4278
TAB                 48F3
TABLEADDI_BORADDI_WORADDI_L  1DA0
TABLEADDQ_BORADDQ_WORADDQ_L  1A9C
TABLEADD_BORADD_WORADD_L  192A
TABLEAND_BORAND_WORAND_LORMULS_W  189C
TABLEASL_ASR        1816
TABLEBCCORBGTORBLE  14C2
TABLECMP_BORCMP_WORCMP_L  1A46
TABLELSL_LSR        17E0
TABLEMOVEA_LORMOVE_L  1DF6
TABLEMOVEA_WORMOVE_W  1E84
TABLENOPORCLRORRTSORJSR  1B5C
TABLENOP_MOVEM_LEA_JSR_CLR_RTS  1CA8
TABLEOR_BOROR_WOROR_LORDIVU  1518
TABLEROD_LSD_ASD    184C
TABLEROL_ROR        17AA
TABLESOMEASL        15FC
TABLESOMEASR        15A6
TABLESOMECLR        1AF2
TABLESOMELSL        16A8
TABLESOMELSR        1652
TABLESOMEMOVEM      1C68
TABLESOMEROL        16FE
TABLESOMEROR        1754
TABLESUB_BORSUB_WORSUB_L  19B8
UPDATE_PTR          28D0
UPYES               59
WORD                48A5
WRITE2MEM           440E
WRITE_ENDL          4422
WRITE_LINE          43F2
