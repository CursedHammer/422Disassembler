00001514 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 6/2/2016 11:07:16 AM

00000000                             1  ******************************************************************************
00000000                             2  * Title      : 68k Disassembler
00000000                             3  * Written by : Brandon Authier (Hblkr), Jack S. Eldridge
00000000                             4  *              (JackScottie), Marijn Burger (marijnburger)
00000000                             5  * Date       : 16 May 2016
00000000                             6  * Description: An inverse assembler that will convert a memory
00000000                             7  *              image of instructions and data back to the display.
00000000                             8  *              The following will be decoded:
00000000                             9  *
00000000                            10  *              Addressing Modes
00000000                            11  *
00000000                            12  *                Data Register Direct
00000000                            13  *                Address Register Direct
00000000                            14  *                Address Register Indirect
00000000                            15  *                Immediate Data
00000000                            16  *                Address Register Indirect with Post Increment
00000000                            17  *                Address Register Indirect with Pre Decrement
00000000                            18  *                Absolute Long Address
00000000                            19  *                Absolute Word Address
00000000                            20  *
00000000                            21  *              Instructions
00000000                            22  *
00000000                            23  *                NOP
00000000                            24  *                MOVE
00000000                            25  *                MOVEA
00000000                            26  *                MOVEQ
00000000                            27  *                MOVEM
00000000                            28  *                ADD
00000000                            29  *                ADDA
00000000                            30  *                ADDI
00000000                            31  *                ADDQ
00000000                            32  *                SUB
00000000                            33  *                MULS
00000000                            34  *                DIVU
00000000                            35  *                LEA
00000000                            36  *                CLR
00000000                            37  *                AND
00000000                            38  *                OR
00000000                            39  *                LSL
00000000                            40  *                LSR
00000000                            41  *                ASR
00000000                            42  *                ASL
00000000                            43  *                ROL
00000000                            44  *                ROR
00000000                            45  *                CMP
00000000                            46  *                Bcc (BCC, BGT, BLE)
00000000                            47  *                JSR
00000000                            48  *                RTS
00000000                            49  *
00000000                            50  ******************************************************************************
00000000                            51  
00000000                            52  ******************************************************************************
00000000                            53  *           DEFINITIONS                                                      *
00000000                            54  ******************************************************************************
00000000  =00007000                 55  STACK     EQU   $7000               * Beginning address for stack pointer
00000000                            56  
00000000  =00005000                 57  BEGINADDR EQU   $5000               * Variable to hold beginning address value
00000000  =00005010                 58  ENDADDR   EQU   $5010               * Variable to hold ending address value
00000000                            59  
00000000  =00006000                 60  RUNAGAIN  EQU   $6000               * Value equivalent to 'true'
00000000                            61  
00001000                            62            ORG   $1000               * Program begins at address 1000
00001000                            63            
00001000                            64  *********** END DEFINITIONS **************************************************
00001000                            65  
00001000                            66            
00001000                            67  ******************************************************************************
00001000                            68  *           INCLUDES                                                         *
00001000                            69  ******************************************************************************
00001000                            70  
00001000                            71      INCLUDE 'IO.X68'
00001000                            72  
00001000                            73  
00001000                            74  
00001000  =00005020                 75  STR_LEN   EQU   $5020
00001000  =00005021                 76  HEXFLAG   EQU   $5021
00001000  =00005030                 77  HEXVALUE  EQU   $5030
00001000  =00005050                 78  REMAINDER EQU   $5050
00001000  =00000002                 79  MOD       EQU   2
00001000                            80  
00001000  =0000000D                 81  CR        EQU   $0D
00001000  =0000000A                 82  LF        EQU   $0A 
00001000                            83  
00001000                            84  
00001000                            85  GET_ADDRESSES
00001000  4EB9 000012CE             86      JSR         CLEARSCRN
00001006  4EB9 000010C4             87      JSR         IO_WELCOME          * Run welcome subroutine
0000100C                            88              
0000100C                            89  GET_FIRST_ADDRESS
0000100C  43F9 00001314             90      LEA         PS1,A1              * Loads message into A1
00001012  4EB9 000010F2             91      JSR         GET_HEXSTRING       * Get string from user
00001018  0C38 0001 5021            92      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000101E  66EC                      93      BNE         GET_FIRST_ADDRESS   * If no, get hex again
00001020                            94     
00001020  4EB9 00001122             95      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001026  0C38 0001 5021            96      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000102C  66DE                      97      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000102E                            98      
0000102E  4EB9 0000127E             99      JSR         IS_HEX_EVEN         * Check that hex value is even
00001034  0C38 0001 5021           100      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000103A  66D0                     101      BNE         GET_FIRST_ADDRESS   * If no, get hex again
0000103C                           102     
0000103C  21F8 5030 5000           103      MOVE.L      HEXVALUE,BEGINADDR  * Copy hex value to begin
00001042  43F9 000013A6            104      LEA         BMESSAGE,A1         * Load message in A1 for display
00001048  2238 5030                105      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display 
0000104C  4EB9 000012C0            106      JSR         NEW_LINE            * Space
00001052                           107      
00001052  4EB9 000010D8            108      JSR         CLEAR               * Clear values for next hex
00001058                           109      
00001058                           110  GET_SECOND_ADDRESS
00001058  43F9 0000135E            111      LEA         PS2,A1              * Loads message into A1
0000105E  4EB9 000010F2            112      JSR         GET_HEXSTRING       * Get string from user
00001064  0C38 0001 5021           113      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
0000106A  66EC                     114      BNE         GET_SECOND_ADDRESS  * If no, get hex again
0000106C                           115     
0000106C  4EB9 00001122            116      JSR         ASCII_TO_HEX        * Convert ascii to hex
00001072  0C38 0001 5021           117      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001078  66DE                     118      BNE         GET_SECOND_ADDRESS  * If no, get hex again
0000107A                           119      
0000107A  4EB9 0000127E            120      JSR         IS_HEX_EVEN         * Check that hex value is even
00001080  0C38 0001 5021           121      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
00001086  66D0                     122      BNE         GET_SECOND_ADDRESS  * If no, get hex again
00001088                           123     
00001088  21F8 5030 5010           124      MOVE.L      HEXVALUE,ENDADDR    * Copy hex value to begin
0000108E  43F9 000013C5            125      LEA         EMESSAGE,A1         * Load message in A1 for display
00001094  2238 5030                126      MOVE.L      (HEXVALUE),D1       * Load hex value into A1 for display
00001098  4EB9 000012C0            127      JSR         NEW_LINE            * Space
0000109E                           128      
0000109E  4EB9 000010D8            129      JSR         CLEAR               * Clear values for next hex
000010A4                           130      
000010A4                           131  CHECK_BADDR_IS_LESS_THAN_EADDR
000010A4  4EB9 0000125E            132      JSR         IS_LESSTHAN         *
000010AA  0C38 0001 5021           133      CMPI.B      #1,HEXFLAG          * Does HEXFLAG = 1
000010B0  6700 0010                134      BEQ         FINISHED            * If yes, finished
000010B4  43F9 000013E7            135      LEA         ADR_ERR_NOTLT,A1    * Else, load error message
000010BA  6100 021E                136      BSR.W       ADDRESS_ERR
000010BE  6100 0454                137      BSR.W       START      
000010C2                           138  
000010C2                           139  
000010C2                           140  FINISHED
000010C2  4E75                     141      RTS                             * Return to Disassembler
000010C4                           142      
000010C4                           143         
000010C4                           144             
000010C4                           145             
000010C4                           146  
000010C4                           147  IO_WELCOME: 
000010C4  43F9 000012EC            148      LEA         INTRO,A1            * Loads message into A1
000010CA  103C 000E                149      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010CE  4E4F                     150      TRAP        #15                 * Displays Intro Message 
000010D0                           151        
000010D0  4EB9 000012C0            152      JSR         NEW_LINE            * Call Subroutine        
000010D6  4E75                     153      RTS                             * Return from subroutine
000010D8                           154          
000010D8                           155  
000010D8                           156  
000010D8                           157  CLEAR
000010D8  4286                     158      CLR.L       D6                   * Clear
000010DA  31FC FFFF 5020           159      MOVE.W      #$FFFF,STR_LEN       * Clear   
000010E0  21FC FFFFFFFF 5030       160      MOVE.L      #$FFFFFFFF,HEXVALUE  * Clear  
000010E8  21FC FFFFFFFF 5050       161      MOVE.L      #$FFFFFFFF,REMAINDER * Clear
000010F0  4E75                     162      RTS                              * Return to main to get hex
000010F2                           163  
000010F2                           164  
000010F2                           165          
000010F2                           166  GET_HEXSTRING
000010F2  103C 000E                167      MOVE.B      #14,D0              * Moves the Task 14 into D0
000010F6  323C 004A                168      MOVE.W      #(PS2-PS1),D1       * The prompt string length
000010FA  4E4F                     169      TRAP        #15                 * Displays contents of A1
000010FC                           170   
000010FC  43F9 00001442            171      LEA         HEXSTRING,A1        * Pointer to store the sentence
00001102  103C 0002                172      MOVE.B      #2,D0               * Set up readstring function
00001106  4E4F                     173      TRAP        #15                 * Get string from keyboard
00001108  11C1 5020                174      MOVE.B      D1,STR_LEN          * Save length of input string
0000110C                           175      
0000110C  0C38 0008 5020           176      CMPI.B      #8,(STR_LEN)        * Is length > 8?
00001112  6EDE                     177      BGT         GET_HEXSTRING       * If yes, get hex again
00001114                           178         
00001114  41F9 00001442            179      LEA         HEXSTRING,A0        * Load address for verification     
0000111A  11FC 0001 5021           180      MOVE.B      #1,(HEXFLAG)   
00001120  4E75                     181      RTS                             * Return from subroutine
00001122                           182          
00001122                           183  
00001122                           184  
00001122                           185  ASCII_TO_HEX      
00001122  1618                     186      MOVE.B      (A0)+,D3            * Move first char into D3    
00001124  0C03 0030                187      CMPI.B      #'0',D3             * Is Char equal to 0?
00001128  6700 00D4                188      BEQ         HEXZERO            
0000112C  0C03 0031                189      CMPI.B      #'1',D3             * Is Char equal to 1?
00001130  6700 00D4                190      BEQ         HEXONE                   
00001134  0C03 0032                191      CMPI.B      #'2',D3             * Is Char equal to 2?
00001138  6700 00D0                192      BEQ         HEXTWO    
0000113C  0C03 0033                193      CMPI.B      #'3',D3             * Is Char equal to 3?
00001140  6700 00CC                194      BEQ         HEXTHREE    
00001144  0C03 0034                195      CMPI.B      #'4',D3             * Is Char equal to 4?
00001148  6700 00C8                196      BEQ         HEXFOUR    
0000114C  0C03 0035                197      CMPI.B      #'5',D3             * Is Char equal to 5?
00001150  6700 00C4                198      BEQ         HEXFIVE    
00001154  0C03 0036                199      CMPI.B      #'6',D3             * Is Char equal to 6?
00001158  6700 00C0                200      BEQ         HEXSIX
0000115C  0C03 0037                201      CMPI.B      #'7',D3             * Is Char equal to 7?
00001160  6700 00BC                202      BEQ         HEXSEVEN
00001164  0C03 0038                203      CMPI.B      #'8',D3             * Is Char equal to 8?
00001168  6700 00B8                204      BEQ         HEXEIGHT
0000116C  0C03 0039                205      CMPI.B      #'9',D3             * Is Char equal to 9?
00001170  6700 00B4                206      BEQ         HEXNINE
00001174  0C03 0041                207      CMPI.B      #'A',D3             * Is Char equal to A?
00001178  6700 00B4                208      BEQ         HEXA                      
0000117C  0C03 0042                209      CMPI.B      #'B',D3             * Is Char equal to B?
00001180  6700 00B4                210      BEQ         HEXB
00001184  0C03 0043                211      CMPI.B      #'C',D3             * Is Char equal to C?
00001188  6700 00B4                212      BEQ         HEXC
0000118C  0C03 0044                213      CMPI.B      #'D',D3             * Is Char equal to D?
00001190  6700 00B4                214      BEQ         HEXD
00001194  0C03 0045                215      CMPI.B      #'E',D3             * Is Char equal to E?
00001198  6700 00B4                216      BEQ         HEXE
0000119C  0C03 0046                217      CMPI.B      #'F',D3             * Is Char equal to F?
000011A0  6700 00B4                218      BEQ         HEXF
000011A4  0C03 0061                219      CMPI.B      #'a',D3             * Is Char equal to a?
000011A8  6700 0084                220      BEQ         HEXA
000011AC  0C03 0062                221      CMPI.B      #'b',D3             * Is Char equal to b?
000011B0  6700 0084                222      BEQ         HEXB
000011B4  0C03 0063                223      CMPI.B      #'c',D3             * Is Char equal to c?
000011B8  6700 0084                224      BEQ         HEXC
000011BC  0C03 0064                225      CMPI.B      #'d',D3             * Is Char equal to d?
000011C0  6700 0084                226      BEQ         HEXD
000011C4  0C03 0065                227      CMPI.B      #'e',D3             * Is Char equal to e?
000011C8  6700 0084                228      BEQ         HEXE
000011CC  0C03 0066                229      CMPI.B      #'f',D3             * Is Char equal to f?
000011D0  6700 0084                230      BEQ         HEXF
000011D4                           231      
000011D4  11FC 0000 5021           232      MOVE.B      #0,HEXFLAG          * Set false    
000011DA  6000 FEFC                233      BRA         CLEAR               * Clear some values
000011DE                           234      
000011DE                           235  FOUND  
000011DE  5338 5020                236      SUBI.B      #1,STR_LEN          * Decrease string by one
000011E2  0C38 0000 5020           237      CMPI.B      #0,STR_LEN          * Is string = 0?
000011E8  6600 000E                238      BNE         SHIFTLEFT           * If no, shift value left 
000011EC  21C6 5030                239      MOVE.L      D6,HEXVALUE         * If yes, save hex value
000011F0  11FC 0001 5021           240      MOVE.B      #1,HEXFLAG          * Set true
000011F6  4E75                     241      RTS                             * Then, return to main
000011F8                           242  
000011F8                           243  SHIFTLEFT
000011F8  E98E                     244      LSL.L       #4,D6               * Shift the value left
000011FA  6000 FF26                245      BRA         ASCII_TO_HEX        * Check next char
000011FE                           246  
000011FE                           247  HEXZERO
000011FE  0686 00000000            248      ADD.L       #$0,D6              * Add value
00001204  60D8                     249      BRA         FOUND               * found, decrease strlen, shift value left    
00001206                           250  HEXONE
00001206  5286                     251      ADD.L       #$1,D6              * Add value
00001208  60D4                     252      BRA         FOUND               * found, decrease strlen, shift value left
0000120A                           253  HEXTWO
0000120A  5486                     254      ADD.L       #$2,D6              * Add value
0000120C  60D0                     255      BRA         FOUND               * found, decrease strlen, shift value left
0000120E                           256  HEXTHREE
0000120E  5686                     257      ADD.L       #$3,D6              * Add value
00001210  60CC                     258      BRA         FOUND               * found, decrease strlen, shift value left
00001212                           259  HEXFOUR
00001212  5886                     260      ADD.L       #$4,D6              * Add value
00001214  60C8                     261      BRA         FOUND               * found, decrease strlen, shift value left
00001216                           262  HEXFIVE
00001216  5A86                     263      ADD.L       #$5,D6              * Add value
00001218  60C4                     264      BRA         FOUND               * found, decrease strlen, shift value left
0000121A                           265  HEXSIX
0000121A  5C86                     266      ADD.L       #$6,D6              * Add value
0000121C  60C0                     267      BRA         FOUND               * found, decrease strlen, shift value left
0000121E                           268  HEXSEVEN
0000121E  5E86                     269      ADD.L       #$7,D6              * Add value
00001220  60BC                     270      BRA         FOUND               * found, decrease strlen, shift value left
00001222                           271  HEXEIGHT
00001222  5086                     272      ADD.L       #$8,D6              * Add value
00001224  60B8                     273      BRA         FOUND               * found, decrease strlen, shift value left
00001226                           274  HEXNINE
00001226  0686 00000009            275      ADD.L       #$9,D6              * Add value
0000122C  60B0                     276      BRA         FOUND               * found, decrease strlen, shift value left
0000122E                           277  HEXA
0000122E  0686 0000000A            278      ADD.L       #$A,D6              * Add value
00001234  60A8                     279      BRA         FOUND               * found, decrease strlen, shift value left    
00001236                           280  HEXB
00001236  0686 0000000B            281      ADD.L       #$B,D6              * Add value
0000123C  60A0                     282      BRA         FOUND               * found, decrease strlen, shift value left
0000123E                           283  HEXC
0000123E  0686 0000000C            284      ADD.L       #$C,D6              * Add value
00001244  6098                     285      BRA         FOUND               * found, decrease strlen, shift value left
00001246                           286  HEXD
00001246  0686 0000000D            287      ADD.L       #$D,D6              * Add value
0000124C  6090                     288      BRA         FOUND               * found, decrease strlen, shift value left
0000124E                           289  HEXE
0000124E  0686 0000000E            290      ADD.L       #$E,D6              * Add value
00001254  6088                     291      BRA         FOUND               * found, decrease strlen, shift value left
00001256                           292  HEXF
00001256  0686 0000000F            293      ADD.L       #$F,D6              * Add value
0000125C  6080                     294      BRA         FOUND               * found, decrease strlen, shift value left 
0000125E                           295     
0000125E                           296  
0000125E                           297  
0000125E                           298  IS_LESSTHAN
0000125E  2838 5000                299      MOVE.L      BEGINADDR,D4        * Store beginning address in D4
00001262  2C38 5010                300      MOVE.L      ENDADDR,D6          * Store ending address in D6
00001266  B886                     301      CMP.L       D6,D4               * Is D4 < D6
00001268  6D00 000C                302      BLT         LT                  * Yes, mark true return to main
0000126C  11FC 0000 5021           303      MOVE.B      #0,HEXFLAG          * No, mark false
00001272  6000 FE64                304      BRA         CLEAR               * Clear values, return to main
00001276                           305  
00001276                           306  LT
00001276  11FC 0001 5021           307      MOVE.B      #1,HEXFLAG          * Mark true
0000127C  4E75                     308      RTS                             * Return to main
0000127E                           309  
0000127E                           310  
0000127E                           311  
0000127E                           312  IS_HEX_EVEN      
0000127E  3606                     313      MOVE.W      D6,D3               * Move value to be modded into D3
00001280  3A3C 0002                314      MOVE.W      #MOD,D5             * Move mod value into D5
00001284  86C5                     315      DIVU        D5,D3               * Divide D3 by D5
00001286  123C 0003                316      MOVE.B      #3,D1               * Set counter to shift value into word 
0000128A                           317                                      * position    
0000128A                           318  REPEAT 
0000128A  E88B                     319      LSR.L       #4,D3               * Shift remainder to lower word
0000128C  57C9 FFFC                320      DBEQ        D1,REPEAT           * UNTIL [D0] = - 1
00001290  4241                     321      CLR         D1                  * Clear
00001292                           322      
00001292  B6BC 00000000            323      CMP.L       #0,D3               * Is hex even?
00001298  6600 000E                324      BNE         NOTEVEN             * No, clear and go back to get_hex
0000129C  31C3 5050                325      MOVE.W      D3,REMAINDER        * Save remainder
000012A0  11FC 0001 5021           326      MOVE.B      #1,HEXFLAG          * Set true
000012A6  4E75                     327      RTS                             * Return to main
000012A8                           328  
000012A8                           329  NOTEVEN
000012A8  11FC 0000 5021           330      MOVE.B      #0,HEXFLAG          * Set false
000012AE  6000 FE28                331      BRA         CLEAR               * Clear values
000012B2                           332  
000012B2                           333  
000012B2                           334  
000012B2                           335  PRINT_HEXVALUE
000012B2  103C 000E                336      MOVE.B      #14,D0              * Moves the Task 14 into D0
000012B6  4E4F                     337      TRAP        #15                 * Displays contents of A1
000012B8                           338      
000012B8                           339      
000012B8  103C 0003                340      MOVE.B      #3,D0               * Moves the Task 3 into D0
000012BC  4E4F                     341      TRAP        #15                 * Displays contents of D1
000012BE                           342      
000012BE  4E75                     343      RTS                             * Return from subroutine                                  
000012C0                           344  
000012C0                           345  
000012C0                           346  NEW_LINE
000012C0  43F9 000013E4            347      LEA         ENDL,A1             * Loads message into A1
000012C6  103C 000E                348      MOVE.B      #14,D0              * Moves the TRACK 14 into D0
000012CA  4E4F                     349      TRAP        #15                 * Displays New line
000012CC  4E75                     350      RTS                             * Return from subroutine
000012CE                           351  
000012CE                           352  
000012CE                           353  CLEARSCRN     
000012CE  103C 000B                354      MOVE.B      #11,D0              * Task 11 for clearing screen
000012D2  323C FF00                355      MOVE.W      #$FF00,D1           * FF00, Clear screen
000012D6  4E4F                     356      TRAP        #15                 * Wait for keystroke
000012D8  4E75                     357      RTS                             * Return from subroutine
000012DA                           358  
000012DA                           359  
000012DA                           360  
000012DA                           361  
000012DA                           362  ADDRESS_ERR
000012DA  6100 FFF2                363      BSR.W       CLEARSCRN           * Clear output before displaying error
000012DE  103C 000D                364      MOVE.B      #13,D0              * Moves the Task 13 into D0
000012E2  4E4F                     365      TRAP        #15                 * Displays contents of A1
000012E4  103C 0005                366      MOVE.B      #5,D0               * Read single character from 
000012E8  4E4F                     367      TRAP        #15                 * The keyboard into D1.B
000012EA  4E75                     368      RTS                             * Return from subroutine
000012EC                           369  
000012EC                           370  
000012EC                           371  
000012EC                           372  
000012EC= 57 45 4C 43 4F 4D ...    373  INTRO           DC.B 'WELCOME!',CR,LF,'THIS IS A 68K DISASSEMBLER.',CR,LF,0
00001314= 50 4C 45 41 53 45 ...    374  PS1             DC.B 'PLEASE ENTER THE STARTING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
0000135E= 50 4C 45 41 53 45 ...    375  PS2             DC.B 'PLEASE ENTER THE ENDING HEX ADDRESS',CR,LF,'(MAX 8 DIGITS AND MUST BE EVEN): $',0
000013A6= 0D 0A 42 45 47 49 ...    376  BMESSAGE        DC.B CR,LF,'BEGINNING ADDRESS GIVEN IS: ',0
000013C5= 0D 0A 45 4E 44 49 ...    377  EMESSAGE        DC.B CR,LF,'ENDING ADDRESS GIVEN IS   : ',0
000013E4= 0D 0A 00                 378  ENDL            DC.B CR,LF,0
000013E7                           379  
000013E7= 54 48 45 20 42 45 ...    380  ADR_ERR_NOTLT   DC.B 'THE BEGINNING ADDRESS MUST BE LESS THAN THE ENDING ADDRESS.',CR,LF,'PRESS ANY KEY TO TRY AGAIN...',0
00001442                           381  
00001442                           382  HEXSTRING       DS.B 80             * Var for hex string
00001492                           383  
00001492= 31 30 30 30 20 20 ...    384  ILLEGAL         DC.B '1000    DATA    $WXYZ',CR,LF,0
000014AA                           385  
000014AA                           386  
000014AA                           387  
000014AA                           388  
000014AA                           389  
000014AA                           390  
000014AA                           391  
000014AA                           392  
000014AA                           393  -------------------- end include --------------------
000014AA                           394      *INCLUDE 'OpCodes.X68'
000014AA                           395      *INCLUDE 'EA.X68'
000014AA                           396      INCLUDE 'EndProgram.X68'
000014AA                           397  
000014AA                           398  
000014AA                           399  
000014AA  =00000059                400  UPYES     EQU   'Y'
000014AA  =00000079                401  LOWYES    EQU   'y'
000014AA                           402  
000014AA                           403            *ORG   $1000
000014AA                           404  
000014AA                           405  
000014AA                           406  KEEP_RUNNING
000014AA  6100 0004                407      BSR.W       RERUN               * Run welcome subroutine
000014AE  4E75                     408      RTS                             * Return to Disassembler
000014B0                           409      
000014B0                           410  
000014B0                           411  
000014B0                           412             
000014B0                           413  
000014B0                           414  RERUN 
000014B0  43F9 000014E4            415      LEA         ENDQUESTION,A1      * Loads message into A1
000014B6  103C 000E                416      MOVE.B      #14,D0              * Moves the Task 14 into D0
000014BA  4E4F                     417      TRAP        #15                 * Displays Intro Message
000014BC                           418      
000014BC  103C 0005                419      MOVE.B      #5,D0               * Move task 5 to read one char
000014C0  4E4F                     420      TRAP        #15                 * Trap 15 for IO
000014C2                           421      
000014C2  0C01 0059                422      CMPI.B      #UPYES,D1           * Is char = Y
000014C6  6700 0012                423      BEQ         NOTDONE             * If yes, notdone
000014CA  0C01 0079                424      CMPI.B      #LOWYES,D1          * Is char = y   
000014CE  6700 000A                425      BEQ         NOTDONE             * If yes, notdone
000014D2  11FC 0000 6000           426      MOVE.B      #0,(RUNAGAIN)       * 0 for false to end program
000014D8  4E75                     427      RTS 
000014DA                           428      
000014DA                           429  NOTDONE
000014DA  11FC 0001 6000           430      MOVE.B      #1,(RUNAGAIN)       * 1 for true to rerun program
000014E0  6000 FDEC                431      BRA.W       CLEARSCRN           * Clear screen and return from subroutine         
000014E4                           432          
000014E4                           433  
000014E4                           434  
000014E4                           435  
000014E4                           436  
000014E4                           437  
000014E4= 57 4F 55 4C 44 20 ...    438  ENDQUESTION     DC.B 'WOULD YOU LIKE TO RUN THE PROGRAM AGAIN (Y/N)? ',0
00001514                           439  
00001514                           440      *END         KEEP_RUNNING
00001514                           441  
00001514                           442  
00001514                           443  
00001514                           444  -------------------- end include --------------------
00001514                           445  
00001514                           446  *********** END INCLUDES *****************************************************    
00001514                           447        
00001514                           448        
00001514                           449  ******************************************************************************
00001514                           450  *           BEGIN CODE                                                       *
00001514                           451  ******************************************************************************
00001514                           452  
00001514                           453  *---------- START ------------------------------------------------------------
00001514                           454  * Begins program's logical flow. Similar to main in C/C++
00001514                           455  *-----------------------------------------------------------------------------
00001514                           456  START
00001514  4FF8 7000                457      LEA         STACK,SP            * SP is stored in A7
00001518  4EB8 1000                458      JSR         GET_ADDRESSES       * Runs GET_ADDRESSES and IO_WELCOME
0000151C  2C78 5000                459      MOVEA.L     BEGINADDR,A6        * Assign beginning address to A6 for use
00001520                           460  
00001520                           461  LOOP
00001520                           462      * OC_PARSE Command doesn't work due to issues in the Opcode include
00001520                           463      * many errors need to be fixed. Same with EA include
00001520                           464      *JSR         OC_PARSE            * Determine if there is an initial opcode match
00001520                           465      * decrement row count
00001520                           466      * if at 0, prompt for next page
00001520                           467      * else, continue
00001520  584E                     468      ADDA.W      #$4,A6            * Advance address to test LOOP (test only)
00001522                           469      
00001522                           470  LOOP_CHECK
00001522                           471      * Changed the following code from: 
00001522                           472      * CMPA        A6, ENDADDR         
00001522                           473      * to:
00001522                           474      * CMPA      (ENDADDR),A6 
00001522                           475      * When using the CMPA, destination must be an address so A6
00001522  BDF8 5010                476      CMPA.L      ENDADDR,A6          * Is pointer at end of address range?
00001526                           477      
00001526  6E00 0004                478      BGT         END_LOOP            * If yes, END_LOOP
0000152A                           479      ; in case this resets status register, do another compare TODO
0000152A                           480      
0000152A  66F4                     481      BNE         LOOP                * If not, continue processing addresses
0000152C                           482      ; If at end of address range, check if user wants to continue
0000152C                           483      ; if user wants to continue, restart
0000152C                           484      ; else, end    
0000152C                           485  
0000152C                           486  END_LOOP
0000152C  4EB8 14AA                487      JSR         KEEP_RUNNING        * Does the user want to run program again
00001530  0C38 0001 6000           488      CMPI.B      #1,(RUNAGAIN)       * Does RUNAGAIN = TRUE?
00001536  67DC                     489      BEQ         START               * If yes, rerun program
00001538  4E72 3000                490      STOP        #$3000              * Else, end program
0000153C                           491      
0000153C                           492  *---------- END - START ------------------------------------------------------
0000153C                           493  
0000153C                           494  *********** END BEGIN CODE ***************************************************
0000153C                           495  
0000153C                           496  
0000153C                           497  ******************************************************************************
0000153C                           498  *           VARIABLES AND CONSTANTS                                          *
0000153C                           499  ******************************************************************************
0000153C                           500  
0000153C                           501  
0000153C                           502  
0000153C                           503  *---------- Reserved Registers -----------------------------
0000153C                           504  *   A7: stack pointer
0000153C                           505  *   A6: current address (updated by subroutines)
0000153C                           506  *   D0: instruction validity flag (reset by main control
0000153C                           507  *       code, can be set to false by subroutines)
0000153C                           508  *-----------------------------------------------------------
0000153C                           509  
0000153C                           510  *---------- End --------------------------------------------
0000153C                           511                 END  START          * Last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDRESS_ERR         12DA
ADR_ERR_NOTLT       13E7
ASCII_TO_HEX        1122
BEGINADDR           5000
BMESSAGE            13A6
CHECK_BADDR_IS_LESS_THAN_EADDR  10A4
CLEAR               10D8
CLEARSCRN           12CE
CR                  D
EMESSAGE            13C5
ENDADDR             5010
ENDL                13E4
ENDQUESTION         14E4
END_LOOP            152C
FINISHED            10C2
FOUND               11DE
GET_ADDRESSES       1000
GET_FIRST_ADDRESS   100C
GET_HEXSTRING       10F2
GET_SECOND_ADDRESS  1058
HEXA                122E
HEXB                1236
HEXC                123E
HEXD                1246
HEXE                124E
HEXEIGHT            1222
HEXF                1256
HEXFIVE             1216
HEXFLAG             5021
HEXFOUR             1212
HEXNINE             1226
HEXONE              1206
HEXSEVEN            121E
HEXSIX              121A
HEXSTRING           1442
HEXTHREE            120E
HEXTWO              120A
HEXVALUE            5030
HEXZERO             11FE
ILLEGAL             1492
INTRO               12EC
IO_WELCOME          10C4
IS_HEX_EVEN         127E
IS_LESSTHAN         125E
KEEP_RUNNING        14AA
LF                  A
LOOP                1520
LOOP_CHECK          1522
LOWYES              79
LT                  1276
MOD                 2
NEW_LINE            12C0
NOTDONE             14DA
NOTEVEN             12A8
PRINT_HEXVALUE      12B2
PS1                 1314
PS2                 135E
REMAINDER           5050
REPEAT              128A
RERUN               14B0
RUNAGAIN            6000
SHIFTLEFT           11F8
STACK               7000
START               1514
STR_LEN             5020
UPYES               59
